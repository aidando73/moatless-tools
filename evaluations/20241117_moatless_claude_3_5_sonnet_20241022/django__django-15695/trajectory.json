{
  "metadata": {
    "evaluation_name": "20241117_moatless_tools_0_4_claude_3_5_sonnet_20241022",
    "instance_id": "django__django-15695"
  },
  "max_iterations": 30,
  "max_cost": 0.5,
  "agent": {
    "system_prompt": "You are an autonomous AI assistant and a core member of the development team for the django/django project. As a senior developer on the team, you have deep knowledge of the codebase and best practices.\n\n\nYou will write your reasoning steps inside `<thoughts>` tags, and then perform actions by making function calls as needed. \nAfter each action, you will receive an Observation that contains the result of your action. Use these observations to inform your next steps.\n\n## How to Interact\n\n- **Think Step by Step:** Use the ReAct pattern to reason about the task. Document each thought process within `<thoughts>`.\n- **Function Calls:** After your thoughts, make the necessary function calls to interact with the codebase or environment.\n- **Observations:** After each function call, you will receive an Observation containing the result. Use this information to plan your next step.\n- **One Action at a Time:** Only perform one action before waiting for its Observation.\n\n## Workflow Overview\n\n1. **Understand the Task**\n   - **Review the Task:** Carefully read the task provided in `<task>`.\n   - **Identify Code to Change:** Determine which parts of the codebase need modification.\n   - **Identify Necessary Context:** Figure out what additional code or information you need.\n\n2. **Locate Relevant Code**\n   - **Search for Code:** Use functions like `SearchCode` to find relevant code if it's not in the current context.\n   - **Request Additional Context:** Use `ViewCode` to view specific code spans, functions, classes, or lines of code.\n\n3. **Locate Relevant Tests**\n   - **Find Related Tests:** Use functions to locate existing tests related to the code changes.\n\n4. **Apply Code Changes**\n   - **One Step at a Time:** Plan and implement one code change at a time.\n   - **Provide Instructions and Pseudo Code:** Use `str_replace_editor` to update the code.\n   - **Automatic Testing:** Tests run automatically after each code change.\n\n5. **Modify or Add Tests**\n   - **Ensure Test Coverage:** Update or add tests to verify the changes using `str_replace_editor`.\n\n6. **Repeat as Necessary**\n   - **Iterate:** If tests fail or further changes are needed, repeat the steps above.\n\n7. **Finish the Task**\n   - **Completion:** When confident that all changes are correct and the task is resolved, use `Finish`.\n\n# Important Guidelines\n\n- **Focus on the Specific Task**\n  - Implement requirements exactly as specified.\n  - Do not modify unrelated code.\n\n- **Clear Communication**\n  - Provide detailed yet concise instructions.\n  - Include all necessary information for accurate implementation.\n\n- **Code Context and Changes**\n  - Limit changes to files in the current context.\n  - Explicitly request more code if needed.\n  - Provide line numbers if known; otherwise, explain where changes should be made.\n\n- **Testing**\n  - Always update or add tests to verify your changes.\n\n- **Error Handling**\n  - If tests fail, analyze the output and plan corrections.\n  - Document your reasoning in `<thoughts>` before making function calls.\n\n- **Task Completion**\n  - Finish only when the task is fully resolved and verified.\n  - Do not suggest additional changes beyond the scope.\n\n# Additional Notes\n\n- **ReAct Pattern Usage:** Always write your thoughts in `<thoughts>` before making function calls.\n- **Incremental Changes:** Focus on one change at a time and verify each step.\n- **Never Guess:** Do not guess code content. Use `ViewCode` to obtain accurate information.\n- **Collaboration:** The AI agent relies on your detailed instructions; clarity is key.\n",
    "actions": [],
    "message_history_type": "messages",
    "include_extra_history": true,
    "include_file_context": false,
    "include_git_patch": false,
    "completion": {
      "model": "claude-3-5-sonnet-20241022",
      "temperature": 0.0,
      "max_tokens": 4000,
      "response_format": "tool_call"
    },
    "agent_class": "moatless.agent.code_agent.CodingAgent"
  },
  "nodes": [
    {
      "node_id": 0,
      "file_context": {
        "max_tokens": 8000,
        "files": []
      },
      "message": "<task>\nRenameIndex() crashes when unnamed index is moving backward and forward.\nDescription\n\t\nRenameIndex() should restore the old auto-generated name when an unnamed index for unique_together is moving backward. Now re-applying RenameIndex() crashes. For example:\ntests/migrations/test_operations.py\ndiff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex cfd28b1b39..c0a55023bb 100644\n\t\t\t\t\t\n\t\t\t\t\t a\n\t\t\t\t \n\t\t\t\t\t\n\t\t\t\t\t b\n\t\t\t\t \n class OperationTests(OperationTestBase):\u00a0\n29882988\u00a0 \u00a0 \u00a0 \u00a0 with connection.schema_editor() as editor, self.assertNumQueries(0):\n29892989\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 operation.database_backwards(app_label, editor, new_state, project_state)\n29902990\u00a0 \u00a0 \u00a0 \u00a0 self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n\u00a02991\u00a0 \u00a0 \u00a0 \u00a0 # Re-apply renaming.\n\u00a02992\u00a0 \u00a0 \u00a0 \u00a0 with connection.schema_editor() as editor:\n\u00a02993\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 operation.database_forwards(app_label, editor, project_state, new_state)\n\u00a02994\u00a0 \u00a0 \u00a0 \u00a0 self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n29912995\u00a0 \u00a0 \u00a0 \u00a0 # Deconstruction.\n29922996\u00a0 \u00a0 \u00a0 \u00a0 definition = operation.deconstruct()\n29932997\u00a0 \u00a0 \u00a0 \u00a0 self.assertEqual(definition[0], \"RenameIndex\")\ncrashes on PostgreSQL:\ndjango.db.utils.ProgrammingError: relation \"new_pony_test_idx\" already exists\n\n</task>",
      "completions": {},
      "possible_actions": [],
      "parent_id": null
    },
    {
      "node_id": 1,
      "action": {
        "scratch_pad": "1. First, I need to understand the context better by:\n   - Looking at the test file to see the full test case\n   - Finding the RenameIndex operation implementation\n   - Understanding how index naming works in this context\n\n2. Let's start by viewing the test file to see the full test case context.",
        "files": [
          {
            "file_path": "tests/migrations/test_operations.py",
            "span_ids": []
          }
        ],
        "action_args_class": "moatless.actions.view_code.ViewCodeArgs"
      },
      "observation": {
        "message": "Here's the contents of the requested code spans:\ntests/migrations/test_operations.py\n```\n     1\tfrom django.core.exceptions import FieldDoesNotExist\n     2\tfrom django.db import IntegrityError, connection, migrations, models, transaction\n     3\tfrom django.db.migrations.migration import Migration\n     4\tfrom django.db.migrations.operations.fields import FieldOperation\n     5\tfrom django.db.migrations.state import ModelState, ProjectState\n     6\tfrom django.db.models.functions import Abs\n     7\tfrom django.db.transaction import atomic\n     8\tfrom django.test import SimpleTestCase, override_settings, skipUnlessDBFeature\n     9\tfrom django.test.utils import CaptureQueriesContext\n    10\t\n    11\tfrom .models import FoodManager, FoodQuerySet, UnicodeModel\n    12\tfrom .test_base import OperationTestBase\n    13\t\n    14\t\n    15\tclass Mixin:\n    16\t    pass\n    17\t\n    18\t\n    19\tclass OperationTests(OperationTestBase):\n    20\t    \"\"\"\n    21\t    Tests running the operations and making sure they do what they say they do.\n    22\t    Each test looks at their state changing, and then their database operation -\n    23\t    both forwards and backwards.\n    24\t    \"\"\"\n    25\t\n    26\t    def test_create_model(self):\n    27\t        \"\"\"\n    28\t        Tests the CreateModel operation.\n    29\t        Most other tests use this operation as part of setup, so check failures\n    30\t        here first.\n    31\t        \"\"\"\n    32\t        operation = migrations.CreateModel(\n    33\t            \"Pony\",\n    34\t            [\n    35\t                (\"id\", models.AutoField(primary_key=True)),\n    36\t                (\"pink\", models.IntegerField(default=1)),\n    37\t            ],\n    38\t        )\n    39\t        self.assertEqual(operation.describe(), \"Create model Pony\")\n    40\t        self.assertEqual(operation.migration_name_fragment, \"pony\")\n    41\t        # Test the state alteration\n    42\t        project_state = ProjectState()\n    43\t        new_state = project_state.clone()\n    44\t        operation.state_forwards(\"test_crmo\", new_state)\n    45\t        self.assertEqual(new_state.models[\"test_crmo\", \"pony\"].name, \"Pony\")\n    46\t        self.assertEqual(len(new_state.models[\"test_crmo\", \"pony\"].fields), 2)\n    47\t        # Test the database alteration\n    48\t        self.assertTableNotExists(\"test_crmo_pony\")\n    49\t        with connection.schema_editor() as editor:\n    50\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n    51\t        self.assertTableExists(\"test_crmo_pony\")\n    52\t        # And test reversal\n    53\t        with connection.schema_editor() as editor:\n    54\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n    55\t        self.assertTableNotExists(\"test_crmo_pony\")\n    56\t        # And deconstruction\n    57\t        definition = operation.deconstruct()\n    58\t        self.assertEqual(definition[0], \"CreateModel\")\n    59\t        self.assertEqual(definition[1], [])\n    60\t        self.assertEqual(sorted(definition[2]), [\"fields\", \"name\"])\n    61\t        # And default manager not in set\n    62\t        operation = migrations.CreateModel(\n    63\t            \"Foo\", fields=[], managers=[(\"objects\", models.Manager())]\n    64\t        )\n    65\t        definition = operation.deconstruct()\n    66\t        self.assertNotIn(\"managers\", definition[2])\n    67\t\n    68\t    def test_create_model_with_duplicate_field_name(self):\n    69\t        with self.assertRaisesMessage(\n    70\t            ValueError, \"Found duplicate value pink in CreateModel fields argument.\"\n    71\t        ):\n    72\t            migrations.CreateModel(\n    73\t                \"Pony\",\n    74\t                [\n    75\t                    (\"id\", models.AutoField(primary_key=True)),\n    76\t                    (\"pink\", models.TextField()),\n    77\t                    (\"pink\", models.IntegerField(default=1)),\n    78\t                ],\n    79\t            )\n    80\t\n    81\t    def test_create_model_with_duplicate_base(self):\n    82\t        message = \"Found duplicate value test_crmo.pony in CreateModel bases argument.\"\n    83\t        with self.assertRaisesMessage(ValueError, message):\n    84\t            migrations.CreateModel(\n    85\t                \"Pony\",\n    86\t                fields=[],\n    87\t                bases=(\n    88\t                    \"test_crmo.Pony\",\n    89\t                    \"test_crmo.Pony\",\n    90\t                ),\n    91\t            )\n    92\t        with self.assertRaisesMessage(ValueError, message):\n    93\t            migrations.CreateModel(\n    94\t                \"Pony\",\n    95\t                fields=[],\n    96\t                bases=(\n    97\t                    \"test_crmo.Pony\",\n    98\t                    \"test_crmo.pony\",\n    99\t                ),\n   100\t            )\n   101\t        message = (\n   102\t            \"Found duplicate value migrations.unicodemodel in CreateModel bases \"\n   103\t            \"argument.\"\n   104\t        )\n   105\t        with self.assertRaisesMessage(ValueError, message):\n   106\t            migrations.CreateModel(\n   107\t                \"Pony\",\n   108\t                fields=[],\n   109\t                bases=(\n   110\t                    UnicodeModel,\n   111\t                    UnicodeModel,\n   112\t                ),\n   113\t            )\n   114\t        with self.assertRaisesMessage(ValueError, message):\n   115\t            migrations.CreateModel(\n   116\t                \"Pony\",\n   117\t                fields=[],\n   118\t                bases=(\n   119\t                    UnicodeModel,\n   120\t                    \"migrations.unicodemodel\",\n   121\t                ),\n   122\t            )\n   123\t        with self.assertRaisesMessage(ValueError, message):\n   124\t            migrations.CreateModel(\n   125\t                \"Pony\",\n   126\t                fields=[],\n   127\t                bases=(\n   128\t                    UnicodeModel,\n   129\t                    \"migrations.UnicodeModel\",\n   130\t                ),\n   131\t            )\n   132\t        message = (\n   133\t            \"Found duplicate value <class 'django.db.models.base.Model'> in \"\n   134\t            \"CreateModel bases argument.\"\n   135\t        )\n   136\t        with self.assertRaisesMessage(ValueError, message):\n   137\t            migrations.CreateModel(\n   138\t                \"Pony\",\n   139\t                fields=[],\n   140\t                bases=(\n   141\t                    models.Model,\n   142\t                    models.Model,\n   143\t                ),\n   144\t            )\n   145\t        message = (\n   146\t            \"Found duplicate value <class 'migrations.test_operations.Mixin'> in \"\n   147\t            \"CreateModel bases argument.\"\n   148\t        )\n   149\t        with self.assertRaisesMessage(ValueError, message):\n   150\t            migrations.CreateModel(\n   151\t                \"Pony\",\n   152\t                fields=[],\n   153\t                bases=(\n   154\t                    Mixin,\n   155\t                    Mixin,\n   156\t                ),\n   157\t            )\n   158\t\n   159\t    def test_create_model_with_duplicate_manager_name(self):\n   160\t        with self.assertRaisesMessage(\n   161\t            ValueError,\n   162\t            \"Found duplicate value objects in CreateModel managers argument.\",\n   163\t        ):\n   164\t            migrations.CreateModel(\n   165\t                \"Pony\",\n   166\t                fields=[],\n   167\t                managers=[\n   168\t                    (\"objects\", models.Manager()),\n   169\t                    (\"objects\", models.Manager()),\n   170\t                ],\n   171\t            )\n   172\t\n   173\t    def test_create_model_with_unique_after(self):\n   174\t        \"\"\"\n   175\t        Tests the CreateModel operation directly followed by an\n   176\t        AlterUniqueTogether (bug #22844 - sqlite remake issues)\n   177\t        \"\"\"\n   178\t        operation1 = migrations.CreateModel(\n   179\t            \"Pony\",\n   180\t            [\n   181\t                (\"id\", models.AutoField(primary_key=True)),\n   182\t                (\"pink\", models.IntegerField(default=1)),\n   183\t            ],\n   184\t        )\n   185\t        operation2 = migrations.CreateModel(\n   186\t            \"Rider\",\n   187\t            [\n   188\t                (\"id\", models.AutoField(primary_key=True)),\n   189\t                (\"number\", models.IntegerField(default=1)),\n   190\t                (\"pony\", models.ForeignKey(\"test_crmoua.Pony\", models.CASCADE)),\n   191\t            ],\n   192\t        )\n   193\t        operation3 = migrations.AlterUniqueTogether(\n   194\t            \"Rider\",\n   195\t            [\n   196\t                (\"number\", \"pony\"),\n   197\t            ],\n   198\t        )\n   199\t        # Test the database alteration\n   200\t        project_state = ProjectState()\n   201\t        self.assertTableNotExists(\"test_crmoua_pony\")\n   202\t        self.assertTableNotExists(\"test_crmoua_rider\")\n   203\t        with connection.schema_editor() as editor:\n   204\t            new_state = project_state.clone()\n   205\t            operation1.state_forwards(\"test_crmoua\", new_state)\n   206\t            operation1.database_forwards(\n   207\t                \"test_crmoua\", editor, project_state, new_state\n   208\t            )\n   209\t            project_state, new_state = new_state, new_state.clone()\n   210\t            operation2.state_forwards(\"test_crmoua\", new_state)\n   211\t            operation2.database_forwards(\n   212\t                \"test_crmoua\", editor, project_state, new_state\n   213\t            )\n   214\t            project_state, new_state = new_state, new_state.clone()\n   215\t            operation3.state_forwards(\"test_crmoua\", new_state)\n   216\t            operation3.database_forwards(\n   217\t                \"test_crmoua\", editor, project_state, new_state\n   218\t            )\n   219\t        self.assertTableExists(\"test_crmoua_pony\")\n   220\t        self.assertTableExists(\"test_crmoua_rider\")\n   221\t\n   222\t    def test_create_model_m2m(self):\n   223\t        \"\"\"\n   224\t        Test the creation of a model with a ManyToMany field and the\n   225\t        auto-created \"through\" model.\n   226\t        \"\"\"\n   227\t        project_state = self.set_up_test_model(\"test_crmomm\")\n   228\t        operation = migrations.CreateModel(\n   229\t            \"Stable\",\n   230\t            [\n   231\t                (\"id\", models.AutoField(primary_key=True)),\n   232\t                (\"ponies\", models.ManyToManyField(\"Pony\", related_name=\"stables\")),\n   233\t            ],\n   234\t        )\n   235\t        # Test the state alteration\n   236\t        new_state = project_state.clone()\n   237\t        operation.state_forwards(\"test_crmomm\", new_state)\n   238\t        # Test the database alteration\n   239\t        self.assertTableNotExists(\"test_crmomm_stable_ponies\")\n   240\t        with connection.schema_editor() as editor:\n   241\t            operation.database_forwards(\"test_crmomm\", editor, project_state, new_state)\n   242\t        self.assertTableExists(\"test_crmomm_stable\")\n   243\t        self.assertTableExists(\"test_crmomm_stable_ponies\")\n   244\t        self.assertColumnNotExists(\"test_crmomm_stable\", \"ponies\")\n   245\t        # Make sure the M2M field actually works\n   246\t        with atomic():\n   247\t            Pony = new_state.apps.get_model(\"test_crmomm\", \"Pony\")\n   248\t            Stable = new_state.apps.get_model(\"test_crmomm\", \"Stable\")\n   249\t            stable = Stable.objects.create()\n   250\t            p1 = Pony.objects.create(pink=False, weight=4.55)\n   251\t            p2 = Pony.objects.create(pink=True, weight=5.43)\n   252\t            stable.ponies.add(p1, p2)\n   253\t            self.assertEqual(stable.ponies.count(), 2)\n   254\t            stable.ponies.all().delete()\n   255\t        # And test reversal\n   256\t        with connection.schema_editor() as editor:\n   257\t            operation.database_backwards(\n   258\t                \"test_crmomm\", editor, new_state, project_state\n   259\t            )\n   260\t        self.assertTableNotExists(\"test_crmomm_stable\")\n   261\t        self.assertTableNotExists(\"test_crmomm_stable_ponies\")\n   262\t\n   263\t    @skipUnlessDBFeature(\"supports_collation_on_charfield\", \"supports_foreign_keys\")\n   264\t    def test_create_fk_models_to_pk_field_db_collation(self):\n   265\t        \"\"\"Creation of models with a FK to a PK with db_collation.\"\"\"\n   266\t        collation = connection.features.test_collations.get(\"non_default\")\n   267\t        if not collation:\n   268\t            self.skipTest(\"Language collations are not supported.\")\n   269\t\n   270\t        app_label = \"test_cfkmtopkfdbc\"\n   271\t        operations = [\n   272\t            migrations.CreateModel(\n   273\t                \"Pony\",\n   274\t                [\n   275\t                    (\n   276\t                        \"id\",\n   277\t                        models.CharField(\n   278\t                            primary_key=True,\n   279\t                            max_length=10,\n   280\t                            db_collation=collation,\n   281\t                        ),\n   282\t                    ),\n   283\t                ],\n   284\t            )\n   285\t        ]\n   286\t        project_state = self.apply_operations(app_label, ProjectState(), operations)\n   287\t        # ForeignKey.\n   288\t        new_state = project_state.clone()\n   289\t        operation = migrations.CreateModel(\n   290\t            \"Rider\",\n   291\t            [\n   292\t                (\"id\", models.AutoField(primary_key=True)),\n   293\t                (\"pony\", models.ForeignKey(\"Pony\", models.CASCADE)),\n   294\t            ],\n   295\t        )\n   296\t        operation.state_forwards(app_label, new_state)\n   297\t        with connection.schema_editor() as editor:\n   298\t            operation.database_forwards(app_label, editor, project_state, new_state)\n   299\t        self.assertColumnCollation(f\"{app_label}_rider\", \"pony_id\", collation)\n   300\t        # Reversal.\n   301\t        with connection.schema_editor() as editor:\n   302\t            operation.database_backwards(app_label, editor, new_state, project_state)\n   303\t        # OneToOneField.\n   304\t        new_state = project_state.clone()\n   305\t        operation = migrations.CreateModel(\n   306\t            \"ShetlandPony\",\n   307\t            [\n   308\t                (\n   309\t                    \"pony\",\n   310\t                    models.OneToOneField(\"Pony\", models.CASCADE, primary_key=True),\n   311\t                ),\n   312\t                (\"cuteness\", models.IntegerField(default=1)),\n   313\t            ],\n   314\t        )\n   315\t        operation.state_forwards(app_label, new_state)\n   316\t        with connection.schema_editor() as editor:\n   317\t            operation.database_forwards(app_label, editor, project_state, new_state)\n   318\t        self.assertColumnCollation(f\"{app_label}_shetlandpony\", \"pony_id\", collation)\n   319\t        # Reversal.\n   320\t        with connection.schema_editor() as editor:\n   321\t            operation.database_backwards(app_label, editor, new_state, project_state)\n   322\t\n   323\t    def test_create_model_inheritance(self):\n   324\t        \"\"\"\n   325\t        Tests the CreateModel operation on a multi-table inheritance setup.\n   326\t        \"\"\"\n   327\t        project_state = self.set_up_test_model(\"test_crmoih\")\n   328\t        # Test the state alteration\n   329\t        operation = migrations.CreateModel(\n   330\t            \"ShetlandPony\",\n   331\t            [\n   332\t                (\n   333\t                    \"pony_ptr\",\n   334\t                    models.OneToOneField(\n   335\t                        \"test_crmoih.Pony\",\n   336\t                        models.CASCADE,\n   337\t                        auto_created=True,\n   338\t                        primary_key=True,\n   339\t                        to_field=\"id\",\n   340\t                        serialize=False,\n   341\t                    ),\n   342\t                ),\n   343\t                (\"cuteness\", models.IntegerField(default=1)),\n   344\t            ],\n   345\t        )\n   346\t        new_state = project_state.clone()\n   347\t        operation.state_forwards(\"test_crmoih\", new_state)\n   348\t        self.assertIn((\"test_crmoih\", \"shetlandpony\"), new_state.models)\n   349\t        # Test the database alteration\n   350\t        self.assertTableNotExists(\"test_crmoih_shetlandpony\")\n   351\t        with connection.schema_editor() as editor:\n   352\t            operation.database_forwards(\"test_crmoih\", editor, project_state, new_state)\n   353\t        self.assertTableExists(\"test_crmoih_shetlandpony\")\n   354\t        # And test reversal\n   355\t        with connection.schema_editor() as editor:\n   356\t            operation.database_backwards(\n   357\t                \"test_crmoih\", editor, new_state, project_state\n   358\t            )\n   359\t        self.assertTableNotExists(\"test_crmoih_shetlandpony\")\n   360\t\n   361\t    def test_create_proxy_model(self):\n   362\t        \"\"\"\n   363\t        CreateModel ignores proxy models.\n   364\t        \"\"\"\n   365\t        project_state = self.set_up_test_model(\"test_crprmo\")\n   366\t        # Test the state alteration\n   367\t        operation = migrations.CreateModel(\n   368\t            \"ProxyPony\",\n   369\t            [],\n   370\t            options={\"proxy\": True},\n   371\t            bases=(\"test_crprmo.Pony\",),\n   372\t        )\n   373\t        self.assertEqual(operation.describe(), \"Create proxy model ProxyPony\")\n   374\t        new_state = project_state.clone()\n   375\t        operation.state_forwards(\"test_crprmo\", new_state)\n   376\t        self.assertIn((\"test_crprmo\", \"proxypony\"), new_state.models)\n   377\t        # Test the database alteration\n   378\t        self.assertTableNotExists(\"test_crprmo_proxypony\")\n   379\t        self.assertTableExists(\"test_crprmo_pony\")\n   380\t        with connection.schema_editor() as editor:\n   381\t            operation.database_forwards(\"test_crprmo\", editor, project_state, new_state)\n   382\t        self.assertTableNotExists(\"test_crprmo_proxypony\")\n   383\t        self.assertTableExists(\"test_crprmo_pony\")\n   384\t        # And test reversal\n   385\t        with connection.schema_editor() as editor:\n   386\t            operation.database_backwards(\n   387\t                \"test_crprmo\", editor, new_state, project_state\n   388\t            )\n   389\t        self.assertTableNotExists(\"test_crprmo_proxypony\")\n   390\t        self.assertTableExists(\"test_crprmo_pony\")\n   391\t        # And deconstruction\n   392\t        definition = operation.deconstruct()\n   393\t        self.assertEqual(definition[0], \"CreateModel\")\n   394\t        self.assertEqual(definition[1], [])\n   395\t        self.assertEqual(sorted(definition[2]), [\"bases\", \"fields\", \"name\", \"options\"])\n   396\t\n   397\t    def test_create_unmanaged_model(self):\n   398\t        \"\"\"\n   399\t        CreateModel ignores unmanaged models.\n   400\t        \"\"\"\n   401\t        project_state = self.set_up_test_model(\"test_crummo\")\n   402\t        # Test the state alteration\n   403\t        operation = migrations.CreateModel(\n   404\t            \"UnmanagedPony\",\n   405\t            [],\n   406\t            options={\"proxy\": True},\n   407\t            bases=(\"test_crummo.Pony\",),\n   408\t        )\n   409\t        self.assertEqual(operation.describe(), \"Create proxy model UnmanagedPony\")\n   410\t        new_state = project_state.clone()\n   411\t        operation.state_forwards(\"test_crummo\", new_state)\n   412\t        self.assertIn((\"test_crummo\", \"unmanagedpony\"), new_state.models)\n   413\t        # Test the database alteration\n   414\t        self.assertTableNotExists(\"test_crummo_unmanagedpony\")\n   415\t        self.assertTableExists(\"test_crummo_pony\")\n   416\t        with connection.schema_editor() as editor:\n   417\t            operation.database_forwards(\"test_crummo\", editor, project_state, new_state)\n   418\t        self.assertTableNotExists(\"test_crummo_unmanagedpony\")\n   419\t        self.assertTableExists(\"test_crummo_pony\")\n   420\t        # And test reversal\n   421\t        with connection.schema_editor() as editor:\n   422\t            operation.database_backwards(\n   423\t                \"test_crummo\", editor, new_state, project_state\n   424\t            )\n   425\t        self.assertTableNotExists(\"test_crummo_unmanagedpony\")\n   426\t        self.assertTableExists(\"test_crummo_pony\")\n   427\t\n   428\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n   429\t    def test_create_model_with_constraint(self):\n   430\t        where = models.Q(pink__gt=2)\n   431\t        check_constraint = models.CheckConstraint(\n   432\t            check=where, name=\"test_constraint_pony_pink_gt_2\"\n   433\t        )\n   434\t        operation = migrations.CreateModel(\n   435\t            \"Pony\",\n   436\t            [\n   437\t                (\"id\", models.AutoField(primary_key=True)),\n   438\t                (\"pink\", models.IntegerField(default=3)),\n   439\t            ],\n   440\t            options={\"constraints\": [check_constraint]},\n   441\t        )\n   442\t\n   443\t        # Test the state alteration\n   444\t        project_state = ProjectState()\n   445\t        new_state = project_state.clone()\n   446\t        operation.state_forwards(\"test_crmo\", new_state)\n   447\t        self.assertEqual(\n   448\t            len(new_state.models[\"test_crmo\", \"pony\"].options[\"constraints\"]), 1\n   449\t        )\n   450\t\n   451\t        # Test database alteration\n   452\t        self.assertTableNotExists(\"test_crmo_pony\")\n   453\t        with connection.schema_editor() as editor:\n   454\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n   455\t        self.assertTableExists(\"test_crmo_pony\")\n   456\t        with connection.cursor() as cursor:\n   457\t            with self.assertRaises(IntegrityError):\n   458\t                cursor.execute(\"INSERT INTO test_crmo_pony (id, pink) VALUES (1, 1)\")\n   459\t\n   460\t        # Test reversal\n   461\t        with connection.schema_editor() as editor:\n   462\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n   463\t        self.assertTableNotExists(\"test_crmo_pony\")\n   464\t\n   465\t        # Test deconstruction\n   466\t        definition = operation.deconstruct()\n   467\t        self.assertEqual(definition[0], \"CreateModel\")\n   468\t        self.assertEqual(definition[1], [])\n   469\t        self.assertEqual(definition[2][\"options\"][\"constraints\"], [check_constraint])\n   470\t\n   471\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n   472\t    def test_create_model_with_boolean_expression_in_check_constraint(self):\n   473\t        app_label = \"test_crmobechc\"\n   474\t        rawsql_constraint = models.CheckConstraint(\n   475\t            check=models.expressions.RawSQL(\n   476\t                \"price < %s\", (1000,), output_field=models.BooleanField()\n   477\t            ),\n   478\t            name=f\"{app_label}_price_lt_1000_raw\",\n   479\t        )\n   480\t        wrapper_constraint = models.CheckConstraint(\n   481\t            check=models.expressions.ExpressionWrapper(\n   482\t                models.Q(price__gt=500) | models.Q(price__lt=500),\n   483\t                output_field=models.BooleanField(),\n   484\t            ),\n   485\t            name=f\"{app_label}_price_neq_500_wrap\",\n   486\t        )\n   487\t        operation = migrations.CreateModel(\n   488\t            \"Product\",\n   489\t            [\n   490\t                (\"id\", models.AutoField(primary_key=True)),\n   491\t                (\"price\", models.IntegerField(null=True)),\n   492\t            ],\n   493\t            options={\"constraints\": [rawsql_constraint, wrapper_constraint]},\n   494\t        )\n   495\t\n   496\t        project_state = ProjectState()\n   497\t        new_state = project_state.clone()\n   498\t        operation.state_forwards(app_label, new_state)\n   499\t        # Add table.\n   500\t        self.assertTableNotExists(app_label)\n   501\t        with connection.schema_editor() as editor:\n   502\t            operation.database_forwards(app_label, editor, project_state, new_state)\n   503\t        self.assertTableExists(f\"{app_label}_product\")\n   504\t        insert_sql = f\"INSERT INTO {app_label}_product (id, price) VALUES (%d, %d)\"\n   505\t        with connection.cursor() as cursor:\n   506\t            with self.assertRaises(IntegrityError):\n   507\t                cursor.execute(insert_sql % (1, 1000))\n   508\t            cursor.execute(insert_sql % (1, 999))\n   509\t            with self.assertRaises(IntegrityError):\n   510\t                cursor.execute(insert_sql % (2, 500))\n   511\t            cursor.execute(insert_sql % (2, 499))\n   512\t\n   513\t    def test_create_model_with_partial_unique_constraint(self):\n   514\t        partial_unique_constraint = models.UniqueConstraint(\n   515\t            fields=[\"pink\"],\n   516\t            condition=models.Q(weight__gt=5),\n   517\t            name=\"test_constraint_pony_pink_for_weight_gt_5_uniq\",\n   518\t        )\n   519\t        operation = migrations.CreateModel(\n   520\t            \"Pony\",\n   521\t            [\n   522\t                (\"id\", models.AutoField(primary_key=True)),\n   523\t                (\"pink\", models.IntegerField(default=3)),\n   524\t                (\"weight\", models.FloatField()),\n   525\t            ],\n   526\t            options={\"constraints\": [partial_unique_constraint]},\n   527\t        )\n   528\t        # Test the state alteration\n   529\t        project_state = ProjectState()\n   530\t        new_state = project_state.clone()\n   531\t        operation.state_forwards(\"test_crmo\", new_state)\n   532\t        self.assertEqual(\n   533\t            len(new_state.models[\"test_crmo\", \"pony\"].options[\"constraints\"]), 1\n   534\t        )\n   535\t        # Test database alteration\n   536\t        self.assertTableNotExists(\"test_crmo_pony\")\n   537\t        with connection.schema_editor() as editor:\n   538\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n   539\t        self.assertTableExists(\"test_crmo_pony\")\n   540\t        # Test constraint works\n   541\t        Pony = new_state.apps.get_model(\"test_crmo\", \"Pony\")\n   542\t        Pony.objects.create(pink=1, weight=4.0)\n   543\t        Pony.objects.create(pink=1, weight=4.0)\n   544\t        Pony.objects.create(pink=1, weight=6.0)\n   545\t        if connection.features.supports_partial_indexes:\n   546\t            with self.assertRaises(IntegrityError):\n   547\t                Pony.objects.create(pink=1, weight=7.0)\n   548\t        else:\n   549\t            Pony.objects.create(pink=1, weight=7.0)\n   550\t        # Test reversal\n   551\t        with connection.schema_editor() as editor:\n   552\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n   553\t        self.assertTableNotExists(\"test_crmo_pony\")\n   554\t        # Test deconstruction\n   555\t        definition = operation.deconstruct()\n   556\t        self.assertEqual(definition[0], \"CreateModel\")\n   557\t        self.assertEqual(definition[1], [])\n   558\t        self.assertEqual(\n   559\t            definition[2][\"options\"][\"constraints\"], [partial_unique_constraint]\n   560\t        )\n   561\t\n   562\t    def test_create_model_with_deferred_unique_constraint(self):\n   563\t        deferred_unique_constraint = models.UniqueConstraint(\n   564\t            fields=[\"pink\"],\n   565\t            name=\"deferrable_pink_constraint\",\n   566\t            deferrable=models.Deferrable.DEFERRED,\n   567\t        )\n   568\t        operation = migrations.CreateModel(\n   569\t            \"Pony\",\n   570\t            [\n   571\t                (\"id\", models.AutoField(primary_key=True)),\n   572\t                (\"pink\", models.IntegerField(default=3)),\n   573\t            ],\n   574\t            options={\"constraints\": [deferred_unique_constraint]},\n   575\t        )\n   576\t        project_state = ProjectState()\n   577\t        new_state = project_state.clone()\n   578\t        operation.state_forwards(\"test_crmo\", new_state)\n   579\t        self.assertEqual(\n   580\t            len(new_state.models[\"test_crmo\", \"pony\"].options[\"constraints\"]), 1\n   581\t        )\n   582\t        self.assertTableNotExists(\"test_crmo_pony\")\n   583\t        # Create table.\n   584\t        with connection.schema_editor() as editor:\n   585\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n   586\t        self.assertTableExists(\"test_crmo_pony\")\n   587\t        Pony = new_state.apps.get_model(\"test_crmo\", \"Pony\")\n   588\t        Pony.objects.create(pink=1)\n   589\t        if connection.features.supports_deferrable_unique_constraints:\n   590\t            # Unique constraint is deferred.\n   591\t            with transaction.atomic():\n   592\t                obj = Pony.objects.create(pink=1)\n   593\t                obj.pink = 2\n   594\t                obj.save()\n   595\t            # Constraint behavior can be changed with SET CONSTRAINTS.\n   596\t            with self.assertRaises(IntegrityError):\n   597\t                with transaction.atomic(), connection.cursor() as cursor:\n   598\t                    quoted_name = connection.ops.quote_name(\n   599\t                        deferred_unique_constraint.name\n   600\t                    )\n   601\t                    cursor.execute(\"SET CONSTRAINTS %s IMMEDIATE\" % quoted_name)\n   602\t                    obj = Pony.objects.create(pink=1)\n   603\t                    obj.pink = 3\n   604\t                    obj.save()\n   605\t        else:\n   606\t            Pony.objects.create(pink=1)\n   607\t        # Reversal.\n   608\t        with connection.schema_editor() as editor:\n   609\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n   610\t        self.assertTableNotExists(\"test_crmo_pony\")\n   611\t        # Deconstruction.\n   612\t        definition = operation.deconstruct()\n   613\t        self.assertEqual(definition[0], \"CreateModel\")\n   614\t        self.assertEqual(definition[1], [])\n   615\t        self.assertEqual(\n   616\t            definition[2][\"options\"][\"constraints\"],\n   617\t            [deferred_unique_constraint],\n   618\t        )\n   619\t\n   620\t    @skipUnlessDBFeature(\"supports_covering_indexes\")\n   621\t    def test_create_model_with_covering_unique_constraint(self):\n   622\t        covering_unique_constraint = models.UniqueConstraint(\n   623\t            fields=[\"pink\"],\n   624\t            include=[\"weight\"],\n   625\t            name=\"test_constraint_pony_pink_covering_weight\",\n   626\t        )\n   627\t        operation = migrations.CreateModel(\n   628\t            \"Pony\",\n   629\t            [\n   630\t                (\"id\", models.AutoField(primary_key=True)),\n   631\t                (\"pink\", models.IntegerField(default=3)),\n   632\t                (\"weight\", models.FloatField()),\n   633\t            ],\n   634\t            options={\"constraints\": [covering_unique_constraint]},\n   635\t        )\n   636\t        project_state = ProjectState()\n   637\t        new_state = project_state.clone()\n   638\t        operation.state_forwards(\"test_crmo\", new_state)\n   639\t        self.assertEqual(\n   640\t            len(new_state.models[\"test_crmo\", \"pony\"].options[\"constraints\"]), 1\n   641\t        )\n   642\t        self.assertTableNotExists(\"test_crmo_pony\")\n   643\t        # Create table.\n   644\t        with connection.schema_editor() as editor:\n   645\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n   646\t        self.assertTableExists(\"test_crmo_pony\")\n   647\t        Pony = new_state.apps.get_model(\"test_crmo\", \"Pony\")\n   648\t        Pony.objects.create(pink=1, weight=4.0)\n   649\t        with self.assertRaises(IntegrityError):\n   650\t            Pony.objects.create(pink=1, weight=7.0)\n   651\t        # Reversal.\n   652\t        with connection.schema_editor() as editor:\n   653\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n   654\t        self.assertTableNotExists(\"test_crmo_pony\")\n   655\t        # Deconstruction.\n   656\t        definition = operation.deconstruct()\n   657\t        self.assertEqual(definition[0], \"CreateModel\")\n   658\t        self.assertEqual(definition[1], [])\n   659\t        self.assertEqual(\n   660\t            definition[2][\"options\"][\"constraints\"],\n   661\t            [covering_unique_constraint],\n   662\t        )\n   663\t\n   664\t    def test_create_model_managers(self):\n   665\t        \"\"\"\n   666\t        The managers on a model are set.\n   667\t        \"\"\"\n   668\t        project_state = self.set_up_test_model(\"test_cmoma\")\n   669\t        # Test the state alteration\n   670\t        operation = migrations.CreateModel(\n   671\t            \"Food\",\n   672\t            fields=[\n   673\t                (\"id\", models.AutoField(primary_key=True)),\n   674\t            ],\n   675\t            managers=[\n   676\t                (\"food_qs\", FoodQuerySet.as_manager()),\n   677\t                (\"food_mgr\", FoodManager(\"a\", \"b\")),\n   678\t                (\"food_mgr_kwargs\", FoodManager(\"x\", \"y\", 3, 4)),\n   679\t            ],\n   680\t        )\n   681\t        self.assertEqual(operation.describe(), \"Create model Food\")\n   682\t        new_state = project_state.clone()\n   683\t        operation.state_forwards(\"test_cmoma\", new_state)\n   684\t        self.assertIn((\"test_cmoma\", \"food\"), new_state.models)\n   685\t        managers = new_state.models[\"test_cmoma\", \"food\"].managers\n   686\t        self.assertEqual(managers[0][0], \"food_qs\")\n   687\t        self.assertIsInstance(managers[0][1], models.Manager)\n   688\t        self.assertEqual(managers[1][0], \"food_mgr\")\n   689\t        self.assertIsInstance(managers[1][1], FoodManager)\n   690\t        self.assertEqual(managers[1][1].args, (\"a\", \"b\", 1, 2))\n   691\t        self.assertEqual(managers[2][0], \"food_mgr_kwargs\")\n   692\t        self.assertIsInstance(managers[2][1], FoodManager)\n   693\t        self.assertEqual(managers[2][1].args, (\"x\", \"y\", 3, 4))\n   694\t\n   695\t    def test_delete_model(self):\n   696\t        \"\"\"\n   697\t        Tests the DeleteModel operation.\n   698\t        \"\"\"\n   699\t        project_state = self.set_up_test_model(\"test_dlmo\")\n   700\t        # Test the state alteration\n   701\t        operation = migrations.DeleteModel(\"Pony\")\n   702\t        self.assertEqual(operation.describe(), \"Delete model Pony\")\n   703\t        self.assertEqual(operation.migration_name_fragment, \"delete_pony\")\n   704\t        new_state = project_state.clone()\n   705\t        operation.state_forwards(\"test_dlmo\", new_state)\n   706\t        self.assertNotIn((\"test_dlmo\", \"pony\"), new_state.models)\n   707\t        # Test the database alteration\n   708\t        self.assertTableExists(\"test_dlmo_pony\")\n   709\t        with connection.schema_editor() as editor:\n   710\t            operation.database_forwards(\"test_dlmo\", editor, project_state, new_state)\n   711\t        self.assertTableNotExists(\"test_dlmo_pony\")\n   712\t        # And test reversal\n   713\t        with connection.schema_editor() as editor:\n   714\t            operation.database_backwards(\"test_dlmo\", editor, new_state, project_state)\n   715\t        self.assertTableExists(\"test_dlmo_pony\")\n   716\t        # And deconstruction\n   717\t        definition = operation.deconstruct()\n   718\t        self.assertEqual(definition[0], \"DeleteModel\")\n   719\t        self.assertEqual(definition[1], [])\n   720\t        self.assertEqual(list(definition[2]), [\"name\"])\n   721\t\n   722\t    def test_delete_proxy_model(self):\n   723\t        \"\"\"\n   724\t        Tests the DeleteModel operation ignores proxy models.\n   725\t        \"\"\"\n   726\t        project_state = self.set_up_test_model(\"test_dlprmo\", proxy_model=True)\n   727\t        # Test the state alteration\n   728\t        operation = migrations.DeleteModel(\"ProxyPony\")\n   729\t        new_state = project_state.clone()\n   730\t        operation.state_forwards(\"test_dlprmo\", new_state)\n   731\t        self.assertIn((\"test_dlprmo\", \"proxypony\"), project_state.models)\n   732\t        self.assertNotIn((\"test_dlprmo\", \"proxypony\"), new_state.models)\n   733\t        # Test the database alteration\n   734\t        self.assertTableExists(\"test_dlprmo_pony\")\n   735\t        self.assertTableNotExists(\"test_dlprmo_proxypony\")\n   736\t        with connection.schema_editor() as editor:\n   737\t            operation.database_forwards(\"test_dlprmo\", editor, project_state, new_state)\n   738\t        self.assertTableExists(\"test_dlprmo_pony\")\n   739\t        self.assertTableNotExists(\"test_dlprmo_proxypony\")\n   740\t        # And test reversal\n   741\t        with connection.schema_editor() as editor:\n   742\t            operation.database_backwards(\n   743\t                \"test_dlprmo\", editor, new_state, project_state\n   744\t            )\n   745\t        self.assertTableExists(\"test_dlprmo_pony\")\n   746\t        self.assertTableNotExists(\"test_dlprmo_proxypony\")\n   747\t\n   748\t    def test_delete_mti_model(self):\n   749\t        project_state = self.set_up_test_model(\"test_dlmtimo\", mti_model=True)\n   750\t        # Test the state alteration\n   751\t        operation = migrations.DeleteModel(\"ShetlandPony\")\n   752\t        new_state = project_state.clone()\n   753\t        operation.state_forwards(\"test_dlmtimo\", new_state)\n   754\t        self.assertIn((\"test_dlmtimo\", \"shetlandpony\"), project_state.models)\n   755\t        self.assertNotIn((\"test_dlmtimo\", \"shetlandpony\"), new_state.models)\n   756\t        # Test the database alteration\n   757\t        self.assertTableExists(\"test_dlmtimo_pony\")\n   758\t        self.assertTableExists(\"test_dlmtimo_shetlandpony\")\n   759\t        self.assertColumnExists(\"test_dlmtimo_shetlandpony\", \"pony_ptr_id\")\n   760\t        with connection.schema_editor() as editor:\n   761\t            operation.database_forwards(\n   762\t                \"test_dlmtimo\", editor, project_state, new_state\n   763\t            )\n   764\t        self.assertTableExists(\"test_dlmtimo_pony\")\n   765\t        self.assertTableNotExists(\"test_dlmtimo_shetlandpony\")\n   766\t        # And test reversal\n   767\t        with connection.schema_editor() as editor:\n   768\t            operation.database_backwards(\n   769\t                \"test_dlmtimo\", editor, new_state, project_state\n   770\t            )\n   771\t        self.assertTableExists(\"test_dlmtimo_pony\")\n   772\t        self.assertTableExists(\"test_dlmtimo_shetlandpony\")\n   773\t        self.assertColumnExists(\"test_dlmtimo_shetlandpony\", \"pony_ptr_id\")\n   774\t\n   775\t    def test_rename_model(self):\n   776\t        \"\"\"\n   777\t        Tests the RenameModel operation.\n   778\t        \"\"\"\n   779\t        project_state = self.set_up_test_model(\"test_rnmo\", related_model=True)\n   780\t        # Test the state alteration\n   781\t        operation = migrations.RenameModel(\"Pony\", \"Horse\")\n   782\t        self.assertEqual(operation.describe(), \"Rename model Pony to Horse\")\n   783\t        self.assertEqual(operation.migration_name_fragment, \"rename_pony_horse\")\n   784\t        # Test initial state and database\n   785\t        self.assertIn((\"test_rnmo\", \"pony\"), project_state.models)\n   786\t        self.assertNotIn((\"test_rnmo\", \"horse\"), project_state.models)\n   787\t        self.assertTableExists(\"test_rnmo_pony\")\n   788\t        self.assertTableNotExists(\"test_rnmo_horse\")\n   789\t        if connection.features.supports_foreign_keys:\n   790\t            self.assertFKExists(\n   791\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_pony\", \"id\")\n   792\t            )\n   793\t            self.assertFKNotExists(\n   794\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_horse\", \"id\")\n   795\t            )\n   796\t        # Migrate forwards\n   797\t        new_state = project_state.clone()\n   798\t        atomic_rename = connection.features.supports_atomic_references_rename\n   799\t        new_state = self.apply_operations(\n   800\t            \"test_rnmo\", new_state, [operation], atomic=atomic_rename\n   801\t        )\n   802\t        # Test new state and database\n   803\t        self.assertNotIn((\"test_rnmo\", \"pony\"), new_state.models)\n   804\t        self.assertIn((\"test_rnmo\", \"horse\"), new_state.models)\n   805\t        # RenameModel also repoints all incoming FKs and M2Ms\n   806\t        self.assertEqual(\n   807\t            new_state.models[\"test_rnmo\", \"rider\"].fields[\"pony\"].remote_field.model,\n   808\t            \"test_rnmo.Horse\",\n   809\t        )\n   810\t        self.assertTableNotExists(\"test_rnmo_pony\")\n   811\t        self.assertTableExists(\"test_rnmo_horse\")\n   812\t        if connection.features.supports_foreign_keys:\n   813\t            self.assertFKNotExists(\n   814\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_pony\", \"id\")\n   815\t            )\n   816\t            self.assertFKExists(\n   817\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_horse\", \"id\")\n   818\t            )\n   819\t        # Migrate backwards\n   820\t        original_state = self.unapply_operations(\n   821\t            \"test_rnmo\", project_state, [operation], atomic=atomic_rename\n   822\t        )\n   823\t        # Test original state and database\n   824\t        self.assertIn((\"test_rnmo\", \"pony\"), original_state.models)\n   825\t        self.assertNotIn((\"test_rnmo\", \"horse\"), original_state.models)\n   826\t        self.assertEqual(\n   827\t            original_state.models[\"test_rnmo\", \"rider\"]\n   828\t            .fields[\"pony\"]\n   829\t            .remote_field.model,\n   830\t            \"Pony\",\n   831\t        )\n   832\t        self.assertTableExists(\"test_rnmo_pony\")\n   833\t        self.assertTableNotExists(\"test_rnmo_horse\")\n   834\t        if connection.features.supports_foreign_keys:\n   835\t            self.assertFKExists(\n   836\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_pony\", \"id\")\n   837\t            )\n   838\t            self.assertFKNotExists(\n   839\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_horse\", \"id\")\n   840\t            )\n   841\t        # And deconstruction\n   842\t        definition = operation.deconstruct()\n   843\t        self.assertEqual(definition[0], \"RenameModel\")\n   844\t        self.assertEqual(definition[1], [])\n   845\t        self.assertEqual(definition[2], {\"old_name\": \"Pony\", \"new_name\": \"Horse\"})\n   846\t\n   847\t    def test_rename_model_state_forwards(self):\n   848\t        \"\"\"\n   849\t        RenameModel operations shouldn't trigger the caching of rendered apps\n   850\t        on state without prior apps.\n   851\t        \"\"\"\n   852\t        state = ProjectState()\n   853\t        state.add_model(ModelState(\"migrations\", \"Foo\", []))\n   854\t        operation = migrations.RenameModel(\"Foo\", \"Bar\")\n   855\t        operation.state_forwards(\"migrations\", state)\n   856\t        self.assertNotIn(\"apps\", state.__dict__)\n   857\t        self.assertNotIn((\"migrations\", \"foo\"), state.models)\n   858\t        self.assertIn((\"migrations\", \"bar\"), state.models)\n   859\t        # Now with apps cached.\n   860\t        apps = state.apps\n   861\t        operation = migrations.RenameModel(\"Bar\", \"Foo\")\n   862\t        operation.state_forwards(\"migrations\", state)\n   863\t        self.assertIs(state.apps, apps)\n   864\t        self.assertNotIn((\"migrations\", \"bar\"), state.models)\n   865\t        self.assertIn((\"migrations\", \"foo\"), state.models)\n   866\t\n   867\t    def test_rename_model_with_self_referential_fk(self):\n   868\t        \"\"\"\n   869\t        Tests the RenameModel operation on model with self referential FK.\n   870\t        \"\"\"\n   871\t        project_state = self.set_up_test_model(\"test_rmwsrf\", related_model=True)\n   872\t        # Test the state alteration\n   873\t        operation = migrations.RenameModel(\"Rider\", \"HorseRider\")\n   874\t        self.assertEqual(operation.describe(), \"Rename model Rider to HorseRider\")\n   875\t        new_state = project_state.clone()\n   876\t        operation.state_forwards(\"test_rmwsrf\", new_state)\n   877\t        self.assertNotIn((\"test_rmwsrf\", \"rider\"), new_state.models)\n   878\t        self.assertIn((\"test_rmwsrf\", \"horserider\"), new_state.models)\n   879\t        # Remember, RenameModel also repoints all incoming FKs and M2Ms\n   880\t        self.assertEqual(\n   881\t            \"self\",\n   882\t            new_state.models[\"test_rmwsrf\", \"horserider\"]\n   883\t            .fields[\"friend\"]\n   884\t            .remote_field.model,\n   885\t        )\n   886\t        HorseRider = new_state.apps.get_model(\"test_rmwsrf\", \"horserider\")\n   887\t        self.assertIs(\n   888\t            HorseRider._meta.get_field(\"horserider\").remote_field.model, HorseRider\n   889\t        )\n   890\t        # Test the database alteration\n   891\t        self.assertTableExists(\"test_rmwsrf_rider\")\n   892\t        self.assertTableNotExists(\"test_rmwsrf_horserider\")\n   893\t        if connection.features.supports_foreign_keys:\n   894\t            self.assertFKExists(\n   895\t                \"test_rmwsrf_rider\", [\"friend_id\"], (\"test_rmwsrf_rider\", \"id\")\n   896\t            )\n   897\t            self.assertFKNotExists(\n   898\t                \"test_rmwsrf_rider\", [\"friend_id\"], (\"test_rmwsrf_horserider\", \"id\")\n   899\t            )\n   900\t        atomic_rename = connection.features.supports_atomic_references_rename\n   901\t        with connection.schema_editor(atomic=atomic_rename) as editor:\n   902\t            operation.database_forwards(\"test_rmwsrf\", editor, project_state, new_state)\n   903\t        self.assertTableNotExists(\"test_rmwsrf_rider\")\n   904\t        self.assertTableExists(\"test_rmwsrf_horserider\")\n   905\t        if connection.features.supports_foreign_keys:\n   906\t            self.assertFKNotExists(\n   907\t                \"test_rmwsrf_horserider\", [\"friend_id\"], (\"test_rmwsrf_rider\", \"id\")\n   908\t            )\n   909\t            self.assertFKExists(\n   910\t                \"test_rmwsrf_horserider\",\n   911\t                [\"friend_id\"],\n   912\t                (\"test_rmwsrf_horserider\", \"id\"),\n   913\t            )\n   914\t        # And test reversal\n   915\t        with connection.schema_editor(atomic=atomic_rename) as editor:\n   916\t            operation.database_backwards(\n   917\t                \"test_rmwsrf\", editor, new_state, project_state\n   918\t            )\n   919\t        self.assertTableExists(\"test_rmwsrf_rider\")\n   920\t        self.assertTableNotExists(\"test_rmwsrf_horserider\")\n   921\t        if connection.features.supports_foreign_keys:\n   922\t            self.assertFKExists(\n   923\t                \"test_rmwsrf_rider\", [\"friend_id\"], (\"test_rmwsrf_rider\", \"id\")\n   924\t            )\n   925\t            self.assertFKNotExists(\n   926\t                \"test_rmwsrf_rider\", [\"friend_id\"], (\"test_rmwsrf_horserider\", \"id\")\n   927\t            )\n   928\t\n   929\t    def test_rename_model_with_superclass_fk(self):\n   930\t        \"\"\"\n   931\t        Tests the RenameModel operation on a model which has a superclass that\n   932\t        has a foreign key.\n   933\t        \"\"\"\n   934\t        project_state = self.set_up_test_model(\n   935\t            \"test_rmwsc\", related_model=True, mti_model=True\n   936\t        )\n   937\t        # Test the state alteration\n   938\t        operation = migrations.RenameModel(\"ShetlandPony\", \"LittleHorse\")\n   939\t        self.assertEqual(\n   940\t            operation.describe(), \"Rename model ShetlandPony to LittleHorse\"\n   941\t        )\n   942\t        new_state = project_state.clone()\n   943\t        operation.state_forwards(\"test_rmwsc\", new_state)\n   944\t        self.assertNotIn((\"test_rmwsc\", \"shetlandpony\"), new_state.models)\n   945\t        self.assertIn((\"test_rmwsc\", \"littlehorse\"), new_state.models)\n   946\t        # RenameModel shouldn't repoint the superclass's relations, only local ones\n   947\t        self.assertEqual(\n   948\t            project_state.models[\"test_rmwsc\", \"rider\"]\n   949\t            .fields[\"pony\"]\n   950\t            .remote_field.model,\n   951\t            new_state.models[\"test_rmwsc\", \"rider\"].fields[\"pony\"].remote_field.model,\n   952\t        )\n   953\t        # Before running the migration we have a table for Shetland Pony, not\n   954\t        # Little Horse.\n   955\t        self.assertTableExists(\"test_rmwsc_shetlandpony\")\n   956\t        self.assertTableNotExists(\"test_rmwsc_littlehorse\")\n   957\t        if connection.features.supports_foreign_keys:\n   958\t            # and the foreign key on rider points to pony, not shetland pony\n   959\t            self.assertFKExists(\n   960\t                \"test_rmwsc_rider\", [\"pony_id\"], (\"test_rmwsc_pony\", \"id\")\n   961\t            )\n   962\t            self.assertFKNotExists(\n   963\t                \"test_rmwsc_rider\", [\"pony_id\"], (\"test_rmwsc_shetlandpony\", \"id\")\n   964\t            )\n   965\t        with connection.schema_editor(\n   966\t            atomic=connection.features.supports_atomic_references_rename\n   967\t        ) as editor:\n   968\t            operation.database_forwards(\"test_rmwsc\", editor, project_state, new_state)\n   969\t        # Now we have a little horse table, not shetland pony\n   970\t        self.assertTableNotExists(\"test_rmwsc_shetlandpony\")\n   971\t        self.assertTableExists(\"test_rmwsc_littlehorse\")\n   972\t        if connection.features.supports_foreign_keys:\n   973\t            # but the Foreign keys still point at pony, not little horse\n   974\t            self.assertFKExists(\n   975\t                \"test_rmwsc_rider\", [\"pony_id\"], (\"test_rmwsc_pony\", \"id\")\n   976\t            )\n   977\t            self.assertFKNotExists(\n   978\t                \"test_rmwsc_rider\", [\"pony_id\"], (\"test_rmwsc_littlehorse\", \"id\")\n   979\t            )\n   980\t\n   981\t    def test_rename_model_with_self_referential_m2m(self):\n   982\t        app_label = \"test_rename_model_with_self_referential_m2m\"\n   983\t\n   984\t        project_state = self.apply_operations(\n   985\t            app_label,\n   986\t            ProjectState(),\n   987\t            operations=[\n   988\t                migrations.CreateModel(\n   989\t                    \"ReflexivePony\",\n   990\t                    fields=[\n   991\t                        (\"id\", models.AutoField(primary_key=True)),\n   992\t                        (\"ponies\", models.ManyToManyField(\"self\")),\n   993\t                    ],\n   994\t                ),\n   995\t            ],\n   996\t        )\n   997\t        project_state = self.apply_operations(\n   998\t            app_label,\n   999\t            project_state,\n  1000\t            operations=[\n  1001\t                migrations.RenameModel(\"ReflexivePony\", \"ReflexivePony2\"),\n  1002\t            ],\n  1003\t            atomic=connection.features.supports_atomic_references_rename,\n  1004\t        )\n  1005\t        Pony = project_state.apps.get_model(app_label, \"ReflexivePony2\")\n  1006\t        pony = Pony.objects.create()\n  1007\t        pony.ponies.add(pony)\n  1008\t\n  1009\t    def test_rename_model_with_m2m(self):\n  1010\t        app_label = \"test_rename_model_with_m2m\"\n  1011\t        project_state = self.apply_operations(\n  1012\t            app_label,\n  1013\t            ProjectState(),\n  1014\t            operations=[\n  1015\t                migrations.CreateModel(\n  1016\t                    \"Rider\",\n  1017\t                    fields=[\n  1018\t                        (\"id\", models.AutoField(primary_key=True)),\n  1019\t                    ],\n  1020\t                ),\n  1021\t                migrations.CreateModel(\n  1022\t                    \"Pony\",\n  1023\t                    fields=[\n  1024\t                        (\"id\", models.AutoField(primary_key=True)),\n  1025\t                        (\"riders\", models.ManyToManyField(\"Rider\")),\n  1026\t                    ],\n  1027\t                ),\n  1028\t            ],\n  1029\t        )\n  1030\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1031\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1032\t        pony = Pony.objects.create()\n  1033\t        rider = Rider.objects.create()\n  1034\t        pony.riders.add(rider)\n  1035\t\n  1036\t        project_state = self.apply_operations(\n  1037\t            app_label,\n  1038\t            project_state,\n  1039\t            operations=[\n  1040\t                migrations.RenameModel(\"Pony\", \"Pony2\"),\n  1041\t            ],\n  1042\t            atomic=connection.features.supports_atomic_references_rename,\n  1043\t        )\n  1044\t        Pony = project_state.apps.get_model(app_label, \"Pony2\")\n  1045\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1046\t        pony = Pony.objects.create()\n  1047\t        rider = Rider.objects.create()\n  1048\t        pony.riders.add(rider)\n  1049\t        self.assertEqual(Pony.objects.count(), 2)\n  1050\t        self.assertEqual(Rider.objects.count(), 2)\n  1051\t        self.assertEqual(\n  1052\t            Pony._meta.get_field(\"riders\").remote_field.through.objects.count(), 2\n  1053\t        )\n  1054\t\n  1055\t    def test_rename_model_with_db_table_noop(self):\n  1056\t        app_label = \"test_rmwdbtn\"\n  1057\t        project_state = self.apply_operations(\n  1058\t            app_label,\n  1059\t            ProjectState(),\n  1060\t            operations=[\n  1061\t                migrations.CreateModel(\n  1062\t                    \"Rider\",\n  1063\t                    fields=[\n  1064\t                        (\"id\", models.AutoField(primary_key=True)),\n  1065\t                    ],\n  1066\t                    options={\"db_table\": \"rider\"},\n  1067\t                ),\n  1068\t                migrations.CreateModel(\n  1069\t                    \"Pony\",\n  1070\t                    fields=[\n  1071\t                        (\"id\", models.AutoField(primary_key=True)),\n  1072\t                        (\n  1073\t                            \"rider\",\n  1074\t                            models.ForeignKey(\"%s.Rider\" % app_label, models.CASCADE),\n  1075\t                        ),\n  1076\t                    ],\n  1077\t                ),\n  1078\t            ],\n  1079\t        )\n  1080\t        new_state = project_state.clone()\n  1081\t        operation = migrations.RenameModel(\"Rider\", \"Runner\")\n  1082\t        operation.state_forwards(app_label, new_state)\n  1083\t\n  1084\t        with connection.schema_editor() as editor:\n  1085\t            with self.assertNumQueries(0):\n  1086\t                operation.database_forwards(app_label, editor, project_state, new_state)\n  1087\t        with connection.schema_editor() as editor:\n  1088\t            with self.assertNumQueries(0):\n  1089\t                operation.database_backwards(\n  1090\t                    app_label, editor, new_state, project_state\n  1091\t                )\n  1092\t\n  1093\t    def test_rename_m2m_target_model(self):\n  1094\t        app_label = \"test_rename_m2m_target_model\"\n  1095\t        project_state = self.apply_operations(\n  1096\t            app_label,\n  1097\t            ProjectState(),\n  1098\t            operations=[\n  1099\t                migrations.CreateModel(\n  1100\t                    \"Rider\",\n  1101\t                    fields=[\n  1102\t                        (\"id\", models.AutoField(primary_key=True)),\n  1103\t                    ],\n  1104\t                ),\n  1105\t                migrations.CreateModel(\n  1106\t                    \"Pony\",\n  1107\t                    fields=[\n  1108\t                        (\"id\", models.AutoField(primary_key=True)),\n  1109\t                        (\"riders\", models.ManyToManyField(\"Rider\")),\n  1110\t                    ],\n  1111\t                ),\n  1112\t            ],\n  1113\t        )\n  1114\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1115\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1116\t        pony = Pony.objects.create()\n  1117\t        rider = Rider.objects.create()\n  1118\t        pony.riders.add(rider)\n  1119\t\n  1120\t        project_state = self.apply_operations(\n  1121\t            app_label,\n  1122\t            project_state,\n  1123\t            operations=[\n  1124\t                migrations.RenameModel(\"Rider\", \"Rider2\"),\n  1125\t            ],\n  1126\t            atomic=connection.features.supports_atomic_references_rename,\n  1127\t        )\n  1128\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1129\t        Rider = project_state.apps.get_model(app_label, \"Rider2\")\n  1130\t        pony = Pony.objects.create()\n  1131\t        rider = Rider.objects.create()\n  1132\t        pony.riders.add(rider)\n  1133\t        self.assertEqual(Pony.objects.count(), 2)\n  1134\t        self.assertEqual(Rider.objects.count(), 2)\n  1135\t        self.assertEqual(\n  1136\t            Pony._meta.get_field(\"riders\").remote_field.through.objects.count(), 2\n  1137\t        )\n  1138\t\n  1139\t    def test_rename_m2m_through_model(self):\n  1140\t        app_label = \"test_rename_through\"\n  1141\t        project_state = self.apply_operations(\n  1142\t            app_label,\n  1143\t            ProjectState(),\n  1144\t            operations=[\n  1145\t                migrations.CreateModel(\n  1146\t                    \"Rider\",\n  1147\t                    fields=[\n  1148\t                        (\"id\", models.AutoField(primary_key=True)),\n  1149\t                    ],\n  1150\t                ),\n  1151\t                migrations.CreateModel(\n  1152\t                    \"Pony\",\n  1153\t                    fields=[\n  1154\t                        (\"id\", models.AutoField(primary_key=True)),\n  1155\t                    ],\n  1156\t                ),\n  1157\t                migrations.CreateModel(\n  1158\t                    \"PonyRider\",\n  1159\t                    fields=[\n  1160\t                        (\"id\", models.AutoField(primary_key=True)),\n  1161\t                        (\n  1162\t                            \"rider\",\n  1163\t                            models.ForeignKey(\n  1164\t                                \"test_rename_through.Rider\", models.CASCADE\n  1165\t                            ),\n  1166\t                        ),\n  1167\t                        (\n  1168\t                            \"pony\",\n  1169\t                            models.ForeignKey(\n  1170\t                                \"test_rename_through.Pony\", models.CASCADE\n  1171\t                            ),\n  1172\t                        ),\n  1173\t                    ],\n  1174\t                ),\n  1175\t                migrations.AddField(\n  1176\t                    \"Pony\",\n  1177\t                    \"riders\",\n  1178\t                    models.ManyToManyField(\n  1179\t                        \"test_rename_through.Rider\",\n  1180\t                        through=\"test_rename_through.PonyRider\",\n  1181\t                    ),\n  1182\t                ),\n  1183\t            ],\n  1184\t        )\n  1185\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1186\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1187\t        PonyRider = project_state.apps.get_model(app_label, \"PonyRider\")\n  1188\t        pony = Pony.objects.create()\n  1189\t        rider = Rider.objects.create()\n  1190\t        PonyRider.objects.create(pony=pony, rider=rider)\n  1191\t\n  1192\t        project_state = self.apply_operations(\n  1193\t            app_label,\n  1194\t            project_state,\n  1195\t            operations=[\n  1196\t                migrations.RenameModel(\"PonyRider\", \"PonyRider2\"),\n  1197\t            ],\n  1198\t        )\n  1199\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1200\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1201\t        PonyRider = project_state.apps.get_model(app_label, \"PonyRider2\")\n  1202\t        pony = Pony.objects.first()\n  1203\t        rider = Rider.objects.create()\n  1204\t        PonyRider.objects.create(pony=pony, rider=rider)\n  1205\t        self.assertEqual(Pony.objects.count(), 1)\n  1206\t        self.assertEqual(Rider.objects.count(), 2)\n  1207\t        self.assertEqual(PonyRider.objects.count(), 2)\n  1208\t        self.assertEqual(pony.riders.count(), 2)\n  1209\t\n  1210\t    def test_rename_m2m_model_after_rename_field(self):\n  1211\t        \"\"\"RenameModel renames a many-to-many column after a RenameField.\"\"\"\n  1212\t        app_label = \"test_rename_multiple\"\n  1213\t        project_state = self.apply_operations(\n  1214\t            app_label,\n  1215\t            ProjectState(),\n  1216\t            operations=[\n  1217\t                migrations.CreateModel(\n  1218\t                    \"Pony\",\n  1219\t                    fields=[\n  1220\t                        (\"id\", models.AutoField(primary_key=True)),\n  1221\t                        (\"name\", models.CharField(max_length=20)),\n  1222\t                    ],\n  1223\t                ),\n  1224\t                migrations.CreateModel(\n  1225\t                    \"Rider\",\n  1226\t                    fields=[\n  1227\t                        (\"id\", models.AutoField(primary_key=True)),\n  1228\t                        (\n  1229\t                            \"pony\",\n  1230\t                            models.ForeignKey(\n  1231\t                                \"test_rename_multiple.Pony\", models.CASCADE\n  1232\t                            ),\n  1233\t                        ),\n  1234\t                    ],\n  1235\t                ),\n  1236\t                migrations.CreateModel(\n  1237\t                    \"PonyRider\",\n  1238\t                    fields=[\n  1239\t                        (\"id\", models.AutoField(primary_key=True)),\n  1240\t                        (\"riders\", models.ManyToManyField(\"Rider\")),\n  1241\t                    ],\n  1242\t                ),\n  1243\t                migrations.RenameField(\n  1244\t                    model_name=\"pony\", old_name=\"name\", new_name=\"fancy_name\"\n  1245\t                ),\n  1246\t                migrations.RenameModel(old_name=\"Rider\", new_name=\"Jockey\"),\n  1247\t            ],\n  1248\t            atomic=connection.features.supports_atomic_references_rename,\n  1249\t        )\n  1250\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1251\t        Jockey = project_state.apps.get_model(app_label, \"Jockey\")\n  1252\t        PonyRider = project_state.apps.get_model(app_label, \"PonyRider\")\n  1253\t        # No \"no such column\" error means the column was renamed correctly.\n  1254\t        pony = Pony.objects.create(fancy_name=\"a good name\")\n  1255\t        jockey = Jockey.objects.create(pony=pony)\n  1256\t        ponyrider = PonyRider.objects.create()\n  1257\t        ponyrider.riders.add(jockey)\n  1258\t\n  1259\t    def test_add_field(self):\n  1260\t        \"\"\"\n  1261\t        Tests the AddField operation.\n  1262\t        \"\"\"\n  1263\t        # Test the state alteration\n  1264\t        operation = migrations.AddField(\n  1265\t            \"Pony\",\n  1266\t            \"height\",\n  1267\t            models.FloatField(null=True, default=5),\n  1268\t        )\n  1269\t        self.assertEqual(operation.describe(), \"Add field height to Pony\")\n  1270\t        self.assertEqual(operation.migration_name_fragment, \"pony_height\")\n  1271\t        project_state, new_state = self.make_test_state(\"test_adfl\", operation)\n  1272\t        self.assertEqual(len(new_state.models[\"test_adfl\", \"pony\"].fields), 4)\n  1273\t        field = new_state.models[\"test_adfl\", \"pony\"].fields[\"height\"]\n  1274\t        self.assertEqual(field.default, 5)\n  1275\t        # Test the database alteration\n  1276\t        self.assertColumnNotExists(\"test_adfl_pony\", \"height\")\n  1277\t        with connection.schema_editor() as editor:\n  1278\t            operation.database_forwards(\"test_adfl\", editor, project_state, new_state)\n  1279\t        self.assertColumnExists(\"test_adfl_pony\", \"height\")\n  1280\t        # And test reversal\n  1281\t        with connection.schema_editor() as editor:\n  1282\t            operation.database_backwards(\"test_adfl\", editor, new_state, project_state)\n  1283\t        self.assertColumnNotExists(\"test_adfl_pony\", \"height\")\n  1284\t        # And deconstruction\n  1285\t        definition = operation.deconstruct()\n  1286\t        self.assertEqual(definition[0], \"AddField\")\n  1287\t        self.assertEqual(definition[1], [])\n  1288\t        self.assertEqual(sorted(definition[2]), [\"field\", \"model_name\", \"name\"])\n  1289\t\n  1290\t    def test_add_charfield(self):\n  1291\t        \"\"\"\n  1292\t        Tests the AddField operation on TextField.\n  1293\t        \"\"\"\n  1294\t        project_state = self.set_up_test_model(\"test_adchfl\")\n  1295\t\n  1296\t        Pony = project_state.apps.get_model(\"test_adchfl\", \"Pony\")\n  1297\t        pony = Pony.objects.create(weight=42)\n  1298\t\n  1299\t        new_state = self.apply_operations(\n  1300\t            \"test_adchfl\",\n  1301\t            project_state,\n  1302\t            [\n  1303\t                migrations.AddField(\n  1304\t                    \"Pony\",\n  1305\t                    \"text\",\n  1306\t                    models.CharField(max_length=10, default=\"some text\"),\n  1307\t                ),\n  1308\t                migrations.AddField(\n  1309\t                    \"Pony\",\n  1310\t                    \"empty\",\n  1311\t                    models.CharField(max_length=10, default=\"\"),\n  1312\t                ),\n  1313\t                # If not properly quoted digits would be interpreted as an int.\n  1314\t                migrations.AddField(\n  1315\t                    \"Pony\",\n  1316\t                    \"digits\",\n  1317\t                    models.CharField(max_length=10, default=\"42\"),\n  1318\t                ),\n  1319\t                # Manual quoting is fragile and could trip on quotes. Refs #xyz.\n  1320\t                migrations.AddField(\n  1321\t                    \"Pony\",\n  1322\t                    \"quotes\",\n  1323\t                    models.CharField(max_length=10, default='\"\\'\"'),\n  1324\t                ),\n  1325\t            ],\n  1326\t        )\n  1327\t\n  1328\t        Pony = new_state.apps.get_model(\"test_adchfl\", \"Pony\")\n  1329\t        pony = Pony.objects.get(pk=pony.pk)\n  1330\t        self.assertEqual(pony.text, \"some text\")\n  1331\t        self.assertEqual(pony.empty, \"\")\n  1332\t        self.assertEqual(pony.digits, \"42\")\n  1333\t        self.assertEqual(pony.quotes, '\"\\'\"')\n  1334\t\n  1335\t    def test_add_textfield(self):\n  1336\t        \"\"\"\n  1337\t        Tests the AddField operation on TextField.\n  1338\t        \"\"\"\n  1339\t        project_state = self.set_up_test_model(\"test_adtxtfl\")\n  1340\t\n  1341\t        Pony = project_state.apps.get_model(\"test_adtxtfl\", \"Pony\")\n  1342\t        pony = Pony.objects.create(weight=42)\n  1343\t\n  1344\t        new_state = self.apply_operations(\n  1345\t            \"test_adtxtfl\",\n  1346\t            project_state,\n  1347\t            [\n  1348\t                migrations.AddField(\n  1349\t                    \"Pony\",\n  1350\t                    \"text\",\n  1351\t                    models.TextField(default=\"some text\"),\n  1352\t                ),\n  1353\t                migrations.AddField(\n  1354\t                    \"Pony\",\n  1355\t                    \"empty\",\n  1356\t                    models.TextField(default=\"\"),\n  1357\t                ),\n  1358\t                # If not properly quoted digits would be interpreted as an int.\n  1359\t                migrations.AddField(\n  1360\t                    \"Pony\",\n  1361\t                    \"digits\",\n  1362\t                    models.TextField(default=\"42\"),\n  1363\t                ),\n  1364\t                # Manual quoting is fragile and could trip on quotes. Refs #xyz.\n  1365\t                migrations.AddField(\n  1366\t                    \"Pony\",\n  1367\t                    \"quotes\",\n  1368\t                    models.TextField(default='\"\\'\"'),\n  1369\t                ),\n  1370\t            ],\n  1371\t        )\n  1372\t\n  1373\t        Pony = new_state.apps.get_model(\"test_adtxtfl\", \"Pony\")\n  1374\t        pony = Pony.objects.get(pk=pony.pk)\n  1375\t        self.assertEqual(pony.text, \"some text\")\n  1376\t        self.assertEqual(pony.empty, \"\")\n  1377\t        self.assertEqual(pony.digits, \"42\")\n  1378\t        self.assertEqual(pony.quotes, '\"\\'\"')\n  1379\t\n  1380\t    def test_add_binaryfield(self):\n  1381\t        \"\"\"\n  1382\t        Tests the AddField operation on TextField/BinaryField.\n  1383\t        \"\"\"\n  1384\t        project_state = self.set_up_test_model(\"test_adbinfl\")\n  1385\t\n  1386\t        Pony = project_state.apps.get_model(\"test_adbinfl\", \"Pony\")\n  1387\t        pony = Pony.objects.create(weight=42)\n  1388\t\n  1389\t        new_state = self.apply_operations(\n  1390\t            \"test_adbinfl\",\n  1391\t            project_state,\n  1392\t            [\n  1393\t                migrations.AddField(\n  1394\t                    \"Pony\",\n  1395\t                    \"blob\",\n  1396\t                    models.BinaryField(default=b\"some text\"),\n  1397\t                ),\n  1398\t                migrations.AddField(\n  1399\t                    \"Pony\",\n  1400\t                    \"empty\",\n  1401\t                    models.BinaryField(default=b\"\"),\n  1402\t                ),\n  1403\t                # If not properly quoted digits would be interpreted as an int.\n  1404\t                migrations.AddField(\n  1405\t                    \"Pony\",\n  1406\t                    \"digits\",\n  1407\t                    models.BinaryField(default=b\"42\"),\n  1408\t                ),\n  1409\t                # Manual quoting is fragile and could trip on quotes. Refs #xyz.\n  1410\t                migrations.AddField(\n  1411\t                    \"Pony\",\n  1412\t                    \"quotes\",\n  1413\t                    models.BinaryField(default=b'\"\\'\"'),\n  1414\t                ),\n  1415\t            ],\n  1416\t        )\n  1417\t\n  1418\t        Pony = new_state.apps.get_model(\"test_adbinfl\", \"Pony\")\n  1419\t        pony = Pony.objects.get(pk=pony.pk)\n  1420\t        # SQLite returns buffer/memoryview, cast to bytes for checking.\n  1421\t        self.assertEqual(bytes(pony.blob), b\"some text\")\n  1422\t        self.assertEqual(bytes(pony.empty), b\"\")\n  1423\t        self.assertEqual(bytes(pony.digits), b\"42\")\n  1424\t        self.assertEqual(bytes(pony.quotes), b'\"\\'\"')\n  1425\t\n  1426\t    def test_column_name_quoting(self):\n  1427\t        \"\"\"\n  1428\t        Column names that are SQL keywords shouldn't cause problems when used\n  1429\t        in migrations (#22168).\n  1430\t        \"\"\"\n  1431\t        project_state = self.set_up_test_model(\"test_regr22168\")\n  1432\t        operation = migrations.AddField(\n  1433\t            \"Pony\",\n  1434\t            \"order\",\n  1435\t            models.IntegerField(default=0),\n  1436\t        )\n  1437\t        new_state = project_state.clone()\n  1438\t        operation.state_forwards(\"test_regr22168\", new_state)\n  1439\t        with connection.schema_editor() as editor:\n  1440\t            operation.database_forwards(\n  1441\t                \"test_regr22168\", editor, project_state, new_state\n  1442\t            )\n  1443\t        self.assertColumnExists(\"test_regr22168_pony\", \"order\")\n  1444\t\n  1445\t    def test_add_field_preserve_default(self):\n  1446\t        \"\"\"\n  1447\t        Tests the AddField operation's state alteration\n  1448\t        when preserve_default = False.\n  1449\t        \"\"\"\n  1450\t        project_state = self.set_up_test_model(\"test_adflpd\")\n  1451\t        # Test the state alteration\n  1452\t        operation = migrations.AddField(\n  1453\t            \"Pony\",\n  1454\t            \"height\",\n  1455\t            models.FloatField(null=True, default=4),\n  1456\t            preserve_default=False,\n  1457\t        )\n  1458\t        new_state = project_state.clone()\n  1459\t        operation.state_forwards(\"test_adflpd\", new_state)\n  1460\t        self.assertEqual(len(new_state.models[\"test_adflpd\", \"pony\"].fields), 4)\n  1461\t        field = new_state.models[\"test_adflpd\", \"pony\"].fields[\"height\"]\n  1462\t        self.assertEqual(field.default, models.NOT_PROVIDED)\n  1463\t        # Test the database alteration\n  1464\t        project_state.apps.get_model(\"test_adflpd\", \"pony\").objects.create(\n  1465\t            weight=4,\n  1466\t        )\n  1467\t        self.assertColumnNotExists(\"test_adflpd_pony\", \"height\")\n  1468\t        with connection.schema_editor() as editor:\n  1469\t            operation.database_forwards(\"test_adflpd\", editor, project_state, new_state)\n  1470\t        self.assertColumnExists(\"test_adflpd_pony\", \"height\")\n  1471\t        # And deconstruction\n  1472\t        definition = operation.deconstruct()\n  1473\t        self.assertEqual(definition[0], \"AddField\")\n  1474\t        self.assertEqual(definition[1], [])\n  1475\t        self.assertEqual(\n  1476\t            sorted(definition[2]), [\"field\", \"model_name\", \"name\", \"preserve_default\"]\n  1477\t        )\n  1478\t\n  1479\t    def test_add_field_m2m(self):\n  1480\t        \"\"\"\n  1481\t        Tests the AddField operation with a ManyToManyField.\n  1482\t        \"\"\"\n  1483\t        project_state = self.set_up_test_model(\"test_adflmm\", second_model=True)\n  1484\t        # Test the state alteration\n  1485\t        operation = migrations.AddField(\n  1486\t            \"Pony\", \"stables\", models.ManyToManyField(\"Stable\", related_name=\"ponies\")\n  1487\t        )\n  1488\t        new_state = project_state.clone()\n  1489\t        operation.state_forwards(\"test_adflmm\", new_state)\n  1490\t        self.assertEqual(len(new_state.models[\"test_adflmm\", \"pony\"].fields), 4)\n  1491\t        # Test the database alteration\n  1492\t        self.assertTableNotExists(\"test_adflmm_pony_stables\")\n  1493\t        with connection.schema_editor() as editor:\n  1494\t            operation.database_forwards(\"test_adflmm\", editor, project_state, new_state)\n  1495\t        self.assertTableExists(\"test_adflmm_pony_stables\")\n  1496\t        self.assertColumnNotExists(\"test_adflmm_pony\", \"stables\")\n  1497\t        # Make sure the M2M field actually works\n  1498\t        with atomic():\n  1499\t            Pony = new_state.apps.get_model(\"test_adflmm\", \"Pony\")\n  1500\t            p = Pony.objects.create(pink=False, weight=4.55)\n  1501\t            p.stables.create()\n  1502\t            self.assertEqual(p.stables.count(), 1)\n  1503\t            p.stables.all().delete()\n  1504\t        # And test reversal\n  1505\t        with connection.schema_editor() as editor:\n  1506\t            operation.database_backwards(\n  1507\t                \"test_adflmm\", editor, new_state, project_state\n  1508\t            )\n  1509\t        self.assertTableNotExists(\"test_adflmm_pony_stables\")\n  1510\t\n  1511\t    def test_alter_field_m2m(self):\n  1512\t        project_state = self.set_up_test_model(\"test_alflmm\", second_model=True)\n  1513\t\n  1514\t        project_state = self.apply_operations(\n  1515\t            \"test_alflmm\",\n  1516\t            project_state,\n  1517\t            operations=[\n  1518\t                migrations.AddField(\n  1519\t                    \"Pony\",\n  1520\t                    \"stables\",\n  1521\t                    models.ManyToManyField(\"Stable\", related_name=\"ponies\"),\n  1522\t                )\n  1523\t            ],\n  1524\t        )\n  1525\t        Pony = project_state.apps.get_model(\"test_alflmm\", \"Pony\")\n  1526\t        self.assertFalse(Pony._meta.get_field(\"stables\").blank)\n  1527\t\n  1528\t        project_state = self.apply_operations(\n  1529\t            \"test_alflmm\",\n  1530\t            project_state,\n  1531\t            operations=[\n  1532\t                migrations.AlterField(\n  1533\t                    \"Pony\",\n  1534\t                    \"stables\",\n  1535\t                    models.ManyToManyField(\n  1536\t                        to=\"Stable\", related_name=\"ponies\", blank=True\n  1537\t                    ),\n  1538\t                )\n  1539\t            ],\n  1540\t        )\n  1541\t        Pony = project_state.apps.get_model(\"test_alflmm\", \"Pony\")\n  1542\t        self.assertTrue(Pony._meta.get_field(\"stables\").blank)\n  1543\t\n  1544\t    def test_repoint_field_m2m(self):\n  1545\t        project_state = self.set_up_test_model(\n  1546\t            \"test_alflmm\", second_model=True, third_model=True\n  1547\t        )\n  1548\t\n  1549\t        project_state = self.apply_operations(\n  1550\t            \"test_alflmm\",\n  1551\t            project_state,\n  1552\t            operations=[\n  1553\t                migrations.AddField(\n  1554\t                    \"Pony\",\n  1555\t                    \"places\",\n  1556\t                    models.ManyToManyField(\"Stable\", related_name=\"ponies\"),\n  1557\t                )\n  1558\t            ],\n  1559\t        )\n  1560\t        Pony = project_state.apps.get_model(\"test_alflmm\", \"Pony\")\n  1561\t\n  1562\t        project_state = self.apply_operations(\n  1563\t            \"test_alflmm\",\n  1564\t            project_state,\n  1565\t            operations=[\n  1566\t                migrations.AlterField(\n  1567\t                    \"Pony\",\n  1568\t                    \"places\",\n  1569\t                    models.ManyToManyField(to=\"Van\", related_name=\"ponies\"),\n  1570\t                )\n  1571\t            ],\n  1572\t        )\n  1573\t\n  1574\t        # Ensure the new field actually works\n  1575\t        Pony = project_state.apps.get_model(\"test_alflmm\", \"Pony\")\n  1576\t        p = Pony.objects.create(pink=False, weight=4.55)\n  1577\t        p.places.create()\n  1578\t        self.assertEqual(p.places.count(), 1)\n  1579\t        p.places.all().delete()\n  1580\t\n  1581\t    def test_remove_field_m2m(self):\n  1582\t        project_state = self.set_up_test_model(\"test_rmflmm\", second_model=True)\n  1583\t\n  1584\t        project_state = self.apply_operations(\n  1585\t            \"test_rmflmm\",\n  1586\t            project_state,\n  1587\t            operations=[\n  1588\t                migrations.AddField(\n  1589\t                    \"Pony\",\n  1590\t                    \"stables\",\n  1591\t                    models.ManyToManyField(\"Stable\", related_name=\"ponies\"),\n  1592\t                )\n  1593\t            ],\n  1594\t        )\n  1595\t        self.assertTableExists(\"test_rmflmm_pony_stables\")\n  1596\t\n  1597\t        with_field_state = project_state.clone()\n  1598\t        operations = [migrations.RemoveField(\"Pony\", \"stables\")]\n  1599\t        project_state = self.apply_operations(\n  1600\t            \"test_rmflmm\", project_state, operations=operations\n  1601\t        )\n  1602\t        self.assertTableNotExists(\"test_rmflmm_pony_stables\")\n  1603\t\n  1604\t        # And test reversal\n  1605\t        self.unapply_operations(\"test_rmflmm\", with_field_state, operations=operations)\n  1606\t        self.assertTableExists(\"test_rmflmm_pony_stables\")\n  1607\t\n  1608\t    def test_remove_field_m2m_with_through(self):\n  1609\t        project_state = self.set_up_test_model(\"test_rmflmmwt\", second_model=True)\n  1610\t\n  1611\t        self.assertTableNotExists(\"test_rmflmmwt_ponystables\")\n  1612\t        project_state = self.apply_operations(\n  1613\t            \"test_rmflmmwt\",\n  1614\t            project_state,\n  1615\t            operations=[\n  1616\t                migrations.CreateModel(\n  1617\t                    \"PonyStables\",\n  1618\t                    fields=[\n  1619\t                        (\n  1620\t                            \"pony\",\n  1621\t                            models.ForeignKey(\"test_rmflmmwt.Pony\", models.CASCADE),\n  1622\t                        ),\n  1623\t                        (\n  1624\t                            \"stable\",\n  1625\t                            models.ForeignKey(\"test_rmflmmwt.Stable\", models.CASCADE),\n  1626\t                        ),\n  1627\t                    ],\n  1628\t                ),\n  1629\t                migrations.AddField(\n  1630\t                    \"Pony\",\n  1631\t                    \"stables\",\n  1632\t                    models.ManyToManyField(\n  1633\t                        \"Stable\",\n  1634\t                        related_name=\"ponies\",\n  1635\t                        through=\"test_rmflmmwt.PonyStables\",\n  1636\t                    ),\n  1637\t                ),\n  1638\t            ],\n  1639\t        )\n  1640\t        self.assertTableExists(\"test_rmflmmwt_ponystables\")\n  1641\t\n  1642\t        operations = [\n  1643\t            migrations.RemoveField(\"Pony\", \"stables\"),\n  1644\t            migrations.DeleteModel(\"PonyStables\"),\n  1645\t        ]\n  1646\t        self.apply_operations(\"test_rmflmmwt\", project_state, operations=operations)\n  1647\t\n  1648\t    def test_remove_field(self):\n  1649\t        \"\"\"\n  1650\t        Tests the RemoveField operation.\n  1651\t        \"\"\"\n  1652\t        project_state = self.set_up_test_model(\"test_rmfl\")\n  1653\t        # Test the state alteration\n  1654\t        operation = migrations.RemoveField(\"Pony\", \"pink\")\n  1655\t        self.assertEqual(operation.describe(), \"Remove field pink from Pony\")\n  1656\t        self.assertEqual(operation.migration_name_fragment, \"remove_pony_pink\")\n  1657\t        new_state = project_state.clone()\n  1658\t        operation.state_forwards(\"test_rmfl\", new_state)\n  1659\t        self.assertEqual(len(new_state.models[\"test_rmfl\", \"pony\"].fields), 2)\n  1660\t        # Test the database alteration\n  1661\t        self.assertColumnExists(\"test_rmfl_pony\", \"pink\")\n  1662\t        with connection.schema_editor() as editor:\n  1663\t            operation.database_forwards(\"test_rmfl\", editor, project_state, new_state)\n  1664\t        self.assertColumnNotExists(\"test_rmfl_pony\", \"pink\")\n  1665\t        # And test reversal\n  1666\t        with connection.schema_editor() as editor:\n  1667\t            operation.database_backwards(\"test_rmfl\", editor, new_state, project_state)\n  1668\t        self.assertColumnExists(\"test_rmfl_pony\", \"pink\")\n  1669\t        # And deconstruction\n  1670\t        definition = operation.deconstruct()\n  1671\t        self.assertEqual(definition[0], \"RemoveField\")\n  1672\t        self.assertEqual(definition[1], [])\n  1673\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"name\": \"pink\"})\n  1674\t\n  1675\t    def test_remove_fk(self):\n  1676\t        \"\"\"\n  1677\t        Tests the RemoveField operation on a foreign key.\n  1678\t        \"\"\"\n  1679\t        project_state = self.set_up_test_model(\"test_rfk\", related_model=True)\n  1680\t        self.assertColumnExists(\"test_rfk_rider\", \"pony_id\")\n  1681\t        operation = migrations.RemoveField(\"Rider\", \"pony\")\n  1682\t\n  1683\t        new_state = project_state.clone()\n  1684\t        operation.state_forwards(\"test_rfk\", new_state)\n  1685\t        with connection.schema_editor() as editor:\n  1686\t            operation.database_forwards(\"test_rfk\", editor, project_state, new_state)\n  1687\t        self.assertColumnNotExists(\"test_rfk_rider\", \"pony_id\")\n  1688\t        with connection.schema_editor() as editor:\n  1689\t            operation.database_backwards(\"test_rfk\", editor, new_state, project_state)\n  1690\t        self.assertColumnExists(\"test_rfk_rider\", \"pony_id\")\n  1691\t\n  1692\t    def test_alter_model_table(self):\n  1693\t        \"\"\"\n  1694\t        Tests the AlterModelTable operation.\n  1695\t        \"\"\"\n  1696\t        project_state = self.set_up_test_model(\"test_almota\")\n  1697\t        # Test the state alteration\n  1698\t        operation = migrations.AlterModelTable(\"Pony\", \"test_almota_pony_2\")\n  1699\t        self.assertEqual(\n  1700\t            operation.describe(), \"Rename table for Pony to test_almota_pony_2\"\n  1701\t        )\n  1702\t        self.assertEqual(operation.migration_name_fragment, \"alter_pony_table\")\n  1703\t        new_state = project_state.clone()\n  1704\t        operation.state_forwards(\"test_almota\", new_state)\n  1705\t        self.assertEqual(\n  1706\t            new_state.models[\"test_almota\", \"pony\"].options[\"db_table\"],\n  1707\t            \"test_almota_pony_2\",\n  1708\t        )\n  1709\t        # Test the database alteration\n  1710\t        self.assertTableExists(\"test_almota_pony\")\n  1711\t        self.assertTableNotExists(\"test_almota_pony_2\")\n  1712\t        with connection.schema_editor() as editor:\n  1713\t            operation.database_forwards(\"test_almota\", editor, project_state, new_state)\n  1714\t        self.assertTableNotExists(\"test_almota_pony\")\n  1715\t        self.assertTableExists(\"test_almota_pony_2\")\n  1716\t        # And test reversal\n  1717\t        with connection.schema_editor() as editor:\n  1718\t            operation.database_backwards(\n  1719\t                \"test_almota\", editor, new_state, project_state\n  1720\t            )\n  1721\t        self.assertTableExists(\"test_almota_pony\")\n  1722\t        self.assertTableNotExists(\"test_almota_pony_2\")\n  1723\t        # And deconstruction\n  1724\t        definition = operation.deconstruct()\n  1725\t        self.assertEqual(definition[0], \"AlterModelTable\")\n  1726\t        self.assertEqual(definition[1], [])\n  1727\t        self.assertEqual(definition[2], {\"name\": \"Pony\", \"table\": \"test_almota_pony_2\"})\n  1728\t\n  1729\t    def test_alter_model_table_none(self):\n  1730\t        \"\"\"\n  1731\t        Tests the AlterModelTable operation if the table name is set to None.\n  1732\t        \"\"\"\n  1733\t        operation = migrations.AlterModelTable(\"Pony\", None)\n  1734\t        self.assertEqual(operation.describe(), \"Rename table for Pony to (default)\")\n  1735\t\n  1736\t    def test_alter_model_table_noop(self):\n  1737\t        \"\"\"\n  1738\t        Tests the AlterModelTable operation if the table name is not changed.\n  1739\t        \"\"\"\n  1740\t        project_state = self.set_up_test_model(\"test_almota\")\n  1741\t        # Test the state alteration\n  1742\t        operation = migrations.AlterModelTable(\"Pony\", \"test_almota_pony\")\n  1743\t        new_state = project_state.clone()\n  1744\t        operation.state_forwards(\"test_almota\", new_state)\n  1745\t        self.assertEqual(\n  1746\t            new_state.models[\"test_almota\", \"pony\"].options[\"db_table\"],\n  1747\t            \"test_almota_pony\",\n  1748\t        )\n  1749\t        # Test the database alteration\n  1750\t        self.assertTableExists(\"test_almota_pony\")\n  1751\t        with connection.schema_editor() as editor:\n  1752\t            operation.database_forwards(\"test_almota\", editor, project_state, new_state)\n  1753\t        self.assertTableExists(\"test_almota_pony\")\n  1754\t        # And test reversal\n  1755\t        with connection.schema_editor() as editor:\n  1756\t            operation.database_backwards(\n  1757\t                \"test_almota\", editor, new_state, project_state\n  1758\t            )\n  1759\t        self.assertTableExists(\"test_almota_pony\")\n  1760\t\n  1761\t    def test_alter_model_table_m2m(self):\n  1762\t        \"\"\"\n  1763\t        AlterModelTable should rename auto-generated M2M tables.\n  1764\t        \"\"\"\n  1765\t        app_label = \"test_talflmltlm2m\"\n  1766\t        pony_db_table = \"pony_foo\"\n  1767\t        project_state = self.set_up_test_model(\n  1768\t            app_label, second_model=True, db_table=pony_db_table\n  1769\t        )\n  1770\t        # Add the M2M field\n  1771\t        first_state = project_state.clone()\n  1772\t        operation = migrations.AddField(\n  1773\t            \"Pony\", \"stables\", models.ManyToManyField(\"Stable\")\n  1774\t        )\n  1775\t        operation.state_forwards(app_label, first_state)\n  1776\t        with connection.schema_editor() as editor:\n  1777\t            operation.database_forwards(app_label, editor, project_state, first_state)\n  1778\t        original_m2m_table = \"%s_%s\" % (pony_db_table, \"stables\")\n  1779\t        new_m2m_table = \"%s_%s\" % (app_label, \"pony_stables\")\n  1780\t        self.assertTableExists(original_m2m_table)\n  1781\t        self.assertTableNotExists(new_m2m_table)\n  1782\t        # Rename the Pony db_table which should also rename the m2m table.\n  1783\t        second_state = first_state.clone()\n  1784\t        operation = migrations.AlterModelTable(name=\"pony\", table=None)\n  1785\t        operation.state_forwards(app_label, second_state)\n  1786\t        atomic_rename = connection.features.supports_atomic_references_rename\n  1787\t        with connection.schema_editor(atomic=atomic_rename) as editor:\n  1788\t            operation.database_forwards(app_label, editor, first_state, second_state)\n  1789\t        self.assertTableExists(new_m2m_table)\n  1790\t        self.assertTableNotExists(original_m2m_table)\n  1791\t        # And test reversal\n  1792\t        with connection.schema_editor(atomic=atomic_rename) as editor:\n  1793\t            operation.database_backwards(app_label, editor, second_state, first_state)\n  1794\t        self.assertTableExists(original_m2m_table)\n  1795\t        self.assertTableNotExists(new_m2m_table)\n  1796\t\n  1797\t    def test_alter_field(self):\n  1798\t        \"\"\"\n  1799\t        Tests the AlterField operation.\n  1800\t        \"\"\"\n  1801\t        project_state = self.set_up_test_model(\"test_alfl\")\n  1802\t        # Test the state alteration\n  1803\t        operation = migrations.AlterField(\n  1804\t            \"Pony\", \"pink\", models.IntegerField(null=True)\n  1805\t        )\n  1806\t        self.assertEqual(operation.describe(), \"Alter field pink on Pony\")\n  1807\t        self.assertEqual(operation.migration_name_fragment, \"alter_pony_pink\")\n  1808\t        new_state = project_state.clone()\n  1809\t        operation.state_forwards(\"test_alfl\", new_state)\n  1810\t        self.assertIs(\n  1811\t            project_state.models[\"test_alfl\", \"pony\"].fields[\"pink\"].null, False\n  1812\t        )\n  1813\t        self.assertIs(new_state.models[\"test_alfl\", \"pony\"].fields[\"pink\"].null, True)\n  1814\t        # Test the database alteration\n  1815\t        self.assertColumnNotNull(\"test_alfl_pony\", \"pink\")\n  1816\t        with connection.schema_editor() as editor:\n  1817\t            operation.database_forwards(\"test_alfl\", editor, project_state, new_state)\n  1818\t        self.assertColumnNull(\"test_alfl_pony\", \"pink\")\n  1819\t        # And test reversal\n  1820\t        with connection.schema_editor() as editor:\n  1821\t            operation.database_backwards(\"test_alfl\", editor, new_state, project_state)\n  1822\t        self.assertColumnNotNull(\"test_alfl_pony\", \"pink\")\n  1823\t        # And deconstruction\n  1824\t        definition = operation.deconstruct()\n  1825\t        self.assertEqual(definition[0], \"AlterField\")\n  1826\t        self.assertEqual(definition[1], [])\n  1827\t        self.assertEqual(sorted(definition[2]), [\"field\", \"model_name\", \"name\"])\n  1828\t\n  1829\t    def test_alter_field_add_db_column_noop(self):\n  1830\t        \"\"\"\n  1831\t        AlterField operation is a noop when adding only a db_column and the\n  1832\t        column name is not changed.\n  1833\t        \"\"\"\n  1834\t        app_label = \"test_afadbn\"\n  1835\t        project_state = self.set_up_test_model(app_label, related_model=True)\n  1836\t        pony_table = \"%s_pony\" % app_label\n  1837\t        new_state = project_state.clone()\n  1838\t        operation = migrations.AlterField(\n  1839\t            \"Pony\", \"weight\", models.FloatField(db_column=\"weight\")\n  1840\t        )\n  1841\t        operation.state_forwards(app_label, new_state)\n  1842\t        self.assertIsNone(\n  1843\t            project_state.models[app_label, \"pony\"].fields[\"weight\"].db_column,\n  1844\t        )\n  1845\t        self.assertEqual(\n  1846\t            new_state.models[app_label, \"pony\"].fields[\"weight\"].db_column,\n  1847\t            \"weight\",\n  1848\t        )\n  1849\t        self.assertColumnExists(pony_table, \"weight\")\n  1850\t        with connection.schema_editor() as editor:\n  1851\t            with self.assertNumQueries(0):\n  1852\t                operation.database_forwards(app_label, editor, project_state, new_state)\n  1853\t        self.assertColumnExists(pony_table, \"weight\")\n  1854\t        with connection.schema_editor() as editor:\n  1855\t            with self.assertNumQueries(0):\n  1856\t                operation.database_backwards(\n  1857\t                    app_label, editor, new_state, project_state\n  1858\t                )\n  1859\t        self.assertColumnExists(pony_table, \"weight\")\n  1860\t\n  1861\t        rider_table = \"%s_rider\" % app_label\n  1862\t        new_state = project_state.clone()\n  1863\t        operation = migrations.AlterField(\n  1864\t            \"Rider\",\n  1865\t            \"pony\",\n  1866\t            models.ForeignKey(\"Pony\", models.CASCADE, db_column=\"pony_id\"),\n  1867\t        )\n  1868\t        operation.state_forwards(app_label, new_state)\n  1869\t        self.assertIsNone(\n  1870\t            project_state.models[app_label, \"rider\"].fields[\"pony\"].db_column,\n  1871\t        )\n  1872\t        self.assertIs(\n  1873\t            new_state.models[app_label, \"rider\"].fields[\"pony\"].db_column,\n  1874\t            \"pony_id\",\n  1875\t        )\n  1876\t        self.assertColumnExists(rider_table, \"pony_id\")\n  1877\t        with connection.schema_editor() as editor:\n  1878\t            with self.assertNumQueries(0):\n  1879\t                operation.database_forwards(app_label, editor, project_state, new_state)\n  1880\t        self.assertColumnExists(rider_table, \"pony_id\")\n  1881\t        with connection.schema_editor() as editor:\n  1882\t            with self.assertNumQueries(0):\n  1883\t                operation.database_forwards(app_label, editor, new_state, project_state)\n  1884\t        self.assertColumnExists(rider_table, \"pony_id\")\n  1885\t\n  1886\t    def test_alter_field_pk(self):\n  1887\t        \"\"\"\n  1888\t        The AlterField operation on primary keys (things like PostgreSQL's\n  1889\t        SERIAL weirdness).\n  1890\t        \"\"\"\n  1891\t        project_state = self.set_up_test_model(\"test_alflpk\")\n  1892\t        # Test the state alteration\n  1893\t        operation = migrations.AlterField(\n  1894\t            \"Pony\", \"id\", models.IntegerField(primary_key=True)\n  1895\t        )\n  1896\t        new_state = project_state.clone()\n  1897\t        operation.state_forwards(\"test_alflpk\", new_state)\n  1898\t        self.assertIsInstance(\n  1899\t            project_state.models[\"test_alflpk\", \"pony\"].fields[\"id\"],\n  1900\t            models.AutoField,\n  1901\t        )\n  1902\t        self.assertIsInstance(\n  1903\t            new_state.models[\"test_alflpk\", \"pony\"].fields[\"id\"],\n  1904\t            models.IntegerField,\n  1905\t        )\n  1906\t        # Test the database alteration\n  1907\t        with connection.schema_editor() as editor:\n  1908\t            operation.database_forwards(\"test_alflpk\", editor, project_state, new_state)\n  1909\t        # And test reversal\n  1910\t        with connection.schema_editor() as editor:\n  1911\t            operation.database_backwards(\n  1912\t                \"test_alflpk\", editor, new_state, project_state\n  1913\t            )\n  1914\t\n  1915\t    @skipUnlessDBFeature(\"supports_foreign_keys\")\n  1916\t    def test_alter_field_pk_fk(self):\n  1917\t        \"\"\"\n  1918\t        Tests the AlterField operation on primary keys changes any FKs pointing to it.\n  1919\t        \"\"\"\n  1920\t        project_state = self.set_up_test_model(\"test_alflpkfk\", related_model=True)\n  1921\t        project_state = self.apply_operations(\n  1922\t            \"test_alflpkfk\",\n  1923\t            project_state,\n  1924\t            [\n  1925\t                migrations.CreateModel(\n  1926\t                    \"Stable\",\n  1927\t                    fields=[\n  1928\t                        (\"ponies\", models.ManyToManyField(\"Pony\")),\n  1929\t                    ],\n  1930\t                ),\n  1931\t                migrations.AddField(\n  1932\t                    \"Pony\",\n  1933\t                    \"stables\",\n  1934\t                    models.ManyToManyField(\"Stable\"),\n  1935\t                ),\n  1936\t            ],\n  1937\t        )\n  1938\t        # Test the state alteration\n  1939\t        operation = migrations.AlterField(\n  1940\t            \"Pony\", \"id\", models.FloatField(primary_key=True)\n  1941\t        )\n  1942\t        new_state = project_state.clone()\n  1943\t        operation.state_forwards(\"test_alflpkfk\", new_state)\n  1944\t        self.assertIsInstance(\n  1945\t            project_state.models[\"test_alflpkfk\", \"pony\"].fields[\"id\"],\n  1946\t            models.AutoField,\n  1947\t        )\n  1948\t        self.assertIsInstance(\n  1949\t            new_state.models[\"test_alflpkfk\", \"pony\"].fields[\"id\"],\n  1950\t            models.FloatField,\n  1951\t        )\n  1952\t\n  1953\t        def assertIdTypeEqualsFkType():\n  1954\t            with connection.cursor() as cursor:\n  1955\t                id_type, id_null = [\n  1956\t                    (c.type_code, c.null_ok)\n  1957\t                    for c in connection.introspection.get_table_description(\n  1958\t                        cursor, \"test_alflpkfk_pony\"\n  1959\t                    )\n  1960\t                    if c.name == \"id\"\n  1961\t                ][0]\n  1962\t                fk_type, fk_null = [\n  1963\t                    (c.type_code, c.null_ok)\n  1964\t                    for c in connection.introspection.get_table_description(\n  1965\t                        cursor, \"test_alflpkfk_rider\"\n  1966\t                    )\n  1967\t                    if c.name == \"pony_id\"\n  1968\t                ][0]\n  1969\t                m2m_fk_type, m2m_fk_null = [\n  1970\t                    (c.type_code, c.null_ok)\n  1971\t                    for c in connection.introspection.get_table_description(\n  1972\t                        cursor,\n  1973\t                        \"test_alflpkfk_pony_stables\",\n  1974\t                    )\n  1975\t                    if c.name == \"pony_id\"\n  1976\t                ][0]\n  1977\t                remote_m2m_fk_type, remote_m2m_fk_null = [\n  1978\t                    (c.type_code, c.null_ok)\n  1979\t                    for c in connection.introspection.get_table_description(\n  1980\t                        cursor,\n  1981\t                        \"test_alflpkfk_stable_ponies\",\n  1982\t                    )\n  1983\t                    if c.name == \"pony_id\"\n  1984\t                ][0]\n  1985\t            self.assertEqual(id_type, fk_type)\n  1986\t            self.assertEqual(id_type, m2m_fk_type)\n  1987\t            self.assertEqual(id_type, remote_m2m_fk_type)\n  1988\t            self.assertEqual(id_null, fk_null)\n  1989\t            self.assertEqual(id_null, m2m_fk_null)\n  1990\t            self.assertEqual(id_null, remote_m2m_fk_null)\n  1991\t\n  1992\t        assertIdTypeEqualsFkType()\n  1993\t        # Test the database alteration\n  1994\t        with connection.schema_editor() as editor:\n  1995\t            operation.database_forwards(\n  1996\t                \"test_alflpkfk\", editor, project_state, new_state\n  1997\t            )\n  1998\t        assertIdTypeEqualsFkType()\n  1999\t        if connection.features.supports_foreign_keys:\n  2000\t            self.assertFKExists(\n  2001\t                \"test_alflpkfk_pony_stables\",\n  2002\t                [\"pony_id\"],\n  2003\t                (\"test_alflpkfk_pony\", \"id\"),\n  2004\t            )\n  2005\t            self.assertFKExists(\n  2006\t                \"test_alflpkfk_stable_ponies\",\n  2007\t                [\"pony_id\"],\n  2008\t                (\"test_alflpkfk_pony\", \"id\"),\n  2009\t            )\n  2010\t        # And test reversal\n  2011\t        with connection.schema_editor() as editor:\n  2012\t            operation.database_backwards(\n  2013\t                \"test_alflpkfk\", editor, new_state, project_state\n  2014\t            )\n  2015\t        assertIdTypeEqualsFkType()\n  2016\t        if connection.features.supports_foreign_keys:\n  2017\t            self.assertFKExists(\n  2018\t                \"test_alflpkfk_pony_stables\",\n  2019\t                [\"pony_id\"],\n  2020\t                (\"test_alflpkfk_pony\", \"id\"),\n  2021\t            )\n  2022\t            self.assertFKExists(\n  2023\t                \"test_alflpkfk_stable_ponies\",\n  2024\t                [\"pony_id\"],\n  2025\t                (\"test_alflpkfk_pony\", \"id\"),\n  2026\t            )\n  2027\t\n  2028\t    @skipUnlessDBFeature(\"supports_collation_on_charfield\", \"supports_foreign_keys\")\n  2029\t    def test_alter_field_pk_fk_db_collation(self):\n  2030\t        \"\"\"\n  2031\t        AlterField operation of db_collation on primary keys changes any FKs\n  2032\t        pointing to it.\n  2033\t        \"\"\"\n  2034\t        collation = connection.features.test_collations.get(\"non_default\")\n  2035\t        if not collation:\n  2036\t            self.skipTest(\"Language collations are not supported.\")\n  2037\t\n  2038\t        app_label = \"test_alflpkfkdbc\"\n  2039\t        project_state = self.apply_operations(\n  2040\t            app_label,\n  2041\t            ProjectState(),\n  2042\t            [\n  2043\t                migrations.CreateModel(\n  2044\t                    \"Pony\",\n  2045\t                    [\n  2046\t                        (\"id\", models.CharField(primary_key=True, max_length=10)),\n  2047\t                    ],\n  2048\t                ),\n  2049\t                migrations.CreateModel(\n  2050\t                    \"Rider\",\n  2051\t                    [\n  2052\t                        (\"pony\", models.ForeignKey(\"Pony\", models.CASCADE)),\n  2053\t                    ],\n  2054\t                ),\n  2055\t                migrations.CreateModel(\n  2056\t                    \"Stable\",\n  2057\t                    [\n  2058\t                        (\"ponies\", models.ManyToManyField(\"Pony\")),\n  2059\t                    ],\n  2060\t                ),\n  2061\t            ],\n  2062\t        )\n  2063\t        # State alteration.\n  2064\t        operation = migrations.AlterField(\n  2065\t            \"Pony\",\n  2066\t            \"id\",\n  2067\t            models.CharField(\n  2068\t                primary_key=True,\n  2069\t                max_length=10,\n  2070\t                db_collation=collation,\n  2071\t            ),\n  2072\t        )\n  2073\t        new_state = project_state.clone()\n  2074\t        operation.state_forwards(app_label, new_state)\n  2075\t        # Database alteration.\n  2076\t        with connection.schema_editor() as editor:\n  2077\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2078\t        self.assertColumnCollation(f\"{app_label}_pony\", \"id\", collation)\n  2079\t        self.assertColumnCollation(f\"{app_label}_rider\", \"pony_id\", collation)\n  2080\t        self.assertColumnCollation(f\"{app_label}_stable_ponies\", \"pony_id\", collation)\n  2081\t        # Reversal.\n  2082\t        with connection.schema_editor() as editor:\n  2083\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2084\t\n  2085\t    def test_alter_field_pk_mti_fk(self):\n  2086\t        app_label = \"test_alflpkmtifk\"\n  2087\t        project_state = self.set_up_test_model(app_label, mti_model=True)\n  2088\t        project_state = self.apply_operations(\n  2089\t            app_label,\n  2090\t            project_state,\n  2091\t            [\n  2092\t                migrations.CreateModel(\n  2093\t                    \"ShetlandRider\",\n  2094\t                    fields=[\n  2095\t                        (\n  2096\t                            \"pony\",\n  2097\t                            models.ForeignKey(\n  2098\t                                f\"{app_label}.ShetlandPony\", models.CASCADE\n  2099\t                            ),\n  2100\t                        ),\n  2101\t                    ],\n  2102\t                ),\n  2103\t            ],\n  2104\t        )\n  2105\t        operation = migrations.AlterField(\n  2106\t            \"Pony\",\n  2107\t            \"id\",\n  2108\t            models.BigAutoField(primary_key=True),\n  2109\t        )\n  2110\t        new_state = project_state.clone()\n  2111\t        operation.state_forwards(app_label, new_state)\n  2112\t        self.assertIsInstance(\n  2113\t            new_state.models[app_label, \"pony\"].fields[\"id\"],\n  2114\t            models.BigAutoField,\n  2115\t        )\n  2116\t\n  2117\t        def _get_column_id_type(cursor, table, column):\n  2118\t            return [\n  2119\t                c.type_code\n  2120\t                for c in connection.introspection.get_table_description(\n  2121\t                    cursor,\n  2122\t                    f\"{app_label}_{table}\",\n  2123\t                )\n  2124\t                if c.name == column\n  2125\t            ][0]\n  2126\t\n  2127\t        def assertIdTypeEqualsMTIFkType():\n  2128\t            with connection.cursor() as cursor:\n  2129\t                parent_id_type = _get_column_id_type(cursor, \"pony\", \"id\")\n  2130\t                child_id_type = _get_column_id_type(\n  2131\t                    cursor, \"shetlandpony\", \"pony_ptr_id\"\n  2132\t                )\n  2133\t                mti_id_type = _get_column_id_type(cursor, \"shetlandrider\", \"pony_id\")\n  2134\t            self.assertEqual(parent_id_type, child_id_type)\n  2135\t            self.assertEqual(parent_id_type, mti_id_type)\n  2136\t\n  2137\t        assertIdTypeEqualsMTIFkType()\n  2138\t        # Alter primary key.\n  2139\t        with connection.schema_editor() as editor:\n  2140\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2141\t        assertIdTypeEqualsMTIFkType()\n  2142\t        if connection.features.supports_foreign_keys:\n  2143\t            self.assertFKExists(\n  2144\t                f\"{app_label}_shetlandpony\",\n  2145\t                [\"pony_ptr_id\"],\n  2146\t                (f\"{app_label}_pony\", \"id\"),\n  2147\t            )\n  2148\t            self.assertFKExists(\n  2149\t                f\"{app_label}_shetlandrider\",\n  2150\t                [\"pony_id\"],\n  2151\t                (f\"{app_label}_shetlandpony\", \"pony_ptr_id\"),\n  2152\t            )\n  2153\t        # Reversal.\n  2154\t        with connection.schema_editor() as editor:\n  2155\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2156\t        assertIdTypeEqualsMTIFkType()\n  2157\t        if connection.features.supports_foreign_keys:\n  2158\t            self.assertFKExists(\n  2159\t                f\"{app_label}_shetlandpony\",\n  2160\t                [\"pony_ptr_id\"],\n  2161\t                (f\"{app_label}_pony\", \"id\"),\n  2162\t            )\n  2163\t            self.assertFKExists(\n  2164\t                f\"{app_label}_shetlandrider\",\n  2165\t                [\"pony_id\"],\n  2166\t                (f\"{app_label}_shetlandpony\", \"pony_ptr_id\"),\n  2167\t            )\n  2168\t\n  2169\t    def test_alter_field_pk_mti_and_fk_to_base(self):\n  2170\t        app_label = \"test_alflpkmtiftb\"\n  2171\t        project_state = self.set_up_test_model(\n  2172\t            app_label,\n  2173\t            mti_model=True,\n  2174\t            related_model=True,\n  2175\t        )\n  2176\t        operation = migrations.AlterField(\n  2177\t            \"Pony\",\n  2178\t            \"id\",\n  2179\t            models.BigAutoField(primary_key=True),\n  2180\t        )\n  2181\t        new_state = project_state.clone()\n  2182\t        operation.state_forwards(app_label, new_state)\n  2183\t        self.assertIsInstance(\n  2184\t            new_state.models[app_label, \"pony\"].fields[\"id\"],\n  2185\t            models.BigAutoField,\n  2186\t        )\n  2187\t\n  2188\t        def _get_column_id_type(cursor, table, column):\n  2189\t            return [\n  2190\t                c.type_code\n  2191\t                for c in connection.introspection.get_table_description(\n  2192\t                    cursor,\n  2193\t                    f\"{app_label}_{table}\",\n  2194\t                )\n  2195\t                if c.name == column\n  2196\t            ][0]\n  2197\t\n  2198\t        def assertIdTypeEqualsMTIFkType():\n  2199\t            with connection.cursor() as cursor:\n  2200\t                parent_id_type = _get_column_id_type(cursor, \"pony\", \"id\")\n  2201\t                fk_id_type = _get_column_id_type(cursor, \"rider\", \"pony_id\")\n  2202\t                child_id_type = _get_column_id_type(\n  2203\t                    cursor, \"shetlandpony\", \"pony_ptr_id\"\n  2204\t                )\n  2205\t            self.assertEqual(parent_id_type, child_id_type)\n  2206\t            self.assertEqual(parent_id_type, fk_id_type)\n  2207\t\n  2208\t        assertIdTypeEqualsMTIFkType()\n  2209\t        # Alter primary key.\n  2210\t        with connection.schema_editor() as editor:\n  2211\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2212\t        assertIdTypeEqualsMTIFkType()\n  2213\t        if connection.features.supports_foreign_keys:\n  2214\t            self.assertFKExists(\n  2215\t                f\"{app_label}_shetlandpony\",\n  2216\t                [\"pony_ptr_id\"],\n  2217\t                (f\"{app_label}_pony\", \"id\"),\n  2218\t            )\n  2219\t            self.assertFKExists(\n  2220\t                f\"{app_label}_rider\",\n  2221\t                [\"pony_id\"],\n  2222\t                (f\"{app_label}_pony\", \"id\"),\n  2223\t            )\n  2224\t        # Reversal.\n  2225\t        with connection.schema_editor() as editor:\n  2226\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2227\t        assertIdTypeEqualsMTIFkType()\n  2228\t        if connection.features.supports_foreign_keys:\n  2229\t            self.assertFKExists(\n  2230\t                f\"{app_label}_shetlandpony\",\n  2231\t                [\"pony_ptr_id\"],\n  2232\t                (f\"{app_label}_pony\", \"id\"),\n  2233\t            )\n  2234\t            self.assertFKExists(\n  2235\t                f\"{app_label}_rider\",\n  2236\t                [\"pony_id\"],\n  2237\t                (f\"{app_label}_pony\", \"id\"),\n  2238\t            )\n  2239\t\n  2240\t    @skipUnlessDBFeature(\"supports_foreign_keys\")\n  2241\t    def test_alter_field_reloads_state_on_fk_with_to_field_target_type_change(self):\n  2242\t        app_label = \"test_alflrsfkwtflttc\"\n  2243\t        project_state = self.apply_operations(\n  2244\t            app_label,\n  2245\t            ProjectState(),\n  2246\t            operations=[\n  2247\t                migrations.CreateModel(\n  2248\t                    \"Rider\",\n  2249\t                    fields=[\n  2250\t                        (\"id\", models.AutoField(primary_key=True)),\n  2251\t                        (\"code\", models.IntegerField(unique=True)),\n  2252\t                    ],\n  2253\t                ),\n  2254\t                migrations.CreateModel(\n  2255\t                    \"Pony\",\n  2256\t                    fields=[\n  2257\t                        (\"id\", models.AutoField(primary_key=True)),\n  2258\t                        (\n  2259\t                            \"rider\",\n  2260\t                            models.ForeignKey(\n  2261\t                                \"%s.Rider\" % app_label, models.CASCADE, to_field=\"code\"\n  2262\t                            ),\n  2263\t                        ),\n  2264\t                    ],\n  2265\t                ),\n  2266\t            ],\n  2267\t        )\n  2268\t        operation = migrations.AlterField(\n  2269\t            \"Rider\",\n  2270\t            \"code\",\n  2271\t            models.CharField(max_length=100, unique=True),\n  2272\t        )\n  2273\t        self.apply_operations(app_label, project_state, operations=[operation])\n  2274\t        id_type, id_null = [\n  2275\t            (c.type_code, c.null_ok)\n  2276\t            for c in self.get_table_description(\"%s_rider\" % app_label)\n  2277\t            if c.name == \"code\"\n  2278\t        ][0]\n  2279\t        fk_type, fk_null = [\n  2280\t            (c.type_code, c.null_ok)\n  2281\t            for c in self.get_table_description(\"%s_pony\" % app_label)\n  2282\t            if c.name == \"rider_id\"\n  2283\t        ][0]\n  2284\t        self.assertEqual(id_type, fk_type)\n  2285\t        self.assertEqual(id_null, fk_null)\n  2286\t\n  2287\t    @skipUnlessDBFeature(\"supports_foreign_keys\")\n  2288\t    def test_alter_field_reloads_state_fk_with_to_field_related_name_target_type_change(\n  2289\t        self,\n  2290\t    ):\n  2291\t        app_label = \"test_alflrsfkwtflrnttc\"\n  2292\t        project_state = self.apply_operations(\n  2293\t            app_label,\n  2294\t            ProjectState(),\n  2295\t            operations=[\n  2296\t                migrations.CreateModel(\n  2297\t                    \"Rider\",\n  2298\t                    fields=[\n  2299\t                        (\"id\", models.AutoField(primary_key=True)),\n  2300\t                        (\"code\", models.PositiveIntegerField(unique=True)),\n  2301\t                    ],\n  2302\t                ),\n  2303\t                migrations.CreateModel(\n  2304\t                    \"Pony\",\n  2305\t                    fields=[\n  2306\t                        (\"id\", models.AutoField(primary_key=True)),\n  2307\t                        (\n  2308\t                            \"rider\",\n  2309\t                            models.ForeignKey(\n  2310\t                                \"%s.Rider\" % app_label,\n  2311\t                                models.CASCADE,\n  2312\t                                to_field=\"code\",\n  2313\t                                related_name=\"+\",\n  2314\t                            ),\n  2315\t                        ),\n  2316\t                    ],\n  2317\t                ),\n  2318\t            ],\n  2319\t        )\n  2320\t        operation = migrations.AlterField(\n  2321\t            \"Rider\",\n  2322\t            \"code\",\n  2323\t            models.CharField(max_length=100, unique=True),\n  2324\t        )\n  2325\t        self.apply_operations(app_label, project_state, operations=[operation])\n  2326\t\n  2327\t    def test_alter_field_reloads_state_on_fk_target_changes(self):\n  2328\t        \"\"\"\n  2329\t        If AlterField doesn't reload state appropriately, the second AlterField\n  2330\t        crashes on MySQL due to not dropping the PonyRider.pony foreign key\n  2331\t        constraint before modifying the column.\n  2332\t        \"\"\"\n  2333\t        app_label = \"alter_alter_field_reloads_state_on_fk_target_changes\"\n  2334\t        project_state = self.apply_operations(\n  2335\t            app_label,\n  2336\t            ProjectState(),\n  2337\t            operations=[\n  2338\t                migrations.CreateModel(\n  2339\t                    \"Rider\",\n  2340\t                    fields=[\n  2341\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2342\t                    ],\n  2343\t                ),\n  2344\t                migrations.CreateModel(\n  2345\t                    \"Pony\",\n  2346\t                    fields=[\n  2347\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2348\t                        (\n  2349\t                            \"rider\",\n  2350\t                            models.ForeignKey(\"%s.Rider\" % app_label, models.CASCADE),\n  2351\t                        ),\n  2352\t                    ],\n  2353\t                ),\n  2354\t                migrations.CreateModel(\n  2355\t                    \"PonyRider\",\n  2356\t                    fields=[\n  2357\t                        (\"id\", models.AutoField(primary_key=True)),\n  2358\t                        (\n  2359\t                            \"pony\",\n  2360\t                            models.ForeignKey(\"%s.Pony\" % app_label, models.CASCADE),\n  2361\t                        ),\n  2362\t                    ],\n  2363\t                ),\n  2364\t            ],\n  2365\t        )\n  2366\t        project_state = self.apply_operations(\n  2367\t            app_label,\n  2368\t            project_state,\n  2369\t            operations=[\n  2370\t                migrations.AlterField(\n  2371\t                    \"Rider\", \"id\", models.CharField(primary_key=True, max_length=99)\n  2372\t                ),\n  2373\t                migrations.AlterField(\n  2374\t                    \"Pony\", \"id\", models.CharField(primary_key=True, max_length=99)\n  2375\t                ),\n  2376\t            ],\n  2377\t        )\n  2378\t\n  2379\t    def test_alter_field_reloads_state_on_fk_with_to_field_target_changes(self):\n  2380\t        \"\"\"\n  2381\t        If AlterField doesn't reload state appropriately, the second AlterField\n  2382\t        crashes on MySQL due to not dropping the PonyRider.pony foreign key\n  2383\t        constraint before modifying the column.\n  2384\t        \"\"\"\n  2385\t        app_label = \"alter_alter_field_reloads_state_on_fk_with_to_field_target_changes\"\n  2386\t        project_state = self.apply_operations(\n  2387\t            app_label,\n  2388\t            ProjectState(),\n  2389\t            operations=[\n  2390\t                migrations.CreateModel(\n  2391\t                    \"Rider\",\n  2392\t                    fields=[\n  2393\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2394\t                        (\"slug\", models.CharField(unique=True, max_length=100)),\n  2395\t                    ],\n  2396\t                ),\n  2397\t                migrations.CreateModel(\n  2398\t                    \"Pony\",\n  2399\t                    fields=[\n  2400\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2401\t                        (\n  2402\t                            \"rider\",\n  2403\t                            models.ForeignKey(\n  2404\t                                \"%s.Rider\" % app_label, models.CASCADE, to_field=\"slug\"\n  2405\t                            ),\n  2406\t                        ),\n  2407\t                        (\"slug\", models.CharField(unique=True, max_length=100)),\n  2408\t                    ],\n  2409\t                ),\n  2410\t                migrations.CreateModel(\n  2411\t                    \"PonyRider\",\n  2412\t                    fields=[\n  2413\t                        (\"id\", models.AutoField(primary_key=True)),\n  2414\t                        (\n  2415\t                            \"pony\",\n  2416\t                            models.ForeignKey(\n  2417\t                                \"%s.Pony\" % app_label, models.CASCADE, to_field=\"slug\"\n  2418\t                            ),\n  2419\t                        ),\n  2420\t                    ],\n  2421\t                ),\n  2422\t            ],\n  2423\t        )\n  2424\t        project_state = self.apply_operations(\n  2425\t            app_label,\n  2426\t            project_state,\n  2427\t            operations=[\n  2428\t                migrations.AlterField(\n  2429\t                    \"Rider\", \"slug\", models.CharField(unique=True, max_length=99)\n  2430\t                ),\n  2431\t                migrations.AlterField(\n  2432\t                    \"Pony\", \"slug\", models.CharField(unique=True, max_length=99)\n  2433\t                ),\n  2434\t            ],\n  2435\t        )\n  2436\t\n  2437\t    def test_rename_field_reloads_state_on_fk_target_changes(self):\n  2438\t        \"\"\"\n  2439\t        If RenameField doesn't reload state appropriately, the AlterField\n  2440\t        crashes on MySQL due to not dropping the PonyRider.pony foreign key\n  2441\t        constraint before modifying the column.\n  2442\t        \"\"\"\n  2443\t        app_label = \"alter_rename_field_reloads_state_on_fk_target_changes\"\n  2444\t        project_state = self.apply_operations(\n  2445\t            app_label,\n  2446\t            ProjectState(),\n  2447\t            operations=[\n  2448\t                migrations.CreateModel(\n  2449\t                    \"Rider\",\n  2450\t                    fields=[\n  2451\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2452\t                    ],\n  2453\t                ),\n  2454\t                migrations.CreateModel(\n  2455\t                    \"Pony\",\n  2456\t                    fields=[\n  2457\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2458\t                        (\n  2459\t                            \"rider\",\n  2460\t                            models.ForeignKey(\"%s.Rider\" % app_label, models.CASCADE),\n  2461\t                        ),\n  2462\t                    ],\n  2463\t                ),\n  2464\t                migrations.CreateModel(\n  2465\t                    \"PonyRider\",\n  2466\t                    fields=[\n  2467\t                        (\"id\", models.AutoField(primary_key=True)),\n  2468\t                        (\n  2469\t                            \"pony\",\n  2470\t                            models.ForeignKey(\"%s.Pony\" % app_label, models.CASCADE),\n  2471\t                        ),\n  2472\t                    ],\n  2473\t                ),\n  2474\t            ],\n  2475\t        )\n  2476\t        project_state = self.apply_operations(\n  2477\t            app_label,\n  2478\t            project_state,\n  2479\t            operations=[\n  2480\t                migrations.RenameField(\"Rider\", \"id\", \"id2\"),\n  2481\t                migrations.AlterField(\n  2482\t                    \"Pony\", \"id\", models.CharField(primary_key=True, max_length=99)\n  2483\t                ),\n  2484\t            ],\n  2485\t            atomic=connection.features.supports_atomic_references_rename,\n  2486\t        )\n  2487\t\n  2488\t    def test_rename_field(self):\n  2489\t        \"\"\"\n  2490\t        Tests the RenameField operation.\n  2491\t        \"\"\"\n  2492\t        project_state = self.set_up_test_model(\n  2493\t            \"test_rnfl\", unique_together=True, index_together=True\n  2494\t        )\n  2495\t        # Test the state alteration\n  2496\t        operation = migrations.RenameField(\"Pony\", \"pink\", \"blue\")\n  2497\t        self.assertEqual(operation.describe(), \"Rename field pink on Pony to blue\")\n  2498\t        self.assertEqual(operation.migration_name_fragment, \"rename_pink_pony_blue\")\n  2499\t        new_state = project_state.clone()\n  2500\t        operation.state_forwards(\"test_rnfl\", new_state)\n  2501\t        self.assertIn(\"blue\", new_state.models[\"test_rnfl\", \"pony\"].fields)\n  2502\t        self.assertNotIn(\"pink\", new_state.models[\"test_rnfl\", \"pony\"].fields)\n  2503\t        # Make sure the unique_together has the renamed column too\n  2504\t        self.assertIn(\n  2505\t            \"blue\", new_state.models[\"test_rnfl\", \"pony\"].options[\"unique_together\"][0]\n  2506\t        )\n  2507\t        self.assertNotIn(\n  2508\t            \"pink\", new_state.models[\"test_rnfl\", \"pony\"].options[\"unique_together\"][0]\n  2509\t        )\n  2510\t        # Make sure the index_together has the renamed column too\n  2511\t        self.assertIn(\n  2512\t            \"blue\", new_state.models[\"test_rnfl\", \"pony\"].options[\"index_together\"][0]\n  2513\t        )\n  2514\t        self.assertNotIn(\n  2515\t            \"pink\", new_state.models[\"test_rnfl\", \"pony\"].options[\"index_together\"][0]\n  2516\t        )\n  2517\t        # Test the database alteration\n  2518\t        self.assertColumnExists(\"test_rnfl_pony\", \"pink\")\n  2519\t        self.assertColumnNotExists(\"test_rnfl_pony\", \"blue\")\n  2520\t        with connection.schema_editor() as editor:\n  2521\t            operation.database_forwards(\"test_rnfl\", editor, project_state, new_state)\n  2522\t        self.assertColumnExists(\"test_rnfl_pony\", \"blue\")\n  2523\t        self.assertColumnNotExists(\"test_rnfl_pony\", \"pink\")\n  2524\t        # Ensure the unique constraint has been ported over\n  2525\t        with connection.cursor() as cursor:\n  2526\t            cursor.execute(\"INSERT INTO test_rnfl_pony (blue, weight) VALUES (1, 1)\")\n  2527\t            with self.assertRaises(IntegrityError):\n  2528\t                with atomic():\n  2529\t                    cursor.execute(\n  2530\t                        \"INSERT INTO test_rnfl_pony (blue, weight) VALUES (1, 1)\"\n  2531\t                    )\n  2532\t            cursor.execute(\"DELETE FROM test_rnfl_pony\")\n  2533\t        # Ensure the index constraint has been ported over\n  2534\t        self.assertIndexExists(\"test_rnfl_pony\", [\"weight\", \"blue\"])\n  2535\t        # And test reversal\n  2536\t        with connection.schema_editor() as editor:\n  2537\t            operation.database_backwards(\"test_rnfl\", editor, new_state, project_state)\n  2538\t        self.assertColumnExists(\"test_rnfl_pony\", \"pink\")\n  2539\t        self.assertColumnNotExists(\"test_rnfl_pony\", \"blue\")\n  2540\t        # Ensure the index constraint has been reset\n  2541\t        self.assertIndexExists(\"test_rnfl_pony\", [\"weight\", \"pink\"])\n  2542\t        # And deconstruction\n  2543\t        definition = operation.deconstruct()\n  2544\t        self.assertEqual(definition[0], \"RenameField\")\n  2545\t        self.assertEqual(definition[1], [])\n  2546\t        self.assertEqual(\n  2547\t            definition[2],\n  2548\t            {\"model_name\": \"Pony\", \"old_name\": \"pink\", \"new_name\": \"blue\"},\n  2549\t        )\n  2550\t\n  2551\t    def test_rename_field_with_db_column(self):\n  2552\t        project_state = self.apply_operations(\n  2553\t            \"test_rfwdbc\",\n  2554\t            ProjectState(),\n  2555\t            operations=[\n  2556\t                migrations.CreateModel(\n  2557\t                    \"Pony\",\n  2558\t                    fields=[\n  2559\t                        (\"id\", models.AutoField(primary_key=True)),\n  2560\t                        (\"field\", models.IntegerField(db_column=\"db_field\")),\n  2561\t                        (\n  2562\t                            \"fk_field\",\n  2563\t                            models.ForeignKey(\n  2564\t                                \"Pony\",\n  2565\t                                models.CASCADE,\n  2566\t                                db_column=\"db_fk_field\",\n  2567\t                            ),\n  2568\t                        ),\n  2569\t                    ],\n  2570\t                ),\n  2571\t            ],\n  2572\t        )\n  2573\t        new_state = project_state.clone()\n  2574\t        operation = migrations.RenameField(\"Pony\", \"field\", \"renamed_field\")\n  2575\t        operation.state_forwards(\"test_rfwdbc\", new_state)\n  2576\t        self.assertIn(\"renamed_field\", new_state.models[\"test_rfwdbc\", \"pony\"].fields)\n  2577\t        self.assertNotIn(\"field\", new_state.models[\"test_rfwdbc\", \"pony\"].fields)\n  2578\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_field\")\n  2579\t        with connection.schema_editor() as editor:\n  2580\t            with self.assertNumQueries(0):\n  2581\t                operation.database_forwards(\n  2582\t                    \"test_rfwdbc\", editor, project_state, new_state\n  2583\t                )\n  2584\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_field\")\n  2585\t        with connection.schema_editor() as editor:\n  2586\t            with self.assertNumQueries(0):\n  2587\t                operation.database_backwards(\n  2588\t                    \"test_rfwdbc\", editor, new_state, project_state\n  2589\t                )\n  2590\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_field\")\n  2591\t\n  2592\t        new_state = project_state.clone()\n  2593\t        operation = migrations.RenameField(\"Pony\", \"fk_field\", \"renamed_fk_field\")\n  2594\t        operation.state_forwards(\"test_rfwdbc\", new_state)\n  2595\t        self.assertIn(\n  2596\t            \"renamed_fk_field\", new_state.models[\"test_rfwdbc\", \"pony\"].fields\n  2597\t        )\n  2598\t        self.assertNotIn(\"fk_field\", new_state.models[\"test_rfwdbc\", \"pony\"].fields)\n  2599\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_fk_field\")\n  2600\t        with connection.schema_editor() as editor:\n  2601\t            with self.assertNumQueries(0):\n  2602\t                operation.database_forwards(\n  2603\t                    \"test_rfwdbc\", editor, project_state, new_state\n  2604\t                )\n  2605\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_fk_field\")\n  2606\t        with connection.schema_editor() as editor:\n  2607\t            with self.assertNumQueries(0):\n  2608\t                operation.database_backwards(\n  2609\t                    \"test_rfwdbc\", editor, new_state, project_state\n  2610\t                )\n  2611\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_fk_field\")\n  2612\t\n  2613\t    def test_rename_field_case(self):\n  2614\t        project_state = self.apply_operations(\n  2615\t            \"test_rfmx\",\n  2616\t            ProjectState(),\n  2617\t            operations=[\n  2618\t                migrations.CreateModel(\n  2619\t                    \"Pony\",\n  2620\t                    fields=[\n  2621\t                        (\"id\", models.AutoField(primary_key=True)),\n  2622\t                        (\"field\", models.IntegerField()),\n  2623\t                    ],\n  2624\t                ),\n  2625\t            ],\n  2626\t        )\n  2627\t        new_state = project_state.clone()\n  2628\t        operation = migrations.RenameField(\"Pony\", \"field\", \"FiElD\")\n  2629\t        operation.state_forwards(\"test_rfmx\", new_state)\n  2630\t        self.assertIn(\"FiElD\", new_state.models[\"test_rfmx\", \"pony\"].fields)\n  2631\t        self.assertColumnExists(\"test_rfmx_pony\", \"field\")\n  2632\t        with connection.schema_editor() as editor:\n  2633\t            operation.database_forwards(\"test_rfmx\", editor, project_state, new_state)\n  2634\t        self.assertColumnExists(\n  2635\t            \"test_rfmx_pony\",\n  2636\t            connection.introspection.identifier_converter(\"FiElD\"),\n  2637\t        )\n  2638\t        with connection.schema_editor() as editor:\n  2639\t            operation.database_backwards(\"test_rfmx\", editor, new_state, project_state)\n  2640\t        self.assertColumnExists(\"test_rfmx_pony\", \"field\")\n  2641\t\n  2642\t    def test_rename_missing_field(self):\n  2643\t        state = ProjectState()\n  2644\t        state.add_model(ModelState(\"app\", \"model\", []))\n  2645\t        with self.assertRaisesMessage(\n  2646\t            FieldDoesNotExist, \"app.model has no field named 'field'\"\n  2647\t        ):\n  2648\t            migrations.RenameField(\"model\", \"field\", \"new_field\").state_forwards(\n  2649\t                \"app\", state\n  2650\t            )\n  2651\t\n  2652\t    def test_rename_referenced_field_state_forward(self):\n  2653\t        state = ProjectState()\n  2654\t        state.add_model(\n  2655\t            ModelState(\n  2656\t                \"app\",\n  2657\t                \"Model\",\n  2658\t                [\n  2659\t                    (\"id\", models.AutoField(primary_key=True)),\n  2660\t                    (\"field\", models.IntegerField(unique=True)),\n  2661\t                ],\n  2662\t            )\n  2663\t        )\n  2664\t        state.add_model(\n  2665\t            ModelState(\n  2666\t                \"app\",\n  2667\t                \"OtherModel\",\n  2668\t                [\n  2669\t                    (\"id\", models.AutoField(primary_key=True)),\n  2670\t                    (\n  2671\t                        \"fk\",\n  2672\t                        models.ForeignKey(\"Model\", models.CASCADE, to_field=\"field\"),\n  2673\t                    ),\n  2674\t                    (\n  2675\t                        \"fo\",\n  2676\t                        models.ForeignObject(\n  2677\t                            \"Model\",\n  2678\t                            models.CASCADE,\n  2679\t                            from_fields=(\"fk\",),\n  2680\t                            to_fields=(\"field\",),\n  2681\t                        ),\n  2682\t                    ),\n  2683\t                ],\n  2684\t            )\n  2685\t        )\n  2686\t        operation = migrations.RenameField(\"Model\", \"field\", \"renamed\")\n  2687\t        new_state = state.clone()\n  2688\t        operation.state_forwards(\"app\", new_state)\n  2689\t        self.assertEqual(\n  2690\t            new_state.models[\"app\", \"othermodel\"].fields[\"fk\"].remote_field.field_name,\n  2691\t            \"renamed\",\n  2692\t        )\n  2693\t        self.assertEqual(\n  2694\t            new_state.models[\"app\", \"othermodel\"].fields[\"fk\"].from_fields, [\"self\"]\n  2695\t        )\n  2696\t        self.assertEqual(\n  2697\t            new_state.models[\"app\", \"othermodel\"].fields[\"fk\"].to_fields, (\"renamed\",)\n  2698\t        )\n  2699\t        self.assertEqual(\n  2700\t            new_state.models[\"app\", \"othermodel\"].fields[\"fo\"].from_fields, (\"fk\",)\n  2701\t        )\n  2702\t        self.assertEqual(\n  2703\t            new_state.models[\"app\", \"othermodel\"].fields[\"fo\"].to_fields, (\"renamed\",)\n  2704\t        )\n  2705\t        operation = migrations.RenameField(\"OtherModel\", \"fk\", \"renamed_fk\")\n  2706\t        new_state = state.clone()\n  2707\t        operation.state_forwards(\"app\", new_state)\n  2708\t        self.assertEqual(\n  2709\t            new_state.models[\"app\", \"othermodel\"]\n  2710\t            .fields[\"renamed_fk\"]\n  2711\t            .remote_field.field_name,\n  2712\t            \"renamed\",\n  2713\t        )\n  2714\t        self.assertEqual(\n  2715\t            new_state.models[\"app\", \"othermodel\"].fields[\"renamed_fk\"].from_fields,\n  2716\t            (\"self\",),\n  2717\t        )\n  2718\t        self.assertEqual(\n  2719\t            new_state.models[\"app\", \"othermodel\"].fields[\"renamed_fk\"].to_fields,\n  2720\t            (\"renamed\",),\n  2721\t        )\n  2722\t        self.assertEqual(\n  2723\t            new_state.models[\"app\", \"othermodel\"].fields[\"fo\"].from_fields,\n  2724\t            (\"renamed_fk\",),\n  2725\t        )\n  2726\t        self.assertEqual(\n  2727\t            new_state.models[\"app\", \"othermodel\"].fields[\"fo\"].to_fields, (\"renamed\",)\n  2728\t        )\n  2729\t\n  2730\t    def test_alter_unique_together(self):\n  2731\t        \"\"\"\n  2732\t        Tests the AlterUniqueTogether operation.\n  2733\t        \"\"\"\n  2734\t        project_state = self.set_up_test_model(\"test_alunto\")\n  2735\t        # Test the state alteration\n  2736\t        operation = migrations.AlterUniqueTogether(\"Pony\", [(\"pink\", \"weight\")])\n  2737\t        self.assertEqual(\n  2738\t            operation.describe(), \"Alter unique_together for Pony (1 constraint(s))\"\n  2739\t        )\n  2740\t        self.assertEqual(\n  2741\t            operation.migration_name_fragment,\n  2742\t            \"alter_pony_unique_together\",\n  2743\t        )\n  2744\t        new_state = project_state.clone()\n  2745\t        operation.state_forwards(\"test_alunto\", new_state)\n  2746\t        self.assertEqual(\n  2747\t            len(\n  2748\t                project_state.models[\"test_alunto\", \"pony\"].options.get(\n  2749\t                    \"unique_together\", set()\n  2750\t                )\n  2751\t            ),\n  2752\t            0,\n  2753\t        )\n  2754\t        self.assertEqual(\n  2755\t            len(\n  2756\t                new_state.models[\"test_alunto\", \"pony\"].options.get(\n  2757\t                    \"unique_together\", set()\n  2758\t                )\n  2759\t            ),\n  2760\t            1,\n  2761\t        )\n  2762\t        # Make sure we can insert duplicate rows\n  2763\t        with connection.cursor() as cursor:\n  2764\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2765\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2766\t            cursor.execute(\"DELETE FROM test_alunto_pony\")\n  2767\t            # Test the database alteration\n  2768\t            with connection.schema_editor() as editor:\n  2769\t                operation.database_forwards(\n  2770\t                    \"test_alunto\", editor, project_state, new_state\n  2771\t                )\n  2772\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2773\t            with self.assertRaises(IntegrityError):\n  2774\t                with atomic():\n  2775\t                    cursor.execute(\n  2776\t                        \"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\"\n  2777\t                    )\n  2778\t            cursor.execute(\"DELETE FROM test_alunto_pony\")\n  2779\t            # And test reversal\n  2780\t            with connection.schema_editor() as editor:\n  2781\t                operation.database_backwards(\n  2782\t                    \"test_alunto\", editor, new_state, project_state\n  2783\t                )\n  2784\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2785\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2786\t            cursor.execute(\"DELETE FROM test_alunto_pony\")\n  2787\t        # Test flat unique_together\n  2788\t        operation = migrations.AlterUniqueTogether(\"Pony\", (\"pink\", \"weight\"))\n  2789\t        operation.state_forwards(\"test_alunto\", new_state)\n  2790\t        self.assertEqual(\n  2791\t            len(\n  2792\t                new_state.models[\"test_alunto\", \"pony\"].options.get(\n  2793\t                    \"unique_together\", set()\n  2794\t                )\n  2795\t            ),\n  2796\t            1,\n  2797\t        )\n  2798\t        # And deconstruction\n  2799\t        definition = operation.deconstruct()\n  2800\t        self.assertEqual(definition[0], \"AlterUniqueTogether\")\n  2801\t        self.assertEqual(definition[1], [])\n  2802\t        self.assertEqual(\n  2803\t            definition[2], {\"name\": \"Pony\", \"unique_together\": {(\"pink\", \"weight\")}}\n  2804\t        )\n  2805\t\n  2806\t    def test_alter_unique_together_remove(self):\n  2807\t        operation = migrations.AlterUniqueTogether(\"Pony\", None)\n  2808\t        self.assertEqual(\n  2809\t            operation.describe(), \"Alter unique_together for Pony (0 constraint(s))\"\n  2810\t        )\n  2811\t\n  2812\t    def test_add_index(self):\n  2813\t        \"\"\"\n  2814\t        Test the AddIndex operation.\n  2815\t        \"\"\"\n  2816\t        project_state = self.set_up_test_model(\"test_adin\")\n  2817\t        msg = (\n  2818\t            \"Indexes passed to AddIndex operations require a name argument. \"\n  2819\t            \"<Index: fields=['pink']> doesn't have one.\"\n  2820\t        )\n  2821\t        with self.assertRaisesMessage(ValueError, msg):\n  2822\t            migrations.AddIndex(\"Pony\", models.Index(fields=[\"pink\"]))\n  2823\t        index = models.Index(fields=[\"pink\"], name=\"test_adin_pony_pink_idx\")\n  2824\t        operation = migrations.AddIndex(\"Pony\", index)\n  2825\t        self.assertEqual(\n  2826\t            operation.describe(),\n  2827\t            \"Create index test_adin_pony_pink_idx on field(s) pink of model Pony\",\n  2828\t        )\n  2829\t        self.assertEqual(\n  2830\t            operation.migration_name_fragment,\n  2831\t            \"pony_test_adin_pony_pink_idx\",\n  2832\t        )\n  2833\t        new_state = project_state.clone()\n  2834\t        operation.state_forwards(\"test_adin\", new_state)\n  2835\t        # Test the database alteration\n  2836\t        self.assertEqual(\n  2837\t            len(new_state.models[\"test_adin\", \"pony\"].options[\"indexes\"]), 1\n  2838\t        )\n  2839\t        self.assertIndexNotExists(\"test_adin_pony\", [\"pink\"])\n  2840\t        with connection.schema_editor() as editor:\n  2841\t            operation.database_forwards(\"test_adin\", editor, project_state, new_state)\n  2842\t        self.assertIndexExists(\"test_adin_pony\", [\"pink\"])\n  2843\t        # And test reversal\n  2844\t        with connection.schema_editor() as editor:\n  2845\t            operation.database_backwards(\"test_adin\", editor, new_state, project_state)\n  2846\t        self.assertIndexNotExists(\"test_adin_pony\", [\"pink\"])\n  2847\t        # And deconstruction\n  2848\t        definition = operation.deconstruct()\n  2849\t        self.assertEqual(definition[0], \"AddIndex\")\n  2850\t        self.assertEqual(definition[1], [])\n  2851\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"index\": index})\n  2852\t\n  2853\t    def test_remove_index(self):\n  2854\t        \"\"\"\n  2855\t        Test the RemoveIndex operation.\n  2856\t        \"\"\"\n  2857\t        project_state = self.set_up_test_model(\"test_rmin\", multicol_index=True)\n  2858\t        self.assertTableExists(\"test_rmin_pony\")\n  2859\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2860\t        operation = migrations.RemoveIndex(\"Pony\", \"pony_test_idx\")\n  2861\t        self.assertEqual(operation.describe(), \"Remove index pony_test_idx from Pony\")\n  2862\t        self.assertEqual(\n  2863\t            operation.migration_name_fragment,\n  2864\t            \"remove_pony_pony_test_idx\",\n  2865\t        )\n  2866\t        new_state = project_state.clone()\n  2867\t        operation.state_forwards(\"test_rmin\", new_state)\n  2868\t        # Test the state alteration\n  2869\t        self.assertEqual(\n  2870\t            len(new_state.models[\"test_rmin\", \"pony\"].options[\"indexes\"]), 0\n  2871\t        )\n  2872\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2873\t        # Test the database alteration\n  2874\t        with connection.schema_editor() as editor:\n  2875\t            operation.database_forwards(\"test_rmin\", editor, project_state, new_state)\n  2876\t        self.assertIndexNotExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2877\t        # And test reversal\n  2878\t        with connection.schema_editor() as editor:\n  2879\t            operation.database_backwards(\"test_rmin\", editor, new_state, project_state)\n  2880\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2881\t        # And deconstruction\n  2882\t        definition = operation.deconstruct()\n  2883\t        self.assertEqual(definition[0], \"RemoveIndex\")\n  2884\t        self.assertEqual(definition[1], [])\n  2885\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"name\": \"pony_test_idx\"})\n  2886\t\n  2887\t        # Also test a field dropped with index - sqlite remake issue\n  2888\t        operations = [\n  2889\t            migrations.RemoveIndex(\"Pony\", \"pony_test_idx\"),\n  2890\t            migrations.RemoveField(\"Pony\", \"pink\"),\n  2891\t        ]\n  2892\t        self.assertColumnExists(\"test_rmin_pony\", \"pink\")\n  2893\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2894\t        # Test database alteration\n  2895\t        new_state = project_state.clone()\n  2896\t        self.apply_operations(\"test_rmin\", new_state, operations=operations)\n  2897\t        self.assertColumnNotExists(\"test_rmin_pony\", \"pink\")\n  2898\t        self.assertIndexNotExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2899\t        # And test reversal\n  2900\t        self.unapply_operations(\"test_rmin\", project_state, operations=operations)\n  2901\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2902\t\n  2903\t    def test_rename_index(self):\n  2904\t        app_label = \"test_rnin\"\n  2905\t        project_state = self.set_up_test_model(app_label, index=True)\n  2906\t        table_name = app_label + \"_pony\"\n  2907\t        self.assertIndexNameExists(table_name, \"pony_pink_idx\")\n  2908\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2909\t        operation = migrations.RenameIndex(\n  2910\t            \"Pony\", new_name=\"new_pony_test_idx\", old_name=\"pony_pink_idx\"\n  2911\t        )\n  2912\t        self.assertEqual(\n  2913\t            operation.describe(),\n  2914\t            \"Rename index pony_pink_idx on Pony to new_pony_test_idx\",\n  2915\t        )\n  2916\t        self.assertEqual(\n  2917\t            operation.migration_name_fragment,\n  2918\t            \"rename_pony_pink_idx_new_pony_test_idx\",\n  2919\t        )\n  2920\t\n  2921\t        new_state = project_state.clone()\n  2922\t        operation.state_forwards(app_label, new_state)\n  2923\t        # Rename index.\n  2924\t        expected_queries = 1 if connection.features.can_rename_index else 2\n  2925\t        with connection.schema_editor() as editor, self.assertNumQueries(\n  2926\t            expected_queries\n  2927\t        ):\n  2928\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2929\t        self.assertIndexNameNotExists(table_name, \"pony_pink_idx\")\n  2930\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2931\t        # Reversal.\n  2932\t        with connection.schema_editor() as editor, self.assertNumQueries(\n  2933\t            expected_queries\n  2934\t        ):\n  2935\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2936\t        self.assertIndexNameExists(table_name, \"pony_pink_idx\")\n  2937\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2938\t        # Deconstruction.\n  2939\t        definition = operation.deconstruct()\n  2940\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2941\t        self.assertEqual(definition[1], [])\n  2942\t        self.assertEqual(\n  2943\t            definition[2],\n  2944\t            {\n  2945\t                \"model_name\": \"Pony\",\n  2946\t                \"old_name\": \"pony_pink_idx\",\n  2947\t                \"new_name\": \"new_pony_test_idx\",\n  2948\t            },\n  2949\t        )\n  2950\t\n  2951\t    def test_rename_index_arguments(self):\n  2952\t        msg = \"RenameIndex.old_name and old_fields are mutually exclusive.\"\n  2953\t        with self.assertRaisesMessage(ValueError, msg):\n  2954\t            migrations.RenameIndex(\n  2955\t                \"Pony\",\n  2956\t                new_name=\"new_idx_name\",\n  2957\t                old_name=\"old_idx_name\",\n  2958\t                old_fields=(\"weight\", \"pink\"),\n  2959\t            )\n  2960\t        msg = \"RenameIndex requires one of old_name and old_fields arguments to be set.\"\n  2961\t        with self.assertRaisesMessage(ValueError, msg):\n  2962\t            migrations.RenameIndex(\"Pony\", new_name=\"new_idx_name\")\n  2963\t\n  2964\t    def test_rename_index_unnamed_index(self):\n  2965\t        app_label = \"test_rninui\"\n  2966\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  2967\t        table_name = app_label + \"_pony\"\n  2968\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2969\t        operation = migrations.RenameIndex(\n  2970\t            \"Pony\", new_name=\"new_pony_test_idx\", old_fields=(\"weight\", \"pink\")\n  2971\t        )\n  2972\t        self.assertEqual(\n  2973\t            operation.describe(),\n  2974\t            \"Rename unnamed index for ('weight', 'pink') on Pony to new_pony_test_idx\",\n  2975\t        )\n  2976\t        self.assertEqual(\n  2977\t            operation.migration_name_fragment,\n  2978\t            \"rename_pony_weight_pink_new_pony_test_idx\",\n  2979\t        )\n  2980\t\n  2981\t        new_state = project_state.clone()\n  2982\t        operation.state_forwards(app_label, new_state)\n  2983\t        # Rename index.\n  2984\t        with connection.schema_editor() as editor:\n  2985\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2986\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2987\t        # Reverse is a no-op.\n  2988\t        with connection.schema_editor() as editor, self.assertNumQueries(0):\n  2989\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2990\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2991\t        # Deconstruction.\n  2992\t        definition = operation.deconstruct()\n  2993\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2994\t        self.assertEqual(definition[1], [])\n  2995\t        self.assertEqual(\n  2996\t            definition[2],\n  2997\t            {\n  2998\t                \"model_name\": \"Pony\",\n  2999\t                \"new_name\": \"new_pony_test_idx\",\n  3000\t                \"old_fields\": (\"weight\", \"pink\"),\n  3001\t            },\n  3002\t        )\n  3003\t\n  3004\t    def test_rename_index_unknown_unnamed_index(self):\n  3005\t        app_label = \"test_rninuui\"\n  3006\t        project_state = self.set_up_test_model(app_label)\n  3007\t        operation = migrations.RenameIndex(\n  3008\t            \"Pony\", new_name=\"new_pony_test_idx\", old_fields=(\"weight\", \"pink\")\n  3009\t        )\n  3010\t        new_state = project_state.clone()\n  3011\t        operation.state_forwards(app_label, new_state)\n  3012\t        msg = \"Found wrong number (0) of indexes for test_rninuui_pony(weight, pink).\"\n  3013\t        with connection.schema_editor() as editor:\n  3014\t            with self.assertRaisesMessage(ValueError, msg):\n  3015\t                operation.database_forwards(app_label, editor, project_state, new_state)\n  3016\t\n  3017\t    def test_add_index_state_forwards(self):\n  3018\t        project_state = self.set_up_test_model(\"test_adinsf\")\n  3019\t        index = models.Index(fields=[\"pink\"], name=\"test_adinsf_pony_pink_idx\")\n  3020\t        old_model = project_state.apps.get_model(\"test_adinsf\", \"Pony\")\n  3021\t        new_state = project_state.clone()\n  3022\t\n  3023\t        operation = migrations.AddIndex(\"Pony\", index)\n  3024\t        operation.state_forwards(\"test_adinsf\", new_state)\n  3025\t        new_model = new_state.apps.get_model(\"test_adinsf\", \"Pony\")\n  3026\t        self.assertIsNot(old_model, new_model)\n  3027\t\n  3028\t    def test_remove_index_state_forwards(self):\n  3029\t        project_state = self.set_up_test_model(\"test_rminsf\")\n  3030\t        index = models.Index(fields=[\"pink\"], name=\"test_rminsf_pony_pink_idx\")\n  3031\t        migrations.AddIndex(\"Pony\", index).state_forwards(\"test_rminsf\", project_state)\n  3032\t        old_model = project_state.apps.get_model(\"test_rminsf\", \"Pony\")\n  3033\t        new_state = project_state.clone()\n  3034\t\n  3035\t        operation = migrations.RemoveIndex(\"Pony\", \"test_rminsf_pony_pink_idx\")\n  3036\t        operation.state_forwards(\"test_rminsf\", new_state)\n  3037\t        new_model = new_state.apps.get_model(\"test_rminsf\", \"Pony\")\n  3038\t        self.assertIsNot(old_model, new_model)\n  3039\t\n  3040\t    def test_rename_index_state_forwards(self):\n  3041\t        app_label = \"test_rnidsf\"\n  3042\t        project_state = self.set_up_test_model(app_label, index=True)\n  3043\t        old_model = project_state.apps.get_model(app_label, \"Pony\")\n  3044\t        new_state = project_state.clone()\n  3045\t\n  3046\t        operation = migrations.RenameIndex(\n  3047\t            \"Pony\", new_name=\"new_pony_pink_idx\", old_name=\"pony_pink_idx\"\n  3048\t        )\n  3049\t        operation.state_forwards(app_label, new_state)\n  3050\t        new_model = new_state.apps.get_model(app_label, \"Pony\")\n  3051\t        self.assertIsNot(old_model, new_model)\n  3052\t        self.assertEqual(new_model._meta.indexes[0].name, \"new_pony_pink_idx\")\n  3053\t\n  3054\t    def test_rename_index_state_forwards_unnamed_index(self):\n  3055\t        app_label = \"test_rnidsfui\"\n  3056\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  3057\t        old_model = project_state.apps.get_model(app_label, \"Pony\")\n  3058\t        new_state = project_state.clone()\n  3059\t\n  3060\t        operation = migrations.RenameIndex(\n  3061\t            \"Pony\", new_name=\"new_pony_pink_idx\", old_fields=(\"weight\", \"pink\")\n  3062\t        )\n  3063\t        operation.state_forwards(app_label, new_state)\n  3064\t        new_model = new_state.apps.get_model(app_label, \"Pony\")\n  3065\t        self.assertIsNot(old_model, new_model)\n  3066\t        self.assertEqual(new_model._meta.index_together, tuple())\n  3067\t        self.assertEqual(new_model._meta.indexes[0].name, \"new_pony_pink_idx\")\n  3068\t\n  3069\t    @skipUnlessDBFeature(\"supports_expression_indexes\")\n  3070\t    def test_add_func_index(self):\n  3071\t        app_label = \"test_addfuncin\"\n  3072\t        index_name = f\"{app_label}_pony_abs_idx\"\n  3073\t        table_name = f\"{app_label}_pony\"\n  3074\t        project_state = self.set_up_test_model(app_label)\n  3075\t        index = models.Index(Abs(\"weight\"), name=index_name)\n  3076\t        operation = migrations.AddIndex(\"Pony\", index)\n  3077\t        self.assertEqual(\n  3078\t            operation.describe(),\n  3079\t            \"Create index test_addfuncin_pony_abs_idx on Abs(F(weight)) on model Pony\",\n  3080\t        )\n  3081\t        self.assertEqual(\n  3082\t            operation.migration_name_fragment,\n  3083\t            \"pony_test_addfuncin_pony_abs_idx\",\n  3084\t        )\n  3085\t        new_state = project_state.clone()\n  3086\t        operation.state_forwards(app_label, new_state)\n  3087\t        self.assertEqual(len(new_state.models[app_label, \"pony\"].options[\"indexes\"]), 1)\n  3088\t        self.assertIndexNameNotExists(table_name, index_name)\n  3089\t        # Add index.\n  3090\t        with connection.schema_editor() as editor:\n  3091\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3092\t        self.assertIndexNameExists(table_name, index_name)\n  3093\t        # Reversal.\n  3094\t        with connection.schema_editor() as editor:\n  3095\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3096\t        self.assertIndexNameNotExists(table_name, index_name)\n  3097\t        # Deconstruction.\n  3098\t        definition = operation.deconstruct()\n  3099\t        self.assertEqual(definition[0], \"AddIndex\")\n  3100\t        self.assertEqual(definition[1], [])\n  3101\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"index\": index})\n  3102\t\n  3103\t    @skipUnlessDBFeature(\"supports_expression_indexes\")\n  3104\t    def test_remove_func_index(self):\n  3105\t        app_label = \"test_rmfuncin\"\n  3106\t        index_name = f\"{app_label}_pony_abs_idx\"\n  3107\t        table_name = f\"{app_label}_pony\"\n  3108\t        project_state = self.set_up_test_model(\n  3109\t            app_label,\n  3110\t            indexes=[\n  3111\t                models.Index(Abs(\"weight\"), name=index_name),\n  3112\t            ],\n  3113\t        )\n  3114\t        self.assertTableExists(table_name)\n  3115\t        self.assertIndexNameExists(table_name, index_name)\n  3116\t        operation = migrations.RemoveIndex(\"Pony\", index_name)\n  3117\t        self.assertEqual(\n  3118\t            operation.describe(),\n  3119\t            \"Remove index test_rmfuncin_pony_abs_idx from Pony\",\n  3120\t        )\n  3121\t        self.assertEqual(\n  3122\t            operation.migration_name_fragment,\n  3123\t            \"remove_pony_test_rmfuncin_pony_abs_idx\",\n  3124\t        )\n  3125\t        new_state = project_state.clone()\n  3126\t        operation.state_forwards(app_label, new_state)\n  3127\t        self.assertEqual(len(new_state.models[app_label, \"pony\"].options[\"indexes\"]), 0)\n  3128\t        # Remove index.\n  3129\t        with connection.schema_editor() as editor:\n  3130\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3131\t        self.assertIndexNameNotExists(table_name, index_name)\n  3132\t        # Reversal.\n  3133\t        with connection.schema_editor() as editor:\n  3134\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3135\t        self.assertIndexNameExists(table_name, index_name)\n  3136\t        # Deconstruction.\n  3137\t        definition = operation.deconstruct()\n  3138\t        self.assertEqual(definition[0], \"RemoveIndex\")\n  3139\t        self.assertEqual(definition[1], [])\n  3140\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"name\": index_name})\n  3141\t\n  3142\t    @skipUnlessDBFeature(\"supports_expression_indexes\")\n  3143\t    def test_alter_field_with_func_index(self):\n  3144\t        app_label = \"test_alfuncin\"\n  3145\t        index_name = f\"{app_label}_pony_idx\"\n  3146\t        table_name = f\"{app_label}_pony\"\n  3147\t        project_state = self.set_up_test_model(\n  3148\t            app_label,\n  3149\t            indexes=[models.Index(Abs(\"pink\"), name=index_name)],\n  3150\t        )\n  3151\t        operation = migrations.AlterField(\n  3152\t            \"Pony\", \"pink\", models.IntegerField(null=True)\n  3153\t        )\n  3154\t        new_state = project_state.clone()\n  3155\t        operation.state_forwards(app_label, new_state)\n  3156\t        with connection.schema_editor() as editor:\n  3157\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3158\t        self.assertIndexNameExists(table_name, index_name)\n  3159\t        with connection.schema_editor() as editor:\n  3160\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3161\t        self.assertIndexNameExists(table_name, index_name)\n  3162\t\n  3163\t    def test_alter_field_with_index(self):\n  3164\t        \"\"\"\n  3165\t        Test AlterField operation with an index to ensure indexes created via\n  3166\t        Meta.indexes don't get dropped with sqlite3 remake.\n  3167\t        \"\"\"\n  3168\t        project_state = self.set_up_test_model(\"test_alflin\", index=True)\n  3169\t        operation = migrations.AlterField(\n  3170\t            \"Pony\", \"pink\", models.IntegerField(null=True)\n  3171\t        )\n  3172\t        new_state = project_state.clone()\n  3173\t        operation.state_forwards(\"test_alflin\", new_state)\n  3174\t        # Test the database alteration\n  3175\t        self.assertColumnNotNull(\"test_alflin_pony\", \"pink\")\n  3176\t        with connection.schema_editor() as editor:\n  3177\t            operation.database_forwards(\"test_alflin\", editor, project_state, new_state)\n  3178\t        # Index hasn't been dropped\n  3179\t        self.assertIndexExists(\"test_alflin_pony\", [\"pink\"])\n  3180\t        # And test reversal\n  3181\t        with connection.schema_editor() as editor:\n  3182\t            operation.database_backwards(\n  3183\t                \"test_alflin\", editor, new_state, project_state\n  3184\t            )\n  3185\t        # Ensure the index is still there\n  3186\t        self.assertIndexExists(\"test_alflin_pony\", [\"pink\"])\n  3187\t\n  3188\t    def test_alter_index_together(self):\n  3189\t        \"\"\"\n  3190\t        Tests the AlterIndexTogether operation.\n  3191\t        \"\"\"\n  3192\t        project_state = self.set_up_test_model(\"test_alinto\")\n  3193\t        # Test the state alteration\n  3194\t        operation = migrations.AlterIndexTogether(\"Pony\", [(\"pink\", \"weight\")])\n  3195\t        self.assertEqual(\n  3196\t            operation.describe(), \"Alter index_together for Pony (1 constraint(s))\"\n  3197\t        )\n  3198\t        self.assertEqual(\n  3199\t            operation.migration_name_fragment,\n  3200\t            \"alter_pony_index_together\",\n  3201\t        )\n  3202\t        new_state = project_state.clone()\n  3203\t        operation.state_forwards(\"test_alinto\", new_state)\n  3204\t        self.assertEqual(\n  3205\t            len(\n  3206\t                project_state.models[\"test_alinto\", \"pony\"].options.get(\n  3207\t                    \"index_together\", set()\n  3208\t                )\n  3209\t            ),\n  3210\t            0,\n  3211\t        )\n  3212\t        self.assertEqual(\n  3213\t            len(\n  3214\t                new_state.models[\"test_alinto\", \"pony\"].options.get(\n  3215\t                    \"index_together\", set()\n  3216\t                )\n  3217\t            ),\n  3218\t            1,\n  3219\t        )\n  3220\t        # Make sure there's no matching index\n  3221\t        self.assertIndexNotExists(\"test_alinto_pony\", [\"pink\", \"weight\"])\n  3222\t        # Test the database alteration\n  3223\t        with connection.schema_editor() as editor:\n  3224\t            operation.database_forwards(\"test_alinto\", editor, project_state, new_state)\n  3225\t        self.assertIndexExists(\"test_alinto_pony\", [\"pink\", \"weight\"])\n  3226\t        # And test reversal\n  3227\t        with connection.schema_editor() as editor:\n  3228\t            operation.database_backwards(\n  3229\t                \"test_alinto\", editor, new_state, project_state\n  3230\t            )\n  3231\t        self.assertIndexNotExists(\"test_alinto_pony\", [\"pink\", \"weight\"])\n  3232\t        # And deconstruction\n  3233\t        definition = operation.deconstruct()\n  3234\t        self.assertEqual(definition[0], \"AlterIndexTogether\")\n  3235\t        self.assertEqual(definition[1], [])\n  3236\t        self.assertEqual(\n  3237\t            definition[2], {\"name\": \"Pony\", \"index_together\": {(\"pink\", \"weight\")}}\n  3238\t        )\n  3239\t\n  3240\t    def test_alter_index_together_remove(self):\n  3241\t        operation = migrations.AlterIndexTogether(\"Pony\", None)\n  3242\t        self.assertEqual(\n  3243\t            operation.describe(), \"Alter index_together for Pony (0 constraint(s))\"\n  3244\t        )\n  3245\t\n  3246\t    @skipUnlessDBFeature(\"allows_multiple_constraints_on_same_fields\")\n  3247\t    def test_alter_index_together_remove_with_unique_together(self):\n  3248\t        app_label = \"test_alintoremove_wunto\"\n  3249\t        table_name = \"%s_pony\" % app_label\n  3250\t        project_state = self.set_up_test_model(app_label, unique_together=True)\n  3251\t        self.assertUniqueConstraintExists(table_name, [\"pink\", \"weight\"])\n  3252\t        # Add index together.\n  3253\t        new_state = project_state.clone()\n  3254\t        operation = migrations.AlterIndexTogether(\"Pony\", [(\"pink\", \"weight\")])\n  3255\t        operation.state_forwards(app_label, new_state)\n  3256\t        with connection.schema_editor() as editor:\n  3257\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3258\t        self.assertIndexExists(table_name, [\"pink\", \"weight\"])\n  3259\t        # Remove index together.\n  3260\t        project_state = new_state\n  3261\t        new_state = project_state.clone()\n  3262\t        operation = migrations.AlterIndexTogether(\"Pony\", set())\n  3263\t        operation.state_forwards(app_label, new_state)\n  3264\t        with connection.schema_editor() as editor:\n  3265\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3266\t        self.assertIndexNotExists(table_name, [\"pink\", \"weight\"])\n  3267\t        self.assertUniqueConstraintExists(table_name, [\"pink\", \"weight\"])\n  3268\t\n  3269\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3270\t    def test_add_constraint(self):\n  3271\t        project_state = self.set_up_test_model(\"test_addconstraint\")\n  3272\t        gt_check = models.Q(pink__gt=2)\n  3273\t        gt_constraint = models.CheckConstraint(\n  3274\t            check=gt_check, name=\"test_add_constraint_pony_pink_gt_2\"\n  3275\t        )\n  3276\t        gt_operation = migrations.AddConstraint(\"Pony\", gt_constraint)\n  3277\t        self.assertEqual(\n  3278\t            gt_operation.describe(),\n  3279\t            \"Create constraint test_add_constraint_pony_pink_gt_2 on model Pony\",\n  3280\t        )\n  3281\t        self.assertEqual(\n  3282\t            gt_operation.migration_name_fragment,\n  3283\t            \"pony_test_add_constraint_pony_pink_gt_2\",\n  3284\t        )\n  3285\t        # Test the state alteration\n  3286\t        new_state = project_state.clone()\n  3287\t        gt_operation.state_forwards(\"test_addconstraint\", new_state)\n  3288\t        self.assertEqual(\n  3289\t            len(new_state.models[\"test_addconstraint\", \"pony\"].options[\"constraints\"]),\n  3290\t            1,\n  3291\t        )\n  3292\t        Pony = new_state.apps.get_model(\"test_addconstraint\", \"Pony\")\n  3293\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3294\t        # Test the database alteration\n  3295\t        with connection.schema_editor() as editor:\n  3296\t            gt_operation.database_forwards(\n  3297\t                \"test_addconstraint\", editor, project_state, new_state\n  3298\t            )\n  3299\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3300\t            Pony.objects.create(pink=1, weight=1.0)\n  3301\t        # Add another one.\n  3302\t        lt_check = models.Q(pink__lt=100)\n  3303\t        lt_constraint = models.CheckConstraint(\n  3304\t            check=lt_check, name=\"test_add_constraint_pony_pink_lt_100\"\n  3305\t        )\n  3306\t        lt_operation = migrations.AddConstraint(\"Pony\", lt_constraint)\n  3307\t        lt_operation.state_forwards(\"test_addconstraint\", new_state)\n  3308\t        self.assertEqual(\n  3309\t            len(new_state.models[\"test_addconstraint\", \"pony\"].options[\"constraints\"]),\n  3310\t            2,\n  3311\t        )\n  3312\t        Pony = new_state.apps.get_model(\"test_addconstraint\", \"Pony\")\n  3313\t        self.assertEqual(len(Pony._meta.constraints), 2)\n  3314\t        with connection.schema_editor() as editor:\n  3315\t            lt_operation.database_forwards(\n  3316\t                \"test_addconstraint\", editor, project_state, new_state\n  3317\t            )\n  3318\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3319\t            Pony.objects.create(pink=100, weight=1.0)\n  3320\t        # Test reversal\n  3321\t        with connection.schema_editor() as editor:\n  3322\t            gt_operation.database_backwards(\n  3323\t                \"test_addconstraint\", editor, new_state, project_state\n  3324\t            )\n  3325\t        Pony.objects.create(pink=1, weight=1.0)\n  3326\t        # Test deconstruction\n  3327\t        definition = gt_operation.deconstruct()\n  3328\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3329\t        self.assertEqual(definition[1], [])\n  3330\t        self.assertEqual(\n  3331\t            definition[2], {\"model_name\": \"Pony\", \"constraint\": gt_constraint}\n  3332\t        )\n  3333\t\n  3334\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3335\t    def test_add_constraint_percent_escaping(self):\n  3336\t        app_label = \"add_constraint_string_quoting\"\n  3337\t        operations = [\n  3338\t            migrations.CreateModel(\n  3339\t                \"Author\",\n  3340\t                fields=[\n  3341\t                    (\"id\", models.AutoField(primary_key=True)),\n  3342\t                    (\"name\", models.CharField(max_length=100)),\n  3343\t                    (\"surname\", models.CharField(max_length=100, default=\"\")),\n  3344\t                    (\"rebate\", models.CharField(max_length=100)),\n  3345\t                ],\n  3346\t            ),\n  3347\t        ]\n  3348\t        from_state = self.apply_operations(app_label, ProjectState(), operations)\n  3349\t        # \"%\" generated in startswith lookup should be escaped in a way that is\n  3350\t        # considered a leading wildcard.\n  3351\t        check = models.Q(name__startswith=\"Albert\")\n  3352\t        constraint = models.CheckConstraint(check=check, name=\"name_constraint\")\n  3353\t        operation = migrations.AddConstraint(\"Author\", constraint)\n  3354\t        to_state = from_state.clone()\n  3355\t        operation.state_forwards(app_label, to_state)\n  3356\t        with connection.schema_editor() as editor:\n  3357\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3358\t        Author = to_state.apps.get_model(app_label, \"Author\")\n  3359\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3360\t            Author.objects.create(name=\"Artur\")\n  3361\t        # Literal \"%\" should be escaped in a way that is not a considered a\n  3362\t        # wildcard.\n  3363\t        check = models.Q(rebate__endswith=\"%\")\n  3364\t        constraint = models.CheckConstraint(check=check, name=\"rebate_constraint\")\n  3365\t        operation = migrations.AddConstraint(\"Author\", constraint)\n  3366\t        from_state = to_state\n  3367\t        to_state = from_state.clone()\n  3368\t        operation.state_forwards(app_label, to_state)\n  3369\t        Author = to_state.apps.get_model(app_label, \"Author\")\n  3370\t        with connection.schema_editor() as editor:\n  3371\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3372\t        Author = to_state.apps.get_model(app_label, \"Author\")\n  3373\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3374\t            Author.objects.create(name=\"Albert\", rebate=\"10$\")\n  3375\t        author = Author.objects.create(name=\"Albert\", rebate=\"10%\")\n  3376\t        self.assertEqual(Author.objects.get(), author)\n  3377\t        # Right-hand-side baked \"%\" literals should not be used for parameters\n  3378\t        # interpolation.\n  3379\t        check = ~models.Q(surname__startswith=models.F(\"name\"))\n  3380\t        constraint = models.CheckConstraint(check=check, name=\"name_constraint_rhs\")\n  3381\t        operation = migrations.AddConstraint(\"Author\", constraint)\n  3382\t        from_state = to_state\n  3383\t        to_state = from_state.clone()\n  3384\t        operation.state_forwards(app_label, to_state)\n  3385\t        with connection.schema_editor() as editor:\n  3386\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3387\t        Author = to_state.apps.get_model(app_label, \"Author\")\n  3388\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3389\t            Author.objects.create(name=\"Albert\", surname=\"Alberto\")\n  3390\t\n  3391\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3392\t    def test_add_or_constraint(self):\n  3393\t        app_label = \"test_addorconstraint\"\n  3394\t        constraint_name = \"add_constraint_or\"\n  3395\t        from_state = self.set_up_test_model(app_label)\n  3396\t        check = models.Q(pink__gt=2, weight__gt=2) | models.Q(weight__lt=0)\n  3397\t        constraint = models.CheckConstraint(check=check, name=constraint_name)\n  3398\t        operation = migrations.AddConstraint(\"Pony\", constraint)\n  3399\t        to_state = from_state.clone()\n  3400\t        operation.state_forwards(app_label, to_state)\n  3401\t        with connection.schema_editor() as editor:\n  3402\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3403\t        Pony = to_state.apps.get_model(app_label, \"Pony\")\n  3404\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3405\t            Pony.objects.create(pink=2, weight=3.0)\n  3406\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3407\t            Pony.objects.create(pink=3, weight=1.0)\n  3408\t        Pony.objects.bulk_create(\n  3409\t            [\n  3410\t                Pony(pink=3, weight=-1.0),\n  3411\t                Pony(pink=1, weight=-1.0),\n  3412\t                Pony(pink=3, weight=3.0),\n  3413\t            ]\n  3414\t        )\n  3415\t\n  3416\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3417\t    def test_add_constraint_combinable(self):\n  3418\t        app_label = \"test_addconstraint_combinable\"\n  3419\t        operations = [\n  3420\t            migrations.CreateModel(\n  3421\t                \"Book\",\n  3422\t                fields=[\n  3423\t                    (\"id\", models.AutoField(primary_key=True)),\n  3424\t                    (\"read\", models.PositiveIntegerField()),\n  3425\t                    (\"unread\", models.PositiveIntegerField()),\n  3426\t                ],\n  3427\t            ),\n  3428\t        ]\n  3429\t        from_state = self.apply_operations(app_label, ProjectState(), operations)\n  3430\t        constraint = models.CheckConstraint(\n  3431\t            check=models.Q(read=(100 - models.F(\"unread\"))),\n  3432\t            name=\"test_addconstraint_combinable_sum_100\",\n  3433\t        )\n  3434\t        operation = migrations.AddConstraint(\"Book\", constraint)\n  3435\t        to_state = from_state.clone()\n  3436\t        operation.state_forwards(app_label, to_state)\n  3437\t        with connection.schema_editor() as editor:\n  3438\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3439\t        Book = to_state.apps.get_model(app_label, \"Book\")\n  3440\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3441\t            Book.objects.create(read=70, unread=10)\n  3442\t        Book.objects.create(read=70, unread=30)\n  3443\t\n  3444\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3445\t    def test_remove_constraint(self):\n  3446\t        project_state = self.set_up_test_model(\n  3447\t            \"test_removeconstraint\",\n  3448\t            constraints=[\n  3449\t                models.CheckConstraint(\n  3450\t                    check=models.Q(pink__gt=2),\n  3451\t                    name=\"test_remove_constraint_pony_pink_gt_2\",\n  3452\t                ),\n  3453\t                models.CheckConstraint(\n  3454\t                    check=models.Q(pink__lt=100),\n  3455\t                    name=\"test_remove_constraint_pony_pink_lt_100\",\n  3456\t                ),\n  3457\t            ],\n  3458\t        )\n  3459\t        gt_operation = migrations.RemoveConstraint(\n  3460\t            \"Pony\", \"test_remove_constraint_pony_pink_gt_2\"\n  3461\t        )\n  3462\t        self.assertEqual(\n  3463\t            gt_operation.describe(),\n  3464\t            \"Remove constraint test_remove_constraint_pony_pink_gt_2 from model Pony\",\n  3465\t        )\n  3466\t        self.assertEqual(\n  3467\t            gt_operation.migration_name_fragment,\n  3468\t            \"remove_pony_test_remove_constraint_pony_pink_gt_2\",\n  3469\t        )\n  3470\t        # Test state alteration\n  3471\t        new_state = project_state.clone()\n  3472\t        gt_operation.state_forwards(\"test_removeconstraint\", new_state)\n  3473\t        self.assertEqual(\n  3474\t            len(\n  3475\t                new_state.models[\"test_removeconstraint\", \"pony\"].options[\"constraints\"]\n  3476\t            ),\n  3477\t            1,\n  3478\t        )\n  3479\t        Pony = new_state.apps.get_model(\"test_removeconstraint\", \"Pony\")\n  3480\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3481\t        # Test database alteration\n  3482\t        with connection.schema_editor() as editor:\n  3483\t            gt_operation.database_forwards(\n  3484\t                \"test_removeconstraint\", editor, project_state, new_state\n  3485\t            )\n  3486\t        Pony.objects.create(pink=1, weight=1.0).delete()\n  3487\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3488\t            Pony.objects.create(pink=100, weight=1.0)\n  3489\t        # Remove the other one.\n  3490\t        lt_operation = migrations.RemoveConstraint(\n  3491\t            \"Pony\", \"test_remove_constraint_pony_pink_lt_100\"\n  3492\t        )\n  3493\t        lt_operation.state_forwards(\"test_removeconstraint\", new_state)\n  3494\t        self.assertEqual(\n  3495\t            len(\n  3496\t                new_state.models[\"test_removeconstraint\", \"pony\"].options[\"constraints\"]\n  3497\t            ),\n  3498\t            0,\n  3499\t        )\n  3500\t        Pony = new_state.apps.get_model(\"test_removeconstraint\", \"Pony\")\n  3501\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3502\t        with connection.schema_editor() as editor:\n  3503\t            lt_operation.database_forwards(\n  3504\t                \"test_removeconstraint\", editor, project_state, new_state\n  3505\t            )\n  3506\t        Pony.objects.create(pink=100, weight=1.0).delete()\n  3507\t        # Test reversal\n  3508\t        with connection.schema_editor() as editor:\n  3509\t            gt_operation.database_backwards(\n  3510\t                \"test_removeconstraint\", editor, new_state, project_state\n  3511\t            )\n  3512\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3513\t            Pony.objects.create(pink=1, weight=1.0)\n  3514\t        # Test deconstruction\n  3515\t        definition = gt_operation.deconstruct()\n  3516\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3517\t        self.assertEqual(definition[1], [])\n  3518\t        self.assertEqual(\n  3519\t            definition[2],\n  3520\t            {\"model_name\": \"Pony\", \"name\": \"test_remove_constraint_pony_pink_gt_2\"},\n  3521\t        )\n  3522\t\n  3523\t    def test_add_partial_unique_constraint(self):\n  3524\t        project_state = self.set_up_test_model(\"test_addpartialuniqueconstraint\")\n  3525\t        partial_unique_constraint = models.UniqueConstraint(\n  3526\t            fields=[\"pink\"],\n  3527\t            condition=models.Q(weight__gt=5),\n  3528\t            name=\"test_constraint_pony_pink_for_weight_gt_5_uniq\",\n  3529\t        )\n  3530\t        operation = migrations.AddConstraint(\"Pony\", partial_unique_constraint)\n  3531\t        self.assertEqual(\n  3532\t            operation.describe(),\n  3533\t            \"Create constraint test_constraint_pony_pink_for_weight_gt_5_uniq \"\n  3534\t            \"on model Pony\",\n  3535\t        )\n  3536\t        # Test the state alteration\n  3537\t        new_state = project_state.clone()\n  3538\t        operation.state_forwards(\"test_addpartialuniqueconstraint\", new_state)\n  3539\t        self.assertEqual(\n  3540\t            len(\n  3541\t                new_state.models[\"test_addpartialuniqueconstraint\", \"pony\"].options[\n  3542\t                    \"constraints\"\n  3543\t                ]\n  3544\t            ),\n  3545\t            1,\n  3546\t        )\n  3547\t        Pony = new_state.apps.get_model(\"test_addpartialuniqueconstraint\", \"Pony\")\n  3548\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3549\t        # Test the database alteration\n  3550\t        with connection.schema_editor() as editor:\n  3551\t            operation.database_forwards(\n  3552\t                \"test_addpartialuniqueconstraint\", editor, project_state, new_state\n  3553\t            )\n  3554\t        # Test constraint works\n  3555\t        Pony.objects.create(pink=1, weight=4.0)\n  3556\t        Pony.objects.create(pink=1, weight=4.0)\n  3557\t        Pony.objects.create(pink=1, weight=6.0)\n  3558\t        if connection.features.supports_partial_indexes:\n  3559\t            with self.assertRaises(IntegrityError), transaction.atomic():\n  3560\t                Pony.objects.create(pink=1, weight=7.0)\n  3561\t        else:\n  3562\t            Pony.objects.create(pink=1, weight=7.0)\n  3563\t        # Test reversal\n  3564\t        with connection.schema_editor() as editor:\n  3565\t            operation.database_backwards(\n  3566\t                \"test_addpartialuniqueconstraint\", editor, new_state, project_state\n  3567\t            )\n  3568\t        # Test constraint doesn't work\n  3569\t        Pony.objects.create(pink=1, weight=7.0)\n  3570\t        # Test deconstruction\n  3571\t        definition = operation.deconstruct()\n  3572\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3573\t        self.assertEqual(definition[1], [])\n  3574\t        self.assertEqual(\n  3575\t            definition[2],\n  3576\t            {\"model_name\": \"Pony\", \"constraint\": partial_unique_constraint},\n  3577\t        )\n  3578\t\n  3579\t    def test_remove_partial_unique_constraint(self):\n  3580\t        project_state = self.set_up_test_model(\n  3581\t            \"test_removepartialuniqueconstraint\",\n  3582\t            constraints=[\n  3583\t                models.UniqueConstraint(\n  3584\t                    fields=[\"pink\"],\n  3585\t                    condition=models.Q(weight__gt=5),\n  3586\t                    name=\"test_constraint_pony_pink_for_weight_gt_5_uniq\",\n  3587\t                ),\n  3588\t            ],\n  3589\t        )\n  3590\t        gt_operation = migrations.RemoveConstraint(\n  3591\t            \"Pony\", \"test_constraint_pony_pink_for_weight_gt_5_uniq\"\n  3592\t        )\n  3593\t        self.assertEqual(\n  3594\t            gt_operation.describe(),\n  3595\t            \"Remove constraint test_constraint_pony_pink_for_weight_gt_5_uniq from \"\n  3596\t            \"model Pony\",\n  3597\t        )\n  3598\t        # Test state alteration\n  3599\t        new_state = project_state.clone()\n  3600\t        gt_operation.state_forwards(\"test_removepartialuniqueconstraint\", new_state)\n  3601\t        self.assertEqual(\n  3602\t            len(\n  3603\t                new_state.models[\"test_removepartialuniqueconstraint\", \"pony\"].options[\n  3604\t                    \"constraints\"\n  3605\t                ]\n  3606\t            ),\n  3607\t            0,\n  3608\t        )\n  3609\t        Pony = new_state.apps.get_model(\"test_removepartialuniqueconstraint\", \"Pony\")\n  3610\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3611\t        # Test database alteration\n  3612\t        with connection.schema_editor() as editor:\n  3613\t            gt_operation.database_forwards(\n  3614\t                \"test_removepartialuniqueconstraint\", editor, project_state, new_state\n  3615\t            )\n  3616\t        # Test constraint doesn't work\n  3617\t        Pony.objects.create(pink=1, weight=4.0)\n  3618\t        Pony.objects.create(pink=1, weight=4.0)\n  3619\t        Pony.objects.create(pink=1, weight=6.0)\n  3620\t        Pony.objects.create(pink=1, weight=7.0).delete()\n  3621\t        # Test reversal\n  3622\t        with connection.schema_editor() as editor:\n  3623\t            gt_operation.database_backwards(\n  3624\t                \"test_removepartialuniqueconstraint\", editor, new_state, project_state\n  3625\t            )\n  3626\t        # Test constraint works\n  3627\t        if connection.features.supports_partial_indexes:\n  3628\t            with self.assertRaises(IntegrityError), transaction.atomic():\n  3629\t                Pony.objects.create(pink=1, weight=7.0)\n  3630\t        else:\n  3631\t            Pony.objects.create(pink=1, weight=7.0)\n  3632\t        # Test deconstruction\n  3633\t        definition = gt_operation.deconstruct()\n  3634\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3635\t        self.assertEqual(definition[1], [])\n  3636\t        self.assertEqual(\n  3637\t            definition[2],\n  3638\t            {\n  3639\t                \"model_name\": \"Pony\",\n  3640\t                \"name\": \"test_constraint_pony_pink_for_weight_gt_5_uniq\",\n  3641\t            },\n  3642\t        )\n  3643\t\n  3644\t    def test_add_deferred_unique_constraint(self):\n  3645\t        app_label = \"test_adddeferred_uc\"\n  3646\t        project_state = self.set_up_test_model(app_label)\n  3647\t        deferred_unique_constraint = models.UniqueConstraint(\n  3648\t            fields=[\"pink\"],\n  3649\t            name=\"deferred_pink_constraint_add\",\n  3650\t            deferrable=models.Deferrable.DEFERRED,\n  3651\t        )\n  3652\t        operation = migrations.AddConstraint(\"Pony\", deferred_unique_constraint)\n  3653\t        self.assertEqual(\n  3654\t            operation.describe(),\n  3655\t            \"Create constraint deferred_pink_constraint_add on model Pony\",\n  3656\t        )\n  3657\t        # Add constraint.\n  3658\t        new_state = project_state.clone()\n  3659\t        operation.state_forwards(app_label, new_state)\n  3660\t        self.assertEqual(\n  3661\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 1\n  3662\t        )\n  3663\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3664\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3665\t        with connection.schema_editor() as editor, CaptureQueriesContext(\n  3666\t            connection\n  3667\t        ) as ctx:\n  3668\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3669\t        Pony.objects.create(pink=1, weight=4.0)\n  3670\t        if connection.features.supports_deferrable_unique_constraints:\n  3671\t            # Unique constraint is deferred.\n  3672\t            with transaction.atomic():\n  3673\t                obj = Pony.objects.create(pink=1, weight=4.0)\n  3674\t                obj.pink = 2\n  3675\t                obj.save()\n  3676\t            # Constraint behavior can be changed with SET CONSTRAINTS.\n  3677\t            with self.assertRaises(IntegrityError):\n  3678\t                with transaction.atomic(), connection.cursor() as cursor:\n  3679\t                    quoted_name = connection.ops.quote_name(\n  3680\t                        deferred_unique_constraint.name\n  3681\t                    )\n  3682\t                    cursor.execute(\"SET CONSTRAINTS %s IMMEDIATE\" % quoted_name)\n  3683\t                    obj = Pony.objects.create(pink=1, weight=4.0)\n  3684\t                    obj.pink = 3\n  3685\t                    obj.save()\n  3686\t        else:\n  3687\t            self.assertEqual(len(ctx), 0)\n  3688\t            Pony.objects.create(pink=1, weight=4.0)\n  3689\t        # Reversal.\n  3690\t        with connection.schema_editor() as editor:\n  3691\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3692\t        # Constraint doesn't work.\n  3693\t        Pony.objects.create(pink=1, weight=4.0)\n  3694\t        # Deconstruction.\n  3695\t        definition = operation.deconstruct()\n  3696\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3697\t        self.assertEqual(definition[1], [])\n  3698\t        self.assertEqual(\n  3699\t            definition[2],\n  3700\t            {\"model_name\": \"Pony\", \"constraint\": deferred_unique_constraint},\n  3701\t        )\n  3702\t\n  3703\t    def test_remove_deferred_unique_constraint(self):\n  3704\t        app_label = \"test_removedeferred_uc\"\n  3705\t        deferred_unique_constraint = models.UniqueConstraint(\n  3706\t            fields=[\"pink\"],\n  3707\t            name=\"deferred_pink_constraint_rm\",\n  3708\t            deferrable=models.Deferrable.DEFERRED,\n  3709\t        )\n  3710\t        project_state = self.set_up_test_model(\n  3711\t            app_label, constraints=[deferred_unique_constraint]\n  3712\t        )\n  3713\t        operation = migrations.RemoveConstraint(\"Pony\", deferred_unique_constraint.name)\n  3714\t        self.assertEqual(\n  3715\t            operation.describe(),\n  3716\t            \"Remove constraint deferred_pink_constraint_rm from model Pony\",\n  3717\t        )\n  3718\t        # Remove constraint.\n  3719\t        new_state = project_state.clone()\n  3720\t        operation.state_forwards(app_label, new_state)\n  3721\t        self.assertEqual(\n  3722\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 0\n  3723\t        )\n  3724\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3725\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3726\t        with connection.schema_editor() as editor, CaptureQueriesContext(\n  3727\t            connection\n  3728\t        ) as ctx:\n  3729\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3730\t        # Constraint doesn't work.\n  3731\t        Pony.objects.create(pink=1, weight=4.0)\n  3732\t        Pony.objects.create(pink=1, weight=4.0).delete()\n  3733\t        if not connection.features.supports_deferrable_unique_constraints:\n  3734\t            self.assertEqual(len(ctx), 0)\n  3735\t        # Reversal.\n  3736\t        with connection.schema_editor() as editor:\n  3737\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3738\t        if connection.features.supports_deferrable_unique_constraints:\n  3739\t            # Unique constraint is deferred.\n  3740\t            with transaction.atomic():\n  3741\t                obj = Pony.objects.create(pink=1, weight=4.0)\n  3742\t                obj.pink = 2\n  3743\t                obj.save()\n  3744\t            # Constraint behavior can be changed with SET CONSTRAINTS.\n  3745\t            with self.assertRaises(IntegrityError):\n  3746\t                with transaction.atomic(), connection.cursor() as cursor:\n  3747\t                    quoted_name = connection.ops.quote_name(\n  3748\t                        deferred_unique_constraint.name\n  3749\t                    )\n  3750\t                    cursor.execute(\"SET CONSTRAINTS %s IMMEDIATE\" % quoted_name)\n  3751\t                    obj = Pony.objects.create(pink=1, weight=4.0)\n  3752\t                    obj.pink = 3\n  3753\t                    obj.save()\n  3754\t        else:\n  3755\t            Pony.objects.create(pink=1, weight=4.0)\n  3756\t        # Deconstruction.\n  3757\t        definition = operation.deconstruct()\n  3758\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3759\t        self.assertEqual(definition[1], [])\n  3760\t        self.assertEqual(\n  3761\t            definition[2],\n  3762\t            {\n  3763\t                \"model_name\": \"Pony\",\n  3764\t                \"name\": \"deferred_pink_constraint_rm\",\n  3765\t            },\n  3766\t        )\n  3767\t\n  3768\t    def test_add_covering_unique_constraint(self):\n  3769\t        app_label = \"test_addcovering_uc\"\n  3770\t        project_state = self.set_up_test_model(app_label)\n  3771\t        covering_unique_constraint = models.UniqueConstraint(\n  3772\t            fields=[\"pink\"],\n  3773\t            name=\"covering_pink_constraint_add\",\n  3774\t            include=[\"weight\"],\n  3775\t        )\n  3776\t        operation = migrations.AddConstraint(\"Pony\", covering_unique_constraint)\n  3777\t        self.assertEqual(\n  3778\t            operation.describe(),\n  3779\t            \"Create constraint covering_pink_constraint_add on model Pony\",\n  3780\t        )\n  3781\t        # Add constraint.\n  3782\t        new_state = project_state.clone()\n  3783\t        operation.state_forwards(app_label, new_state)\n  3784\t        self.assertEqual(\n  3785\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 1\n  3786\t        )\n  3787\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3788\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3789\t        with connection.schema_editor() as editor, CaptureQueriesContext(\n  3790\t            connection\n  3791\t        ) as ctx:\n  3792\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3793\t        Pony.objects.create(pink=1, weight=4.0)\n  3794\t        if connection.features.supports_covering_indexes:\n  3795\t            with self.assertRaises(IntegrityError):\n  3796\t                Pony.objects.create(pink=1, weight=4.0)\n  3797\t        else:\n  3798\t            self.assertEqual(len(ctx), 0)\n  3799\t            Pony.objects.create(pink=1, weight=4.0)\n  3800\t        # Reversal.\n  3801\t        with connection.schema_editor() as editor:\n  3802\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3803\t        # Constraint doesn't work.\n  3804\t        Pony.objects.create(pink=1, weight=4.0)\n  3805\t        # Deconstruction.\n  3806\t        definition = operation.deconstruct()\n  3807\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3808\t        self.assertEqual(definition[1], [])\n  3809\t        self.assertEqual(\n  3810\t            definition[2],\n  3811\t            {\"model_name\": \"Pony\", \"constraint\": covering_unique_constraint},\n  3812\t        )\n  3813\t\n  3814\t    def test_remove_covering_unique_constraint(self):\n  3815\t        app_label = \"test_removecovering_uc\"\n  3816\t        covering_unique_constraint = models.UniqueConstraint(\n  3817\t            fields=[\"pink\"],\n  3818\t            name=\"covering_pink_constraint_rm\",\n  3819\t            include=[\"weight\"],\n  3820\t        )\n  3821\t        project_state = self.set_up_test_model(\n  3822\t            app_label, constraints=[covering_unique_constraint]\n  3823\t        )\n  3824\t        operation = migrations.RemoveConstraint(\"Pony\", covering_unique_constraint.name)\n  3825\t        self.assertEqual(\n  3826\t            operation.describe(),\n  3827\t            \"Remove constraint covering_pink_constraint_rm from model Pony\",\n  3828\t        )\n  3829\t        # Remove constraint.\n  3830\t        new_state = project_state.clone()\n  3831\t        operation.state_forwards(app_label, new_state)\n  3832\t        self.assertEqual(\n  3833\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 0\n  3834\t        )\n  3835\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3836\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3837\t        with connection.schema_editor() as editor, CaptureQueriesContext(\n  3838\t            connection\n  3839\t        ) as ctx:\n  3840\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3841\t        # Constraint doesn't work.\n  3842\t        Pony.objects.create(pink=1, weight=4.0)\n  3843\t        Pony.objects.create(pink=1, weight=4.0).delete()\n  3844\t        if not connection.features.supports_covering_indexes:\n  3845\t            self.assertEqual(len(ctx), 0)\n  3846\t        # Reversal.\n  3847\t        with connection.schema_editor() as editor:\n  3848\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3849\t        if connection.features.supports_covering_indexes:\n  3850\t            with self.assertRaises(IntegrityError):\n  3851\t                Pony.objects.create(pink=1, weight=4.0)\n  3852\t        else:\n  3853\t            Pony.objects.create(pink=1, weight=4.0)\n  3854\t        # Deconstruction.\n  3855\t        definition = operation.deconstruct()\n  3856\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3857\t        self.assertEqual(definition[1], [])\n  3858\t        self.assertEqual(\n  3859\t            definition[2],\n  3860\t            {\n  3861\t                \"model_name\": \"Pony\",\n  3862\t                \"name\": \"covering_pink_constraint_rm\",\n  3863\t            },\n  3864\t        )\n  3865\t\n  3866\t    def test_alter_field_with_func_unique_constraint(self):\n  3867\t        app_label = \"test_alfuncuc\"\n  3868\t        constraint_name = f\"{app_label}_pony_uq\"\n  3869\t        table_name = f\"{app_label}_pony\"\n  3870\t        project_state = self.set_up_test_model(\n  3871\t            app_label,\n  3872\t            constraints=[\n  3873\t                models.UniqueConstraint(\"pink\", \"weight\", name=constraint_name)\n  3874\t            ],\n  3875\t        )\n  3876\t        operation = migrations.AlterField(\n  3877\t            \"Pony\", \"pink\", models.IntegerField(null=True)\n  3878\t        )\n  3879\t        new_state = project_state.clone()\n  3880\t        operation.state_forwards(app_label, new_state)\n  3881\t        with connection.schema_editor() as editor:\n  3882\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3883\t        if connection.features.supports_expression_indexes:\n  3884\t            self.assertIndexNameExists(table_name, constraint_name)\n  3885\t        with connection.schema_editor() as editor:\n  3886\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3887\t        if connection.features.supports_expression_indexes:\n  3888\t            self.assertIndexNameExists(table_name, constraint_name)\n  3889\t\n  3890\t    def test_add_func_unique_constraint(self):\n  3891\t        app_label = \"test_adfuncuc\"\n  3892\t        constraint_name = f\"{app_label}_pony_abs_uq\"\n  3893\t        table_name = f\"{app_label}_pony\"\n  3894\t        project_state = self.set_up_test_model(app_label)\n  3895\t        constraint = models.UniqueConstraint(Abs(\"weight\"), name=constraint_name)\n  3896\t        operation = migrations.AddConstraint(\"Pony\", constraint)\n  3897\t        self.assertEqual(\n  3898\t            operation.describe(),\n  3899\t            \"Create constraint test_adfuncuc_pony_abs_uq on model Pony\",\n  3900\t        )\n  3901\t        self.assertEqual(\n  3902\t            operation.migration_name_fragment,\n  3903\t            \"pony_test_adfuncuc_pony_abs_uq\",\n  3904\t        )\n  3905\t        new_state = project_state.clone()\n  3906\t        operation.state_forwards(app_label, new_state)\n  3907\t        self.assertEqual(\n  3908\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 1\n  3909\t        )\n  3910\t        self.assertIndexNameNotExists(table_name, constraint_name)\n  3911\t        # Add constraint.\n  3912\t        with connection.schema_editor() as editor:\n  3913\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3914\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3915\t        Pony.objects.create(weight=4.0)\n  3916\t        if connection.features.supports_expression_indexes:\n  3917\t            self.assertIndexNameExists(table_name, constraint_name)\n  3918\t            with self.assertRaises(IntegrityError):\n  3919\t                Pony.objects.create(weight=-4.0)\n  3920\t        else:\n  3921\t            self.assertIndexNameNotExists(table_name, constraint_name)\n  3922\t            Pony.objects.create(weight=-4.0)\n  3923\t        # Reversal.\n  3924\t        with connection.schema_editor() as editor:\n  3925\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3926\t        self.assertIndexNameNotExists(table_name, constraint_name)\n  3927\t        # Constraint doesn't work.\n  3928\t        Pony.objects.create(weight=-4.0)\n  3929\t        # Deconstruction.\n  3930\t        definition = operation.deconstruct()\n  3931\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3932\t        self.assertEqual(definition[1], [])\n  3933\t        self.assertEqual(\n  3934\t            definition[2],\n  3935\t            {\"model_name\": \"Pony\", \"constraint\": constraint},\n  3936\t        )\n  3937\t\n  3938\t    def test_remove_func_unique_constraint(self):\n  3939\t        app_label = \"test_rmfuncuc\"\n  3940\t        constraint_name = f\"{app_label}_pony_abs_uq\"\n  3941\t        table_name = f\"{app_label}_pony\"\n  3942\t        project_state = self.set_up_test_model(\n  3943\t            app_label,\n  3944\t            constraints=[\n  3945\t                models.UniqueConstraint(Abs(\"weight\"), name=constraint_name),\n  3946\t            ],\n  3947\t        )\n  3948\t        self.assertTableExists(table_name)\n  3949\t        if connection.features.supports_expression_indexes:\n  3950\t            self.assertIndexNameExists(table_name, constraint_name)\n  3951\t        operation = migrations.RemoveConstraint(\"Pony\", constraint_name)\n  3952\t        self.assertEqual(\n  3953\t            operation.describe(),\n  3954\t            \"Remove constraint test_rmfuncuc_pony_abs_uq from model Pony\",\n  3955\t        )\n  3956\t        self.assertEqual(\n  3957\t            operation.migration_name_fragment,\n  3958\t            \"remove_pony_test_rmfuncuc_pony_abs_uq\",\n  3959\t        )\n  3960\t        new_state = project_state.clone()\n  3961\t        operation.state_forwards(app_label, new_state)\n  3962\t        self.assertEqual(\n  3963\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 0\n  3964\t        )\n  3965\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3966\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3967\t        # Remove constraint.\n  3968\t        with connection.schema_editor() as editor:\n  3969\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3970\t        self.assertIndexNameNotExists(table_name, constraint_name)\n  3971\t        # Constraint doesn't work.\n  3972\t        Pony.objects.create(pink=1, weight=4.0)\n  3973\t        Pony.objects.create(pink=1, weight=-4.0).delete()\n  3974\t        # Reversal.\n  3975\t        with connection.schema_editor() as editor:\n  3976\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3977\t        if connection.features.supports_expression_indexes:\n  3978\t            self.assertIndexNameExists(table_name, constraint_name)\n  3979\t            with self.assertRaises(IntegrityError):\n  3980\t                Pony.objects.create(weight=-4.0)\n  3981\t        else:\n  3982\t            self.assertIndexNameNotExists(table_name, constraint_name)\n  3983\t            Pony.objects.create(weight=-4.0)\n  3984\t        # Deconstruction.\n  3985\t        definition = operation.deconstruct()\n  3986\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3987\t        self.assertEqual(definition[1], [])\n  3988\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"name\": constraint_name})\n  3989\t\n  3990\t    def test_alter_model_options(self):\n  3991\t        \"\"\"\n  3992\t        Tests the AlterModelOptions operation.\n  3993\t        \"\"\"\n  3994\t        project_state = self.set_up_test_model(\"test_almoop\")\n  3995\t        # Test the state alteration (no DB alteration to test)\n  3996\t        operation = migrations.AlterModelOptions(\n  3997\t            \"Pony\", {\"permissions\": [(\"can_groom\", \"Can groom\")]}\n  3998\t        )\n  3999\t        self.assertEqual(operation.describe(), \"Change Meta options on Pony\")\n  4000\t        self.assertEqual(operation.migration_name_fragment, \"alter_pony_options\")\n  4001\t        new_state = project_state.clone()\n  4002\t        operation.state_forwards(\"test_almoop\", new_state)\n  4003\t        self.assertEqual(\n  4004\t            len(\n  4005\t                project_state.models[\"test_almoop\", \"pony\"].options.get(\n  4006\t                    \"permissions\", []\n  4007\t                )\n  4008\t            ),\n  4009\t            0,\n  4010\t        )\n  4011\t        self.assertEqual(\n  4012\t            len(new_state.models[\"test_almoop\", \"pony\"].options.get(\"permissions\", [])),\n  4013\t            1,\n  4014\t        )\n  4015\t        self.assertEqual(\n  4016\t            new_state.models[\"test_almoop\", \"pony\"].options[\"permissions\"][0][0],\n  4017\t            \"can_groom\",\n  4018\t        )\n  4019\t        # And deconstruction\n  4020\t        definition = operation.deconstruct()\n  4021\t        self.assertEqual(definition[0], \"AlterModelOptions\")\n  4022\t        self.assertEqual(definition[1], [])\n  4023\t        self.assertEqual(\n  4024\t            definition[2],\n  4025\t            {\"name\": \"Pony\", \"options\": {\"permissions\": [(\"can_groom\", \"Can groom\")]}},\n  4026\t        )\n  4027\t\n  4028\t    def test_alter_model_options_emptying(self):\n  4029\t        \"\"\"\n  4030\t        The AlterModelOptions operation removes keys from the dict (#23121)\n  4031\t        \"\"\"\n  4032\t        project_state = self.set_up_test_model(\"test_almoop\", options=True)\n  4033\t        # Test the state alteration (no DB alteration to test)\n  4034\t        operation = migrations.AlterModelOptions(\"Pony\", {})\n  4035\t        self.assertEqual(operation.describe(), \"Change Meta options on Pony\")\n  4036\t        new_state = project_state.clone()\n  4037\t        operation.state_forwards(\"test_almoop\", new_state)\n  4038\t        self.assertEqual(\n  4039\t            len(\n  4040\t                project_state.models[\"test_almoop\", \"pony\"].options.get(\n  4041\t                    \"permissions\", []\n  4042\t                )\n  4043\t            ),\n  4044\t            1,\n  4045\t        )\n  4046\t        self.assertEqual(\n  4047\t            len(new_state.models[\"test_almoop\", \"pony\"].options.get(\"permissions\", [])),\n  4048\t            0,\n  4049\t        )\n  4050\t        # And deconstruction\n  4051\t        definition = operation.deconstruct()\n  4052\t        self.assertEqual(definition[0], \"AlterModelOptions\")\n  4053\t        self.assertEqual(definition[1], [])\n  4054\t        self.assertEqual(definition[2], {\"name\": \"Pony\", \"options\": {}})\n  4055\t\n  4056\t    def test_alter_order_with_respect_to(self):\n  4057\t        \"\"\"\n  4058\t        Tests the AlterOrderWithRespectTo operation.\n  4059\t        \"\"\"\n  4060\t        project_state = self.set_up_test_model(\"test_alorwrtto\", related_model=True)\n  4061\t        # Test the state alteration\n  4062\t        operation = migrations.AlterOrderWithRespectTo(\"Rider\", \"pony\")\n  4063\t        self.assertEqual(\n  4064\t            operation.describe(), \"Set order_with_respect_to on Rider to pony\"\n  4065\t        )\n  4066\t        self.assertEqual(\n  4067\t            operation.migration_name_fragment,\n  4068\t            \"alter_rider_order_with_respect_to\",\n  4069\t        )\n  4070\t        new_state = project_state.clone()\n  4071\t        operation.state_forwards(\"test_alorwrtto\", new_state)\n  4072\t        self.assertIsNone(\n  4073\t            project_state.models[\"test_alorwrtto\", \"rider\"].options.get(\n  4074\t                \"order_with_respect_to\", None\n  4075\t            )\n  4076\t        )\n  4077\t        self.assertEqual(\n  4078\t            new_state.models[\"test_alorwrtto\", \"rider\"].options.get(\n  4079\t                \"order_with_respect_to\", None\n  4080\t            ),\n  4081\t            \"pony\",\n  4082\t        )\n  4083\t        # Make sure there's no matching index\n  4084\t        self.assertColumnNotExists(\"test_alorwrtto_rider\", \"_order\")\n  4085\t        # Create some rows before alteration\n  4086\t        rendered_state = project_state.apps\n  4087\t        pony = rendered_state.get_model(\"test_alorwrtto\", \"Pony\").objects.create(\n  4088\t            weight=50\n  4089\t        )\n  4090\t        rider1 = rendered_state.get_model(\"test_alorwrtto\", \"Rider\").objects.create(\n  4091\t            pony=pony\n  4092\t        )\n  4093\t        rider1.friend = rider1\n  4094\t        rider1.save()\n  4095\t        rider2 = rendered_state.get_model(\"test_alorwrtto\", \"Rider\").objects.create(\n  4096\t            pony=pony\n  4097\t        )\n  4098\t        rider2.friend = rider2\n  4099\t        rider2.save()\n  4100\t        # Test the database alteration\n  4101\t        with connection.schema_editor() as editor:\n  4102\t            operation.database_forwards(\n  4103\t                \"test_alorwrtto\", editor, project_state, new_state\n  4104\t            )\n  4105\t        self.assertColumnExists(\"test_alorwrtto_rider\", \"_order\")\n  4106\t        # Check for correct value in rows\n  4107\t        updated_riders = new_state.apps.get_model(\n  4108\t            \"test_alorwrtto\", \"Rider\"\n  4109\t        ).objects.all()\n  4110\t        self.assertEqual(updated_riders[0]._order, 0)\n  4111\t        self.assertEqual(updated_riders[1]._order, 0)\n  4112\t        # And test reversal\n  4113\t        with connection.schema_editor() as editor:\n  4114\t            operation.database_backwards(\n  4115\t                \"test_alorwrtto\", editor, new_state, project_state\n  4116\t            )\n  4117\t        self.assertColumnNotExists(\"test_alorwrtto_rider\", \"_order\")\n  4118\t        # And deconstruction\n  4119\t        definition = operation.deconstruct()\n  4120\t        self.assertEqual(definition[0], \"AlterOrderWithRespectTo\")\n  4121\t        self.assertEqual(definition[1], [])\n  4122\t        self.assertEqual(\n  4123\t            definition[2], {\"name\": \"Rider\", \"order_with_respect_to\": \"pony\"}\n  4124\t        )\n  4125\t\n  4126\t    def test_alter_model_managers(self):\n  4127\t        \"\"\"\n  4128\t        The managers on a model are set.\n  4129\t        \"\"\"\n  4130\t        project_state = self.set_up_test_model(\"test_almoma\")\n  4131\t        # Test the state alteration\n  4132\t        operation = migrations.AlterModelManagers(\n  4133\t            \"Pony\",\n  4134\t            managers=[\n  4135\t                (\"food_qs\", FoodQuerySet.as_manager()),\n  4136\t                (\"food_mgr\", FoodManager(\"a\", \"b\")),\n  4137\t                (\"food_mgr_kwargs\", FoodManager(\"x\", \"y\", 3, 4)),\n  4138\t            ],\n  4139\t        )\n  4140\t        self.assertEqual(operation.describe(), \"Change managers on Pony\")\n  4141\t        self.assertEqual(operation.migration_name_fragment, \"alter_pony_managers\")\n  4142\t        managers = project_state.models[\"test_almoma\", \"pony\"].managers\n  4143\t        self.assertEqual(managers, [])\n  4144\t\n  4145\t        new_state = project_state.clone()\n  4146\t        operation.state_forwards(\"test_almoma\", new_state)\n  4147\t        self.assertIn((\"test_almoma\", \"pony\"), new_state.models)\n  4148\t        managers = new_state.models[\"test_almoma\", \"pony\"].managers\n  4149\t        self.assertEqual(managers[0][0], \"food_qs\")\n  4150\t        self.assertIsInstance(managers[0][1], models.Manager)\n  4151\t        self.assertEqual(managers[1][0], \"food_mgr\")\n  4152\t        self.assertIsInstance(managers[1][1], FoodManager)\n  4153\t        self.assertEqual(managers[1][1].args, (\"a\", \"b\", 1, 2))\n  4154\t        self.assertEqual(managers[2][0], \"food_mgr_kwargs\")\n  4155\t        self.assertIsInstance(managers[2][1], FoodManager)\n  4156\t        self.assertEqual(managers[2][1].args, (\"x\", \"y\", 3, 4))\n  4157\t        rendered_state = new_state.apps\n  4158\t        model = rendered_state.get_model(\"test_almoma\", \"pony\")\n  4159\t        self.assertIsInstance(model.food_qs, models.Manager)\n  4160\t        self.assertIsInstance(model.food_mgr, FoodManager)\n  4161\t        self.assertIsInstance(model.food_mgr_kwargs, FoodManager)\n  4162\t\n  4163\t    def test_alter_model_managers_emptying(self):\n  4164\t        \"\"\"\n  4165\t        The managers on a model are set.\n  4166\t        \"\"\"\n  4167\t        project_state = self.set_up_test_model(\"test_almomae\", manager_model=True)\n  4168\t        # Test the state alteration\n  4169\t        operation = migrations.AlterModelManagers(\"Food\", managers=[])\n  4170\t        self.assertEqual(operation.describe(), \"Change managers on Food\")\n  4171\t        self.assertIn((\"test_almomae\", \"food\"), project_state.models)\n  4172\t        managers = project_state.models[\"test_almomae\", \"food\"].managers\n  4173\t        self.assertEqual(managers[0][0], \"food_qs\")\n  4174\t        self.assertIsInstance(managers[0][1], models.Manager)\n  4175\t        self.assertEqual(managers[1][0], \"food_mgr\")\n  4176\t        self.assertIsInstance(managers[1][1], FoodManager)\n  4177\t        self.assertEqual(managers[1][1].args, (\"a\", \"b\", 1, 2))\n  4178\t        self.assertEqual(managers[2][0], \"food_mgr_kwargs\")\n  4179\t        self.assertIsInstance(managers[2][1], FoodManager)\n  4180\t        self.assertEqual(managers[2][1].args, (\"x\", \"y\", 3, 4))\n  4181\t\n  4182\t        new_state = project_state.clone()\n  4183\t        operation.state_forwards(\"test_almomae\", new_state)\n  4184\t        managers = new_state.models[\"test_almomae\", \"food\"].managers\n  4185\t        self.assertEqual(managers, [])\n  4186\t\n  4187\t    def test_alter_fk(self):\n  4188\t        \"\"\"\n  4189\t        Creating and then altering an FK works correctly\n  4190\t        and deals with the pending SQL (#23091)\n  4191\t        \"\"\"\n  4192\t        project_state = self.set_up_test_model(\"test_alfk\")\n  4193\t        # Test adding and then altering the FK in one go\n  4194\t        create_operation = migrations.CreateModel(\n  4195\t            name=\"Rider\",\n  4196\t            fields=[\n  4197\t                (\"id\", models.AutoField(primary_key=True)),\n  4198\t                (\"pony\", models.ForeignKey(\"Pony\", models.CASCADE)),\n  4199\t            ],\n  4200\t        )\n  4201\t        create_state = project_state.clone()\n  4202\t        create_operation.state_forwards(\"test_alfk\", create_state)\n  4203\t        alter_operation = migrations.AlterField(\n  4204\t            model_name=\"Rider\",\n  4205\t            name=\"pony\",\n  4206\t            field=models.ForeignKey(\"Pony\", models.CASCADE, editable=False),\n  4207\t        )\n  4208\t        alter_state = create_state.clone()\n  4209\t        alter_operation.state_forwards(\"test_alfk\", alter_state)\n  4210\t        with connection.schema_editor() as editor:\n  4211\t            create_operation.database_forwards(\n  4212\t                \"test_alfk\", editor, project_state, create_state\n  4213\t            )\n  4214\t            alter_operation.database_forwards(\n  4215\t                \"test_alfk\", editor, create_state, alter_state\n  4216\t            )\n  4217\t\n  4218\t    def test_alter_fk_non_fk(self):\n  4219\t        \"\"\"\n  4220\t        Altering an FK to a non-FK works (#23244)\n  4221\t        \"\"\"\n  4222\t        # Test the state alteration\n  4223\t        operation = migrations.AlterField(\n  4224\t            model_name=\"Rider\",\n  4225\t            name=\"pony\",\n  4226\t            field=models.FloatField(),\n  4227\t        )\n  4228\t        project_state, new_state = self.make_test_state(\n  4229\t            \"test_afknfk\", operation, related_model=True\n  4230\t        )\n  4231\t        # Test the database alteration\n  4232\t        self.assertColumnExists(\"test_afknfk_rider\", \"pony_id\")\n  4233\t        self.assertColumnNotExists(\"test_afknfk_rider\", \"pony\")\n  4234\t        with connection.schema_editor() as editor:\n  4235\t            operation.database_forwards(\"test_afknfk\", editor, project_state, new_state)\n  4236\t        self.assertColumnExists(\"test_afknfk_rider\", \"pony\")\n  4237\t        self.assertColumnNotExists(\"test_afknfk_rider\", \"pony_id\")\n  4238\t        # And test reversal\n  4239\t        with connection.schema_editor() as editor:\n  4240\t            operation.database_backwards(\n  4241\t                \"test_afknfk\", editor, new_state, project_state\n  4242\t            )\n  4243\t        self.assertColumnExists(\"test_afknfk_rider\", \"pony_id\")\n  4244\t        self.assertColumnNotExists(\"test_afknfk_rider\", \"pony\")\n  4245\t\n  4246\t    def test_run_sql(self):\n  4247\t        \"\"\"\n  4248\t        Tests the RunSQL operation.\n  4249\t        \"\"\"\n  4250\t        project_state = self.set_up_test_model(\"test_runsql\")\n  4251\t        # Create the operation\n  4252\t        operation = migrations.RunSQL(\n  4253\t            # Use a multi-line string with a comment to test splitting on\n  4254\t            # SQLite and MySQL respectively.\n  4255\t            \"CREATE TABLE i_love_ponies (id int, special_thing varchar(15));\\n\"\n  4256\t            \"INSERT INTO i_love_ponies (id, special_thing) \"\n  4257\t            \"VALUES (1, 'i love ponies'); -- this is magic!\\n\"\n  4258\t            \"INSERT INTO i_love_ponies (id, special_thing) \"\n  4259\t            \"VALUES (2, 'i love django');\\n\"\n  4260\t            \"UPDATE i_love_ponies SET special_thing = 'Ponies' \"\n  4261\t            \"WHERE special_thing LIKE '%%ponies';\"\n  4262\t            \"UPDATE i_love_ponies SET special_thing = 'Django' \"\n  4263\t            \"WHERE special_thing LIKE '%django';\",\n  4264\t            # Run delete queries to test for parameter substitution failure\n  4265\t            # reported in #23426\n  4266\t            \"DELETE FROM i_love_ponies WHERE special_thing LIKE '%Django%';\"\n  4267\t            \"DELETE FROM i_love_ponies WHERE special_thing LIKE '%%Ponies%%';\"\n  4268\t            \"DROP TABLE i_love_ponies\",\n  4269\t            state_operations=[\n  4270\t                migrations.CreateModel(\n  4271\t                    \"SomethingElse\", [(\"id\", models.AutoField(primary_key=True))]\n  4272\t                )\n  4273\t            ],\n  4274\t        )\n  4275\t        self.assertEqual(operation.describe(), \"Raw SQL operation\")\n  4276\t        # Test the state alteration\n  4277\t        new_state = project_state.clone()\n  4278\t        operation.state_forwards(\"test_runsql\", new_state)\n  4279\t        self.assertEqual(\n  4280\t            len(new_state.models[\"test_runsql\", \"somethingelse\"].fields), 1\n  4281\t        )\n  4282\t        # Make sure there's no table\n  4283\t        self.assertTableNotExists(\"i_love_ponies\")\n  4284\t        # Test SQL collection\n  4285\t        with connection.schema_editor(collect_sql=True) as editor:\n  4286\t            operation.database_forwards(\"test_runsql\", editor, project_state, new_state)\n  4287\t            self.assertIn(\"LIKE '%%ponies';\", \"\\n\".join(editor.collected_sql))\n  4288\t            operation.database_backwards(\n  4289\t                \"test_runsql\", editor, project_state, new_state\n  4290\t            )\n  4291\t            self.assertIn(\"LIKE '%%Ponies%%';\", \"\\n\".join(editor.collected_sql))\n  4292\t        # Test the database alteration\n  4293\t        with connection.schema_editor() as editor:\n  4294\t            operation.database_forwards(\"test_runsql\", editor, project_state, new_state)\n  4295\t        self.assertTableExists(\"i_love_ponies\")\n  4296\t        # Make sure all the SQL was processed\n  4297\t        with connection.cursor() as cursor:\n  4298\t            cursor.execute(\"SELECT COUNT(*) FROM i_love_ponies\")\n  4299\t            self.assertEqual(cursor.fetchall()[0][0], 2)\n  4300\t            cursor.execute(\n  4301\t                \"SELECT COUNT(*) FROM i_love_ponies WHERE special_thing = 'Django'\"\n  4302\t            )\n  4303\t            self.assertEqual(cursor.fetchall()[0][0], 1)\n  4304\t            cursor.execute(\n  4305\t                \"SELECT COUNT(*) FROM i_love_ponies WHERE special_thing = 'Ponies'\"\n  4306\t            )\n  4307\t            self.assertEqual(cursor.fetchall()[0][0], 1)\n  4308\t        # And test reversal\n  4309\t        self.assertTrue(operation.reversible)\n  4310\t        with connection.schema_editor() as editor:\n  4311\t            operation.database_backwards(\n  4312\t                \"test_runsql\", editor, new_state, project_state\n  4313\t            )\n  4314\t        self.assertTableNotExists(\"i_love_ponies\")\n  4315\t        # And deconstruction\n  4316\t        definition = operation.deconstruct()\n  4317\t        self.assertEqual(definition[0], \"RunSQL\")\n  4318\t        self.assertEqual(definition[1], [])\n  4319\t        self.assertEqual(\n  4320\t            sorted(definition[2]), [\"reverse_sql\", \"sql\", \"state_operations\"]\n  4321\t        )\n  4322\t        # And elidable reduction\n  4323\t        self.assertIs(False, operation.reduce(operation, []))\n  4324\t        elidable_operation = migrations.RunSQL(\"SELECT 1 FROM void;\", elidable=True)\n  4325\t        self.assertEqual(elidable_operation.reduce(operation, []), [operation])\n  4326\t\n  4327\t    def test_run_sql_params(self):\n  4328\t        \"\"\"\n  4329\t        #23426 - RunSQL should accept parameters.\n  4330\t        \"\"\"\n  4331\t        project_state = self.set_up_test_model(\"test_runsql\")\n  4332\t        # Create the operation\n  4333\t        operation = migrations.RunSQL(\n  4334\t            [\"CREATE TABLE i_love_ponies (id int, special_thing varchar(15));\"],\n  4335\t            [\"DROP TABLE i_love_ponies\"],\n  4336\t        )\n  4337\t        param_operation = migrations.RunSQL(\n  4338\t            # forwards\n  4339\t            (\n  4340\t                \"INSERT INTO i_love_ponies (id, special_thing) VALUES (1, 'Django');\",\n  4341\t                [\n  4342\t                    \"INSERT INTO i_love_ponies (id, special_thing) VALUES (2, %s);\",\n  4343\t                    [\"Ponies\"],\n  4344\t                ],\n  4345\t                (\n  4346\t                    \"INSERT INTO i_love_ponies (id, special_thing) VALUES (%s, %s);\",\n  4347\t                    (\n  4348\t                        3,\n  4349\t                        \"Python\",\n  4350\t                    ),\n  4351\t                ),\n  4352\t            ),\n  4353\t            # backwards\n  4354\t            [\n  4355\t                \"DELETE FROM i_love_ponies WHERE special_thing = 'Django';\",\n  4356\t                [\"DELETE FROM i_love_ponies WHERE special_thing = 'Ponies';\", None],\n  4357\t                (\n  4358\t                    \"DELETE FROM i_love_ponies WHERE id = %s OR special_thing = %s;\",\n  4359\t                    [3, \"Python\"],\n  4360\t                ),\n  4361\t            ],\n  4362\t        )\n  4363\t\n  4364\t        # Make sure there's no table\n  4365\t        self.assertTableNotExists(\"i_love_ponies\")\n  4366\t        new_state = project_state.clone()\n  4367\t        # Test the database alteration\n  4368\t        with connection.schema_editor() as editor:\n  4369\t            operation.database_forwards(\"test_runsql\", editor, project_state, new_state)\n  4370\t\n  4371\t        # Test parameter passing\n  4372\t        with connection.schema_editor() as editor:\n  4373\t            param_operation.database_forwards(\n  4374\t                \"test_runsql\", editor, project_state, new_state\n  4375\t            )\n  4376\t        # Make sure all the SQL was processed\n  4377\t        with connection.cursor() as cursor:\n  4378\t            cursor.execute(\"SELECT COUNT(*) FROM i_love_ponies\")\n  4379\t            self.assertEqual(cursor.fetchall()[0][0], 3)\n  4380\t\n  4381\t        with connection.schema_editor() as editor:\n  4382\t            param_operation.database_backwards(\n  4383\t                \"test_runsql\", editor, new_state, project_state\n  4384\t            )\n  4385\t        with connection.cursor() as cursor:\n  4386\t            cursor.execute(\"SELECT COUNT(*) FROM i_love_ponies\")\n  4387\t            self.assertEqual(cursor.fetchall()[0][0], 0)\n  4388\t\n  4389\t        # And test reversal\n  4390\t        with connection.schema_editor() as editor:\n  4391\t            operation.database_backwards(\n  4392\t                \"test_runsql\", editor, new_state, project_state\n  4393\t            )\n  4394\t        self.assertTableNotExists(\"i_love_ponies\")\n  4395\t\n  4396\t    def test_run_sql_params_invalid(self):\n  4397\t        \"\"\"\n  4398\t        #23426 - RunSQL should fail when a list of statements with an incorrect\n  4399\t        number of tuples is given.\n  4400\t        \"\"\"\n  4401\t        project_state = self.set_up_test_model(\"test_runsql\")\n  4402\t        new_state = project_state.clone()\n  4403\t        operation = migrations.RunSQL(\n  4404\t            # forwards\n  4405\t            [[\"INSERT INTO foo (bar) VALUES ('buz');\"]],\n  4406\t            # backwards\n  4407\t            ((\"DELETE FROM foo WHERE bar = 'buz';\", \"invalid\", \"parameter count\"),),\n  4408\t        )\n  4409\t\n  4410\t        with connection.schema_editor() as editor:\n  4411\t            with self.assertRaisesMessage(ValueError, \"Expected a 2-tuple but got 1\"):\n  4412\t                operation.database_forwards(\n  4413\t                    \"test_runsql\", editor, project_state, new_state\n  4414\t                )\n  4415\t\n  4416\t        with connection.schema_editor() as editor:\n  4417\t            with self.assertRaisesMessage(ValueError, \"Expected a 2-tuple but got 3\"):\n  4418\t                operation.database_backwards(\n  4419\t                    \"test_runsql\", editor, new_state, project_state\n  4420\t                )\n  4421\t\n  4422\t    def test_run_sql_noop(self):\n  4423\t        \"\"\"\n  4424\t        #24098 - Tests no-op RunSQL operations.\n  4425\t        \"\"\"\n  4426\t        operation = migrations.RunSQL(migrations.RunSQL.noop, migrations.RunSQL.noop)\n  4427\t        with connection.schema_editor() as editor:\n  4428\t            operation.database_forwards(\"test_runsql\", editor, None, None)\n  4429\t            operation.database_backwards(\"test_runsql\", editor, None, None)\n  4430\t\n  4431\t    def test_run_sql_add_missing_semicolon_on_collect_sql(self):\n  4432\t        project_state = self.set_up_test_model(\"test_runsql\")\n  4433\t        new_state = project_state.clone()\n  4434\t        tests = [\n  4435\t            \"INSERT INTO test_runsql_pony (pink, weight) VALUES (1, 1);\\n\",\n  4436\t            \"INSERT INTO test_runsql_pony (pink, weight) VALUES (1, 1)\\n\",\n  4437\t        ]\n  4438\t        for sql in tests:\n  4439\t            with self.subTest(sql=sql):\n  4440\t                operation = migrations.RunSQL(sql, migrations.RunPython.noop)\n  4441\t                with connection.schema_editor(collect_sql=True) as editor:\n  4442\t                    operation.database_forwards(\n  4443\t                        \"test_runsql\", editor, project_state, new_state\n  4444\t                    )\n  4445\t                    collected_sql = \"\\n\".join(editor.collected_sql)\n  4446\t                    self.assertEqual(collected_sql.count(\";\"), 1)\n  4447\t\n  4448\t    def test_run_python(self):\n  4449\t        \"\"\"\n  4450\t        Tests the RunPython operation\n  4451\t        \"\"\"\n  4452\t\n  4453\t        project_state = self.set_up_test_model(\"test_runpython\", mti_model=True)\n  4454\t\n  4455\t        # Create the operation\n  4456\t        def inner_method(models, schema_editor):\n  4457\t            Pony = models.get_model(\"test_runpython\", \"Pony\")\n  4458\t            Pony.objects.create(pink=1, weight=3.55)\n  4459\t            Pony.objects.create(weight=5)\n  4460\t\n  4461\t        def inner_method_reverse(models, schema_editor):\n  4462\t            Pony = models.get_model(\"test_runpython\", \"Pony\")\n  4463\t            Pony.objects.filter(pink=1, weight=3.55).delete()\n  4464\t            Pony.objects.filter(weight=5).delete()\n  4465\t\n  4466\t        operation = migrations.RunPython(\n  4467\t            inner_method, reverse_code=inner_method_reverse\n  4468\t        )\n  4469\t        self.assertEqual(operation.describe(), \"Raw Python operation\")\n  4470\t        # Test the state alteration does nothing\n  4471\t        new_state = project_state.clone()\n  4472\t        operation.state_forwards(\"test_runpython\", new_state)\n  4473\t        self.assertEqual(new_state, project_state)\n  4474\t        # Test the database alteration\n  4475\t        self.assertEqual(\n  4476\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 0\n  4477\t        )\n  4478\t        with connection.schema_editor() as editor:\n  4479\t            operation.database_forwards(\n  4480\t                \"test_runpython\", editor, project_state, new_state\n  4481\t            )\n  4482\t        self.assertEqual(\n  4483\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 2\n  4484\t        )\n  4485\t        # Now test reversal\n  4486\t        self.assertTrue(operation.reversible)\n  4487\t        with connection.schema_editor() as editor:\n  4488\t            operation.database_backwards(\n  4489\t                \"test_runpython\", editor, project_state, new_state\n  4490\t            )\n  4491\t        self.assertEqual(\n  4492\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 0\n  4493\t        )\n  4494\t        # Now test we can't use a string\n  4495\t        with self.assertRaisesMessage(\n  4496\t            ValueError, \"RunPython must be supplied with a callable\"\n  4497\t        ):\n  4498\t            migrations.RunPython(\"print 'ahahaha'\")\n  4499\t        # And deconstruction\n  4500\t        definition = operation.deconstruct()\n  4501\t        self.assertEqual(definition[0], \"RunPython\")\n  4502\t        self.assertEqual(definition[1], [])\n  4503\t        self.assertEqual(sorted(definition[2]), [\"code\", \"reverse_code\"])\n  4504\t\n  4505\t        # Also test reversal fails, with an operation identical to above but\n  4506\t        # without reverse_code set.\n  4507\t        no_reverse_operation = migrations.RunPython(inner_method)\n  4508\t        self.assertFalse(no_reverse_operation.reversible)\n  4509\t        with connection.schema_editor() as editor:\n  4510\t            no_reverse_operation.database_forwards(\n  4511\t                \"test_runpython\", editor, project_state, new_state\n  4512\t            )\n  4513\t            with self.assertRaises(NotImplementedError):\n  4514\t                no_reverse_operation.database_backwards(\n  4515\t                    \"test_runpython\", editor, new_state, project_state\n  4516\t                )\n  4517\t        self.assertEqual(\n  4518\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 2\n  4519\t        )\n  4520\t\n  4521\t        def create_ponies(models, schema_editor):\n  4522\t            Pony = models.get_model(\"test_runpython\", \"Pony\")\n  4523\t            pony1 = Pony.objects.create(pink=1, weight=3.55)\n  4524\t            self.assertIsNot(pony1.pk, None)\n  4525\t            pony2 = Pony.objects.create(weight=5)\n  4526\t            self.assertIsNot(pony2.pk, None)\n  4527\t            self.assertNotEqual(pony1.pk, pony2.pk)\n  4528\t\n  4529\t        operation = migrations.RunPython(create_ponies)\n  4530\t        with connection.schema_editor() as editor:\n  4531\t            operation.database_forwards(\n  4532\t                \"test_runpython\", editor, project_state, new_state\n  4533\t            )\n  4534\t        self.assertEqual(\n  4535\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 4\n  4536\t        )\n  4537\t        # And deconstruction\n  4538\t        definition = operation.deconstruct()\n  4539\t        self.assertEqual(definition[0], \"RunPython\")\n  4540\t        self.assertEqual(definition[1], [])\n  4541\t        self.assertEqual(sorted(definition[2]), [\"code\"])\n  4542\t\n  4543\t        def create_shetlandponies(models, schema_editor):\n  4544\t            ShetlandPony = models.get_model(\"test_runpython\", \"ShetlandPony\")\n  4545\t            pony1 = ShetlandPony.objects.create(weight=4.0)\n  4546\t            self.assertIsNot(pony1.pk, None)\n  4547\t            pony2 = ShetlandPony.objects.create(weight=5.0)\n  4548\t            self.assertIsNot(pony2.pk, None)\n  4549\t            self.assertNotEqual(pony1.pk, pony2.pk)\n  4550\t\n  4551\t        operation = migrations.RunPython(create_shetlandponies)\n  4552\t        with connection.schema_editor() as editor:\n  4553\t            operation.database_forwards(\n  4554\t                \"test_runpython\", editor, project_state, new_state\n  4555\t            )\n  4556\t        self.assertEqual(\n  4557\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 6\n  4558\t        )\n  4559\t        self.assertEqual(\n  4560\t            project_state.apps.get_model(\n  4561\t                \"test_runpython\", \"ShetlandPony\"\n  4562\t            ).objects.count(),\n  4563\t            2,\n  4564\t        )\n  4565\t        # And elidable reduction\n  4566\t        self.assertIs(False, operation.reduce(operation, []))\n  4567\t        elidable_operation = migrations.RunPython(inner_method, elidable=True)\n  4568\t        self.assertEqual(elidable_operation.reduce(operation, []), [operation])\n  4569\t\n  4570\t    def test_run_python_atomic(self):\n  4571\t        \"\"\"\n  4572\t        Tests the RunPython operation correctly handles the \"atomic\" keyword\n  4573\t        \"\"\"\n  4574\t        project_state = self.set_up_test_model(\"test_runpythonatomic\", mti_model=True)\n  4575\t\n  4576\t        def inner_method(models, schema_editor):\n  4577\t            Pony = models.get_model(\"test_runpythonatomic\", \"Pony\")\n  4578\t            Pony.objects.create(pink=1, weight=3.55)\n  4579\t            raise ValueError(\"Adrian hates ponies.\")\n  4580\t\n  4581\t        # Verify atomicity when applying.\n  4582\t        atomic_migration = Migration(\"test\", \"test_runpythonatomic\")\n  4583\t        atomic_migration.operations = [\n  4584\t            migrations.RunPython(inner_method, reverse_code=inner_method)\n  4585\t        ]\n  4586\t        non_atomic_migration = Migration(\"test\", \"test_runpythonatomic\")\n  4587\t        non_atomic_migration.operations = [\n  4588\t            migrations.RunPython(inner_method, reverse_code=inner_method, atomic=False)\n  4589\t        ]\n  4590\t        # If we're a fully-transactional database, both versions should rollback\n  4591\t        if connection.features.can_rollback_ddl:\n  4592\t            self.assertEqual(\n  4593\t                project_state.apps.get_model(\n  4594\t                    \"test_runpythonatomic\", \"Pony\"\n  4595\t                ).objects.count(),\n  4596\t                0,\n  4597\t            )\n  4598\t            with self.assertRaises(ValueError):\n  4599\t                with connection.schema_editor() as editor:\n  4600\t                    atomic_migration.apply(project_state, editor)\n  4601\t            self.assertEqual(\n  4602\t                project_state.apps.get_model(\n  4603\t                    \"test_runpythonatomic\", \"Pony\"\n  4604\t                ).objects.count(),\n  4605\t                0,\n  4606\t            )\n  4607\t            with self.assertRaises(ValueError):\n  4608\t                with connection.schema_editor() as editor:\n  4609\t                    non_atomic_migration.apply(project_state, editor)\n  4610\t            self.assertEqual(\n  4611\t                project_state.apps.get_model(\n  4612\t                    \"test_runpythonatomic\", \"Pony\"\n  4613\t                ).objects.count(),\n  4614\t                0,\n  4615\t            )\n  4616\t        # Otherwise, the non-atomic operation should leave a row there\n  4617\t        else:\n  4618\t            self.assertEqual(\n  4619\t                project_state.apps.get_model(\n  4620\t                    \"test_runpythonatomic\", \"Pony\"\n  4621\t                ).objects.count(),\n  4622\t                0,\n  4623\t            )\n  4624\t            with self.assertRaises(ValueError):\n  4625\t                with connection.schema_editor() as editor:\n  4626\t                    atomic_migration.apply(project_state, editor)\n  4627\t            self.assertEqual(\n  4628\t                project_state.apps.get_model(\n  4629\t                    \"test_runpythonatomic\", \"Pony\"\n  4630\t                ).objects.count(),\n  4631\t                0,\n  4632\t            )\n  4633\t            with self.assertRaises(ValueError):\n  4634\t                with connection.schema_editor() as editor:\n  4635\t                    non_atomic_migration.apply(project_state, editor)\n  4636\t            self.assertEqual(\n  4637\t                project_state.apps.get_model(\n  4638\t                    \"test_runpythonatomic\", \"Pony\"\n  4639\t                ).objects.count(),\n  4640\t                1,\n  4641\t            )\n  4642\t        # Reset object count to zero and verify atomicity when unapplying.\n  4643\t        project_state.apps.get_model(\n  4644\t            \"test_runpythonatomic\", \"Pony\"\n  4645\t        ).objects.all().delete()\n  4646\t        # On a fully-transactional database, both versions rollback.\n  4647\t        if connection.features.can_rollback_ddl:\n  4648\t            self.assertEqual(\n  4649\t                project_state.apps.get_model(\n  4650\t                    \"test_runpythonatomic\", \"Pony\"\n  4651\t                ).objects.count(),\n  4652\t                0,\n  4653\t            )\n  4654\t            with self.assertRaises(ValueError):\n  4655\t                with connection.schema_editor() as editor:\n  4656\t                    atomic_migration.unapply(project_state, editor)\n  4657\t            self.assertEqual(\n  4658\t                project_state.apps.get_model(\n  4659\t                    \"test_runpythonatomic\", \"Pony\"\n  4660\t                ).objects.count(),\n  4661\t                0,\n  4662\t            )\n  4663\t            with self.assertRaises(ValueError):\n  4664\t                with connection.schema_editor() as editor:\n  4665\t                    non_atomic_migration.unapply(project_state, editor)\n  4666\t            self.assertEqual(\n  4667\t                project_state.apps.get_model(\n  4668\t                    \"test_runpythonatomic\", \"Pony\"\n  4669\t                ).objects.count(),\n  4670\t                0,\n  4671\t            )\n  4672\t        # Otherwise, the non-atomic operation leaves a row there.\n  4673\t        else:\n  4674\t            self.assertEqual(\n  4675\t                project_state.apps.get_model(\n  4676\t                    \"test_runpythonatomic\", \"Pony\"\n  4677\t                ).objects.count(),\n  4678\t                0,\n  4679\t            )\n  4680\t            with self.assertRaises(ValueError):\n  4681\t                with connection.schema_editor() as editor:\n  4682\t                    atomic_migration.unapply(project_state, editor)\n  4683\t            self.assertEqual(\n  4684\t                project_state.apps.get_model(\n  4685\t                    \"test_runpythonatomic\", \"Pony\"\n  4686\t                ).objects.count(),\n  4687\t                0,\n  4688\t            )\n  4689\t            with self.assertRaises(ValueError):\n  4690\t                with connection.schema_editor() as editor:\n  4691\t                    non_atomic_migration.unapply(project_state, editor)\n  4692\t            self.assertEqual(\n  4693\t                project_state.apps.get_model(\n  4694\t                    \"test_runpythonatomic\", \"Pony\"\n  4695\t                ).objects.count(),\n  4696\t                1,\n  4697\t            )\n  4698\t        # Verify deconstruction.\n  4699\t        definition = non_atomic_migration.operations[0].deconstruct()\n  4700\t        self.assertEqual(definition[0], \"RunPython\")\n  4701\t        self.assertEqual(definition[1], [])\n  4702\t        self.assertEqual(sorted(definition[2]), [\"atomic\", \"code\", \"reverse_code\"])\n  4703\t\n  4704\t    def test_run_python_related_assignment(self):\n  4705\t        \"\"\"\n  4706\t        #24282 - Model changes to a FK reverse side update the model\n  4707\t        on the FK side as well.\n  4708\t        \"\"\"\n  4709\t\n  4710\t        def inner_method(models, schema_editor):\n  4711\t            Author = models.get_model(\"test_authors\", \"Author\")\n  4712\t            Book = models.get_model(\"test_books\", \"Book\")\n  4713\t            author = Author.objects.create(name=\"Hemingway\")\n  4714\t            Book.objects.create(title=\"Old Man and The Sea\", author=author)\n  4715\t\n  4716\t        create_author = migrations.CreateModel(\n  4717\t            \"Author\",\n  4718\t            [\n  4719\t                (\"id\", models.AutoField(primary_key=True)),\n  4720\t                (\"name\", models.CharField(max_length=100)),\n  4721\t            ],\n  4722\t            options={},\n  4723\t        )\n  4724\t        create_book = migrations.CreateModel(\n  4725\t            \"Book\",\n  4726\t            [\n  4727\t                (\"id\", models.AutoField(primary_key=True)),\n  4728\t                (\"title\", models.CharField(max_length=100)),\n  4729\t                (\"author\", models.ForeignKey(\"test_authors.Author\", models.CASCADE)),\n  4730\t            ],\n  4731\t            options={},\n  4732\t        )\n  4733\t        add_hometown = migrations.AddField(\n  4734\t            \"Author\",\n  4735\t            \"hometown\",\n  4736\t            models.CharField(max_length=100),\n  4737\t        )\n  4738\t        create_old_man = migrations.RunPython(inner_method, inner_method)\n  4739\t\n  4740\t        project_state = ProjectState()\n  4741\t        new_state = project_state.clone()\n  4742\t        with connection.schema_editor() as editor:\n  4743\t            create_author.state_forwards(\"test_authors\", new_state)\n  4744\t            create_author.database_forwards(\n  4745\t                \"test_authors\", editor, project_state, new_state\n  4746\t            )\n  4747\t        project_state = new_state\n  4748\t        new_state = new_state.clone()\n  4749\t        with connection.schema_editor() as editor:\n  4750\t            create_book.state_forwards(\"test_books\", new_state)\n  4751\t            create_book.database_forwards(\n  4752\t                \"test_books\", editor, project_state, new_state\n  4753\t            )\n  4754\t        project_state = new_state\n  4755\t        new_state = new_state.clone()\n  4756\t        with connection.schema_editor() as editor:\n  4757\t            add_hometown.state_forwards(\"test_authors\", new_state)\n  4758\t            add_hometown.database_forwards(\n  4759\t                \"test_authors\", editor, project_state, new_state\n  4760\t            )\n  4761\t        project_state = new_state\n  4762\t        new_state = new_state.clone()\n  4763\t        with connection.schema_editor() as editor:\n  4764\t            create_old_man.state_forwards(\"test_books\", new_state)\n  4765\t            create_old_man.database_forwards(\n  4766\t                \"test_books\", editor, project_state, new_state\n  4767\t            )\n  4768\t\n  4769\t    def test_model_with_bigautofield(self):\n  4770\t        \"\"\"\n  4771\t        A model with BigAutoField can be created.\n  4772\t        \"\"\"\n  4773\t\n  4774\t        def create_data(models, schema_editor):\n  4775\t            Author = models.get_model(\"test_author\", \"Author\")\n  4776\t            Book = models.get_model(\"test_book\", \"Book\")\n  4777\t            author1 = Author.objects.create(name=\"Hemingway\")\n  4778\t            Book.objects.create(title=\"Old Man and The Sea\", author=author1)\n  4779\t            Book.objects.create(id=2**33, title=\"A farewell to arms\", author=author1)\n  4780\t\n  4781\t            author2 = Author.objects.create(id=2**33, name=\"Remarque\")\n  4782\t            Book.objects.create(title=\"All quiet on the western front\", author=author2)\n  4783\t            Book.objects.create(title=\"Arc de Triomphe\", author=author2)\n  4784\t\n  4785\t        create_author = migrations.CreateModel(\n  4786\t            \"Author\",\n  4787\t            [\n  4788\t                (\"id\", models.BigAutoField(primary_key=True)),\n  4789\t                (\"name\", models.CharField(max_length=100)),\n  4790\t            ],\n  4791\t            options={},\n  4792\t        )\n  4793\t        create_book = migrations.CreateModel(\n  4794\t            \"Book\",\n  4795\t            [\n  4796\t                (\"id\", models.BigAutoField(primary_key=True)),\n  4797\t                (\"title\", models.CharField(max_length=100)),\n  4798\t                (\n  4799\t                    \"author\",\n  4800\t                    models.ForeignKey(\n  4801\t                        to=\"test_author.Author\", on_delete=models.CASCADE\n  4802\t                    ),\n  4803\t                ),\n  4804\t            ],\n  4805\t            options={},\n  4806\t        )\n  4807\t        fill_data = migrations.RunPython(create_data)\n  4808\t\n  4809\t        project_state = ProjectState()\n  4810\t        new_state = project_state.clone()\n  4811\t        with connection.schema_editor() as editor:\n  4812\t            create_author.state_forwards(\"test_author\", new_state)\n  4813\t            create_author.database_forwards(\n  4814\t                \"test_author\", editor, project_state, new_state\n  4815\t            )\n  4816\t\n  4817\t        project_state = new_state\n  4818\t        new_state = new_state.clone()\n  4819\t        with connection.schema_editor() as editor:\n  4820\t            create_book.state_forwards(\"test_book\", new_state)\n  4821\t            create_book.database_forwards(\"test_book\", editor, project_state, new_state)\n  4822\t\n  4823\t        project_state = new_state\n  4824\t        new_state = new_state.clone()\n  4825\t        with connection.schema_editor() as editor:\n  4826\t            fill_data.state_forwards(\"fill_data\", new_state)\n  4827\t            fill_data.database_forwards(\"fill_data\", editor, project_state, new_state)\n  4828\t\n  4829\t    def _test_autofield_foreignfield_growth(\n  4830\t        self, source_field, target_field, target_value\n  4831\t    ):\n  4832\t        \"\"\"\n  4833\t        A field may be migrated in the following ways:\n  4834\t\n  4835\t        - AutoField to BigAutoField\n  4836\t        - SmallAutoField to AutoField\n  4837\t        - SmallAutoField to BigAutoField\n  4838\t        \"\"\"\n  4839\t\n  4840\t        def create_initial_data(models, schema_editor):\n  4841\t            Article = models.get_model(\"test_article\", \"Article\")\n  4842\t            Blog = models.get_model(\"test_blog\", \"Blog\")\n  4843\t            blog = Blog.objects.create(name=\"web development done right\")\n  4844\t            Article.objects.create(name=\"Frameworks\", blog=blog)\n  4845\t            Article.objects.create(name=\"Programming Languages\", blog=blog)\n  4846\t\n  4847\t        def create_big_data(models, schema_editor):\n  4848\t            Article = models.get_model(\"test_article\", \"Article\")\n  4849\t            Blog = models.get_model(\"test_blog\", \"Blog\")\n  4850\t            blog2 = Blog.objects.create(name=\"Frameworks\", id=target_value)\n  4851\t            Article.objects.create(name=\"Django\", blog=blog2)\n  4852\t            Article.objects.create(id=target_value, name=\"Django2\", blog=blog2)\n  4853\t\n  4854\t        create_blog = migrations.CreateModel(\n  4855\t            \"Blog\",\n  4856\t            [\n  4857\t                (\"id\", source_field(primary_key=True)),\n  4858\t                (\"name\", models.CharField(max_length=100)),\n  4859\t            ],\n  4860\t            options={},\n  4861\t        )\n  4862\t        create_article = migrations.CreateModel(\n  4863\t            \"Article\",\n  4864\t            [\n  4865\t                (\"id\", source_field(primary_key=True)),\n  4866\t                (\n  4867\t                    \"blog\",\n  4868\t                    models.ForeignKey(to=\"test_blog.Blog\", on_delete=models.CASCADE),\n  4869\t                ),\n  4870\t                (\"name\", models.CharField(max_length=100)),\n  4871\t                (\"data\", models.TextField(default=\"\")),\n  4872\t            ],\n  4873\t            options={},\n  4874\t        )\n  4875\t        fill_initial_data = migrations.RunPython(\n  4876\t            create_initial_data, create_initial_data\n  4877\t        )\n  4878\t        fill_big_data = migrations.RunPython(create_big_data, create_big_data)\n  4879\t\n  4880\t        grow_article_id = migrations.AlterField(\n  4881\t            \"Article\", \"id\", target_field(primary_key=True)\n  4882\t        )\n  4883\t        grow_blog_id = migrations.AlterField(\n  4884\t            \"Blog\", \"id\", target_field(primary_key=True)\n  4885\t        )\n  4886\t\n  4887\t        project_state = ProjectState()\n  4888\t        new_state = project_state.clone()\n  4889\t        with connection.schema_editor() as editor:\n  4890\t            create_blog.state_forwards(\"test_blog\", new_state)\n  4891\t            create_blog.database_forwards(\"test_blog\", editor, project_state, new_state)\n  4892\t\n  4893\t        project_state = new_state\n  4894\t        new_state = new_state.clone()\n  4895\t        with connection.schema_editor() as editor:\n  4896\t            create_article.state_forwards(\"test_article\", new_state)\n  4897\t            create_article.database_forwards(\n  4898\t                \"test_article\", editor, project_state, new_state\n  4899\t            )\n  4900\t\n  4901\t        project_state = new_state\n  4902\t        new_state = new_state.clone()\n  4903\t        with connection.schema_editor() as editor:\n  4904\t            fill_initial_data.state_forwards(\"fill_initial_data\", new_state)\n  4905\t            fill_initial_data.database_forwards(\n  4906\t                \"fill_initial_data\", editor, project_state, new_state\n  4907\t            )\n  4908\t\n  4909\t        project_state = new_state\n  4910\t        new_state = new_state.clone()\n  4911\t        with connection.schema_editor() as editor:\n  4912\t            grow_article_id.state_forwards(\"test_article\", new_state)\n  4913\t            grow_article_id.database_forwards(\n  4914\t                \"test_article\", editor, project_state, new_state\n  4915\t            )\n  4916\t\n  4917\t        state = new_state.clone()\n  4918\t        article = state.apps.get_model(\"test_article.Article\")\n  4919\t        self.assertIsInstance(article._meta.pk, target_field)\n  4920\t\n  4921\t        project_state = new_state\n  4922\t        new_state = new_state.clone()\n  4923\t        with connection.schema_editor() as editor:\n  4924\t            grow_blog_id.state_forwards(\"test_blog\", new_state)\n  4925\t            grow_blog_id.database_forwards(\n  4926\t                \"test_blog\", editor, project_state, new_state\n  4927\t            )\n  4928\t\n  4929\t        state = new_state.clone()\n  4930\t        blog = state.apps.get_model(\"test_blog.Blog\")\n  4931\t        self.assertIsInstance(blog._meta.pk, target_field)\n  4932\t\n  4933\t        project_state = new_state\n  4934\t        new_state = new_state.clone()\n  4935\t        with connection.schema_editor() as editor:\n  4936\t            fill_big_data.state_forwards(\"fill_big_data\", new_state)\n  4937\t            fill_big_data.database_forwards(\n  4938\t                \"fill_big_data\", editor, project_state, new_state\n  4939\t            )\n  4940\t\n  4941\t    def test_autofield__bigautofield_foreignfield_growth(self):\n  4942\t        \"\"\"A field may be migrated from AutoField to BigAutoField.\"\"\"\n  4943\t        self._test_autofield_foreignfield_growth(\n  4944\t            models.AutoField,\n  4945\t            models.BigAutoField,\n  4946\t            2**33,\n  4947\t        )\n  4948\t\n  4949\t    def test_smallfield_autofield_foreignfield_growth(self):\n  4950\t        \"\"\"A field may be migrated from SmallAutoField to AutoField.\"\"\"\n  4951\t        self._test_autofield_foreignfield_growth(\n  4952\t            models.SmallAutoField,\n  4953\t            models.AutoField,\n  4954\t            2**22,\n  4955\t        )\n  4956\t\n  4957\t    def test_smallfield_bigautofield_foreignfield_growth(self):\n  4958\t        \"\"\"A field may be migrated from SmallAutoField to BigAutoField.\"\"\"\n  4959\t        self._test_autofield_foreignfield_growth(\n  4960\t            models.SmallAutoField,\n  4961\t            models.BigAutoField,\n  4962\t            2**33,\n  4963\t        )\n  4964\t\n  4965\t    def test_run_python_noop(self):\n  4966\t        \"\"\"\n  4967\t        #24098 - Tests no-op RunPython operations.\n  4968\t        \"\"\"\n  4969\t        project_state = ProjectState()\n  4970\t        new_state = project_state.clone()\n  4971\t        operation = migrations.RunPython(\n  4972\t            migrations.RunPython.noop, migrations.RunPython.noop\n  4973\t        )\n  4974\t        with connection.schema_editor() as editor:\n  4975\t            operation.database_forwards(\n  4976\t                \"test_runpython\", editor, project_state, new_state\n  4977\t            )\n  4978\t            operation.database_backwards(\n  4979\t                \"test_runpython\", editor, new_state, project_state\n  4980\t            )\n  4981\t\n  4982\t    def test_separate_database_and_state(self):\n  4983\t        \"\"\"\n  4984\t        Tests the SeparateDatabaseAndState operation.\n  4985\t        \"\"\"\n  4986\t        project_state = self.set_up_test_model(\"test_separatedatabaseandstate\")\n  4987\t        # Create the operation\n  4988\t        database_operation = migrations.RunSQL(\n  4989\t            \"CREATE TABLE i_love_ponies (id int, special_thing int);\",\n  4990\t            \"DROP TABLE i_love_ponies;\",\n  4991\t        )\n  4992\t        state_operation = migrations.CreateModel(\n  4993\t            \"SomethingElse\", [(\"id\", models.AutoField(primary_key=True))]\n  4994\t        )\n  4995\t        operation = migrations.SeparateDatabaseAndState(\n  4996\t            state_operations=[state_operation], database_operations=[database_operation]\n  4997\t        )\n  4998\t        self.assertEqual(\n  4999\t            operation.describe(), \"Custom state/database change combination\"\n  5000\t        )\n  5001\t        # Test the state alteration\n  5002\t        new_state = project_state.clone()\n  5003\t        operation.state_forwards(\"test_separatedatabaseandstate\", new_state)\n  5004\t        self.assertEqual(\n  5005\t            len(\n  5006\t                new_state.models[\n  5007\t                    \"test_separatedatabaseandstate\", \"somethingelse\"\n  5008\t                ].fields\n  5009\t            ),\n  5010\t            1,\n  5011\t        )\n  5012\t        # Make sure there's no table\n  5013\t        self.assertTableNotExists(\"i_love_ponies\")\n  5014\t        # Test the database alteration\n  5015\t        with connection.schema_editor() as editor:\n  5016\t            operation.database_forwards(\n  5017\t                \"test_separatedatabaseandstate\", editor, project_state, new_state\n  5018\t            )\n  5019\t        self.assertTableExists(\"i_love_ponies\")\n  5020\t        # And test reversal\n  5021\t        self.assertTrue(operation.reversible)\n  5022\t        with connection.schema_editor() as editor:\n  5023\t            operation.database_backwards(\n  5024\t                \"test_separatedatabaseandstate\", editor, new_state, project_state\n  5025\t            )\n  5026\t        self.assertTableNotExists(\"i_love_ponies\")\n  5027\t        # And deconstruction\n  5028\t        definition = operation.deconstruct()\n  5029\t        self.assertEqual(definition[0], \"SeparateDatabaseAndState\")\n  5030\t        self.assertEqual(definition[1], [])\n  5031\t        self.assertEqual(\n  5032\t            sorted(definition[2]), [\"database_operations\", \"state_operations\"]\n  5033\t        )\n  5034\t\n  5035\t    def test_separate_database_and_state2(self):\n  5036\t        \"\"\"\n  5037\t        A complex SeparateDatabaseAndState operation: Multiple operations both\n  5038\t        for state and database. Verify the state dependencies within each list\n  5039\t        and that state ops don't affect the database.\n  5040\t        \"\"\"\n  5041\t        app_label = \"test_separatedatabaseandstate2\"\n  5042\t        project_state = self.set_up_test_model(app_label)\n  5043\t        # Create the operation\n  5044\t        database_operations = [\n  5045\t            migrations.CreateModel(\n  5046\t                \"ILovePonies\",\n  5047\t                [(\"id\", models.AutoField(primary_key=True))],\n  5048\t                options={\"db_table\": \"iloveponies\"},\n  5049\t            ),\n  5050\t            migrations.CreateModel(\n  5051\t                \"ILoveMorePonies\",\n  5052\t                # We use IntegerField and not AutoField because\n  5053\t                # the model is going to be deleted immediately\n  5054\t                # and with an AutoField this fails on Oracle\n  5055\t                [(\"id\", models.IntegerField(primary_key=True))],\n  5056\t                options={\"db_table\": \"ilovemoreponies\"},\n  5057\t            ),\n  5058\t            migrations.DeleteModel(\"ILoveMorePonies\"),\n  5059\t            migrations.CreateModel(\n  5060\t                \"ILoveEvenMorePonies\",\n  5061\t                [(\"id\", models.AutoField(primary_key=True))],\n  5062\t                options={\"db_table\": \"iloveevenmoreponies\"},\n  5063\t            ),\n  5064\t        ]\n  5065\t        state_operations = [\n  5066\t            migrations.CreateModel(\n  5067\t                \"SomethingElse\",\n  5068\t                [(\"id\", models.AutoField(primary_key=True))],\n  5069\t                options={\"db_table\": \"somethingelse\"},\n  5070\t            ),\n  5071\t            migrations.DeleteModel(\"SomethingElse\"),\n  5072\t            migrations.CreateModel(\n  5073\t                \"SomethingCompletelyDifferent\",\n  5074\t                [(\"id\", models.AutoField(primary_key=True))],\n  5075\t                options={\"db_table\": \"somethingcompletelydifferent\"},\n  5076\t            ),\n  5077\t        ]\n  5078\t        operation = migrations.SeparateDatabaseAndState(\n  5079\t            state_operations=state_operations,\n  5080\t            database_operations=database_operations,\n  5081\t        )\n  5082\t        # Test the state alteration\n  5083\t        new_state = project_state.clone()\n  5084\t        operation.state_forwards(app_label, new_state)\n  5085\t\n  5086\t        def assertModelsAndTables(after_db):\n  5087\t            # Tables and models exist, or don't, as they should:\n  5088\t            self.assertNotIn((app_label, \"somethingelse\"), new_state.models)\n  5089\t            self.assertEqual(\n  5090\t                len(new_state.models[app_label, \"somethingcompletelydifferent\"].fields),\n  5091\t                1,\n  5092\t            )\n  5093\t            self.assertNotIn((app_label, \"iloveponiesonies\"), new_state.models)\n  5094\t            self.assertNotIn((app_label, \"ilovemoreponies\"), new_state.models)\n  5095\t            self.assertNotIn((app_label, \"iloveevenmoreponies\"), new_state.models)\n  5096\t            self.assertTableNotExists(\"somethingelse\")\n  5097\t            self.assertTableNotExists(\"somethingcompletelydifferent\")\n  5098\t            self.assertTableNotExists(\"ilovemoreponies\")\n  5099\t            if after_db:\n  5100\t                self.assertTableExists(\"iloveponies\")\n  5101\t                self.assertTableExists(\"iloveevenmoreponies\")\n  5102\t            else:\n  5103\t                self.assertTableNotExists(\"iloveponies\")\n  5104\t                self.assertTableNotExists(\"iloveevenmoreponies\")\n  5105\t\n  5106\t        assertModelsAndTables(after_db=False)\n  5107\t        # Test the database alteration\n  5108\t        with connection.schema_editor() as editor:\n  5109\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  5110\t        assertModelsAndTables(after_db=True)\n  5111\t        # And test reversal\n  5112\t        self.assertTrue(operation.reversible)\n  5113\t        with connection.schema_editor() as editor:\n  5114\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  5115\t        assertModelsAndTables(after_db=False)\n  5116\t\n  5117\t\n  5118\tclass SwappableOperationTests(OperationTestBase):\n  5119\t    \"\"\"\n  5120\t    Key operations ignore swappable models\n  5121\t    (we don't want to replicate all of them here, as the functionality\n  5122\t    is in a common base class anyway)\n  5123\t    \"\"\"\n  5124\t\n  5125\t    available_apps = [\"migrations\"]\n  5126\t\n  5127\t    @override_settings(TEST_SWAP_MODEL=\"migrations.SomeFakeModel\")\n  5128\t    def test_create_ignore_swapped(self):\n  5129\t        \"\"\"\n  5130\t        The CreateTable operation ignores swapped models.\n  5131\t        \"\"\"\n  5132\t        operation = migrations.CreateModel(\n  5133\t            \"Pony\",\n  5134\t            [\n  5135\t                (\"id\", models.AutoField(primary_key=True)),\n  5136\t                (\"pink\", models.IntegerField(default=1)),\n  5137\t            ],\n  5138\t            options={\n  5139\t                \"swappable\": \"TEST_SWAP_MODEL\",\n  5140\t            },\n  5141\t        )\n  5142\t        # Test the state alteration (it should still be there!)\n  5143\t        project_state = ProjectState()\n  5144\t        new_state = project_state.clone()\n  5145\t        operation.state_forwards(\"test_crigsw\", new_state)\n  5146\t        self.assertEqual(new_state.models[\"test_crigsw\", \"pony\"].name, \"Pony\")\n  5147\t        self.assertEqual(len(new_state.models[\"test_crigsw\", \"pony\"].fields), 2)\n  5148\t        # Test the database alteration\n  5149\t        self.assertTableNotExists(\"test_crigsw_pony\")\n  5150\t        with connection.schema_editor() as editor:\n  5151\t            operation.database_forwards(\"test_crigsw\", editor, project_state, new_state)\n  5152\t        self.assertTableNotExists(\"test_crigsw_pony\")\n  5153\t        # And test reversal\n  5154\t        with connection.schema_editor() as editor:\n  5155\t            operation.database_backwards(\n  5156\t                \"test_crigsw\", editor, new_state, project_state\n  5157\t            )\n  5158\t        self.assertTableNotExists(\"test_crigsw_pony\")\n  5159\t\n  5160\t    @override_settings(TEST_SWAP_MODEL=\"migrations.SomeFakeModel\")\n  5161\t    def test_delete_ignore_swapped(self):\n  5162\t        \"\"\"\n  5163\t        Tests the DeleteModel operation ignores swapped models.\n  5164\t        \"\"\"\n  5165\t        operation = migrations.DeleteModel(\"Pony\")\n  5166\t        project_state, new_state = self.make_test_state(\"test_dligsw\", operation)\n  5167\t        # Test the database alteration\n  5168\t        self.assertTableNotExists(\"test_dligsw_pony\")\n  5169\t        with connection.schema_editor() as editor:\n  5170\t            operation.database_forwards(\"test_dligsw\", editor, project_state, new_state)\n  5171\t        self.assertTableNotExists(\"test_dligsw_pony\")\n  5172\t        # And test reversal\n  5173\t        with connection.schema_editor() as editor:\n  5174\t            operation.database_backwards(\n  5175\t                \"test_dligsw\", editor, new_state, project_state\n  5176\t            )\n  5177\t        self.assertTableNotExists(\"test_dligsw_pony\")\n  5178\t\n  5179\t    @override_settings(TEST_SWAP_MODEL=\"migrations.SomeFakeModel\")\n  5180\t    def test_add_field_ignore_swapped(self):\n  5181\t        \"\"\"\n  5182\t        Tests the AddField operation.\n  5183\t        \"\"\"\n  5184\t        # Test the state alteration\n  5185\t        operation = migrations.AddField(\n  5186\t            \"Pony\",\n  5187\t            \"height\",\n  5188\t            models.FloatField(null=True, default=5),\n  5189\t        )\n  5190\t        project_state, new_state = self.make_test_state(\"test_adfligsw\", operation)\n  5191\t        # Test the database alteration\n  5192\t        self.assertTableNotExists(\"test_adfligsw_pony\")\n  5193\t        with connection.schema_editor() as editor:\n  5194\t            operation.database_forwards(\n  5195\t                \"test_adfligsw\", editor, project_state, new_state\n  5196\t            )\n  5197\t        self.assertTableNotExists(\"test_adfligsw_pony\")\n  5198\t        # And test reversal\n  5199\t        with connection.schema_editor() as editor:\n  5200\t            operation.database_backwards(\n  5201\t                \"test_adfligsw\", editor, new_state, project_state\n  5202\t            )\n  5203\t        self.assertTableNotExists(\"test_adfligsw_pony\")\n  5204\t\n  5205\t    @override_settings(TEST_SWAP_MODEL=\"migrations.SomeFakeModel\")\n  5206\t    def test_indexes_ignore_swapped(self):\n  5207\t        \"\"\"\n  5208\t        Add/RemoveIndex operations ignore swapped models.\n  5209\t        \"\"\"\n  5210\t        operation = migrations.AddIndex(\n  5211\t            \"Pony\", models.Index(fields=[\"pink\"], name=\"my_name_idx\")\n  5212\t        )\n  5213\t        project_state, new_state = self.make_test_state(\"test_adinigsw\", operation)\n  5214\t        with connection.schema_editor() as editor:\n  5215\t            # No database queries should be run for swapped models\n  5216\t            operation.database_forwards(\n  5217\t                \"test_adinigsw\", editor, project_state, new_state\n  5218\t            )\n  5219\t            operation.database_backwards(\n  5220\t                \"test_adinigsw\", editor, new_state, project_state\n  5221\t            )\n  5222\t\n  5223\t        operation = migrations.RemoveIndex(\n  5224\t            \"Pony\", models.Index(fields=[\"pink\"], name=\"my_name_idx\")\n  5225\t        )\n  5226\t        project_state, new_state = self.make_test_state(\"test_rminigsw\", operation)\n  5227\t        with connection.schema_editor() as editor:\n  5228\t            operation.database_forwards(\n  5229\t                \"test_rminigsw\", editor, project_state, new_state\n  5230\t            )\n  5231\t            operation.database_backwards(\n  5232\t                \"test_rminigsw\", editor, new_state, project_state\n  5233\t            )\n  5234\t\n  5235\t\n  5236\tclass TestCreateModel(SimpleTestCase):\n  5237\t    def test_references_model_mixin(self):\n  5238\t        migrations.CreateModel(\n  5239\t            \"name\",\n  5240\t            fields=[],\n  5241\t            bases=(Mixin, models.Model),\n  5242\t        ).references_model(\"other_model\", \"migrations\")\n  5243\t\n  5244\t\n  5245\tclass FieldOperationTests(SimpleTestCase):\n  5246\t    def test_references_model(self):\n  5247\t        operation = FieldOperation(\n  5248\t            \"MoDel\", \"field\", models.ForeignKey(\"Other\", models.CASCADE)\n  5249\t        )\n  5250\t        # Model name match.\n  5251\t        self.assertIs(operation.references_model(\"mOdEl\", \"migrations\"), True)\n  5252\t        # Referenced field.\n  5253\t        self.assertIs(operation.references_model(\"oTher\", \"migrations\"), True)\n  5254\t        # Doesn't reference.\n  5255\t        self.assertIs(operation.references_model(\"Whatever\", \"migrations\"), False)\n  5256\t\n  5257\t    def test_references_field_by_name(self):\n  5258\t        operation = FieldOperation(\"MoDel\", \"field\", models.BooleanField(default=False))\n  5259\t        self.assertIs(operation.references_field(\"model\", \"field\", \"migrations\"), True)\n  5260\t\n  5261\t    def test_references_field_by_remote_field_model(self):\n  5262\t        operation = FieldOperation(\n  5263\t            \"Model\", \"field\", models.ForeignKey(\"Other\", models.CASCADE)\n  5264\t        )\n  5265\t        self.assertIs(\n  5266\t            operation.references_field(\"Other\", \"whatever\", \"migrations\"), True\n  5267\t        )\n  5268\t        self.assertIs(\n  5269\t            operation.references_field(\"Missing\", \"whatever\", \"migrations\"), False\n  5270\t        )\n  5271\t\n  5272\t    def test_references_field_by_from_fields(self):\n  5273\t        operation = FieldOperation(\n  5274\t            \"Model\",\n  5275\t            \"field\",\n  5276\t            models.fields.related.ForeignObject(\n  5277\t                \"Other\", models.CASCADE, [\"from\"], [\"to\"]\n  5278\t            ),\n  5279\t        )\n  5280\t        self.assertIs(operation.references_field(\"Model\", \"from\", \"migrations\"), True)\n  5281\t        self.assertIs(operation.references_field(\"Model\", \"to\", \"migrations\"), False)\n  5282\t        self.assertIs(operation.references_field(\"Other\", \"from\", \"migrations\"), False)\n  5283\t        self.assertIs(operation.references_field(\"Model\", \"to\", \"migrations\"), False)\n  5284\t\n  5285\t    def test_references_field_by_to_fields(self):\n  5286\t        operation = FieldOperation(\n  5287\t            \"Model\",\n  5288\t            \"field\",\n  5289\t            models.ForeignKey(\"Other\", models.CASCADE, to_field=\"field\"),\n  5290\t        )\n  5291\t        self.assertIs(operation.references_field(\"Other\", \"field\", \"migrations\"), True)\n  5292\t        self.assertIs(\n  5293\t            operation.references_field(\"Other\", \"whatever\", \"migrations\"), False\n  5294\t        )\n  5295\t        self.assertIs(\n  5296\t            operation.references_field(\"Missing\", \"whatever\", \"migrations\"), False\n  5297\t        )\n  5298\t\n  5299\t    def test_references_field_by_through(self):\n  5300\t        operation = FieldOperation(\n  5301\t            \"Model\", \"field\", models.ManyToManyField(\"Other\", through=\"Through\")\n  5302\t        )\n  5303\t        self.assertIs(\n  5304\t            operation.references_field(\"Other\", \"whatever\", \"migrations\"), True\n  5305\t        )\n  5306\t        self.assertIs(\n  5307\t            operation.references_field(\"Through\", \"whatever\", \"migrations\"), True\n  5308\t        )\n  5309\t        self.assertIs(\n  5310\t            operation.references_field(\"Missing\", \"whatever\", \"migrations\"), False\n  5311\t        )\n  5312\t\n  5313\t    def test_reference_field_by_through_fields(self):\n  5314\t        operation = FieldOperation(\n  5315\t            \"Model\",\n  5316\t            \"field\",\n  5317\t            models.ManyToManyField(\n  5318\t                \"Other\", through=\"Through\", through_fields=(\"first\", \"second\")\n  5319\t            ),\n  5320\t        )\n  5321\t        self.assertIs(\n  5322\t            operation.references_field(\"Other\", \"whatever\", \"migrations\"), True\n  5323\t        )\n  5324\t        self.assertIs(\n  5325\t            operation.references_field(\"Through\", \"whatever\", \"migrations\"), False\n  5326\t        )\n  5327\t        self.assertIs(\n  5328\t            operation.references_field(\"Through\", \"first\", \"migrations\"), True\n  5329\t        )\n  5330\t        self.assertIs(\n  5331\t            operation.references_field(\"Through\", \"second\", \"migrations\"), True\n  5332\t        )\n  5333\t\n```\n",
        "summary": "Showed the following code spans:\n\nFile: tests/migrations/test_operations.py\n- Showing all code in file\n",
        "terminal": false,
        "expect_correction": false,
        "properties": {
          "files": {
            "tests/migrations/test_operations.py": {
              "new_span_ids": [
                "imports"
              ]
            }
          }
        }
      },
      "file_context": {
        "max_tokens": 8000,
        "files": [
          {
            "file_path": "tests/migrations/test_operations.py",
            "spans": [
              {
                "span_id": "imports",
                "pinned": false
              }
            ],
            "show_all_spans": true,
            "patch": null
          }
        ]
      },
      "completions": {
        "build_action": {
          "model": "claude-3-5-sonnet-20241022",
          "input": [
            {
              "role": "user",
              "content": "<task>\nRenameIndex() crashes when unnamed index is moving backward and forward.\nDescription\n\t\nRenameIndex() should restore the old auto-generated name when an unnamed index for unique_together is moving backward. Now re-applying RenameIndex() crashes. For example:\ntests/migrations/test_operations.py\ndiff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex cfd28b1b39..c0a55023bb 100644\n\t\t\t\t\t\n\t\t\t\t\t a\n\t\t\t\t \n\t\t\t\t\t\n\t\t\t\t\t b\n\t\t\t\t \n class OperationTests(OperationTestBase):\u00a0\n29882988\u00a0 \u00a0 \u00a0 \u00a0 with connection.schema_editor() as editor, self.assertNumQueries(0):\n29892989\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 operation.database_backwards(app_label, editor, new_state, project_state)\n29902990\u00a0 \u00a0 \u00a0 \u00a0 self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n\u00a02991\u00a0 \u00a0 \u00a0 \u00a0 # Re-apply renaming.\n\u00a02992\u00a0 \u00a0 \u00a0 \u00a0 with connection.schema_editor() as editor:\n\u00a02993\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 operation.database_forwards(app_label, editor, project_state, new_state)\n\u00a02994\u00a0 \u00a0 \u00a0 \u00a0 self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n29912995\u00a0 \u00a0 \u00a0 \u00a0 # Deconstruction.\n29922996\u00a0 \u00a0 \u00a0 \u00a0 definition = operation.deconstruct()\n29932997\u00a0 \u00a0 \u00a0 \u00a0 self.assertEqual(definition[0], \"RenameIndex\")\ncrashes on PostgreSQL:\ndjango.db.utils.ProgrammingError: relation \"new_pony_test_idx\" already exists\n\n</task>"
            }
          ],
          "response": {
            "id": "msg_015vinABNHMxmn2zDr7whwK2",
            "content": [
              {
                "text": "Let me help investigate and fix this issue with RenameIndex() crashing when dealing with unnamed index movements.\n\n<thoughts>\n1. First, I need to understand the context better by:\n   - Looking at the test file to see the full test case\n   - Finding the RenameIndex operation implementation\n   - Understanding how index naming works in this context\n\n2. Let's start by viewing the test file to see the full test case context.\n</thoughts>",
                "type": "text"
              },
              {
                "id": "toolu_01LLjv75nJVjdfwbXE7bPgHi",
                "input": {
                  "files": [
                    {
                      "file_path": "tests/migrations/test_operations.py"
                    }
                  ]
                },
                "name": "ViewCode",
                "type": "tool_use"
              }
            ],
            "model": "claude-3-5-sonnet-20241022",
            "role": "assistant",
            "stop_reason": "tool_use",
            "stop_sequence": null,
            "type": "message",
            "usage": {
              "cache_creation_input_tokens": 0,
              "cache_read_input_tokens": 3981,
              "input_tokens": 524,
              "output_tokens": 170
            }
          },
          "usage": {
            "completion_cost": 0.004122000000000001,
            "completion_tokens": 170,
            "prompt_tokens": 524,
            "cached_tokens": 3981
          }
        }
      },
      "possible_actions": [
        "SemanticSearch",
        "FindClass",
        "FindFunction",
        "FindCodeSnippet",
        "ViewCode",
        "ClaudeEditTool"
      ],
      "output": {
        "message": "Here's the contents of the requested code spans:\ntests/migrations/test_operations.py\n```\n     1\tfrom django.core.exceptions import FieldDoesNotExist\n     2\tfrom django.db import IntegrityError, connection, migrations, models, transaction\n     3\tfrom django.db.migrations.migration import Migration\n     4\tfrom django.db.migrations.operations.fields import FieldOperation\n     5\tfrom django.db.migrations.state import ModelState, ProjectState\n     6\tfrom django.db.models.functions import Abs\n     7\tfrom django.db.transaction import atomic\n     8\tfrom django.test import SimpleTestCase, override_settings, skipUnlessDBFeature\n     9\tfrom django.test.utils import CaptureQueriesContext\n    10\t\n    11\tfrom .models import FoodManager, FoodQuerySet, UnicodeModel\n    12\tfrom .test_base import OperationTestBase\n    13\t\n    14\t\n    15\tclass Mixin:\n    16\t    pass\n    17\t\n    18\t\n    19\tclass OperationTests(OperationTestBase):\n    20\t    \"\"\"\n    21\t    Tests running the operations and making sure they do what they say they do.\n    22\t    Each test looks at their state changing, and then their database operation -\n    23\t    both forwards and backwards.\n    24\t    \"\"\"\n    25\t\n    26\t    def test_create_model(self):\n    27\t        \"\"\"\n    28\t        Tests the CreateModel operation.\n    29\t        Most other tests use this operation as part of setup, so check failures\n    30\t        here first.\n    31\t        \"\"\"\n    32\t        operation = migrations.CreateModel(\n    33\t            \"Pony\",\n    34\t            [\n    35\t                (\"id\", models.AutoField(primary_key=True)),\n    36\t                (\"pink\", models.IntegerField(default=1)),\n    37\t            ],\n    38\t        )\n    39\t        self.assertEqual(operation.describe(), \"Create model Pony\")\n    40\t        self.assertEqual(operation.migration_name_fragment, \"pony\")\n    41\t        # Test the state alteration\n    42\t        project_state = ProjectState()\n    43\t        new_state = project_state.clone()\n    44\t        operation.state_forwards(\"test_crmo\", new_state)\n    45\t        self.assertEqual(new_state.models[\"test_crmo\", \"pony\"].name, \"Pony\")\n    46\t        self.assertEqual(len(new_state.models[\"test_crmo\", \"pony\"].fields), 2)\n    47\t        # Test the database alteration\n    48\t        self.assertTableNotExists(\"test_crmo_pony\")\n    49\t        with connection.schema_editor() as editor:\n    50\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n    51\t        self.assertTableExists(\"test_crmo_pony\")\n    52\t        # And test reversal\n    53\t        with connection.schema_editor() as editor:\n    54\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n    55\t        self.assertTableNotExists(\"test_crmo_pony\")\n    56\t        # And deconstruction\n    57\t        definition = operation.deconstruct()\n    58\t        self.assertEqual(definition[0], \"CreateModel\")\n    59\t        self.assertEqual(definition[1], [])\n    60\t        self.assertEqual(sorted(definition[2]), [\"fields\", \"name\"])\n    61\t        # And default manager not in set\n    62\t        operation = migrations.CreateModel(\n    63\t            \"Foo\", fields=[], managers=[(\"objects\", models.Manager())]\n    64\t        )\n    65\t        definition = operation.deconstruct()\n    66\t        self.assertNotIn(\"managers\", definition[2])\n    67\t\n    68\t    def test_create_model_with_duplicate_field_name(self):\n    69\t        with self.assertRaisesMessage(\n    70\t            ValueError, \"Found duplicate value pink in CreateModel fields argument.\"\n    71\t        ):\n    72\t            migrations.CreateModel(\n    73\t                \"Pony\",\n    74\t                [\n    75\t                    (\"id\", models.AutoField(primary_key=True)),\n    76\t                    (\"pink\", models.TextField()),\n    77\t                    (\"pink\", models.IntegerField(default=1)),\n    78\t                ],\n    79\t            )\n    80\t\n    81\t    def test_create_model_with_duplicate_base(self):\n    82\t        message = \"Found duplicate value test_crmo.pony in CreateModel bases argument.\"\n    83\t        with self.assertRaisesMessage(ValueError, message):\n    84\t            migrations.CreateModel(\n    85\t                \"Pony\",\n    86\t                fields=[],\n    87\t                bases=(\n    88\t                    \"test_crmo.Pony\",\n    89\t                    \"test_crmo.Pony\",\n    90\t                ),\n    91\t            )\n    92\t        with self.assertRaisesMessage(ValueError, message):\n    93\t            migrations.CreateModel(\n    94\t                \"Pony\",\n    95\t                fields=[],\n    96\t                bases=(\n    97\t                    \"test_crmo.Pony\",\n    98\t                    \"test_crmo.pony\",\n    99\t                ),\n   100\t            )\n   101\t        message = (\n   102\t            \"Found duplicate value migrations.unicodemodel in CreateModel bases \"\n   103\t            \"argument.\"\n   104\t        )\n   105\t        with self.assertRaisesMessage(ValueError, message):\n   106\t            migrations.CreateModel(\n   107\t                \"Pony\",\n   108\t                fields=[],\n   109\t                bases=(\n   110\t                    UnicodeModel,\n   111\t                    UnicodeModel,\n   112\t                ),\n   113\t            )\n   114\t        with self.assertRaisesMessage(ValueError, message):\n   115\t            migrations.CreateModel(\n   116\t                \"Pony\",\n   117\t                fields=[],\n   118\t                bases=(\n   119\t                    UnicodeModel,\n   120\t                    \"migrations.unicodemodel\",\n   121\t                ),\n   122\t            )\n   123\t        with self.assertRaisesMessage(ValueError, message):\n   124\t            migrations.CreateModel(\n   125\t                \"Pony\",\n   126\t                fields=[],\n   127\t                bases=(\n   128\t                    UnicodeModel,\n   129\t                    \"migrations.UnicodeModel\",\n   130\t                ),\n   131\t            )\n   132\t        message = (\n   133\t            \"Found duplicate value <class 'django.db.models.base.Model'> in \"\n   134\t            \"CreateModel bases argument.\"\n   135\t        )\n   136\t        with self.assertRaisesMessage(ValueError, message):\n   137\t            migrations.CreateModel(\n   138\t                \"Pony\",\n   139\t                fields=[],\n   140\t                bases=(\n   141\t                    models.Model,\n   142\t                    models.Model,\n   143\t                ),\n   144\t            )\n   145\t        message = (\n   146\t            \"Found duplicate value <class 'migrations.test_operations.Mixin'> in \"\n   147\t            \"CreateModel bases argument.\"\n   148\t        )\n   149\t        with self.assertRaisesMessage(ValueError, message):\n   150\t            migrations.CreateModel(\n   151\t                \"Pony\",\n   152\t                fields=[],\n   153\t                bases=(\n   154\t                    Mixin,\n   155\t                    Mixin,\n   156\t                ),\n   157\t            )\n   158\t\n   159\t    def test_create_model_with_duplicate_manager_name(self):\n   160\t        with self.assertRaisesMessage(\n   161\t            ValueError,\n   162\t            \"Found duplicate value objects in CreateModel managers argument.\",\n   163\t        ):\n   164\t            migrations.CreateModel(\n   165\t                \"Pony\",\n   166\t                fields=[],\n   167\t                managers=[\n   168\t                    (\"objects\", models.Manager()),\n   169\t                    (\"objects\", models.Manager()),\n   170\t                ],\n   171\t            )\n   172\t\n   173\t    def test_create_model_with_unique_after(self):\n   174\t        \"\"\"\n   175\t        Tests the CreateModel operation directly followed by an\n   176\t        AlterUniqueTogether (bug #22844 - sqlite remake issues)\n   177\t        \"\"\"\n   178\t        operation1 = migrations.CreateModel(\n   179\t            \"Pony\",\n   180\t            [\n   181\t                (\"id\", models.AutoField(primary_key=True)),\n   182\t                (\"pink\", models.IntegerField(default=1)),\n   183\t            ],\n   184\t        )\n   185\t        operation2 = migrations.CreateModel(\n   186\t            \"Rider\",\n   187\t            [\n   188\t                (\"id\", models.AutoField(primary_key=True)),\n   189\t                (\"number\", models.IntegerField(default=1)),\n   190\t                (\"pony\", models.ForeignKey(\"test_crmoua.Pony\", models.CASCADE)),\n   191\t            ],\n   192\t        )\n   193\t        operation3 = migrations.AlterUniqueTogether(\n   194\t            \"Rider\",\n   195\t            [\n   196\t                (\"number\", \"pony\"),\n   197\t            ],\n   198\t        )\n   199\t        # Test the database alteration\n   200\t        project_state = ProjectState()\n   201\t        self.assertTableNotExists(\"test_crmoua_pony\")\n   202\t        self.assertTableNotExists(\"test_crmoua_rider\")\n   203\t        with connection.schema_editor() as editor:\n   204\t            new_state = project_state.clone()\n   205\t            operation1.state_forwards(\"test_crmoua\", new_state)\n   206\t            operation1.database_forwards(\n   207\t                \"test_crmoua\", editor, project_state, new_state\n   208\t            )\n   209\t            project_state, new_state = new_state, new_state.clone()\n   210\t            operation2.state_forwards(\"test_crmoua\", new_state)\n   211\t            operation2.database_forwards(\n   212\t                \"test_crmoua\", editor, project_state, new_state\n   213\t            )\n   214\t            project_state, new_state = new_state, new_state.clone()\n   215\t            operation3.state_forwards(\"test_crmoua\", new_state)\n   216\t            operation3.database_forwards(\n   217\t                \"test_crmoua\", editor, project_state, new_state\n   218\t            )\n   219\t        self.assertTableExists(\"test_crmoua_pony\")\n   220\t        self.assertTableExists(\"test_crmoua_rider\")\n   221\t\n   222\t    def test_create_model_m2m(self):\n   223\t        \"\"\"\n   224\t        Test the creation of a model with a ManyToMany field and the\n   225\t        auto-created \"through\" model.\n   226\t        \"\"\"\n   227\t        project_state = self.set_up_test_model(\"test_crmomm\")\n   228\t        operation = migrations.CreateModel(\n   229\t            \"Stable\",\n   230\t            [\n   231\t                (\"id\", models.AutoField(primary_key=True)),\n   232\t                (\"ponies\", models.ManyToManyField(\"Pony\", related_name=\"stables\")),\n   233\t            ],\n   234\t        )\n   235\t        # Test the state alteration\n   236\t        new_state = project_state.clone()\n   237\t        operation.state_forwards(\"test_crmomm\", new_state)\n   238\t        # Test the database alteration\n   239\t        self.assertTableNotExists(\"test_crmomm_stable_ponies\")\n   240\t        with connection.schema_editor() as editor:\n   241\t            operation.database_forwards(\"test_crmomm\", editor, project_state, new_state)\n   242\t        self.assertTableExists(\"test_crmomm_stable\")\n   243\t        self.assertTableExists(\"test_crmomm_stable_ponies\")\n   244\t        self.assertColumnNotExists(\"test_crmomm_stable\", \"ponies\")\n   245\t        # Make sure the M2M field actually works\n   246\t        with atomic():\n   247\t            Pony = new_state.apps.get_model(\"test_crmomm\", \"Pony\")\n   248\t            Stable = new_state.apps.get_model(\"test_crmomm\", \"Stable\")\n   249\t            stable = Stable.objects.create()\n   250\t            p1 = Pony.objects.create(pink=False, weight=4.55)\n   251\t            p2 = Pony.objects.create(pink=True, weight=5.43)\n   252\t            stable.ponies.add(p1, p2)\n   253\t            self.assertEqual(stable.ponies.count(), 2)\n   254\t            stable.ponies.all().delete()\n   255\t        # And test reversal\n   256\t        with connection.schema_editor() as editor:\n   257\t            operation.database_backwards(\n   258\t                \"test_crmomm\", editor, new_state, project_state\n   259\t            )\n   260\t        self.assertTableNotExists(\"test_crmomm_stable\")\n   261\t        self.assertTableNotExists(\"test_crmomm_stable_ponies\")\n   262\t\n   263\t    @skipUnlessDBFeature(\"supports_collation_on_charfield\", \"supports_foreign_keys\")\n   264\t    def test_create_fk_models_to_pk_field_db_collation(self):\n   265\t        \"\"\"Creation of models with a FK to a PK with db_collation.\"\"\"\n   266\t        collation = connection.features.test_collations.get(\"non_default\")\n   267\t        if not collation:\n   268\t            self.skipTest(\"Language collations are not supported.\")\n   269\t\n   270\t        app_label = \"test_cfkmtopkfdbc\"\n   271\t        operations = [\n   272\t            migrations.CreateModel(\n   273\t                \"Pony\",\n   274\t                [\n   275\t                    (\n   276\t                        \"id\",\n   277\t                        models.CharField(\n   278\t                            primary_key=True,\n   279\t                            max_length=10,\n   280\t                            db_collation=collation,\n   281\t                        ),\n   282\t                    ),\n   283\t                ],\n   284\t            )\n   285\t        ]\n   286\t        project_state = self.apply_operations(app_label, ProjectState(), operations)\n   287\t        # ForeignKey.\n   288\t        new_state = project_state.clone()\n   289\t        operation = migrations.CreateModel(\n   290\t            \"Rider\",\n   291\t            [\n   292\t                (\"id\", models.AutoField(primary_key=True)),\n   293\t                (\"pony\", models.ForeignKey(\"Pony\", models.CASCADE)),\n   294\t            ],\n   295\t        )\n   296\t        operation.state_forwards(app_label, new_state)\n   297\t        with connection.schema_editor() as editor:\n   298\t            operation.database_forwards(app_label, editor, project_state, new_state)\n   299\t        self.assertColumnCollation(f\"{app_label}_rider\", \"pony_id\", collation)\n   300\t        # Reversal.\n   301\t        with connection.schema_editor() as editor:\n   302\t            operation.database_backwards(app_label, editor, new_state, project_state)\n   303\t        # OneToOneField.\n   304\t        new_state = project_state.clone()\n   305\t        operation = migrations.CreateModel(\n   306\t            \"ShetlandPony\",\n   307\t            [\n   308\t                (\n   309\t                    \"pony\",\n   310\t                    models.OneToOneField(\"Pony\", models.CASCADE, primary_key=True),\n   311\t                ),\n   312\t                (\"cuteness\", models.IntegerField(default=1)),\n   313\t            ],\n   314\t        )\n   315\t        operation.state_forwards(app_label, new_state)\n   316\t        with connection.schema_editor() as editor:\n   317\t            operation.database_forwards(app_label, editor, project_state, new_state)\n   318\t        self.assertColumnCollation(f\"{app_label}_shetlandpony\", \"pony_id\", collation)\n   319\t        # Reversal.\n   320\t        with connection.schema_editor() as editor:\n   321\t            operation.database_backwards(app_label, editor, new_state, project_state)\n   322\t\n   323\t    def test_create_model_inheritance(self):\n   324\t        \"\"\"\n   325\t        Tests the CreateModel operation on a multi-table inheritance setup.\n   326\t        \"\"\"\n   327\t        project_state = self.set_up_test_model(\"test_crmoih\")\n   328\t        # Test the state alteration\n   329\t        operation = migrations.CreateModel(\n   330\t            \"ShetlandPony\",\n   331\t            [\n   332\t                (\n   333\t                    \"pony_ptr\",\n   334\t                    models.OneToOneField(\n   335\t                        \"test_crmoih.Pony\",\n   336\t                        models.CASCADE,\n   337\t                        auto_created=True,\n   338\t                        primary_key=True,\n   339\t                        to_field=\"id\",\n   340\t                        serialize=False,\n   341\t                    ),\n   342\t                ),\n   343\t                (\"cuteness\", models.IntegerField(default=1)),\n   344\t            ],\n   345\t        )\n   346\t        new_state = project_state.clone()\n   347\t        operation.state_forwards(\"test_crmoih\", new_state)\n   348\t        self.assertIn((\"test_crmoih\", \"shetlandpony\"), new_state.models)\n   349\t        # Test the database alteration\n   350\t        self.assertTableNotExists(\"test_crmoih_shetlandpony\")\n   351\t        with connection.schema_editor() as editor:\n   352\t            operation.database_forwards(\"test_crmoih\", editor, project_state, new_state)\n   353\t        self.assertTableExists(\"test_crmoih_shetlandpony\")\n   354\t        # And test reversal\n   355\t        with connection.schema_editor() as editor:\n   356\t            operation.database_backwards(\n   357\t                \"test_crmoih\", editor, new_state, project_state\n   358\t            )\n   359\t        self.assertTableNotExists(\"test_crmoih_shetlandpony\")\n   360\t\n   361\t    def test_create_proxy_model(self):\n   362\t        \"\"\"\n   363\t        CreateModel ignores proxy models.\n   364\t        \"\"\"\n   365\t        project_state = self.set_up_test_model(\"test_crprmo\")\n   366\t        # Test the state alteration\n   367\t        operation = migrations.CreateModel(\n   368\t            \"ProxyPony\",\n   369\t            [],\n   370\t            options={\"proxy\": True},\n   371\t            bases=(\"test_crprmo.Pony\",),\n   372\t        )\n   373\t        self.assertEqual(operation.describe(), \"Create proxy model ProxyPony\")\n   374\t        new_state = project_state.clone()\n   375\t        operation.state_forwards(\"test_crprmo\", new_state)\n   376\t        self.assertIn((\"test_crprmo\", \"proxypony\"), new_state.models)\n   377\t        # Test the database alteration\n   378\t        self.assertTableNotExists(\"test_crprmo_proxypony\")\n   379\t        self.assertTableExists(\"test_crprmo_pony\")\n   380\t        with connection.schema_editor() as editor:\n   381\t            operation.database_forwards(\"test_crprmo\", editor, project_state, new_state)\n   382\t        self.assertTableNotExists(\"test_crprmo_proxypony\")\n   383\t        self.assertTableExists(\"test_crprmo_pony\")\n   384\t        # And test reversal\n   385\t        with connection.schema_editor() as editor:\n   386\t            operation.database_backwards(\n   387\t                \"test_crprmo\", editor, new_state, project_state\n   388\t            )\n   389\t        self.assertTableNotExists(\"test_crprmo_proxypony\")\n   390\t        self.assertTableExists(\"test_crprmo_pony\")\n   391\t        # And deconstruction\n   392\t        definition = operation.deconstruct()\n   393\t        self.assertEqual(definition[0], \"CreateModel\")\n   394\t        self.assertEqual(definition[1], [])\n   395\t        self.assertEqual(sorted(definition[2]), [\"bases\", \"fields\", \"name\", \"options\"])\n   396\t\n   397\t    def test_create_unmanaged_model(self):\n   398\t        \"\"\"\n   399\t        CreateModel ignores unmanaged models.\n   400\t        \"\"\"\n   401\t        project_state = self.set_up_test_model(\"test_crummo\")\n   402\t        # Test the state alteration\n   403\t        operation = migrations.CreateModel(\n   404\t            \"UnmanagedPony\",\n   405\t            [],\n   406\t            options={\"proxy\": True},\n   407\t            bases=(\"test_crummo.Pony\",),\n   408\t        )\n   409\t        self.assertEqual(operation.describe(), \"Create proxy model UnmanagedPony\")\n   410\t        new_state = project_state.clone()\n   411\t        operation.state_forwards(\"test_crummo\", new_state)\n   412\t        self.assertIn((\"test_crummo\", \"unmanagedpony\"), new_state.models)\n   413\t        # Test the database alteration\n   414\t        self.assertTableNotExists(\"test_crummo_unmanagedpony\")\n   415\t        self.assertTableExists(\"test_crummo_pony\")\n   416\t        with connection.schema_editor() as editor:\n   417\t            operation.database_forwards(\"test_crummo\", editor, project_state, new_state)\n   418\t        self.assertTableNotExists(\"test_crummo_unmanagedpony\")\n   419\t        self.assertTableExists(\"test_crummo_pony\")\n   420\t        # And test reversal\n   421\t        with connection.schema_editor() as editor:\n   422\t            operation.database_backwards(\n   423\t                \"test_crummo\", editor, new_state, project_state\n   424\t            )\n   425\t        self.assertTableNotExists(\"test_crummo_unmanagedpony\")\n   426\t        self.assertTableExists(\"test_crummo_pony\")\n   427\t\n   428\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n   429\t    def test_create_model_with_constraint(self):\n   430\t        where = models.Q(pink__gt=2)\n   431\t        check_constraint = models.CheckConstraint(\n   432\t            check=where, name=\"test_constraint_pony_pink_gt_2\"\n   433\t        )\n   434\t        operation = migrations.CreateModel(\n   435\t            \"Pony\",\n   436\t            [\n   437\t                (\"id\", models.AutoField(primary_key=True)),\n   438\t                (\"pink\", models.IntegerField(default=3)),\n   439\t            ],\n   440\t            options={\"constraints\": [check_constraint]},\n   441\t        )\n   442\t\n   443\t        # Test the state alteration\n   444\t        project_state = ProjectState()\n   445\t        new_state = project_state.clone()\n   446\t        operation.state_forwards(\"test_crmo\", new_state)\n   447\t        self.assertEqual(\n   448\t            len(new_state.models[\"test_crmo\", \"pony\"].options[\"constraints\"]), 1\n   449\t        )\n   450\t\n   451\t        # Test database alteration\n   452\t        self.assertTableNotExists(\"test_crmo_pony\")\n   453\t        with connection.schema_editor() as editor:\n   454\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n   455\t        self.assertTableExists(\"test_crmo_pony\")\n   456\t        with connection.cursor() as cursor:\n   457\t            with self.assertRaises(IntegrityError):\n   458\t                cursor.execute(\"INSERT INTO test_crmo_pony (id, pink) VALUES (1, 1)\")\n   459\t\n   460\t        # Test reversal\n   461\t        with connection.schema_editor() as editor:\n   462\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n   463\t        self.assertTableNotExists(\"test_crmo_pony\")\n   464\t\n   465\t        # Test deconstruction\n   466\t        definition = operation.deconstruct()\n   467\t        self.assertEqual(definition[0], \"CreateModel\")\n   468\t        self.assertEqual(definition[1], [])\n   469\t        self.assertEqual(definition[2][\"options\"][\"constraints\"], [check_constraint])\n   470\t\n   471\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n   472\t    def test_create_model_with_boolean_expression_in_check_constraint(self):\n   473\t        app_label = \"test_crmobechc\"\n   474\t        rawsql_constraint = models.CheckConstraint(\n   475\t            check=models.expressions.RawSQL(\n   476\t                \"price < %s\", (1000,), output_field=models.BooleanField()\n   477\t            ),\n   478\t            name=f\"{app_label}_price_lt_1000_raw\",\n   479\t        )\n   480\t        wrapper_constraint = models.CheckConstraint(\n   481\t            check=models.expressions.ExpressionWrapper(\n   482\t                models.Q(price__gt=500) | models.Q(price__lt=500),\n   483\t                output_field=models.BooleanField(),\n   484\t            ),\n   485\t            name=f\"{app_label}_price_neq_500_wrap\",\n   486\t        )\n   487\t        operation = migrations.CreateModel(\n   488\t            \"Product\",\n   489\t            [\n   490\t                (\"id\", models.AutoField(primary_key=True)),\n   491\t                (\"price\", models.IntegerField(null=True)),\n   492\t            ],\n   493\t            options={\"constraints\": [rawsql_constraint, wrapper_constraint]},\n   494\t        )\n   495\t\n   496\t        project_state = ProjectState()\n   497\t        new_state = project_state.clone()\n   498\t        operation.state_forwards(app_label, new_state)\n   499\t        # Add table.\n   500\t        self.assertTableNotExists(app_label)\n   501\t        with connection.schema_editor() as editor:\n   502\t            operation.database_forwards(app_label, editor, project_state, new_state)\n   503\t        self.assertTableExists(f\"{app_label}_product\")\n   504\t        insert_sql = f\"INSERT INTO {app_label}_product (id, price) VALUES (%d, %d)\"\n   505\t        with connection.cursor() as cursor:\n   506\t            with self.assertRaises(IntegrityError):\n   507\t                cursor.execute(insert_sql % (1, 1000))\n   508\t            cursor.execute(insert_sql % (1, 999))\n   509\t            with self.assertRaises(IntegrityError):\n   510\t                cursor.execute(insert_sql % (2, 500))\n   511\t            cursor.execute(insert_sql % (2, 499))\n   512\t\n   513\t    def test_create_model_with_partial_unique_constraint(self):\n   514\t        partial_unique_constraint = models.UniqueConstraint(\n   515\t            fields=[\"pink\"],\n   516\t            condition=models.Q(weight__gt=5),\n   517\t            name=\"test_constraint_pony_pink_for_weight_gt_5_uniq\",\n   518\t        )\n   519\t        operation = migrations.CreateModel(\n   520\t            \"Pony\",\n   521\t            [\n   522\t                (\"id\", models.AutoField(primary_key=True)),\n   523\t                (\"pink\", models.IntegerField(default=3)),\n   524\t                (\"weight\", models.FloatField()),\n   525\t            ],\n   526\t            options={\"constraints\": [partial_unique_constraint]},\n   527\t        )\n   528\t        # Test the state alteration\n   529\t        project_state = ProjectState()\n   530\t        new_state = project_state.clone()\n   531\t        operation.state_forwards(\"test_crmo\", new_state)\n   532\t        self.assertEqual(\n   533\t            len(new_state.models[\"test_crmo\", \"pony\"].options[\"constraints\"]), 1\n   534\t        )\n   535\t        # Test database alteration\n   536\t        self.assertTableNotExists(\"test_crmo_pony\")\n   537\t        with connection.schema_editor() as editor:\n   538\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n   539\t        self.assertTableExists(\"test_crmo_pony\")\n   540\t        # Test constraint works\n   541\t        Pony = new_state.apps.get_model(\"test_crmo\", \"Pony\")\n   542\t        Pony.objects.create(pink=1, weight=4.0)\n   543\t        Pony.objects.create(pink=1, weight=4.0)\n   544\t        Pony.objects.create(pink=1, weight=6.0)\n   545\t        if connection.features.supports_partial_indexes:\n   546\t            with self.assertRaises(IntegrityError):\n   547\t                Pony.objects.create(pink=1, weight=7.0)\n   548\t        else:\n   549\t            Pony.objects.create(pink=1, weight=7.0)\n   550\t        # Test reversal\n   551\t        with connection.schema_editor() as editor:\n   552\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n   553\t        self.assertTableNotExists(\"test_crmo_pony\")\n   554\t        # Test deconstruction\n   555\t        definition = operation.deconstruct()\n   556\t        self.assertEqual(definition[0], \"CreateModel\")\n   557\t        self.assertEqual(definition[1], [])\n   558\t        self.assertEqual(\n   559\t            definition[2][\"options\"][\"constraints\"], [partial_unique_constraint]\n   560\t        )\n   561\t\n   562\t    def test_create_model_with_deferred_unique_constraint(self):\n   563\t        deferred_unique_constraint = models.UniqueConstraint(\n   564\t            fields=[\"pink\"],\n   565\t            name=\"deferrable_pink_constraint\",\n   566\t            deferrable=models.Deferrable.DEFERRED,\n   567\t        )\n   568\t        operation = migrations.CreateModel(\n   569\t            \"Pony\",\n   570\t            [\n   571\t                (\"id\", models.AutoField(primary_key=True)),\n   572\t                (\"pink\", models.IntegerField(default=3)),\n   573\t            ],\n   574\t            options={\"constraints\": [deferred_unique_constraint]},\n   575\t        )\n   576\t        project_state = ProjectState()\n   577\t        new_state = project_state.clone()\n   578\t        operation.state_forwards(\"test_crmo\", new_state)\n   579\t        self.assertEqual(\n   580\t            len(new_state.models[\"test_crmo\", \"pony\"].options[\"constraints\"]), 1\n   581\t        )\n   582\t        self.assertTableNotExists(\"test_crmo_pony\")\n   583\t        # Create table.\n   584\t        with connection.schema_editor() as editor:\n   585\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n   586\t        self.assertTableExists(\"test_crmo_pony\")\n   587\t        Pony = new_state.apps.get_model(\"test_crmo\", \"Pony\")\n   588\t        Pony.objects.create(pink=1)\n   589\t        if connection.features.supports_deferrable_unique_constraints:\n   590\t            # Unique constraint is deferred.\n   591\t            with transaction.atomic():\n   592\t                obj = Pony.objects.create(pink=1)\n   593\t                obj.pink = 2\n   594\t                obj.save()\n   595\t            # Constraint behavior can be changed with SET CONSTRAINTS.\n   596\t            with self.assertRaises(IntegrityError):\n   597\t                with transaction.atomic(), connection.cursor() as cursor:\n   598\t                    quoted_name = connection.ops.quote_name(\n   599\t                        deferred_unique_constraint.name\n   600\t                    )\n   601\t                    cursor.execute(\"SET CONSTRAINTS %s IMMEDIATE\" % quoted_name)\n   602\t                    obj = Pony.objects.create(pink=1)\n   603\t                    obj.pink = 3\n   604\t                    obj.save()\n   605\t        else:\n   606\t            Pony.objects.create(pink=1)\n   607\t        # Reversal.\n   608\t        with connection.schema_editor() as editor:\n   609\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n   610\t        self.assertTableNotExists(\"test_crmo_pony\")\n   611\t        # Deconstruction.\n   612\t        definition = operation.deconstruct()\n   613\t        self.assertEqual(definition[0], \"CreateModel\")\n   614\t        self.assertEqual(definition[1], [])\n   615\t        self.assertEqual(\n   616\t            definition[2][\"options\"][\"constraints\"],\n   617\t            [deferred_unique_constraint],\n   618\t        )\n   619\t\n   620\t    @skipUnlessDBFeature(\"supports_covering_indexes\")\n   621\t    def test_create_model_with_covering_unique_constraint(self):\n   622\t        covering_unique_constraint = models.UniqueConstraint(\n   623\t            fields=[\"pink\"],\n   624\t            include=[\"weight\"],\n   625\t            name=\"test_constraint_pony_pink_covering_weight\",\n   626\t        )\n   627\t        operation = migrations.CreateModel(\n   628\t            \"Pony\",\n   629\t            [\n   630\t                (\"id\", models.AutoField(primary_key=True)),\n   631\t                (\"pink\", models.IntegerField(default=3)),\n   632\t                (\"weight\", models.FloatField()),\n   633\t            ],\n   634\t            options={\"constraints\": [covering_unique_constraint]},\n   635\t        )\n   636\t        project_state = ProjectState()\n   637\t        new_state = project_state.clone()\n   638\t        operation.state_forwards(\"test_crmo\", new_state)\n   639\t        self.assertEqual(\n   640\t            len(new_state.models[\"test_crmo\", \"pony\"].options[\"constraints\"]), 1\n   641\t        )\n   642\t        self.assertTableNotExists(\"test_crmo_pony\")\n   643\t        # Create table.\n   644\t        with connection.schema_editor() as editor:\n   645\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n   646\t        self.assertTableExists(\"test_crmo_pony\")\n   647\t        Pony = new_state.apps.get_model(\"test_crmo\", \"Pony\")\n   648\t        Pony.objects.create(pink=1, weight=4.0)\n   649\t        with self.assertRaises(IntegrityError):\n   650\t            Pony.objects.create(pink=1, weight=7.0)\n   651\t        # Reversal.\n   652\t        with connection.schema_editor() as editor:\n   653\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n   654\t        self.assertTableNotExists(\"test_crmo_pony\")\n   655\t        # Deconstruction.\n   656\t        definition = operation.deconstruct()\n   657\t        self.assertEqual(definition[0], \"CreateModel\")\n   658\t        self.assertEqual(definition[1], [])\n   659\t        self.assertEqual(\n   660\t            definition[2][\"options\"][\"constraints\"],\n   661\t            [covering_unique_constraint],\n   662\t        )\n   663\t\n   664\t    def test_create_model_managers(self):\n   665\t        \"\"\"\n   666\t        The managers on a model are set.\n   667\t        \"\"\"\n   668\t        project_state = self.set_up_test_model(\"test_cmoma\")\n   669\t        # Test the state alteration\n   670\t        operation = migrations.CreateModel(\n   671\t            \"Food\",\n   672\t            fields=[\n   673\t                (\"id\", models.AutoField(primary_key=True)),\n   674\t            ],\n   675\t            managers=[\n   676\t                (\"food_qs\", FoodQuerySet.as_manager()),\n   677\t                (\"food_mgr\", FoodManager(\"a\", \"b\")),\n   678\t                (\"food_mgr_kwargs\", FoodManager(\"x\", \"y\", 3, 4)),\n   679\t            ],\n   680\t        )\n   681\t        self.assertEqual(operation.describe(), \"Create model Food\")\n   682\t        new_state = project_state.clone()\n   683\t        operation.state_forwards(\"test_cmoma\", new_state)\n   684\t        self.assertIn((\"test_cmoma\", \"food\"), new_state.models)\n   685\t        managers = new_state.models[\"test_cmoma\", \"food\"].managers\n   686\t        self.assertEqual(managers[0][0], \"food_qs\")\n   687\t        self.assertIsInstance(managers[0][1], models.Manager)\n   688\t        self.assertEqual(managers[1][0], \"food_mgr\")\n   689\t        self.assertIsInstance(managers[1][1], FoodManager)\n   690\t        self.assertEqual(managers[1][1].args, (\"a\", \"b\", 1, 2))\n   691\t        self.assertEqual(managers[2][0], \"food_mgr_kwargs\")\n   692\t        self.assertIsInstance(managers[2][1], FoodManager)\n   693\t        self.assertEqual(managers[2][1].args, (\"x\", \"y\", 3, 4))\n   694\t\n   695\t    def test_delete_model(self):\n   696\t        \"\"\"\n   697\t        Tests the DeleteModel operation.\n   698\t        \"\"\"\n   699\t        project_state = self.set_up_test_model(\"test_dlmo\")\n   700\t        # Test the state alteration\n   701\t        operation = migrations.DeleteModel(\"Pony\")\n   702\t        self.assertEqual(operation.describe(), \"Delete model Pony\")\n   703\t        self.assertEqual(operation.migration_name_fragment, \"delete_pony\")\n   704\t        new_state = project_state.clone()\n   705\t        operation.state_forwards(\"test_dlmo\", new_state)\n   706\t        self.assertNotIn((\"test_dlmo\", \"pony\"), new_state.models)\n   707\t        # Test the database alteration\n   708\t        self.assertTableExists(\"test_dlmo_pony\")\n   709\t        with connection.schema_editor() as editor:\n   710\t            operation.database_forwards(\"test_dlmo\", editor, project_state, new_state)\n   711\t        self.assertTableNotExists(\"test_dlmo_pony\")\n   712\t        # And test reversal\n   713\t        with connection.schema_editor() as editor:\n   714\t            operation.database_backwards(\"test_dlmo\", editor, new_state, project_state)\n   715\t        self.assertTableExists(\"test_dlmo_pony\")\n   716\t        # And deconstruction\n   717\t        definition = operation.deconstruct()\n   718\t        self.assertEqual(definition[0], \"DeleteModel\")\n   719\t        self.assertEqual(definition[1], [])\n   720\t        self.assertEqual(list(definition[2]), [\"name\"])\n   721\t\n   722\t    def test_delete_proxy_model(self):\n   723\t        \"\"\"\n   724\t        Tests the DeleteModel operation ignores proxy models.\n   725\t        \"\"\"\n   726\t        project_state = self.set_up_test_model(\"test_dlprmo\", proxy_model=True)\n   727\t        # Test the state alteration\n   728\t        operation = migrations.DeleteModel(\"ProxyPony\")\n   729\t        new_state = project_state.clone()\n   730\t        operation.state_forwards(\"test_dlprmo\", new_state)\n   731\t        self.assertIn((\"test_dlprmo\", \"proxypony\"), project_state.models)\n   732\t        self.assertNotIn((\"test_dlprmo\", \"proxypony\"), new_state.models)\n   733\t        # Test the database alteration\n   734\t        self.assertTableExists(\"test_dlprmo_pony\")\n   735\t        self.assertTableNotExists(\"test_dlprmo_proxypony\")\n   736\t        with connection.schema_editor() as editor:\n   737\t            operation.database_forwards(\"test_dlprmo\", editor, project_state, new_state)\n   738\t        self.assertTableExists(\"test_dlprmo_pony\")\n   739\t        self.assertTableNotExists(\"test_dlprmo_proxypony\")\n   740\t        # And test reversal\n   741\t        with connection.schema_editor() as editor:\n   742\t            operation.database_backwards(\n   743\t                \"test_dlprmo\", editor, new_state, project_state\n   744\t            )\n   745\t        self.assertTableExists(\"test_dlprmo_pony\")\n   746\t        self.assertTableNotExists(\"test_dlprmo_proxypony\")\n   747\t\n   748\t    def test_delete_mti_model(self):\n   749\t        project_state = self.set_up_test_model(\"test_dlmtimo\", mti_model=True)\n   750\t        # Test the state alteration\n   751\t        operation = migrations.DeleteModel(\"ShetlandPony\")\n   752\t        new_state = project_state.clone()\n   753\t        operation.state_forwards(\"test_dlmtimo\", new_state)\n   754\t        self.assertIn((\"test_dlmtimo\", \"shetlandpony\"), project_state.models)\n   755\t        self.assertNotIn((\"test_dlmtimo\", \"shetlandpony\"), new_state.models)\n   756\t        # Test the database alteration\n   757\t        self.assertTableExists(\"test_dlmtimo_pony\")\n   758\t        self.assertTableExists(\"test_dlmtimo_shetlandpony\")\n   759\t        self.assertColumnExists(\"test_dlmtimo_shetlandpony\", \"pony_ptr_id\")\n   760\t        with connection.schema_editor() as editor:\n   761\t            operation.database_forwards(\n   762\t                \"test_dlmtimo\", editor, project_state, new_state\n   763\t            )\n   764\t        self.assertTableExists(\"test_dlmtimo_pony\")\n   765\t        self.assertTableNotExists(\"test_dlmtimo_shetlandpony\")\n   766\t        # And test reversal\n   767\t        with connection.schema_editor() as editor:\n   768\t            operation.database_backwards(\n   769\t                \"test_dlmtimo\", editor, new_state, project_state\n   770\t            )\n   771\t        self.assertTableExists(\"test_dlmtimo_pony\")\n   772\t        self.assertTableExists(\"test_dlmtimo_shetlandpony\")\n   773\t        self.assertColumnExists(\"test_dlmtimo_shetlandpony\", \"pony_ptr_id\")\n   774\t\n   775\t    def test_rename_model(self):\n   776\t        \"\"\"\n   777\t        Tests the RenameModel operation.\n   778\t        \"\"\"\n   779\t        project_state = self.set_up_test_model(\"test_rnmo\", related_model=True)\n   780\t        # Test the state alteration\n   781\t        operation = migrations.RenameModel(\"Pony\", \"Horse\")\n   782\t        self.assertEqual(operation.describe(), \"Rename model Pony to Horse\")\n   783\t        self.assertEqual(operation.migration_name_fragment, \"rename_pony_horse\")\n   784\t        # Test initial state and database\n   785\t        self.assertIn((\"test_rnmo\", \"pony\"), project_state.models)\n   786\t        self.assertNotIn((\"test_rnmo\", \"horse\"), project_state.models)\n   787\t        self.assertTableExists(\"test_rnmo_pony\")\n   788\t        self.assertTableNotExists(\"test_rnmo_horse\")\n   789\t        if connection.features.supports_foreign_keys:\n   790\t            self.assertFKExists(\n   791\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_pony\", \"id\")\n   792\t            )\n   793\t            self.assertFKNotExists(\n   794\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_horse\", \"id\")\n   795\t            )\n   796\t        # Migrate forwards\n   797\t        new_state = project_state.clone()\n   798\t        atomic_rename = connection.features.supports_atomic_references_rename\n   799\t        new_state = self.apply_operations(\n   800\t            \"test_rnmo\", new_state, [operation], atomic=atomic_rename\n   801\t        )\n   802\t        # Test new state and database\n   803\t        self.assertNotIn((\"test_rnmo\", \"pony\"), new_state.models)\n   804\t        self.assertIn((\"test_rnmo\", \"horse\"), new_state.models)\n   805\t        # RenameModel also repoints all incoming FKs and M2Ms\n   806\t        self.assertEqual(\n   807\t            new_state.models[\"test_rnmo\", \"rider\"].fields[\"pony\"].remote_field.model,\n   808\t            \"test_rnmo.Horse\",\n   809\t        )\n   810\t        self.assertTableNotExists(\"test_rnmo_pony\")\n   811\t        self.assertTableExists(\"test_rnmo_horse\")\n   812\t        if connection.features.supports_foreign_keys:\n   813\t            self.assertFKNotExists(\n   814\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_pony\", \"id\")\n   815\t            )\n   816\t            self.assertFKExists(\n   817\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_horse\", \"id\")\n   818\t            )\n   819\t        # Migrate backwards\n   820\t        original_state = self.unapply_operations(\n   821\t            \"test_rnmo\", project_state, [operation], atomic=atomic_rename\n   822\t        )\n   823\t        # Test original state and database\n   824\t        self.assertIn((\"test_rnmo\", \"pony\"), original_state.models)\n   825\t        self.assertNotIn((\"test_rnmo\", \"horse\"), original_state.models)\n   826\t        self.assertEqual(\n   827\t            original_state.models[\"test_rnmo\", \"rider\"]\n   828\t            .fields[\"pony\"]\n   829\t            .remote_field.model,\n   830\t            \"Pony\",\n   831\t        )\n   832\t        self.assertTableExists(\"test_rnmo_pony\")\n   833\t        self.assertTableNotExists(\"test_rnmo_horse\")\n   834\t        if connection.features.supports_foreign_keys:\n   835\t            self.assertFKExists(\n   836\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_pony\", \"id\")\n   837\t            )\n   838\t            self.assertFKNotExists(\n   839\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_horse\", \"id\")\n   840\t            )\n   841\t        # And deconstruction\n   842\t        definition = operation.deconstruct()\n   843\t        self.assertEqual(definition[0], \"RenameModel\")\n   844\t        self.assertEqual(definition[1], [])\n   845\t        self.assertEqual(definition[2], {\"old_name\": \"Pony\", \"new_name\": \"Horse\"})\n   846\t\n   847\t    def test_rename_model_state_forwards(self):\n   848\t        \"\"\"\n   849\t        RenameModel operations shouldn't trigger the caching of rendered apps\n   850\t        on state without prior apps.\n   851\t        \"\"\"\n   852\t        state = ProjectState()\n   853\t        state.add_model(ModelState(\"migrations\", \"Foo\", []))\n   854\t        operation = migrations.RenameModel(\"Foo\", \"Bar\")\n   855\t        operation.state_forwards(\"migrations\", state)\n   856\t        self.assertNotIn(\"apps\", state.__dict__)\n   857\t        self.assertNotIn((\"migrations\", \"foo\"), state.models)\n   858\t        self.assertIn((\"migrations\", \"bar\"), state.models)\n   859\t        # Now with apps cached.\n   860\t        apps = state.apps\n   861\t        operation = migrations.RenameModel(\"Bar\", \"Foo\")\n   862\t        operation.state_forwards(\"migrations\", state)\n   863\t        self.assertIs(state.apps, apps)\n   864\t        self.assertNotIn((\"migrations\", \"bar\"), state.models)\n   865\t        self.assertIn((\"migrations\", \"foo\"), state.models)\n   866\t\n   867\t    def test_rename_model_with_self_referential_fk(self):\n   868\t        \"\"\"\n   869\t        Tests the RenameModel operation on model with self referential FK.\n   870\t        \"\"\"\n   871\t        project_state = self.set_up_test_model(\"test_rmwsrf\", related_model=True)\n   872\t        # Test the state alteration\n   873\t        operation = migrations.RenameModel(\"Rider\", \"HorseRider\")\n   874\t        self.assertEqual(operation.describe(), \"Rename model Rider to HorseRider\")\n   875\t        new_state = project_state.clone()\n   876\t        operation.state_forwards(\"test_rmwsrf\", new_state)\n   877\t        self.assertNotIn((\"test_rmwsrf\", \"rider\"), new_state.models)\n   878\t        self.assertIn((\"test_rmwsrf\", \"horserider\"), new_state.models)\n   879\t        # Remember, RenameModel also repoints all incoming FKs and M2Ms\n   880\t        self.assertEqual(\n   881\t            \"self\",\n   882\t            new_state.models[\"test_rmwsrf\", \"horserider\"]\n   883\t            .fields[\"friend\"]\n   884\t            .remote_field.model,\n   885\t        )\n   886\t        HorseRider = new_state.apps.get_model(\"test_rmwsrf\", \"horserider\")\n   887\t        self.assertIs(\n   888\t            HorseRider._meta.get_field(\"horserider\").remote_field.model, HorseRider\n   889\t        )\n   890\t        # Test the database alteration\n   891\t        self.assertTableExists(\"test_rmwsrf_rider\")\n   892\t        self.assertTableNotExists(\"test_rmwsrf_horserider\")\n   893\t        if connection.features.supports_foreign_keys:\n   894\t            self.assertFKExists(\n   895\t                \"test_rmwsrf_rider\", [\"friend_id\"], (\"test_rmwsrf_rider\", \"id\")\n   896\t            )\n   897\t            self.assertFKNotExists(\n   898\t                \"test_rmwsrf_rider\", [\"friend_id\"], (\"test_rmwsrf_horserider\", \"id\")\n   899\t            )\n   900\t        atomic_rename = connection.features.supports_atomic_references_rename\n   901\t        with connection.schema_editor(atomic=atomic_rename) as editor:\n   902\t            operation.database_forwards(\"test_rmwsrf\", editor, project_state, new_state)\n   903\t        self.assertTableNotExists(\"test_rmwsrf_rider\")\n   904\t        self.assertTableExists(\"test_rmwsrf_horserider\")\n   905\t        if connection.features.supports_foreign_keys:\n   906\t            self.assertFKNotExists(\n   907\t                \"test_rmwsrf_horserider\", [\"friend_id\"], (\"test_rmwsrf_rider\", \"id\")\n   908\t            )\n   909\t            self.assertFKExists(\n   910\t                \"test_rmwsrf_horserider\",\n   911\t                [\"friend_id\"],\n   912\t                (\"test_rmwsrf_horserider\", \"id\"),\n   913\t            )\n   914\t        # And test reversal\n   915\t        with connection.schema_editor(atomic=atomic_rename) as editor:\n   916\t            operation.database_backwards(\n   917\t                \"test_rmwsrf\", editor, new_state, project_state\n   918\t            )\n   919\t        self.assertTableExists(\"test_rmwsrf_rider\")\n   920\t        self.assertTableNotExists(\"test_rmwsrf_horserider\")\n   921\t        if connection.features.supports_foreign_keys:\n   922\t            self.assertFKExists(\n   923\t                \"test_rmwsrf_rider\", [\"friend_id\"], (\"test_rmwsrf_rider\", \"id\")\n   924\t            )\n   925\t            self.assertFKNotExists(\n   926\t                \"test_rmwsrf_rider\", [\"friend_id\"], (\"test_rmwsrf_horserider\", \"id\")\n   927\t            )\n   928\t\n   929\t    def test_rename_model_with_superclass_fk(self):\n   930\t        \"\"\"\n   931\t        Tests the RenameModel operation on a model which has a superclass that\n   932\t        has a foreign key.\n   933\t        \"\"\"\n   934\t        project_state = self.set_up_test_model(\n   935\t            \"test_rmwsc\", related_model=True, mti_model=True\n   936\t        )\n   937\t        # Test the state alteration\n   938\t        operation = migrations.RenameModel(\"ShetlandPony\", \"LittleHorse\")\n   939\t        self.assertEqual(\n   940\t            operation.describe(), \"Rename model ShetlandPony to LittleHorse\"\n   941\t        )\n   942\t        new_state = project_state.clone()\n   943\t        operation.state_forwards(\"test_rmwsc\", new_state)\n   944\t        self.assertNotIn((\"test_rmwsc\", \"shetlandpony\"), new_state.models)\n   945\t        self.assertIn((\"test_rmwsc\", \"littlehorse\"), new_state.models)\n   946\t        # RenameModel shouldn't repoint the superclass's relations, only local ones\n   947\t        self.assertEqual(\n   948\t            project_state.models[\"test_rmwsc\", \"rider\"]\n   949\t            .fields[\"pony\"]\n   950\t            .remote_field.model,\n   951\t            new_state.models[\"test_rmwsc\", \"rider\"].fields[\"pony\"].remote_field.model,\n   952\t        )\n   953\t        # Before running the migration we have a table for Shetland Pony, not\n   954\t        # Little Horse.\n   955\t        self.assertTableExists(\"test_rmwsc_shetlandpony\")\n   956\t        self.assertTableNotExists(\"test_rmwsc_littlehorse\")\n   957\t        if connection.features.supports_foreign_keys:\n   958\t            # and the foreign key on rider points to pony, not shetland pony\n   959\t            self.assertFKExists(\n   960\t                \"test_rmwsc_rider\", [\"pony_id\"], (\"test_rmwsc_pony\", \"id\")\n   961\t            )\n   962\t            self.assertFKNotExists(\n   963\t                \"test_rmwsc_rider\", [\"pony_id\"], (\"test_rmwsc_shetlandpony\", \"id\")\n   964\t            )\n   965\t        with connection.schema_editor(\n   966\t            atomic=connection.features.supports_atomic_references_rename\n   967\t        ) as editor:\n   968\t            operation.database_forwards(\"test_rmwsc\", editor, project_state, new_state)\n   969\t        # Now we have a little horse table, not shetland pony\n   970\t        self.assertTableNotExists(\"test_rmwsc_shetlandpony\")\n   971\t        self.assertTableExists(\"test_rmwsc_littlehorse\")\n   972\t        if connection.features.supports_foreign_keys:\n   973\t            # but the Foreign keys still point at pony, not little horse\n   974\t            self.assertFKExists(\n   975\t                \"test_rmwsc_rider\", [\"pony_id\"], (\"test_rmwsc_pony\", \"id\")\n   976\t            )\n   977\t            self.assertFKNotExists(\n   978\t                \"test_rmwsc_rider\", [\"pony_id\"], (\"test_rmwsc_littlehorse\", \"id\")\n   979\t            )\n   980\t\n   981\t    def test_rename_model_with_self_referential_m2m(self):\n   982\t        app_label = \"test_rename_model_with_self_referential_m2m\"\n   983\t\n   984\t        project_state = self.apply_operations(\n   985\t            app_label,\n   986\t            ProjectState(),\n   987\t            operations=[\n   988\t                migrations.CreateModel(\n   989\t                    \"ReflexivePony\",\n   990\t                    fields=[\n   991\t                        (\"id\", models.AutoField(primary_key=True)),\n   992\t                        (\"ponies\", models.ManyToManyField(\"self\")),\n   993\t                    ],\n   994\t                ),\n   995\t            ],\n   996\t        )\n   997\t        project_state = self.apply_operations(\n   998\t            app_label,\n   999\t            project_state,\n  1000\t            operations=[\n  1001\t                migrations.RenameModel(\"ReflexivePony\", \"ReflexivePony2\"),\n  1002\t            ],\n  1003\t            atomic=connection.features.supports_atomic_references_rename,\n  1004\t        )\n  1005\t        Pony = project_state.apps.get_model(app_label, \"ReflexivePony2\")\n  1006\t        pony = Pony.objects.create()\n  1007\t        pony.ponies.add(pony)\n  1008\t\n  1009\t    def test_rename_model_with_m2m(self):\n  1010\t        app_label = \"test_rename_model_with_m2m\"\n  1011\t        project_state = self.apply_operations(\n  1012\t            app_label,\n  1013\t            ProjectState(),\n  1014\t            operations=[\n  1015\t                migrations.CreateModel(\n  1016\t                    \"Rider\",\n  1017\t                    fields=[\n  1018\t                        (\"id\", models.AutoField(primary_key=True)),\n  1019\t                    ],\n  1020\t                ),\n  1021\t                migrations.CreateModel(\n  1022\t                    \"Pony\",\n  1023\t                    fields=[\n  1024\t                        (\"id\", models.AutoField(primary_key=True)),\n  1025\t                        (\"riders\", models.ManyToManyField(\"Rider\")),\n  1026\t                    ],\n  1027\t                ),\n  1028\t            ],\n  1029\t        )\n  1030\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1031\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1032\t        pony = Pony.objects.create()\n  1033\t        rider = Rider.objects.create()\n  1034\t        pony.riders.add(rider)\n  1035\t\n  1036\t        project_state = self.apply_operations(\n  1037\t            app_label,\n  1038\t            project_state,\n  1039\t            operations=[\n  1040\t                migrations.RenameModel(\"Pony\", \"Pony2\"),\n  1041\t            ],\n  1042\t            atomic=connection.features.supports_atomic_references_rename,\n  1043\t        )\n  1044\t        Pony = project_state.apps.get_model(app_label, \"Pony2\")\n  1045\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1046\t        pony = Pony.objects.create()\n  1047\t        rider = Rider.objects.create()\n  1048\t        pony.riders.add(rider)\n  1049\t        self.assertEqual(Pony.objects.count(), 2)\n  1050\t        self.assertEqual(Rider.objects.count(), 2)\n  1051\t        self.assertEqual(\n  1052\t            Pony._meta.get_field(\"riders\").remote_field.through.objects.count(), 2\n  1053\t        )\n  1054\t\n  1055\t    def test_rename_model_with_db_table_noop(self):\n  1056\t        app_label = \"test_rmwdbtn\"\n  1057\t        project_state = self.apply_operations(\n  1058\t            app_label,\n  1059\t            ProjectState(),\n  1060\t            operations=[\n  1061\t                migrations.CreateModel(\n  1062\t                    \"Rider\",\n  1063\t                    fields=[\n  1064\t                        (\"id\", models.AutoField(primary_key=True)),\n  1065\t                    ],\n  1066\t                    options={\"db_table\": \"rider\"},\n  1067\t                ),\n  1068\t                migrations.CreateModel(\n  1069\t                    \"Pony\",\n  1070\t                    fields=[\n  1071\t                        (\"id\", models.AutoField(primary_key=True)),\n  1072\t                        (\n  1073\t                            \"rider\",\n  1074\t                            models.ForeignKey(\"%s.Rider\" % app_label, models.CASCADE),\n  1075\t                        ),\n  1076\t                    ],\n  1077\t                ),\n  1078\t            ],\n  1079\t        )\n  1080\t        new_state = project_state.clone()\n  1081\t        operation = migrations.RenameModel(\"Rider\", \"Runner\")\n  1082\t        operation.state_forwards(app_label, new_state)\n  1083\t\n  1084\t        with connection.schema_editor() as editor:\n  1085\t            with self.assertNumQueries(0):\n  1086\t                operation.database_forwards(app_label, editor, project_state, new_state)\n  1087\t        with connection.schema_editor() as editor:\n  1088\t            with self.assertNumQueries(0):\n  1089\t                operation.database_backwards(\n  1090\t                    app_label, editor, new_state, project_state\n  1091\t                )\n  1092\t\n  1093\t    def test_rename_m2m_target_model(self):\n  1094\t        app_label = \"test_rename_m2m_target_model\"\n  1095\t        project_state = self.apply_operations(\n  1096\t            app_label,\n  1097\t            ProjectState(),\n  1098\t            operations=[\n  1099\t                migrations.CreateModel(\n  1100\t                    \"Rider\",\n  1101\t                    fields=[\n  1102\t                        (\"id\", models.AutoField(primary_key=True)),\n  1103\t                    ],\n  1104\t                ),\n  1105\t                migrations.CreateModel(\n  1106\t                    \"Pony\",\n  1107\t                    fields=[\n  1108\t                        (\"id\", models.AutoField(primary_key=True)),\n  1109\t                        (\"riders\", models.ManyToManyField(\"Rider\")),\n  1110\t                    ],\n  1111\t                ),\n  1112\t            ],\n  1113\t        )\n  1114\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1115\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1116\t        pony = Pony.objects.create()\n  1117\t        rider = Rider.objects.create()\n  1118\t        pony.riders.add(rider)\n  1119\t\n  1120\t        project_state = self.apply_operations(\n  1121\t            app_label,\n  1122\t            project_state,\n  1123\t            operations=[\n  1124\t                migrations.RenameModel(\"Rider\", \"Rider2\"),\n  1125\t            ],\n  1126\t            atomic=connection.features.supports_atomic_references_rename,\n  1127\t        )\n  1128\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1129\t        Rider = project_state.apps.get_model(app_label, \"Rider2\")\n  1130\t        pony = Pony.objects.create()\n  1131\t        rider = Rider.objects.create()\n  1132\t        pony.riders.add(rider)\n  1133\t        self.assertEqual(Pony.objects.count(), 2)\n  1134\t        self.assertEqual(Rider.objects.count(), 2)\n  1135\t        self.assertEqual(\n  1136\t            Pony._meta.get_field(\"riders\").remote_field.through.objects.count(), 2\n  1137\t        )\n  1138\t\n  1139\t    def test_rename_m2m_through_model(self):\n  1140\t        app_label = \"test_rename_through\"\n  1141\t        project_state = self.apply_operations(\n  1142\t            app_label,\n  1143\t            ProjectState(),\n  1144\t            operations=[\n  1145\t                migrations.CreateModel(\n  1146\t                    \"Rider\",\n  1147\t                    fields=[\n  1148\t                        (\"id\", models.AutoField(primary_key=True)),\n  1149\t                    ],\n  1150\t                ),\n  1151\t                migrations.CreateModel(\n  1152\t                    \"Pony\",\n  1153\t                    fields=[\n  1154\t                        (\"id\", models.AutoField(primary_key=True)),\n  1155\t                    ],\n  1156\t                ),\n  1157\t                migrations.CreateModel(\n  1158\t                    \"PonyRider\",\n  1159\t                    fields=[\n  1160\t                        (\"id\", models.AutoField(primary_key=True)),\n  1161\t                        (\n  1162\t                            \"rider\",\n  1163\t                            models.ForeignKey(\n  1164\t                                \"test_rename_through.Rider\", models.CASCADE\n  1165\t                            ),\n  1166\t                        ),\n  1167\t                        (\n  1168\t                            \"pony\",\n  1169\t                            models.ForeignKey(\n  1170\t                                \"test_rename_through.Pony\", models.CASCADE\n  1171\t                            ),\n  1172\t                        ),\n  1173\t                    ],\n  1174\t                ),\n  1175\t                migrations.AddField(\n  1176\t                    \"Pony\",\n  1177\t                    \"riders\",\n  1178\t                    models.ManyToManyField(\n  1179\t                        \"test_rename_through.Rider\",\n  1180\t                        through=\"test_rename_through.PonyRider\",\n  1181\t                    ),\n  1182\t                ),\n  1183\t            ],\n  1184\t        )\n  1185\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1186\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1187\t        PonyRider = project_state.apps.get_model(app_label, \"PonyRider\")\n  1188\t        pony = Pony.objects.create()\n  1189\t        rider = Rider.objects.create()\n  1190\t        PonyRider.objects.create(pony=pony, rider=rider)\n  1191\t\n  1192\t        project_state = self.apply_operations(\n  1193\t            app_label,\n  1194\t            project_state,\n  1195\t            operations=[\n  1196\t                migrations.RenameModel(\"PonyRider\", \"PonyRider2\"),\n  1197\t            ],\n  1198\t        )\n  1199\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1200\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1201\t        PonyRider = project_state.apps.get_model(app_label, \"PonyRider2\")\n  1202\t        pony = Pony.objects.first()\n  1203\t        rider = Rider.objects.create()\n  1204\t        PonyRider.objects.create(pony=pony, rider=rider)\n  1205\t        self.assertEqual(Pony.objects.count(), 1)\n  1206\t        self.assertEqual(Rider.objects.count(), 2)\n  1207\t        self.assertEqual(PonyRider.objects.count(), 2)\n  1208\t        self.assertEqual(pony.riders.count(), 2)\n  1209\t\n  1210\t    def test_rename_m2m_model_after_rename_field(self):\n  1211\t        \"\"\"RenameModel renames a many-to-many column after a RenameField.\"\"\"\n  1212\t        app_label = \"test_rename_multiple\"\n  1213\t        project_state = self.apply_operations(\n  1214\t            app_label,\n  1215\t            ProjectState(),\n  1216\t            operations=[\n  1217\t                migrations.CreateModel(\n  1218\t                    \"Pony\",\n  1219\t                    fields=[\n  1220\t                        (\"id\", models.AutoField(primary_key=True)),\n  1221\t                        (\"name\", models.CharField(max_length=20)),\n  1222\t                    ],\n  1223\t                ),\n  1224\t                migrations.CreateModel(\n  1225\t                    \"Rider\",\n  1226\t                    fields=[\n  1227\t                        (\"id\", models.AutoField(primary_key=True)),\n  1228\t                        (\n  1229\t                            \"pony\",\n  1230\t                            models.ForeignKey(\n  1231\t                                \"test_rename_multiple.Pony\", models.CASCADE\n  1232\t                            ),\n  1233\t                        ),\n  1234\t                    ],\n  1235\t                ),\n  1236\t                migrations.CreateModel(\n  1237\t                    \"PonyRider\",\n  1238\t                    fields=[\n  1239\t                        (\"id\", models.AutoField(primary_key=True)),\n  1240\t                        (\"riders\", models.ManyToManyField(\"Rider\")),\n  1241\t                    ],\n  1242\t                ),\n  1243\t                migrations.RenameField(\n  1244\t                    model_name=\"pony\", old_name=\"name\", new_name=\"fancy_name\"\n  1245\t                ),\n  1246\t                migrations.RenameModel(old_name=\"Rider\", new_name=\"Jockey\"),\n  1247\t            ],\n  1248\t            atomic=connection.features.supports_atomic_references_rename,\n  1249\t        )\n  1250\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1251\t        Jockey = project_state.apps.get_model(app_label, \"Jockey\")\n  1252\t        PonyRider = project_state.apps.get_model(app_label, \"PonyRider\")\n  1253\t        # No \"no such column\" error means the column was renamed correctly.\n  1254\t        pony = Pony.objects.create(fancy_name=\"a good name\")\n  1255\t        jockey = Jockey.objects.create(pony=pony)\n  1256\t        ponyrider = PonyRider.objects.create()\n  1257\t        ponyrider.riders.add(jockey)\n  1258\t\n  1259\t    def test_add_field(self):\n  1260\t        \"\"\"\n  1261\t        Tests the AddField operation.\n  1262\t        \"\"\"\n  1263\t        # Test the state alteration\n  1264\t        operation = migrations.AddField(\n  1265\t            \"Pony\",\n  1266\t            \"height\",\n  1267\t            models.FloatField(null=True, default=5),\n  1268\t        )\n  1269\t        self.assertEqual(operation.describe(), \"Add field height to Pony\")\n  1270\t        self.assertEqual(operation.migration_name_fragment, \"pony_height\")\n  1271\t        project_state, new_state = self.make_test_state(\"test_adfl\", operation)\n  1272\t        self.assertEqual(len(new_state.models[\"test_adfl\", \"pony\"].fields), 4)\n  1273\t        field = new_state.models[\"test_adfl\", \"pony\"].fields[\"height\"]\n  1274\t        self.assertEqual(field.default, 5)\n  1275\t        # Test the database alteration\n  1276\t        self.assertColumnNotExists(\"test_adfl_pony\", \"height\")\n  1277\t        with connection.schema_editor() as editor:\n  1278\t            operation.database_forwards(\"test_adfl\", editor, project_state, new_state)\n  1279\t        self.assertColumnExists(\"test_adfl_pony\", \"height\")\n  1280\t        # And test reversal\n  1281\t        with connection.schema_editor() as editor:\n  1282\t            operation.database_backwards(\"test_adfl\", editor, new_state, project_state)\n  1283\t        self.assertColumnNotExists(\"test_adfl_pony\", \"height\")\n  1284\t        # And deconstruction\n  1285\t        definition = operation.deconstruct()\n  1286\t        self.assertEqual(definition[0], \"AddField\")\n  1287\t        self.assertEqual(definition[1], [])\n  1288\t        self.assertEqual(sorted(definition[2]), [\"field\", \"model_name\", \"name\"])\n  1289\t\n  1290\t    def test_add_charfield(self):\n  1291\t        \"\"\"\n  1292\t        Tests the AddField operation on TextField.\n  1293\t        \"\"\"\n  1294\t        project_state = self.set_up_test_model(\"test_adchfl\")\n  1295\t\n  1296\t        Pony = project_state.apps.get_model(\"test_adchfl\", \"Pony\")\n  1297\t        pony = Pony.objects.create(weight=42)\n  1298\t\n  1299\t        new_state = self.apply_operations(\n  1300\t            \"test_adchfl\",\n  1301\t            project_state,\n  1302\t            [\n  1303\t                migrations.AddField(\n  1304\t                    \"Pony\",\n  1305\t                    \"text\",\n  1306\t                    models.CharField(max_length=10, default=\"some text\"),\n  1307\t                ),\n  1308\t                migrations.AddField(\n  1309\t                    \"Pony\",\n  1310\t                    \"empty\",\n  1311\t                    models.CharField(max_length=10, default=\"\"),\n  1312\t                ),\n  1313\t                # If not properly quoted digits would be interpreted as an int.\n  1314\t                migrations.AddField(\n  1315\t                    \"Pony\",\n  1316\t                    \"digits\",\n  1317\t                    models.CharField(max_length=10, default=\"42\"),\n  1318\t                ),\n  1319\t                # Manual quoting is fragile and could trip on quotes. Refs #xyz.\n  1320\t                migrations.AddField(\n  1321\t                    \"Pony\",\n  1322\t                    \"quotes\",\n  1323\t                    models.CharField(max_length=10, default='\"\\'\"'),\n  1324\t                ),\n  1325\t            ],\n  1326\t        )\n  1327\t\n  1328\t        Pony = new_state.apps.get_model(\"test_adchfl\", \"Pony\")\n  1329\t        pony = Pony.objects.get(pk=pony.pk)\n  1330\t        self.assertEqual(pony.text, \"some text\")\n  1331\t        self.assertEqual(pony.empty, \"\")\n  1332\t        self.assertEqual(pony.digits, \"42\")\n  1333\t        self.assertEqual(pony.quotes, '\"\\'\"')\n  1334\t\n  1335\t    def test_add_textfield(self):\n  1336\t        \"\"\"\n  1337\t        Tests the AddField operation on TextField.\n  1338\t        \"\"\"\n  1339\t        project_state = self.set_up_test_model(\"test_adtxtfl\")\n  1340\t\n  1341\t        Pony = project_state.apps.get_model(\"test_adtxtfl\", \"Pony\")\n  1342\t        pony = Pony.objects.create(weight=42)\n  1343\t\n  1344\t        new_state = self.apply_operations(\n  1345\t            \"test_adtxtfl\",\n  1346\t            project_state,\n  1347\t            [\n  1348\t                migrations.AddField(\n  1349\t                    \"Pony\",\n  1350\t                    \"text\",\n  1351\t                    models.TextField(default=\"some text\"),\n  1352\t                ),\n  1353\t                migrations.AddField(\n  1354\t                    \"Pony\",\n  1355\t                    \"empty\",\n  1356\t                    models.TextField(default=\"\"),\n  1357\t                ),\n  1358\t                # If not properly quoted digits would be interpreted as an int.\n  1359\t                migrations.AddField(\n  1360\t                    \"Pony\",\n  1361\t                    \"digits\",\n  1362\t                    models.TextField(default=\"42\"),\n  1363\t                ),\n  1364\t                # Manual quoting is fragile and could trip on quotes. Refs #xyz.\n  1365\t                migrations.AddField(\n  1366\t                    \"Pony\",\n  1367\t                    \"quotes\",\n  1368\t                    models.TextField(default='\"\\'\"'),\n  1369\t                ),\n  1370\t            ],\n  1371\t        )\n  1372\t\n  1373\t        Pony = new_state.apps.get_model(\"test_adtxtfl\", \"Pony\")\n  1374\t        pony = Pony.objects.get(pk=pony.pk)\n  1375\t        self.assertEqual(pony.text, \"some text\")\n  1376\t        self.assertEqual(pony.empty, \"\")\n  1377\t        self.assertEqual(pony.digits, \"42\")\n  1378\t        self.assertEqual(pony.quotes, '\"\\'\"')\n  1379\t\n  1380\t    def test_add_binaryfield(self):\n  1381\t        \"\"\"\n  1382\t        Tests the AddField operation on TextField/BinaryField.\n  1383\t        \"\"\"\n  1384\t        project_state = self.set_up_test_model(\"test_adbinfl\")\n  1385\t\n  1386\t        Pony = project_state.apps.get_model(\"test_adbinfl\", \"Pony\")\n  1387\t        pony = Pony.objects.create(weight=42)\n  1388\t\n  1389\t        new_state = self.apply_operations(\n  1390\t            \"test_adbinfl\",\n  1391\t            project_state,\n  1392\t            [\n  1393\t                migrations.AddField(\n  1394\t                    \"Pony\",\n  1395\t                    \"blob\",\n  1396\t                    models.BinaryField(default=b\"some text\"),\n  1397\t                ),\n  1398\t                migrations.AddField(\n  1399\t                    \"Pony\",\n  1400\t                    \"empty\",\n  1401\t                    models.BinaryField(default=b\"\"),\n  1402\t                ),\n  1403\t                # If not properly quoted digits would be interpreted as an int.\n  1404\t                migrations.AddField(\n  1405\t                    \"Pony\",\n  1406\t                    \"digits\",\n  1407\t                    models.BinaryField(default=b\"42\"),\n  1408\t                ),\n  1409\t                # Manual quoting is fragile and could trip on quotes. Refs #xyz.\n  1410\t                migrations.AddField(\n  1411\t                    \"Pony\",\n  1412\t                    \"quotes\",\n  1413\t                    models.BinaryField(default=b'\"\\'\"'),\n  1414\t                ),\n  1415\t            ],\n  1416\t        )\n  1417\t\n  1418\t        Pony = new_state.apps.get_model(\"test_adbinfl\", \"Pony\")\n  1419\t        pony = Pony.objects.get(pk=pony.pk)\n  1420\t        # SQLite returns buffer/memoryview, cast to bytes for checking.\n  1421\t        self.assertEqual(bytes(pony.blob), b\"some text\")\n  1422\t        self.assertEqual(bytes(pony.empty), b\"\")\n  1423\t        self.assertEqual(bytes(pony.digits), b\"42\")\n  1424\t        self.assertEqual(bytes(pony.quotes), b'\"\\'\"')\n  1425\t\n  1426\t    def test_column_name_quoting(self):\n  1427\t        \"\"\"\n  1428\t        Column names that are SQL keywords shouldn't cause problems when used\n  1429\t        in migrations (#22168).\n  1430\t        \"\"\"\n  1431\t        project_state = self.set_up_test_model(\"test_regr22168\")\n  1432\t        operation = migrations.AddField(\n  1433\t            \"Pony\",\n  1434\t            \"order\",\n  1435\t            models.IntegerField(default=0),\n  1436\t        )\n  1437\t        new_state = project_state.clone()\n  1438\t        operation.state_forwards(\"test_regr22168\", new_state)\n  1439\t        with connection.schema_editor() as editor:\n  1440\t            operation.database_forwards(\n  1441\t                \"test_regr22168\", editor, project_state, new_state\n  1442\t            )\n  1443\t        self.assertColumnExists(\"test_regr22168_pony\", \"order\")\n  1444\t\n  1445\t    def test_add_field_preserve_default(self):\n  1446\t        \"\"\"\n  1447\t        Tests the AddField operation's state alteration\n  1448\t        when preserve_default = False.\n  1449\t        \"\"\"\n  1450\t        project_state = self.set_up_test_model(\"test_adflpd\")\n  1451\t        # Test the state alteration\n  1452\t        operation = migrations.AddField(\n  1453\t            \"Pony\",\n  1454\t            \"height\",\n  1455\t            models.FloatField(null=True, default=4),\n  1456\t            preserve_default=False,\n  1457\t        )\n  1458\t        new_state = project_state.clone()\n  1459\t        operation.state_forwards(\"test_adflpd\", new_state)\n  1460\t        self.assertEqual(len(new_state.models[\"test_adflpd\", \"pony\"].fields), 4)\n  1461\t        field = new_state.models[\"test_adflpd\", \"pony\"].fields[\"height\"]\n  1462\t        self.assertEqual(field.default, models.NOT_PROVIDED)\n  1463\t        # Test the database alteration\n  1464\t        project_state.apps.get_model(\"test_adflpd\", \"pony\").objects.create(\n  1465\t            weight=4,\n  1466\t        )\n  1467\t        self.assertColumnNotExists(\"test_adflpd_pony\", \"height\")\n  1468\t        with connection.schema_editor() as editor:\n  1469\t            operation.database_forwards(\"test_adflpd\", editor, project_state, new_state)\n  1470\t        self.assertColumnExists(\"test_adflpd_pony\", \"height\")\n  1471\t        # And deconstruction\n  1472\t        definition = operation.deconstruct()\n  1473\t        self.assertEqual(definition[0], \"AddField\")\n  1474\t        self.assertEqual(definition[1], [])\n  1475\t        self.assertEqual(\n  1476\t            sorted(definition[2]), [\"field\", \"model_name\", \"name\", \"preserve_default\"]\n  1477\t        )\n  1478\t\n  1479\t    def test_add_field_m2m(self):\n  1480\t        \"\"\"\n  1481\t        Tests the AddField operation with a ManyToManyField.\n  1482\t        \"\"\"\n  1483\t        project_state = self.set_up_test_model(\"test_adflmm\", second_model=True)\n  1484\t        # Test the state alteration\n  1485\t        operation = migrations.AddField(\n  1486\t            \"Pony\", \"stables\", models.ManyToManyField(\"Stable\", related_name=\"ponies\")\n  1487\t        )\n  1488\t        new_state = project_state.clone()\n  1489\t        operation.state_forwards(\"test_adflmm\", new_state)\n  1490\t        self.assertEqual(len(new_state.models[\"test_adflmm\", \"pony\"].fields), 4)\n  1491\t        # Test the database alteration\n  1492\t        self.assertTableNotExists(\"test_adflmm_pony_stables\")\n  1493\t        with connection.schema_editor() as editor:\n  1494\t            operation.database_forwards(\"test_adflmm\", editor, project_state, new_state)\n  1495\t        self.assertTableExists(\"test_adflmm_pony_stables\")\n  1496\t        self.assertColumnNotExists(\"test_adflmm_pony\", \"stables\")\n  1497\t        # Make sure the M2M field actually works\n  1498\t        with atomic():\n  1499\t            Pony = new_state.apps.get_model(\"test_adflmm\", \"Pony\")\n  1500\t            p = Pony.objects.create(pink=False, weight=4.55)\n  1501\t            p.stables.create()\n  1502\t            self.assertEqual(p.stables.count(), 1)\n  1503\t            p.stables.all().delete()\n  1504\t        # And test reversal\n  1505\t        with connection.schema_editor() as editor:\n  1506\t            operation.database_backwards(\n  1507\t                \"test_adflmm\", editor, new_state, project_state\n  1508\t            )\n  1509\t        self.assertTableNotExists(\"test_adflmm_pony_stables\")\n  1510\t\n  1511\t    def test_alter_field_m2m(self):\n  1512\t        project_state = self.set_up_test_model(\"test_alflmm\", second_model=True)\n  1513\t\n  1514\t        project_state = self.apply_operations(\n  1515\t            \"test_alflmm\",\n  1516\t            project_state,\n  1517\t            operations=[\n  1518\t                migrations.AddField(\n  1519\t                    \"Pony\",\n  1520\t                    \"stables\",\n  1521\t                    models.ManyToManyField(\"Stable\", related_name=\"ponies\"),\n  1522\t                )\n  1523\t            ],\n  1524\t        )\n  1525\t        Pony = project_state.apps.get_model(\"test_alflmm\", \"Pony\")\n  1526\t        self.assertFalse(Pony._meta.get_field(\"stables\").blank)\n  1527\t\n  1528\t        project_state = self.apply_operations(\n  1529\t            \"test_alflmm\",\n  1530\t            project_state,\n  1531\t            operations=[\n  1532\t                migrations.AlterField(\n  1533\t                    \"Pony\",\n  1534\t                    \"stables\",\n  1535\t                    models.ManyToManyField(\n  1536\t                        to=\"Stable\", related_name=\"ponies\", blank=True\n  1537\t                    ),\n  1538\t                )\n  1539\t            ],\n  1540\t        )\n  1541\t        Pony = project_state.apps.get_model(\"test_alflmm\", \"Pony\")\n  1542\t        self.assertTrue(Pony._meta.get_field(\"stables\").blank)\n  1543\t\n  1544\t    def test_repoint_field_m2m(self):\n  1545\t        project_state = self.set_up_test_model(\n  1546\t            \"test_alflmm\", second_model=True, third_model=True\n  1547\t        )\n  1548\t\n  1549\t        project_state = self.apply_operations(\n  1550\t            \"test_alflmm\",\n  1551\t            project_state,\n  1552\t            operations=[\n  1553\t                migrations.AddField(\n  1554\t                    \"Pony\",\n  1555\t                    \"places\",\n  1556\t                    models.ManyToManyField(\"Stable\", related_name=\"ponies\"),\n  1557\t                )\n  1558\t            ],\n  1559\t        )\n  1560\t        Pony = project_state.apps.get_model(\"test_alflmm\", \"Pony\")\n  1561\t\n  1562\t        project_state = self.apply_operations(\n  1563\t            \"test_alflmm\",\n  1564\t            project_state,\n  1565\t            operations=[\n  1566\t                migrations.AlterField(\n  1567\t                    \"Pony\",\n  1568\t                    \"places\",\n  1569\t                    models.ManyToManyField(to=\"Van\", related_name=\"ponies\"),\n  1570\t                )\n  1571\t            ],\n  1572\t        )\n  1573\t\n  1574\t        # Ensure the new field actually works\n  1575\t        Pony = project_state.apps.get_model(\"test_alflmm\", \"Pony\")\n  1576\t        p = Pony.objects.create(pink=False, weight=4.55)\n  1577\t        p.places.create()\n  1578\t        self.assertEqual(p.places.count(), 1)\n  1579\t        p.places.all().delete()\n  1580\t\n  1581\t    def test_remove_field_m2m(self):\n  1582\t        project_state = self.set_up_test_model(\"test_rmflmm\", second_model=True)\n  1583\t\n  1584\t        project_state = self.apply_operations(\n  1585\t            \"test_rmflmm\",\n  1586\t            project_state,\n  1587\t            operations=[\n  1588\t                migrations.AddField(\n  1589\t                    \"Pony\",\n  1590\t                    \"stables\",\n  1591\t                    models.ManyToManyField(\"Stable\", related_name=\"ponies\"),\n  1592\t                )\n  1593\t            ],\n  1594\t        )\n  1595\t        self.assertTableExists(\"test_rmflmm_pony_stables\")\n  1596\t\n  1597\t        with_field_state = project_state.clone()\n  1598\t        operations = [migrations.RemoveField(\"Pony\", \"stables\")]\n  1599\t        project_state = self.apply_operations(\n  1600\t            \"test_rmflmm\", project_state, operations=operations\n  1601\t        )\n  1602\t        self.assertTableNotExists(\"test_rmflmm_pony_stables\")\n  1603\t\n  1604\t        # And test reversal\n  1605\t        self.unapply_operations(\"test_rmflmm\", with_field_state, operations=operations)\n  1606\t        self.assertTableExists(\"test_rmflmm_pony_stables\")\n  1607\t\n  1608\t    def test_remove_field_m2m_with_through(self):\n  1609\t        project_state = self.set_up_test_model(\"test_rmflmmwt\", second_model=True)\n  1610\t\n  1611\t        self.assertTableNotExists(\"test_rmflmmwt_ponystables\")\n  1612\t        project_state = self.apply_operations(\n  1613\t            \"test_rmflmmwt\",\n  1614\t            project_state,\n  1615\t            operations=[\n  1616\t                migrations.CreateModel(\n  1617\t                    \"PonyStables\",\n  1618\t                    fields=[\n  1619\t                        (\n  1620\t                            \"pony\",\n  1621\t                            models.ForeignKey(\"test_rmflmmwt.Pony\", models.CASCADE),\n  1622\t                        ),\n  1623\t                        (\n  1624\t                            \"stable\",\n  1625\t                            models.ForeignKey(\"test_rmflmmwt.Stable\", models.CASCADE),\n  1626\t                        ),\n  1627\t                    ],\n  1628\t                ),\n  1629\t                migrations.AddField(\n  1630\t                    \"Pony\",\n  1631\t                    \"stables\",\n  1632\t                    models.ManyToManyField(\n  1633\t                        \"Stable\",\n  1634\t                        related_name=\"ponies\",\n  1635\t                        through=\"test_rmflmmwt.PonyStables\",\n  1636\t                    ),\n  1637\t                ),\n  1638\t            ],\n  1639\t        )\n  1640\t        self.assertTableExists(\"test_rmflmmwt_ponystables\")\n  1641\t\n  1642\t        operations = [\n  1643\t            migrations.RemoveField(\"Pony\", \"stables\"),\n  1644\t            migrations.DeleteModel(\"PonyStables\"),\n  1645\t        ]\n  1646\t        self.apply_operations(\"test_rmflmmwt\", project_state, operations=operations)\n  1647\t\n  1648\t    def test_remove_field(self):\n  1649\t        \"\"\"\n  1650\t        Tests the RemoveField operation.\n  1651\t        \"\"\"\n  1652\t        project_state = self.set_up_test_model(\"test_rmfl\")\n  1653\t        # Test the state alteration\n  1654\t        operation = migrations.RemoveField(\"Pony\", \"pink\")\n  1655\t        self.assertEqual(operation.describe(), \"Remove field pink from Pony\")\n  1656\t        self.assertEqual(operation.migration_name_fragment, \"remove_pony_pink\")\n  1657\t        new_state = project_state.clone()\n  1658\t        operation.state_forwards(\"test_rmfl\", new_state)\n  1659\t        self.assertEqual(len(new_state.models[\"test_rmfl\", \"pony\"].fields), 2)\n  1660\t        # Test the database alteration\n  1661\t        self.assertColumnExists(\"test_rmfl_pony\", \"pink\")\n  1662\t        with connection.schema_editor() as editor:\n  1663\t            operation.database_forwards(\"test_rmfl\", editor, project_state, new_state)\n  1664\t        self.assertColumnNotExists(\"test_rmfl_pony\", \"pink\")\n  1665\t        # And test reversal\n  1666\t        with connection.schema_editor() as editor:\n  1667\t            operation.database_backwards(\"test_rmfl\", editor, new_state, project_state)\n  1668\t        self.assertColumnExists(\"test_rmfl_pony\", \"pink\")\n  1669\t        # And deconstruction\n  1670\t        definition = operation.deconstruct()\n  1671\t        self.assertEqual(definition[0], \"RemoveField\")\n  1672\t        self.assertEqual(definition[1], [])\n  1673\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"name\": \"pink\"})\n  1674\t\n  1675\t    def test_remove_fk(self):\n  1676\t        \"\"\"\n  1677\t        Tests the RemoveField operation on a foreign key.\n  1678\t        \"\"\"\n  1679\t        project_state = self.set_up_test_model(\"test_rfk\", related_model=True)\n  1680\t        self.assertColumnExists(\"test_rfk_rider\", \"pony_id\")\n  1681\t        operation = migrations.RemoveField(\"Rider\", \"pony\")\n  1682\t\n  1683\t        new_state = project_state.clone()\n  1684\t        operation.state_forwards(\"test_rfk\", new_state)\n  1685\t        with connection.schema_editor() as editor:\n  1686\t            operation.database_forwards(\"test_rfk\", editor, project_state, new_state)\n  1687\t        self.assertColumnNotExists(\"test_rfk_rider\", \"pony_id\")\n  1688\t        with connection.schema_editor() as editor:\n  1689\t            operation.database_backwards(\"test_rfk\", editor, new_state, project_state)\n  1690\t        self.assertColumnExists(\"test_rfk_rider\", \"pony_id\")\n  1691\t\n  1692\t    def test_alter_model_table(self):\n  1693\t        \"\"\"\n  1694\t        Tests the AlterModelTable operation.\n  1695\t        \"\"\"\n  1696\t        project_state = self.set_up_test_model(\"test_almota\")\n  1697\t        # Test the state alteration\n  1698\t        operation = migrations.AlterModelTable(\"Pony\", \"test_almota_pony_2\")\n  1699\t        self.assertEqual(\n  1700\t            operation.describe(), \"Rename table for Pony to test_almota_pony_2\"\n  1701\t        )\n  1702\t        self.assertEqual(operation.migration_name_fragment, \"alter_pony_table\")\n  1703\t        new_state = project_state.clone()\n  1704\t        operation.state_forwards(\"test_almota\", new_state)\n  1705\t        self.assertEqual(\n  1706\t            new_state.models[\"test_almota\", \"pony\"].options[\"db_table\"],\n  1707\t            \"test_almota_pony_2\",\n  1708\t        )\n  1709\t        # Test the database alteration\n  1710\t        self.assertTableExists(\"test_almota_pony\")\n  1711\t        self.assertTableNotExists(\"test_almota_pony_2\")\n  1712\t        with connection.schema_editor() as editor:\n  1713\t            operation.database_forwards(\"test_almota\", editor, project_state, new_state)\n  1714\t        self.assertTableNotExists(\"test_almota_pony\")\n  1715\t        self.assertTableExists(\"test_almota_pony_2\")\n  1716\t        # And test reversal\n  1717\t        with connection.schema_editor() as editor:\n  1718\t            operation.database_backwards(\n  1719\t                \"test_almota\", editor, new_state, project_state\n  1720\t            )\n  1721\t        self.assertTableExists(\"test_almota_pony\")\n  1722\t        self.assertTableNotExists(\"test_almota_pony_2\")\n  1723\t        # And deconstruction\n  1724\t        definition = operation.deconstruct()\n  1725\t        self.assertEqual(definition[0], \"AlterModelTable\")\n  1726\t        self.assertEqual(definition[1], [])\n  1727\t        self.assertEqual(definition[2], {\"name\": \"Pony\", \"table\": \"test_almota_pony_2\"})\n  1728\t\n  1729\t    def test_alter_model_table_none(self):\n  1730\t        \"\"\"\n  1731\t        Tests the AlterModelTable operation if the table name is set to None.\n  1732\t        \"\"\"\n  1733\t        operation = migrations.AlterModelTable(\"Pony\", None)\n  1734\t        self.assertEqual(operation.describe(), \"Rename table for Pony to (default)\")\n  1735\t\n  1736\t    def test_alter_model_table_noop(self):\n  1737\t        \"\"\"\n  1738\t        Tests the AlterModelTable operation if the table name is not changed.\n  1739\t        \"\"\"\n  1740\t        project_state = self.set_up_test_model(\"test_almota\")\n  1741\t        # Test the state alteration\n  1742\t        operation = migrations.AlterModelTable(\"Pony\", \"test_almota_pony\")\n  1743\t        new_state = project_state.clone()\n  1744\t        operation.state_forwards(\"test_almota\", new_state)\n  1745\t        self.assertEqual(\n  1746\t            new_state.models[\"test_almota\", \"pony\"].options[\"db_table\"],\n  1747\t            \"test_almota_pony\",\n  1748\t        )\n  1749\t        # Test the database alteration\n  1750\t        self.assertTableExists(\"test_almota_pony\")\n  1751\t        with connection.schema_editor() as editor:\n  1752\t            operation.database_forwards(\"test_almota\", editor, project_state, new_state)\n  1753\t        self.assertTableExists(\"test_almota_pony\")\n  1754\t        # And test reversal\n  1755\t        with connection.schema_editor() as editor:\n  1756\t            operation.database_backwards(\n  1757\t                \"test_almota\", editor, new_state, project_state\n  1758\t            )\n  1759\t        self.assertTableExists(\"test_almota_pony\")\n  1760\t\n  1761\t    def test_alter_model_table_m2m(self):\n  1762\t        \"\"\"\n  1763\t        AlterModelTable should rename auto-generated M2M tables.\n  1764\t        \"\"\"\n  1765\t        app_label = \"test_talflmltlm2m\"\n  1766\t        pony_db_table = \"pony_foo\"\n  1767\t        project_state = self.set_up_test_model(\n  1768\t            app_label, second_model=True, db_table=pony_db_table\n  1769\t        )\n  1770\t        # Add the M2M field\n  1771\t        first_state = project_state.clone()\n  1772\t        operation = migrations.AddField(\n  1773\t            \"Pony\", \"stables\", models.ManyToManyField(\"Stable\")\n  1774\t        )\n  1775\t        operation.state_forwards(app_label, first_state)\n  1776\t        with connection.schema_editor() as editor:\n  1777\t            operation.database_forwards(app_label, editor, project_state, first_state)\n  1778\t        original_m2m_table = \"%s_%s\" % (pony_db_table, \"stables\")\n  1779\t        new_m2m_table = \"%s_%s\" % (app_label, \"pony_stables\")\n  1780\t        self.assertTableExists(original_m2m_table)\n  1781\t        self.assertTableNotExists(new_m2m_table)\n  1782\t        # Rename the Pony db_table which should also rename the m2m table.\n  1783\t        second_state = first_state.clone()\n  1784\t        operation = migrations.AlterModelTable(name=\"pony\", table=None)\n  1785\t        operation.state_forwards(app_label, second_state)\n  1786\t        atomic_rename = connection.features.supports_atomic_references_rename\n  1787\t        with connection.schema_editor(atomic=atomic_rename) as editor:\n  1788\t            operation.database_forwards(app_label, editor, first_state, second_state)\n  1789\t        self.assertTableExists(new_m2m_table)\n  1790\t        self.assertTableNotExists(original_m2m_table)\n  1791\t        # And test reversal\n  1792\t        with connection.schema_editor(atomic=atomic_rename) as editor:\n  1793\t            operation.database_backwards(app_label, editor, second_state, first_state)\n  1794\t        self.assertTableExists(original_m2m_table)\n  1795\t        self.assertTableNotExists(new_m2m_table)\n  1796\t\n  1797\t    def test_alter_field(self):\n  1798\t        \"\"\"\n  1799\t        Tests the AlterField operation.\n  1800\t        \"\"\"\n  1801\t        project_state = self.set_up_test_model(\"test_alfl\")\n  1802\t        # Test the state alteration\n  1803\t        operation = migrations.AlterField(\n  1804\t            \"Pony\", \"pink\", models.IntegerField(null=True)\n  1805\t        )\n  1806\t        self.assertEqual(operation.describe(), \"Alter field pink on Pony\")\n  1807\t        self.assertEqual(operation.migration_name_fragment, \"alter_pony_pink\")\n  1808\t        new_state = project_state.clone()\n  1809\t        operation.state_forwards(\"test_alfl\", new_state)\n  1810\t        self.assertIs(\n  1811\t            project_state.models[\"test_alfl\", \"pony\"].fields[\"pink\"].null, False\n  1812\t        )\n  1813\t        self.assertIs(new_state.models[\"test_alfl\", \"pony\"].fields[\"pink\"].null, True)\n  1814\t        # Test the database alteration\n  1815\t        self.assertColumnNotNull(\"test_alfl_pony\", \"pink\")\n  1816\t        with connection.schema_editor() as editor:\n  1817\t            operation.database_forwards(\"test_alfl\", editor, project_state, new_state)\n  1818\t        self.assertColumnNull(\"test_alfl_pony\", \"pink\")\n  1819\t        # And test reversal\n  1820\t        with connection.schema_editor() as editor:\n  1821\t            operation.database_backwards(\"test_alfl\", editor, new_state, project_state)\n  1822\t        self.assertColumnNotNull(\"test_alfl_pony\", \"pink\")\n  1823\t        # And deconstruction\n  1824\t        definition = operation.deconstruct()\n  1825\t        self.assertEqual(definition[0], \"AlterField\")\n  1826\t        self.assertEqual(definition[1], [])\n  1827\t        self.assertEqual(sorted(definition[2]), [\"field\", \"model_name\", \"name\"])\n  1828\t\n  1829\t    def test_alter_field_add_db_column_noop(self):\n  1830\t        \"\"\"\n  1831\t        AlterField operation is a noop when adding only a db_column and the\n  1832\t        column name is not changed.\n  1833\t        \"\"\"\n  1834\t        app_label = \"test_afadbn\"\n  1835\t        project_state = self.set_up_test_model(app_label, related_model=True)\n  1836\t        pony_table = \"%s_pony\" % app_label\n  1837\t        new_state = project_state.clone()\n  1838\t        operation = migrations.AlterField(\n  1839\t            \"Pony\", \"weight\", models.FloatField(db_column=\"weight\")\n  1840\t        )\n  1841\t        operation.state_forwards(app_label, new_state)\n  1842\t        self.assertIsNone(\n  1843\t            project_state.models[app_label, \"pony\"].fields[\"weight\"].db_column,\n  1844\t        )\n  1845\t        self.assertEqual(\n  1846\t            new_state.models[app_label, \"pony\"].fields[\"weight\"].db_column,\n  1847\t            \"weight\",\n  1848\t        )\n  1849\t        self.assertColumnExists(pony_table, \"weight\")\n  1850\t        with connection.schema_editor() as editor:\n  1851\t            with self.assertNumQueries(0):\n  1852\t                operation.database_forwards(app_label, editor, project_state, new_state)\n  1853\t        self.assertColumnExists(pony_table, \"weight\")\n  1854\t        with connection.schema_editor() as editor:\n  1855\t            with self.assertNumQueries(0):\n  1856\t                operation.database_backwards(\n  1857\t                    app_label, editor, new_state, project_state\n  1858\t                )\n  1859\t        self.assertColumnExists(pony_table, \"weight\")\n  1860\t\n  1861\t        rider_table = \"%s_rider\" % app_label\n  1862\t        new_state = project_state.clone()\n  1863\t        operation = migrations.AlterField(\n  1864\t            \"Rider\",\n  1865\t            \"pony\",\n  1866\t            models.ForeignKey(\"Pony\", models.CASCADE, db_column=\"pony_id\"),\n  1867\t        )\n  1868\t        operation.state_forwards(app_label, new_state)\n  1869\t        self.assertIsNone(\n  1870\t            project_state.models[app_label, \"rider\"].fields[\"pony\"].db_column,\n  1871\t        )\n  1872\t        self.assertIs(\n  1873\t            new_state.models[app_label, \"rider\"].fields[\"pony\"].db_column,\n  1874\t            \"pony_id\",\n  1875\t        )\n  1876\t        self.assertColumnExists(rider_table, \"pony_id\")\n  1877\t        with connection.schema_editor() as editor:\n  1878\t            with self.assertNumQueries(0):\n  1879\t                operation.database_forwards(app_label, editor, project_state, new_state)\n  1880\t        self.assertColumnExists(rider_table, \"pony_id\")\n  1881\t        with connection.schema_editor() as editor:\n  1882\t            with self.assertNumQueries(0):\n  1883\t                operation.database_forwards(app_label, editor, new_state, project_state)\n  1884\t        self.assertColumnExists(rider_table, \"pony_id\")\n  1885\t\n  1886\t    def test_alter_field_pk(self):\n  1887\t        \"\"\"\n  1888\t        The AlterField operation on primary keys (things like PostgreSQL's\n  1889\t        SERIAL weirdness).\n  1890\t        \"\"\"\n  1891\t        project_state = self.set_up_test_model(\"test_alflpk\")\n  1892\t        # Test the state alteration\n  1893\t        operation = migrations.AlterField(\n  1894\t            \"Pony\", \"id\", models.IntegerField(primary_key=True)\n  1895\t        )\n  1896\t        new_state = project_state.clone()\n  1897\t        operation.state_forwards(\"test_alflpk\", new_state)\n  1898\t        self.assertIsInstance(\n  1899\t            project_state.models[\"test_alflpk\", \"pony\"].fields[\"id\"],\n  1900\t            models.AutoField,\n  1901\t        )\n  1902\t        self.assertIsInstance(\n  1903\t            new_state.models[\"test_alflpk\", \"pony\"].fields[\"id\"],\n  1904\t            models.IntegerField,\n  1905\t        )\n  1906\t        # Test the database alteration\n  1907\t        with connection.schema_editor() as editor:\n  1908\t            operation.database_forwards(\"test_alflpk\", editor, project_state, new_state)\n  1909\t        # And test reversal\n  1910\t        with connection.schema_editor() as editor:\n  1911\t            operation.database_backwards(\n  1912\t                \"test_alflpk\", editor, new_state, project_state\n  1913\t            )\n  1914\t\n  1915\t    @skipUnlessDBFeature(\"supports_foreign_keys\")\n  1916\t    def test_alter_field_pk_fk(self):\n  1917\t        \"\"\"\n  1918\t        Tests the AlterField operation on primary keys changes any FKs pointing to it.\n  1919\t        \"\"\"\n  1920\t        project_state = self.set_up_test_model(\"test_alflpkfk\", related_model=True)\n  1921\t        project_state = self.apply_operations(\n  1922\t            \"test_alflpkfk\",\n  1923\t            project_state,\n  1924\t            [\n  1925\t                migrations.CreateModel(\n  1926\t                    \"Stable\",\n  1927\t                    fields=[\n  1928\t                        (\"ponies\", models.ManyToManyField(\"Pony\")),\n  1929\t                    ],\n  1930\t                ),\n  1931\t                migrations.AddField(\n  1932\t                    \"Pony\",\n  1933\t                    \"stables\",\n  1934\t                    models.ManyToManyField(\"Stable\"),\n  1935\t                ),\n  1936\t            ],\n  1937\t        )\n  1938\t        # Test the state alteration\n  1939\t        operation = migrations.AlterField(\n  1940\t            \"Pony\", \"id\", models.FloatField(primary_key=True)\n  1941\t        )\n  1942\t        new_state = project_state.clone()\n  1943\t        operation.state_forwards(\"test_alflpkfk\", new_state)\n  1944\t        self.assertIsInstance(\n  1945\t            project_state.models[\"test_alflpkfk\", \"pony\"].fields[\"id\"],\n  1946\t            models.AutoField,\n  1947\t        )\n  1948\t        self.assertIsInstance(\n  1949\t            new_state.models[\"test_alflpkfk\", \"pony\"].fields[\"id\"],\n  1950\t            models.FloatField,\n  1951\t        )\n  1952\t\n  1953\t        def assertIdTypeEqualsFkType():\n  1954\t            with connection.cursor() as cursor:\n  1955\t                id_type, id_null = [\n  1956\t                    (c.type_code, c.null_ok)\n  1957\t                    for c in connection.introspection.get_table_description(\n  1958\t                        cursor, \"test_alflpkfk_pony\"\n  1959\t                    )\n  1960\t                    if c.name == \"id\"\n  1961\t                ][0]\n  1962\t                fk_type, fk_null = [\n  1963\t                    (c.type_code, c.null_ok)\n  1964\t                    for c in connection.introspection.get_table_description(\n  1965\t                        cursor, \"test_alflpkfk_rider\"\n  1966\t                    )\n  1967\t                    if c.name == \"pony_id\"\n  1968\t                ][0]\n  1969\t                m2m_fk_type, m2m_fk_null = [\n  1970\t                    (c.type_code, c.null_ok)\n  1971\t                    for c in connection.introspection.get_table_description(\n  1972\t                        cursor,\n  1973\t                        \"test_alflpkfk_pony_stables\",\n  1974\t                    )\n  1975\t                    if c.name == \"pony_id\"\n  1976\t                ][0]\n  1977\t                remote_m2m_fk_type, remote_m2m_fk_null = [\n  1978\t                    (c.type_code, c.null_ok)\n  1979\t                    for c in connection.introspection.get_table_description(\n  1980\t                        cursor,\n  1981\t                        \"test_alflpkfk_stable_ponies\",\n  1982\t                    )\n  1983\t                    if c.name == \"pony_id\"\n  1984\t                ][0]\n  1985\t            self.assertEqual(id_type, fk_type)\n  1986\t            self.assertEqual(id_type, m2m_fk_type)\n  1987\t            self.assertEqual(id_type, remote_m2m_fk_type)\n  1988\t            self.assertEqual(id_null, fk_null)\n  1989\t            self.assertEqual(id_null, m2m_fk_null)\n  1990\t            self.assertEqual(id_null, remote_m2m_fk_null)\n  1991\t\n  1992\t        assertIdTypeEqualsFkType()\n  1993\t        # Test the database alteration\n  1994\t        with connection.schema_editor() as editor:\n  1995\t            operation.database_forwards(\n  1996\t                \"test_alflpkfk\", editor, project_state, new_state\n  1997\t            )\n  1998\t        assertIdTypeEqualsFkType()\n  1999\t        if connection.features.supports_foreign_keys:\n  2000\t            self.assertFKExists(\n  2001\t                \"test_alflpkfk_pony_stables\",\n  2002\t                [\"pony_id\"],\n  2003\t                (\"test_alflpkfk_pony\", \"id\"),\n  2004\t            )\n  2005\t            self.assertFKExists(\n  2006\t                \"test_alflpkfk_stable_ponies\",\n  2007\t                [\"pony_id\"],\n  2008\t                (\"test_alflpkfk_pony\", \"id\"),\n  2009\t            )\n  2010\t        # And test reversal\n  2011\t        with connection.schema_editor() as editor:\n  2012\t            operation.database_backwards(\n  2013\t                \"test_alflpkfk\", editor, new_state, project_state\n  2014\t            )\n  2015\t        assertIdTypeEqualsFkType()\n  2016\t        if connection.features.supports_foreign_keys:\n  2017\t            self.assertFKExists(\n  2018\t                \"test_alflpkfk_pony_stables\",\n  2019\t                [\"pony_id\"],\n  2020\t                (\"test_alflpkfk_pony\", \"id\"),\n  2021\t            )\n  2022\t            self.assertFKExists(\n  2023\t                \"test_alflpkfk_stable_ponies\",\n  2024\t                [\"pony_id\"],\n  2025\t                (\"test_alflpkfk_pony\", \"id\"),\n  2026\t            )\n  2027\t\n  2028\t    @skipUnlessDBFeature(\"supports_collation_on_charfield\", \"supports_foreign_keys\")\n  2029\t    def test_alter_field_pk_fk_db_collation(self):\n  2030\t        \"\"\"\n  2031\t        AlterField operation of db_collation on primary keys changes any FKs\n  2032\t        pointing to it.\n  2033\t        \"\"\"\n  2034\t        collation = connection.features.test_collations.get(\"non_default\")\n  2035\t        if not collation:\n  2036\t            self.skipTest(\"Language collations are not supported.\")\n  2037\t\n  2038\t        app_label = \"test_alflpkfkdbc\"\n  2039\t        project_state = self.apply_operations(\n  2040\t            app_label,\n  2041\t            ProjectState(),\n  2042\t            [\n  2043\t                migrations.CreateModel(\n  2044\t                    \"Pony\",\n  2045\t                    [\n  2046\t                        (\"id\", models.CharField(primary_key=True, max_length=10)),\n  2047\t                    ],\n  2048\t                ),\n  2049\t                migrations.CreateModel(\n  2050\t                    \"Rider\",\n  2051\t                    [\n  2052\t                        (\"pony\", models.ForeignKey(\"Pony\", models.CASCADE)),\n  2053\t                    ],\n  2054\t                ),\n  2055\t                migrations.CreateModel(\n  2056\t                    \"Stable\",\n  2057\t                    [\n  2058\t                        (\"ponies\", models.ManyToManyField(\"Pony\")),\n  2059\t                    ],\n  2060\t                ),\n  2061\t            ],\n  2062\t        )\n  2063\t        # State alteration.\n  2064\t        operation = migrations.AlterField(\n  2065\t            \"Pony\",\n  2066\t            \"id\",\n  2067\t            models.CharField(\n  2068\t                primary_key=True,\n  2069\t                max_length=10,\n  2070\t                db_collation=collation,\n  2071\t            ),\n  2072\t        )\n  2073\t        new_state = project_state.clone()\n  2074\t        operation.state_forwards(app_label, new_state)\n  2075\t        # Database alteration.\n  2076\t        with connection.schema_editor() as editor:\n  2077\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2078\t        self.assertColumnCollation(f\"{app_label}_pony\", \"id\", collation)\n  2079\t        self.assertColumnCollation(f\"{app_label}_rider\", \"pony_id\", collation)\n  2080\t        self.assertColumnCollation(f\"{app_label}_stable_ponies\", \"pony_id\", collation)\n  2081\t        # Reversal.\n  2082\t        with connection.schema_editor() as editor:\n  2083\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2084\t\n  2085\t    def test_alter_field_pk_mti_fk(self):\n  2086\t        app_label = \"test_alflpkmtifk\"\n  2087\t        project_state = self.set_up_test_model(app_label, mti_model=True)\n  2088\t        project_state = self.apply_operations(\n  2089\t            app_label,\n  2090\t            project_state,\n  2091\t            [\n  2092\t                migrations.CreateModel(\n  2093\t                    \"ShetlandRider\",\n  2094\t                    fields=[\n  2095\t                        (\n  2096\t                            \"pony\",\n  2097\t                            models.ForeignKey(\n  2098\t                                f\"{app_label}.ShetlandPony\", models.CASCADE\n  2099\t                            ),\n  2100\t                        ),\n  2101\t                    ],\n  2102\t                ),\n  2103\t            ],\n  2104\t        )\n  2105\t        operation = migrations.AlterField(\n  2106\t            \"Pony\",\n  2107\t            \"id\",\n  2108\t            models.BigAutoField(primary_key=True),\n  2109\t        )\n  2110\t        new_state = project_state.clone()\n  2111\t        operation.state_forwards(app_label, new_state)\n  2112\t        self.assertIsInstance(\n  2113\t            new_state.models[app_label, \"pony\"].fields[\"id\"],\n  2114\t            models.BigAutoField,\n  2115\t        )\n  2116\t\n  2117\t        def _get_column_id_type(cursor, table, column):\n  2118\t            return [\n  2119\t                c.type_code\n  2120\t                for c in connection.introspection.get_table_description(\n  2121\t                    cursor,\n  2122\t                    f\"{app_label}_{table}\",\n  2123\t                )\n  2124\t                if c.name == column\n  2125\t            ][0]\n  2126\t\n  2127\t        def assertIdTypeEqualsMTIFkType():\n  2128\t            with connection.cursor() as cursor:\n  2129\t                parent_id_type = _get_column_id_type(cursor, \"pony\", \"id\")\n  2130\t                child_id_type = _get_column_id_type(\n  2131\t                    cursor, \"shetlandpony\", \"pony_ptr_id\"\n  2132\t                )\n  2133\t                mti_id_type = _get_column_id_type(cursor, \"shetlandrider\", \"pony_id\")\n  2134\t            self.assertEqual(parent_id_type, child_id_type)\n  2135\t            self.assertEqual(parent_id_type, mti_id_type)\n  2136\t\n  2137\t        assertIdTypeEqualsMTIFkType()\n  2138\t        # Alter primary key.\n  2139\t        with connection.schema_editor() as editor:\n  2140\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2141\t        assertIdTypeEqualsMTIFkType()\n  2142\t        if connection.features.supports_foreign_keys:\n  2143\t            self.assertFKExists(\n  2144\t                f\"{app_label}_shetlandpony\",\n  2145\t                [\"pony_ptr_id\"],\n  2146\t                (f\"{app_label}_pony\", \"id\"),\n  2147\t            )\n  2148\t            self.assertFKExists(\n  2149\t                f\"{app_label}_shetlandrider\",\n  2150\t                [\"pony_id\"],\n  2151\t                (f\"{app_label}_shetlandpony\", \"pony_ptr_id\"),\n  2152\t            )\n  2153\t        # Reversal.\n  2154\t        with connection.schema_editor() as editor:\n  2155\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2156\t        assertIdTypeEqualsMTIFkType()\n  2157\t        if connection.features.supports_foreign_keys:\n  2158\t            self.assertFKExists(\n  2159\t                f\"{app_label}_shetlandpony\",\n  2160\t                [\"pony_ptr_id\"],\n  2161\t                (f\"{app_label}_pony\", \"id\"),\n  2162\t            )\n  2163\t            self.assertFKExists(\n  2164\t                f\"{app_label}_shetlandrider\",\n  2165\t                [\"pony_id\"],\n  2166\t                (f\"{app_label}_shetlandpony\", \"pony_ptr_id\"),\n  2167\t            )\n  2168\t\n  2169\t    def test_alter_field_pk_mti_and_fk_to_base(self):\n  2170\t        app_label = \"test_alflpkmtiftb\"\n  2171\t        project_state = self.set_up_test_model(\n  2172\t            app_label,\n  2173\t            mti_model=True,\n  2174\t            related_model=True,\n  2175\t        )\n  2176\t        operation = migrations.AlterField(\n  2177\t            \"Pony\",\n  2178\t            \"id\",\n  2179\t            models.BigAutoField(primary_key=True),\n  2180\t        )\n  2181\t        new_state = project_state.clone()\n  2182\t        operation.state_forwards(app_label, new_state)\n  2183\t        self.assertIsInstance(\n  2184\t            new_state.models[app_label, \"pony\"].fields[\"id\"],\n  2185\t            models.BigAutoField,\n  2186\t        )\n  2187\t\n  2188\t        def _get_column_id_type(cursor, table, column):\n  2189\t            return [\n  2190\t                c.type_code\n  2191\t                for c in connection.introspection.get_table_description(\n  2192\t                    cursor,\n  2193\t                    f\"{app_label}_{table}\",\n  2194\t                )\n  2195\t                if c.name == column\n  2196\t            ][0]\n  2197\t\n  2198\t        def assertIdTypeEqualsMTIFkType():\n  2199\t            with connection.cursor() as cursor:\n  2200\t                parent_id_type = _get_column_id_type(cursor, \"pony\", \"id\")\n  2201\t                fk_id_type = _get_column_id_type(cursor, \"rider\", \"pony_id\")\n  2202\t                child_id_type = _get_column_id_type(\n  2203\t                    cursor, \"shetlandpony\", \"pony_ptr_id\"\n  2204\t                )\n  2205\t            self.assertEqual(parent_id_type, child_id_type)\n  2206\t            self.assertEqual(parent_id_type, fk_id_type)\n  2207\t\n  2208\t        assertIdTypeEqualsMTIFkType()\n  2209\t        # Alter primary key.\n  2210\t        with connection.schema_editor() as editor:\n  2211\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2212\t        assertIdTypeEqualsMTIFkType()\n  2213\t        if connection.features.supports_foreign_keys:\n  2214\t            self.assertFKExists(\n  2215\t                f\"{app_label}_shetlandpony\",\n  2216\t                [\"pony_ptr_id\"],\n  2217\t                (f\"{app_label}_pony\", \"id\"),\n  2218\t            )\n  2219\t            self.assertFKExists(\n  2220\t                f\"{app_label}_rider\",\n  2221\t                [\"pony_id\"],\n  2222\t                (f\"{app_label}_pony\", \"id\"),\n  2223\t            )\n  2224\t        # Reversal.\n  2225\t        with connection.schema_editor() as editor:\n  2226\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2227\t        assertIdTypeEqualsMTIFkType()\n  2228\t        if connection.features.supports_foreign_keys:\n  2229\t            self.assertFKExists(\n  2230\t                f\"{app_label}_shetlandpony\",\n  2231\t                [\"pony_ptr_id\"],\n  2232\t                (f\"{app_label}_pony\", \"id\"),\n  2233\t            )\n  2234\t            self.assertFKExists(\n  2235\t                f\"{app_label}_rider\",\n  2236\t                [\"pony_id\"],\n  2237\t                (f\"{app_label}_pony\", \"id\"),\n  2238\t            )\n  2239\t\n  2240\t    @skipUnlessDBFeature(\"supports_foreign_keys\")\n  2241\t    def test_alter_field_reloads_state_on_fk_with_to_field_target_type_change(self):\n  2242\t        app_label = \"test_alflrsfkwtflttc\"\n  2243\t        project_state = self.apply_operations(\n  2244\t            app_label,\n  2245\t            ProjectState(),\n  2246\t            operations=[\n  2247\t                migrations.CreateModel(\n  2248\t                    \"Rider\",\n  2249\t                    fields=[\n  2250\t                        (\"id\", models.AutoField(primary_key=True)),\n  2251\t                        (\"code\", models.IntegerField(unique=True)),\n  2252\t                    ],\n  2253\t                ),\n  2254\t                migrations.CreateModel(\n  2255\t                    \"Pony\",\n  2256\t                    fields=[\n  2257\t                        (\"id\", models.AutoField(primary_key=True)),\n  2258\t                        (\n  2259\t                            \"rider\",\n  2260\t                            models.ForeignKey(\n  2261\t                                \"%s.Rider\" % app_label, models.CASCADE, to_field=\"code\"\n  2262\t                            ),\n  2263\t                        ),\n  2264\t                    ],\n  2265\t                ),\n  2266\t            ],\n  2267\t        )\n  2268\t        operation = migrations.AlterField(\n  2269\t            \"Rider\",\n  2270\t            \"code\",\n  2271\t            models.CharField(max_length=100, unique=True),\n  2272\t        )\n  2273\t        self.apply_operations(app_label, project_state, operations=[operation])\n  2274\t        id_type, id_null = [\n  2275\t            (c.type_code, c.null_ok)\n  2276\t            for c in self.get_table_description(\"%s_rider\" % app_label)\n  2277\t            if c.name == \"code\"\n  2278\t        ][0]\n  2279\t        fk_type, fk_null = [\n  2280\t            (c.type_code, c.null_ok)\n  2281\t            for c in self.get_table_description(\"%s_pony\" % app_label)\n  2282\t            if c.name == \"rider_id\"\n  2283\t        ][0]\n  2284\t        self.assertEqual(id_type, fk_type)\n  2285\t        self.assertEqual(id_null, fk_null)\n  2286\t\n  2287\t    @skipUnlessDBFeature(\"supports_foreign_keys\")\n  2288\t    def test_alter_field_reloads_state_fk_with_to_field_related_name_target_type_change(\n  2289\t        self,\n  2290\t    ):\n  2291\t        app_label = \"test_alflrsfkwtflrnttc\"\n  2292\t        project_state = self.apply_operations(\n  2293\t            app_label,\n  2294\t            ProjectState(),\n  2295\t            operations=[\n  2296\t                migrations.CreateModel(\n  2297\t                    \"Rider\",\n  2298\t                    fields=[\n  2299\t                        (\"id\", models.AutoField(primary_key=True)),\n  2300\t                        (\"code\", models.PositiveIntegerField(unique=True)),\n  2301\t                    ],\n  2302\t                ),\n  2303\t                migrations.CreateModel(\n  2304\t                    \"Pony\",\n  2305\t                    fields=[\n  2306\t                        (\"id\", models.AutoField(primary_key=True)),\n  2307\t                        (\n  2308\t                            \"rider\",\n  2309\t                            models.ForeignKey(\n  2310\t                                \"%s.Rider\" % app_label,\n  2311\t                                models.CASCADE,\n  2312\t                                to_field=\"code\",\n  2313\t                                related_name=\"+\",\n  2314\t                            ),\n  2315\t                        ),\n  2316\t                    ],\n  2317\t                ),\n  2318\t            ],\n  2319\t        )\n  2320\t        operation = migrations.AlterField(\n  2321\t            \"Rider\",\n  2322\t            \"code\",\n  2323\t            models.CharField(max_length=100, unique=True),\n  2324\t        )\n  2325\t        self.apply_operations(app_label, project_state, operations=[operation])\n  2326\t\n  2327\t    def test_alter_field_reloads_state_on_fk_target_changes(self):\n  2328\t        \"\"\"\n  2329\t        If AlterField doesn't reload state appropriately, the second AlterField\n  2330\t        crashes on MySQL due to not dropping the PonyRider.pony foreign key\n  2331\t        constraint before modifying the column.\n  2332\t        \"\"\"\n  2333\t        app_label = \"alter_alter_field_reloads_state_on_fk_target_changes\"\n  2334\t        project_state = self.apply_operations(\n  2335\t            app_label,\n  2336\t            ProjectState(),\n  2337\t            operations=[\n  2338\t                migrations.CreateModel(\n  2339\t                    \"Rider\",\n  2340\t                    fields=[\n  2341\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2342\t                    ],\n  2343\t                ),\n  2344\t                migrations.CreateModel(\n  2345\t                    \"Pony\",\n  2346\t                    fields=[\n  2347\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2348\t                        (\n  2349\t                            \"rider\",\n  2350\t                            models.ForeignKey(\"%s.Rider\" % app_label, models.CASCADE),\n  2351\t                        ),\n  2352\t                    ],\n  2353\t                ),\n  2354\t                migrations.CreateModel(\n  2355\t                    \"PonyRider\",\n  2356\t                    fields=[\n  2357\t                        (\"id\", models.AutoField(primary_key=True)),\n  2358\t                        (\n  2359\t                            \"pony\",\n  2360\t                            models.ForeignKey(\"%s.Pony\" % app_label, models.CASCADE),\n  2361\t                        ),\n  2362\t                    ],\n  2363\t                ),\n  2364\t            ],\n  2365\t        )\n  2366\t        project_state = self.apply_operations(\n  2367\t            app_label,\n  2368\t            project_state,\n  2369\t            operations=[\n  2370\t                migrations.AlterField(\n  2371\t                    \"Rider\", \"id\", models.CharField(primary_key=True, max_length=99)\n  2372\t                ),\n  2373\t                migrations.AlterField(\n  2374\t                    \"Pony\", \"id\", models.CharField(primary_key=True, max_length=99)\n  2375\t                ),\n  2376\t            ],\n  2377\t        )\n  2378\t\n  2379\t    def test_alter_field_reloads_state_on_fk_with_to_field_target_changes(self):\n  2380\t        \"\"\"\n  2381\t        If AlterField doesn't reload state appropriately, the second AlterField\n  2382\t        crashes on MySQL due to not dropping the PonyRider.pony foreign key\n  2383\t        constraint before modifying the column.\n  2384\t        \"\"\"\n  2385\t        app_label = \"alter_alter_field_reloads_state_on_fk_with_to_field_target_changes\"\n  2386\t        project_state = self.apply_operations(\n  2387\t            app_label,\n  2388\t            ProjectState(),\n  2389\t            operations=[\n  2390\t                migrations.CreateModel(\n  2391\t                    \"Rider\",\n  2392\t                    fields=[\n  2393\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2394\t                        (\"slug\", models.CharField(unique=True, max_length=100)),\n  2395\t                    ],\n  2396\t                ),\n  2397\t                migrations.CreateModel(\n  2398\t                    \"Pony\",\n  2399\t                    fields=[\n  2400\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2401\t                        (\n  2402\t                            \"rider\",\n  2403\t                            models.ForeignKey(\n  2404\t                                \"%s.Rider\" % app_label, models.CASCADE, to_field=\"slug\"\n  2405\t                            ),\n  2406\t                        ),\n  2407\t                        (\"slug\", models.CharField(unique=True, max_length=100)),\n  2408\t                    ],\n  2409\t                ),\n  2410\t                migrations.CreateModel(\n  2411\t                    \"PonyRider\",\n  2412\t                    fields=[\n  2413\t                        (\"id\", models.AutoField(primary_key=True)),\n  2414\t                        (\n  2415\t                            \"pony\",\n  2416\t                            models.ForeignKey(\n  2417\t                                \"%s.Pony\" % app_label, models.CASCADE, to_field=\"slug\"\n  2418\t                            ),\n  2419\t                        ),\n  2420\t                    ],\n  2421\t                ),\n  2422\t            ],\n  2423\t        )\n  2424\t        project_state = self.apply_operations(\n  2425\t            app_label,\n  2426\t            project_state,\n  2427\t            operations=[\n  2428\t                migrations.AlterField(\n  2429\t                    \"Rider\", \"slug\", models.CharField(unique=True, max_length=99)\n  2430\t                ),\n  2431\t                migrations.AlterField(\n  2432\t                    \"Pony\", \"slug\", models.CharField(unique=True, max_length=99)\n  2433\t                ),\n  2434\t            ],\n  2435\t        )\n  2436\t\n  2437\t    def test_rename_field_reloads_state_on_fk_target_changes(self):\n  2438\t        \"\"\"\n  2439\t        If RenameField doesn't reload state appropriately, the AlterField\n  2440\t        crashes on MySQL due to not dropping the PonyRider.pony foreign key\n  2441\t        constraint before modifying the column.\n  2442\t        \"\"\"\n  2443\t        app_label = \"alter_rename_field_reloads_state_on_fk_target_changes\"\n  2444\t        project_state = self.apply_operations(\n  2445\t            app_label,\n  2446\t            ProjectState(),\n  2447\t            operations=[\n  2448\t                migrations.CreateModel(\n  2449\t                    \"Rider\",\n  2450\t                    fields=[\n  2451\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2452\t                    ],\n  2453\t                ),\n  2454\t                migrations.CreateModel(\n  2455\t                    \"Pony\",\n  2456\t                    fields=[\n  2457\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2458\t                        (\n  2459\t                            \"rider\",\n  2460\t                            models.ForeignKey(\"%s.Rider\" % app_label, models.CASCADE),\n  2461\t                        ),\n  2462\t                    ],\n  2463\t                ),\n  2464\t                migrations.CreateModel(\n  2465\t                    \"PonyRider\",\n  2466\t                    fields=[\n  2467\t                        (\"id\", models.AutoField(primary_key=True)),\n  2468\t                        (\n  2469\t                            \"pony\",\n  2470\t                            models.ForeignKey(\"%s.Pony\" % app_label, models.CASCADE),\n  2471\t                        ),\n  2472\t                    ],\n  2473\t                ),\n  2474\t            ],\n  2475\t        )\n  2476\t        project_state = self.apply_operations(\n  2477\t            app_label,\n  2478\t            project_state,\n  2479\t            operations=[\n  2480\t                migrations.RenameField(\"Rider\", \"id\", \"id2\"),\n  2481\t                migrations.AlterField(\n  2482\t                    \"Pony\", \"id\", models.CharField(primary_key=True, max_length=99)\n  2483\t                ),\n  2484\t            ],\n  2485\t            atomic=connection.features.supports_atomic_references_rename,\n  2486\t        )\n  2487\t\n  2488\t    def test_rename_field(self):\n  2489\t        \"\"\"\n  2490\t        Tests the RenameField operation.\n  2491\t        \"\"\"\n  2492\t        project_state = self.set_up_test_model(\n  2493\t            \"test_rnfl\", unique_together=True, index_together=True\n  2494\t        )\n  2495\t        # Test the state alteration\n  2496\t        operation = migrations.RenameField(\"Pony\", \"pink\", \"blue\")\n  2497\t        self.assertEqual(operation.describe(), \"Rename field pink on Pony to blue\")\n  2498\t        self.assertEqual(operation.migration_name_fragment, \"rename_pink_pony_blue\")\n  2499\t        new_state = project_state.clone()\n  2500\t        operation.state_forwards(\"test_rnfl\", new_state)\n  2501\t        self.assertIn(\"blue\", new_state.models[\"test_rnfl\", \"pony\"].fields)\n  2502\t        self.assertNotIn(\"pink\", new_state.models[\"test_rnfl\", \"pony\"].fields)\n  2503\t        # Make sure the unique_together has the renamed column too\n  2504\t        self.assertIn(\n  2505\t            \"blue\", new_state.models[\"test_rnfl\", \"pony\"].options[\"unique_together\"][0]\n  2506\t        )\n  2507\t        self.assertNotIn(\n  2508\t            \"pink\", new_state.models[\"test_rnfl\", \"pony\"].options[\"unique_together\"][0]\n  2509\t        )\n  2510\t        # Make sure the index_together has the renamed column too\n  2511\t        self.assertIn(\n  2512\t            \"blue\", new_state.models[\"test_rnfl\", \"pony\"].options[\"index_together\"][0]\n  2513\t        )\n  2514\t        self.assertNotIn(\n  2515\t            \"pink\", new_state.models[\"test_rnfl\", \"pony\"].options[\"index_together\"][0]\n  2516\t        )\n  2517\t        # Test the database alteration\n  2518\t        self.assertColumnExists(\"test_rnfl_pony\", \"pink\")\n  2519\t        self.assertColumnNotExists(\"test_rnfl_pony\", \"blue\")\n  2520\t        with connection.schema_editor() as editor:\n  2521\t            operation.database_forwards(\"test_rnfl\", editor, project_state, new_state)\n  2522\t        self.assertColumnExists(\"test_rnfl_pony\", \"blue\")\n  2523\t        self.assertColumnNotExists(\"test_rnfl_pony\", \"pink\")\n  2524\t        # Ensure the unique constraint has been ported over\n  2525\t        with connection.cursor() as cursor:\n  2526\t            cursor.execute(\"INSERT INTO test_rnfl_pony (blue, weight) VALUES (1, 1)\")\n  2527\t            with self.assertRaises(IntegrityError):\n  2528\t                with atomic():\n  2529\t                    cursor.execute(\n  2530\t                        \"INSERT INTO test_rnfl_pony (blue, weight) VALUES (1, 1)\"\n  2531\t                    )\n  2532\t            cursor.execute(\"DELETE FROM test_rnfl_pony\")\n  2533\t        # Ensure the index constraint has been ported over\n  2534\t        self.assertIndexExists(\"test_rnfl_pony\", [\"weight\", \"blue\"])\n  2535\t        # And test reversal\n  2536\t        with connection.schema_editor() as editor:\n  2537\t            operation.database_backwards(\"test_rnfl\", editor, new_state, project_state)\n  2538\t        self.assertColumnExists(\"test_rnfl_pony\", \"pink\")\n  2539\t        self.assertColumnNotExists(\"test_rnfl_pony\", \"blue\")\n  2540\t        # Ensure the index constraint has been reset\n  2541\t        self.assertIndexExists(\"test_rnfl_pony\", [\"weight\", \"pink\"])\n  2542\t        # And deconstruction\n  2543\t        definition = operation.deconstruct()\n  2544\t        self.assertEqual(definition[0], \"RenameField\")\n  2545\t        self.assertEqual(definition[1], [])\n  2546\t        self.assertEqual(\n  2547\t            definition[2],\n  2548\t            {\"model_name\": \"Pony\", \"old_name\": \"pink\", \"new_name\": \"blue\"},\n  2549\t        )\n  2550\t\n  2551\t    def test_rename_field_with_db_column(self):\n  2552\t        project_state = self.apply_operations(\n  2553\t            \"test_rfwdbc\",\n  2554\t            ProjectState(),\n  2555\t            operations=[\n  2556\t                migrations.CreateModel(\n  2557\t                    \"Pony\",\n  2558\t                    fields=[\n  2559\t                        (\"id\", models.AutoField(primary_key=True)),\n  2560\t                        (\"field\", models.IntegerField(db_column=\"db_field\")),\n  2561\t                        (\n  2562\t                            \"fk_field\",\n  2563\t                            models.ForeignKey(\n  2564\t                                \"Pony\",\n  2565\t                                models.CASCADE,\n  2566\t                                db_column=\"db_fk_field\",\n  2567\t                            ),\n  2568\t                        ),\n  2569\t                    ],\n  2570\t                ),\n  2571\t            ],\n  2572\t        )\n  2573\t        new_state = project_state.clone()\n  2574\t        operation = migrations.RenameField(\"Pony\", \"field\", \"renamed_field\")\n  2575\t        operation.state_forwards(\"test_rfwdbc\", new_state)\n  2576\t        self.assertIn(\"renamed_field\", new_state.models[\"test_rfwdbc\", \"pony\"].fields)\n  2577\t        self.assertNotIn(\"field\", new_state.models[\"test_rfwdbc\", \"pony\"].fields)\n  2578\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_field\")\n  2579\t        with connection.schema_editor() as editor:\n  2580\t            with self.assertNumQueries(0):\n  2581\t                operation.database_forwards(\n  2582\t                    \"test_rfwdbc\", editor, project_state, new_state\n  2583\t                )\n  2584\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_field\")\n  2585\t        with connection.schema_editor() as editor:\n  2586\t            with self.assertNumQueries(0):\n  2587\t                operation.database_backwards(\n  2588\t                    \"test_rfwdbc\", editor, new_state, project_state\n  2589\t                )\n  2590\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_field\")\n  2591\t\n  2592\t        new_state = project_state.clone()\n  2593\t        operation = migrations.RenameField(\"Pony\", \"fk_field\", \"renamed_fk_field\")\n  2594\t        operation.state_forwards(\"test_rfwdbc\", new_state)\n  2595\t        self.assertIn(\n  2596\t            \"renamed_fk_field\", new_state.models[\"test_rfwdbc\", \"pony\"].fields\n  2597\t        )\n  2598\t        self.assertNotIn(\"fk_field\", new_state.models[\"test_rfwdbc\", \"pony\"].fields)\n  2599\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_fk_field\")\n  2600\t        with connection.schema_editor() as editor:\n  2601\t            with self.assertNumQueries(0):\n  2602\t                operation.database_forwards(\n  2603\t                    \"test_rfwdbc\", editor, project_state, new_state\n  2604\t                )\n  2605\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_fk_field\")\n  2606\t        with connection.schema_editor() as editor:\n  2607\t            with self.assertNumQueries(0):\n  2608\t                operation.database_backwards(\n  2609\t                    \"test_rfwdbc\", editor, new_state, project_state\n  2610\t                )\n  2611\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_fk_field\")\n  2612\t\n  2613\t    def test_rename_field_case(self):\n  2614\t        project_state = self.apply_operations(\n  2615\t            \"test_rfmx\",\n  2616\t            ProjectState(),\n  2617\t            operations=[\n  2618\t                migrations.CreateModel(\n  2619\t                    \"Pony\",\n  2620\t                    fields=[\n  2621\t                        (\"id\", models.AutoField(primary_key=True)),\n  2622\t                        (\"field\", models.IntegerField()),\n  2623\t                    ],\n  2624\t                ),\n  2625\t            ],\n  2626\t        )\n  2627\t        new_state = project_state.clone()\n  2628\t        operation = migrations.RenameField(\"Pony\", \"field\", \"FiElD\")\n  2629\t        operation.state_forwards(\"test_rfmx\", new_state)\n  2630\t        self.assertIn(\"FiElD\", new_state.models[\"test_rfmx\", \"pony\"].fields)\n  2631\t        self.assertColumnExists(\"test_rfmx_pony\", \"field\")\n  2632\t        with connection.schema_editor() as editor:\n  2633\t            operation.database_forwards(\"test_rfmx\", editor, project_state, new_state)\n  2634\t        self.assertColumnExists(\n  2635\t            \"test_rfmx_pony\",\n  2636\t            connection.introspection.identifier_converter(\"FiElD\"),\n  2637\t        )\n  2638\t        with connection.schema_editor() as editor:\n  2639\t            operation.database_backwards(\"test_rfmx\", editor, new_state, project_state)\n  2640\t        self.assertColumnExists(\"test_rfmx_pony\", \"field\")\n  2641\t\n  2642\t    def test_rename_missing_field(self):\n  2643\t        state = ProjectState()\n  2644\t        state.add_model(ModelState(\"app\", \"model\", []))\n  2645\t        with self.assertRaisesMessage(\n  2646\t            FieldDoesNotExist, \"app.model has no field named 'field'\"\n  2647\t        ):\n  2648\t            migrations.RenameField(\"model\", \"field\", \"new_field\").state_forwards(\n  2649\t                \"app\", state\n  2650\t            )\n  2651\t\n  2652\t    def test_rename_referenced_field_state_forward(self):\n  2653\t        state = ProjectState()\n  2654\t        state.add_model(\n  2655\t            ModelState(\n  2656\t                \"app\",\n  2657\t                \"Model\",\n  2658\t                [\n  2659\t                    (\"id\", models.AutoField(primary_key=True)),\n  2660\t                    (\"field\", models.IntegerField(unique=True)),\n  2661\t                ],\n  2662\t            )\n  2663\t        )\n  2664\t        state.add_model(\n  2665\t            ModelState(\n  2666\t                \"app\",\n  2667\t                \"OtherModel\",\n  2668\t                [\n  2669\t                    (\"id\", models.AutoField(primary_key=True)),\n  2670\t                    (\n  2671\t                        \"fk\",\n  2672\t                        models.ForeignKey(\"Model\", models.CASCADE, to_field=\"field\"),\n  2673\t                    ),\n  2674\t                    (\n  2675\t                        \"fo\",\n  2676\t                        models.ForeignObject(\n  2677\t                            \"Model\",\n  2678\t                            models.CASCADE,\n  2679\t                            from_fields=(\"fk\",),\n  2680\t                            to_fields=(\"field\",),\n  2681\t                        ),\n  2682\t                    ),\n  2683\t                ],\n  2684\t            )\n  2685\t        )\n  2686\t        operation = migrations.RenameField(\"Model\", \"field\", \"renamed\")\n  2687\t        new_state = state.clone()\n  2688\t        operation.state_forwards(\"app\", new_state)\n  2689\t        self.assertEqual(\n  2690\t            new_state.models[\"app\", \"othermodel\"].fields[\"fk\"].remote_field.field_name,\n  2691\t            \"renamed\",\n  2692\t        )\n  2693\t        self.assertEqual(\n  2694\t            new_state.models[\"app\", \"othermodel\"].fields[\"fk\"].from_fields, [\"self\"]\n  2695\t        )\n  2696\t        self.assertEqual(\n  2697\t            new_state.models[\"app\", \"othermodel\"].fields[\"fk\"].to_fields, (\"renamed\",)\n  2698\t        )\n  2699\t        self.assertEqual(\n  2700\t            new_state.models[\"app\", \"othermodel\"].fields[\"fo\"].from_fields, (\"fk\",)\n  2701\t        )\n  2702\t        self.assertEqual(\n  2703\t            new_state.models[\"app\", \"othermodel\"].fields[\"fo\"].to_fields, (\"renamed\",)\n  2704\t        )\n  2705\t        operation = migrations.RenameField(\"OtherModel\", \"fk\", \"renamed_fk\")\n  2706\t        new_state = state.clone()\n  2707\t        operation.state_forwards(\"app\", new_state)\n  2708\t        self.assertEqual(\n  2709\t            new_state.models[\"app\", \"othermodel\"]\n  2710\t            .fields[\"renamed_fk\"]\n  2711\t            .remote_field.field_name,\n  2712\t            \"renamed\",\n  2713\t        )\n  2714\t        self.assertEqual(\n  2715\t            new_state.models[\"app\", \"othermodel\"].fields[\"renamed_fk\"].from_fields,\n  2716\t            (\"self\",),\n  2717\t        )\n  2718\t        self.assertEqual(\n  2719\t            new_state.models[\"app\", \"othermodel\"].fields[\"renamed_fk\"].to_fields,\n  2720\t            (\"renamed\",),\n  2721\t        )\n  2722\t        self.assertEqual(\n  2723\t            new_state.models[\"app\", \"othermodel\"].fields[\"fo\"].from_fields,\n  2724\t            (\"renamed_fk\",),\n  2725\t        )\n  2726\t        self.assertEqual(\n  2727\t            new_state.models[\"app\", \"othermodel\"].fields[\"fo\"].to_fields, (\"renamed\",)\n  2728\t        )\n  2729\t\n  2730\t    def test_alter_unique_together(self):\n  2731\t        \"\"\"\n  2732\t        Tests the AlterUniqueTogether operation.\n  2733\t        \"\"\"\n  2734\t        project_state = self.set_up_test_model(\"test_alunto\")\n  2735\t        # Test the state alteration\n  2736\t        operation = migrations.AlterUniqueTogether(\"Pony\", [(\"pink\", \"weight\")])\n  2737\t        self.assertEqual(\n  2738\t            operation.describe(), \"Alter unique_together for Pony (1 constraint(s))\"\n  2739\t        )\n  2740\t        self.assertEqual(\n  2741\t            operation.migration_name_fragment,\n  2742\t            \"alter_pony_unique_together\",\n  2743\t        )\n  2744\t        new_state = project_state.clone()\n  2745\t        operation.state_forwards(\"test_alunto\", new_state)\n  2746\t        self.assertEqual(\n  2747\t            len(\n  2748\t                project_state.models[\"test_alunto\", \"pony\"].options.get(\n  2749\t                    \"unique_together\", set()\n  2750\t                )\n  2751\t            ),\n  2752\t            0,\n  2753\t        )\n  2754\t        self.assertEqual(\n  2755\t            len(\n  2756\t                new_state.models[\"test_alunto\", \"pony\"].options.get(\n  2757\t                    \"unique_together\", set()\n  2758\t                )\n  2759\t            ),\n  2760\t            1,\n  2761\t        )\n  2762\t        # Make sure we can insert duplicate rows\n  2763\t        with connection.cursor() as cursor:\n  2764\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2765\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2766\t            cursor.execute(\"DELETE FROM test_alunto_pony\")\n  2767\t            # Test the database alteration\n  2768\t            with connection.schema_editor() as editor:\n  2769\t                operation.database_forwards(\n  2770\t                    \"test_alunto\", editor, project_state, new_state\n  2771\t                )\n  2772\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2773\t            with self.assertRaises(IntegrityError):\n  2774\t                with atomic():\n  2775\t                    cursor.execute(\n  2776\t                        \"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\"\n  2777\t                    )\n  2778\t            cursor.execute(\"DELETE FROM test_alunto_pony\")\n  2779\t            # And test reversal\n  2780\t            with connection.schema_editor() as editor:\n  2781\t                operation.database_backwards(\n  2782\t                    \"test_alunto\", editor, new_state, project_state\n  2783\t                )\n  2784\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2785\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2786\t            cursor.execute(\"DELETE FROM test_alunto_pony\")\n  2787\t        # Test flat unique_together\n  2788\t        operation = migrations.AlterUniqueTogether(\"Pony\", (\"pink\", \"weight\"))\n  2789\t        operation.state_forwards(\"test_alunto\", new_state)\n  2790\t        self.assertEqual(\n  2791\t            len(\n  2792\t                new_state.models[\"test_alunto\", \"pony\"].options.get(\n  2793\t                    \"unique_together\", set()\n  2794\t                )\n  2795\t            ),\n  2796\t            1,\n  2797\t        )\n  2798\t        # And deconstruction\n  2799\t        definition = operation.deconstruct()\n  2800\t        self.assertEqual(definition[0], \"AlterUniqueTogether\")\n  2801\t        self.assertEqual(definition[1], [])\n  2802\t        self.assertEqual(\n  2803\t            definition[2], {\"name\": \"Pony\", \"unique_together\": {(\"pink\", \"weight\")}}\n  2804\t        )\n  2805\t\n  2806\t    def test_alter_unique_together_remove(self):\n  2807\t        operation = migrations.AlterUniqueTogether(\"Pony\", None)\n  2808\t        self.assertEqual(\n  2809\t            operation.describe(), \"Alter unique_together for Pony (0 constraint(s))\"\n  2810\t        )\n  2811\t\n  2812\t    def test_add_index(self):\n  2813\t        \"\"\"\n  2814\t        Test the AddIndex operation.\n  2815\t        \"\"\"\n  2816\t        project_state = self.set_up_test_model(\"test_adin\")\n  2817\t        msg = (\n  2818\t            \"Indexes passed to AddIndex operations require a name argument. \"\n  2819\t            \"<Index: fields=['pink']> doesn't have one.\"\n  2820\t        )\n  2821\t        with self.assertRaisesMessage(ValueError, msg):\n  2822\t            migrations.AddIndex(\"Pony\", models.Index(fields=[\"pink\"]))\n  2823\t        index = models.Index(fields=[\"pink\"], name=\"test_adin_pony_pink_idx\")\n  2824\t        operation = migrations.AddIndex(\"Pony\", index)\n  2825\t        self.assertEqual(\n  2826\t            operation.describe(),\n  2827\t            \"Create index test_adin_pony_pink_idx on field(s) pink of model Pony\",\n  2828\t        )\n  2829\t        self.assertEqual(\n  2830\t            operation.migration_name_fragment,\n  2831\t            \"pony_test_adin_pony_pink_idx\",\n  2832\t        )\n  2833\t        new_state = project_state.clone()\n  2834\t        operation.state_forwards(\"test_adin\", new_state)\n  2835\t        # Test the database alteration\n  2836\t        self.assertEqual(\n  2837\t            len(new_state.models[\"test_adin\", \"pony\"].options[\"indexes\"]), 1\n  2838\t        )\n  2839\t        self.assertIndexNotExists(\"test_adin_pony\", [\"pink\"])\n  2840\t        with connection.schema_editor() as editor:\n  2841\t            operation.database_forwards(\"test_adin\", editor, project_state, new_state)\n  2842\t        self.assertIndexExists(\"test_adin_pony\", [\"pink\"])\n  2843\t        # And test reversal\n  2844\t        with connection.schema_editor() as editor:\n  2845\t            operation.database_backwards(\"test_adin\", editor, new_state, project_state)\n  2846\t        self.assertIndexNotExists(\"test_adin_pony\", [\"pink\"])\n  2847\t        # And deconstruction\n  2848\t        definition = operation.deconstruct()\n  2849\t        self.assertEqual(definition[0], \"AddIndex\")\n  2850\t        self.assertEqual(definition[1], [])\n  2851\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"index\": index})\n  2852\t\n  2853\t    def test_remove_index(self):\n  2854\t        \"\"\"\n  2855\t        Test the RemoveIndex operation.\n  2856\t        \"\"\"\n  2857\t        project_state = self.set_up_test_model(\"test_rmin\", multicol_index=True)\n  2858\t        self.assertTableExists(\"test_rmin_pony\")\n  2859\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2860\t        operation = migrations.RemoveIndex(\"Pony\", \"pony_test_idx\")\n  2861\t        self.assertEqual(operation.describe(), \"Remove index pony_test_idx from Pony\")\n  2862\t        self.assertEqual(\n  2863\t            operation.migration_name_fragment,\n  2864\t            \"remove_pony_pony_test_idx\",\n  2865\t        )\n  2866\t        new_state = project_state.clone()\n  2867\t        operation.state_forwards(\"test_rmin\", new_state)\n  2868\t        # Test the state alteration\n  2869\t        self.assertEqual(\n  2870\t            len(new_state.models[\"test_rmin\", \"pony\"].options[\"indexes\"]), 0\n  2871\t        )\n  2872\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2873\t        # Test the database alteration\n  2874\t        with connection.schema_editor() as editor:\n  2875\t            operation.database_forwards(\"test_rmin\", editor, project_state, new_state)\n  2876\t        self.assertIndexNotExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2877\t        # And test reversal\n  2878\t        with connection.schema_editor() as editor:\n  2879\t            operation.database_backwards(\"test_rmin\", editor, new_state, project_state)\n  2880\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2881\t        # And deconstruction\n  2882\t        definition = operation.deconstruct()\n  2883\t        self.assertEqual(definition[0], \"RemoveIndex\")\n  2884\t        self.assertEqual(definition[1], [])\n  2885\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"name\": \"pony_test_idx\"})\n  2886\t\n  2887\t        # Also test a field dropped with index - sqlite remake issue\n  2888\t        operations = [\n  2889\t            migrations.RemoveIndex(\"Pony\", \"pony_test_idx\"),\n  2890\t            migrations.RemoveField(\"Pony\", \"pink\"),\n  2891\t        ]\n  2892\t        self.assertColumnExists(\"test_rmin_pony\", \"pink\")\n  2893\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2894\t        # Test database alteration\n  2895\t        new_state = project_state.clone()\n  2896\t        self.apply_operations(\"test_rmin\", new_state, operations=operations)\n  2897\t        self.assertColumnNotExists(\"test_rmin_pony\", \"pink\")\n  2898\t        self.assertIndexNotExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2899\t        # And test reversal\n  2900\t        self.unapply_operations(\"test_rmin\", project_state, operations=operations)\n  2901\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2902\t\n  2903\t    def test_rename_index(self):\n  2904\t        app_label = \"test_rnin\"\n  2905\t        project_state = self.set_up_test_model(app_label, index=True)\n  2906\t        table_name = app_label + \"_pony\"\n  2907\t        self.assertIndexNameExists(table_name, \"pony_pink_idx\")\n  2908\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2909\t        operation = migrations.RenameIndex(\n  2910\t            \"Pony\", new_name=\"new_pony_test_idx\", old_name=\"pony_pink_idx\"\n  2911\t        )\n  2912\t        self.assertEqual(\n  2913\t            operation.describe(),\n  2914\t            \"Rename index pony_pink_idx on Pony to new_pony_test_idx\",\n  2915\t        )\n  2916\t        self.assertEqual(\n  2917\t            operation.migration_name_fragment,\n  2918\t            \"rename_pony_pink_idx_new_pony_test_idx\",\n  2919\t        )\n  2920\t\n  2921\t        new_state = project_state.clone()\n  2922\t        operation.state_forwards(app_label, new_state)\n  2923\t        # Rename index.\n  2924\t        expected_queries = 1 if connection.features.can_rename_index else 2\n  2925\t        with connection.schema_editor() as editor, self.assertNumQueries(\n  2926\t            expected_queries\n  2927\t        ):\n  2928\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2929\t        self.assertIndexNameNotExists(table_name, \"pony_pink_idx\")\n  2930\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2931\t        # Reversal.\n  2932\t        with connection.schema_editor() as editor, self.assertNumQueries(\n  2933\t            expected_queries\n  2934\t        ):\n  2935\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2936\t        self.assertIndexNameExists(table_name, \"pony_pink_idx\")\n  2937\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2938\t        # Deconstruction.\n  2939\t        definition = operation.deconstruct()\n  2940\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2941\t        self.assertEqual(definition[1], [])\n  2942\t        self.assertEqual(\n  2943\t            definition[2],\n  2944\t            {\n  2945\t                \"model_name\": \"Pony\",\n  2946\t                \"old_name\": \"pony_pink_idx\",\n  2947\t                \"new_name\": \"new_pony_test_idx\",\n  2948\t            },\n  2949\t        )\n  2950\t\n  2951\t    def test_rename_index_arguments(self):\n  2952\t        msg = \"RenameIndex.old_name and old_fields are mutually exclusive.\"\n  2953\t        with self.assertRaisesMessage(ValueError, msg):\n  2954\t            migrations.RenameIndex(\n  2955\t                \"Pony\",\n  2956\t                new_name=\"new_idx_name\",\n  2957\t                old_name=\"old_idx_name\",\n  2958\t                old_fields=(\"weight\", \"pink\"),\n  2959\t            )\n  2960\t        msg = \"RenameIndex requires one of old_name and old_fields arguments to be set.\"\n  2961\t        with self.assertRaisesMessage(ValueError, msg):\n  2962\t            migrations.RenameIndex(\"Pony\", new_name=\"new_idx_name\")\n  2963\t\n  2964\t    def test_rename_index_unnamed_index(self):\n  2965\t        app_label = \"test_rninui\"\n  2966\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  2967\t        table_name = app_label + \"_pony\"\n  2968\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2969\t        operation = migrations.RenameIndex(\n  2970\t            \"Pony\", new_name=\"new_pony_test_idx\", old_fields=(\"weight\", \"pink\")\n  2971\t        )\n  2972\t        self.assertEqual(\n  2973\t            operation.describe(),\n  2974\t            \"Rename unnamed index for ('weight', 'pink') on Pony to new_pony_test_idx\",\n  2975\t        )\n  2976\t        self.assertEqual(\n  2977\t            operation.migration_name_fragment,\n  2978\t            \"rename_pony_weight_pink_new_pony_test_idx\",\n  2979\t        )\n  2980\t\n  2981\t        new_state = project_state.clone()\n  2982\t        operation.state_forwards(app_label, new_state)\n  2983\t        # Rename index.\n  2984\t        with connection.schema_editor() as editor:\n  2985\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2986\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2987\t        # Reverse is a no-op.\n  2988\t        with connection.schema_editor() as editor, self.assertNumQueries(0):\n  2989\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2990\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2991\t        # Deconstruction.\n  2992\t        definition = operation.deconstruct()\n  2993\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2994\t        self.assertEqual(definition[1], [])\n  2995\t        self.assertEqual(\n  2996\t            definition[2],\n  2997\t            {\n  2998\t                \"model_name\": \"Pony\",\n  2999\t                \"new_name\": \"new_pony_test_idx\",\n  3000\t                \"old_fields\": (\"weight\", \"pink\"),\n  3001\t            },\n  3002\t        )\n  3003\t\n  3004\t    def test_rename_index_unknown_unnamed_index(self):\n  3005\t        app_label = \"test_rninuui\"\n  3006\t        project_state = self.set_up_test_model(app_label)\n  3007\t        operation = migrations.RenameIndex(\n  3008\t            \"Pony\", new_name=\"new_pony_test_idx\", old_fields=(\"weight\", \"pink\")\n  3009\t        )\n  3010\t        new_state = project_state.clone()\n  3011\t        operation.state_forwards(app_label, new_state)\n  3012\t        msg = \"Found wrong number (0) of indexes for test_rninuui_pony(weight, pink).\"\n  3013\t        with connection.schema_editor() as editor:\n  3014\t            with self.assertRaisesMessage(ValueError, msg):\n  3015\t                operation.database_forwards(app_label, editor, project_state, new_state)\n  3016\t\n  3017\t    def test_add_index_state_forwards(self):\n  3018\t        project_state = self.set_up_test_model(\"test_adinsf\")\n  3019\t        index = models.Index(fields=[\"pink\"], name=\"test_adinsf_pony_pink_idx\")\n  3020\t        old_model = project_state.apps.get_model(\"test_adinsf\", \"Pony\")\n  3021\t        new_state = project_state.clone()\n  3022\t\n  3023\t        operation = migrations.AddIndex(\"Pony\", index)\n  3024\t        operation.state_forwards(\"test_adinsf\", new_state)\n  3025\t        new_model = new_state.apps.get_model(\"test_adinsf\", \"Pony\")\n  3026\t        self.assertIsNot(old_model, new_model)\n  3027\t\n  3028\t    def test_remove_index_state_forwards(self):\n  3029\t        project_state = self.set_up_test_model(\"test_rminsf\")\n  3030\t        index = models.Index(fields=[\"pink\"], name=\"test_rminsf_pony_pink_idx\")\n  3031\t        migrations.AddIndex(\"Pony\", index).state_forwards(\"test_rminsf\", project_state)\n  3032\t        old_model = project_state.apps.get_model(\"test_rminsf\", \"Pony\")\n  3033\t        new_state = project_state.clone()\n  3034\t\n  3035\t        operation = migrations.RemoveIndex(\"Pony\", \"test_rminsf_pony_pink_idx\")\n  3036\t        operation.state_forwards(\"test_rminsf\", new_state)\n  3037\t        new_model = new_state.apps.get_model(\"test_rminsf\", \"Pony\")\n  3038\t        self.assertIsNot(old_model, new_model)\n  3039\t\n  3040\t    def test_rename_index_state_forwards(self):\n  3041\t        app_label = \"test_rnidsf\"\n  3042\t        project_state = self.set_up_test_model(app_label, index=True)\n  3043\t        old_model = project_state.apps.get_model(app_label, \"Pony\")\n  3044\t        new_state = project_state.clone()\n  3045\t\n  3046\t        operation = migrations.RenameIndex(\n  3047\t            \"Pony\", new_name=\"new_pony_pink_idx\", old_name=\"pony_pink_idx\"\n  3048\t        )\n  3049\t        operation.state_forwards(app_label, new_state)\n  3050\t        new_model = new_state.apps.get_model(app_label, \"Pony\")\n  3051\t        self.assertIsNot(old_model, new_model)\n  3052\t        self.assertEqual(new_model._meta.indexes[0].name, \"new_pony_pink_idx\")\n  3053\t\n  3054\t    def test_rename_index_state_forwards_unnamed_index(self):\n  3055\t        app_label = \"test_rnidsfui\"\n  3056\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  3057\t        old_model = project_state.apps.get_model(app_label, \"Pony\")\n  3058\t        new_state = project_state.clone()\n  3059\t\n  3060\t        operation = migrations.RenameIndex(\n  3061\t            \"Pony\", new_name=\"new_pony_pink_idx\", old_fields=(\"weight\", \"pink\")\n  3062\t        )\n  3063\t        operation.state_forwards(app_label, new_state)\n  3064\t        new_model = new_state.apps.get_model(app_label, \"Pony\")\n  3065\t        self.assertIsNot(old_model, new_model)\n  3066\t        self.assertEqual(new_model._meta.index_together, tuple())\n  3067\t        self.assertEqual(new_model._meta.indexes[0].name, \"new_pony_pink_idx\")\n  3068\t\n  3069\t    @skipUnlessDBFeature(\"supports_expression_indexes\")\n  3070\t    def test_add_func_index(self):\n  3071\t        app_label = \"test_addfuncin\"\n  3072\t        index_name = f\"{app_label}_pony_abs_idx\"\n  3073\t        table_name = f\"{app_label}_pony\"\n  3074\t        project_state = self.set_up_test_model(app_label)\n  3075\t        index = models.Index(Abs(\"weight\"), name=index_name)\n  3076\t        operation = migrations.AddIndex(\"Pony\", index)\n  3077\t        self.assertEqual(\n  3078\t            operation.describe(),\n  3079\t            \"Create index test_addfuncin_pony_abs_idx on Abs(F(weight)) on model Pony\",\n  3080\t        )\n  3081\t        self.assertEqual(\n  3082\t            operation.migration_name_fragment,\n  3083\t            \"pony_test_addfuncin_pony_abs_idx\",\n  3084\t        )\n  3085\t        new_state = project_state.clone()\n  3086\t        operation.state_forwards(app_label, new_state)\n  3087\t        self.assertEqual(len(new_state.models[app_label, \"pony\"].options[\"indexes\"]), 1)\n  3088\t        self.assertIndexNameNotExists(table_name, index_name)\n  3089\t        # Add index.\n  3090\t        with connection.schema_editor() as editor:\n  3091\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3092\t        self.assertIndexNameExists(table_name, index_name)\n  3093\t        # Reversal.\n  3094\t        with connection.schema_editor() as editor:\n  3095\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3096\t        self.assertIndexNameNotExists(table_name, index_name)\n  3097\t        # Deconstruction.\n  3098\t        definition = operation.deconstruct()\n  3099\t        self.assertEqual(definition[0], \"AddIndex\")\n  3100\t        self.assertEqual(definition[1], [])\n  3101\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"index\": index})\n  3102\t\n  3103\t    @skipUnlessDBFeature(\"supports_expression_indexes\")\n  3104\t    def test_remove_func_index(self):\n  3105\t        app_label = \"test_rmfuncin\"\n  3106\t        index_name = f\"{app_label}_pony_abs_idx\"\n  3107\t        table_name = f\"{app_label}_pony\"\n  3108\t        project_state = self.set_up_test_model(\n  3109\t            app_label,\n  3110\t            indexes=[\n  3111\t                models.Index(Abs(\"weight\"), name=index_name),\n  3112\t            ],\n  3113\t        )\n  3114\t        self.assertTableExists(table_name)\n  3115\t        self.assertIndexNameExists(table_name, index_name)\n  3116\t        operation = migrations.RemoveIndex(\"Pony\", index_name)\n  3117\t        self.assertEqual(\n  3118\t            operation.describe(),\n  3119\t            \"Remove index test_rmfuncin_pony_abs_idx from Pony\",\n  3120\t        )\n  3121\t        self.assertEqual(\n  3122\t            operation.migration_name_fragment,\n  3123\t            \"remove_pony_test_rmfuncin_pony_abs_idx\",\n  3124\t        )\n  3125\t        new_state = project_state.clone()\n  3126\t        operation.state_forwards(app_label, new_state)\n  3127\t        self.assertEqual(len(new_state.models[app_label, \"pony\"].options[\"indexes\"]), 0)\n  3128\t        # Remove index.\n  3129\t        with connection.schema_editor() as editor:\n  3130\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3131\t        self.assertIndexNameNotExists(table_name, index_name)\n  3132\t        # Reversal.\n  3133\t        with connection.schema_editor() as editor:\n  3134\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3135\t        self.assertIndexNameExists(table_name, index_name)\n  3136\t        # Deconstruction.\n  3137\t        definition = operation.deconstruct()\n  3138\t        self.assertEqual(definition[0], \"RemoveIndex\")\n  3139\t        self.assertEqual(definition[1], [])\n  3140\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"name\": index_name})\n  3141\t\n  3142\t    @skipUnlessDBFeature(\"supports_expression_indexes\")\n  3143\t    def test_alter_field_with_func_index(self):\n  3144\t        app_label = \"test_alfuncin\"\n  3145\t        index_name = f\"{app_label}_pony_idx\"\n  3146\t        table_name = f\"{app_label}_pony\"\n  3147\t        project_state = self.set_up_test_model(\n  3148\t            app_label,\n  3149\t            indexes=[models.Index(Abs(\"pink\"), name=index_name)],\n  3150\t        )\n  3151\t        operation = migrations.AlterField(\n  3152\t            \"Pony\", \"pink\", models.IntegerField(null=True)\n  3153\t        )\n  3154\t        new_state = project_state.clone()\n  3155\t        operation.state_forwards(app_label, new_state)\n  3156\t        with connection.schema_editor() as editor:\n  3157\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3158\t        self.assertIndexNameExists(table_name, index_name)\n  3159\t        with connection.schema_editor() as editor:\n  3160\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3161\t        self.assertIndexNameExists(table_name, index_name)\n  3162\t\n  3163\t    def test_alter_field_with_index(self):\n  3164\t        \"\"\"\n  3165\t        Test AlterField operation with an index to ensure indexes created via\n  3166\t        Meta.indexes don't get dropped with sqlite3 remake.\n  3167\t        \"\"\"\n  3168\t        project_state = self.set_up_test_model(\"test_alflin\", index=True)\n  3169\t        operation = migrations.AlterField(\n  3170\t            \"Pony\", \"pink\", models.IntegerField(null=True)\n  3171\t        )\n  3172\t        new_state = project_state.clone()\n  3173\t        operation.state_forwards(\"test_alflin\", new_state)\n  3174\t        # Test the database alteration\n  3175\t        self.assertColumnNotNull(\"test_alflin_pony\", \"pink\")\n  3176\t        with connection.schema_editor() as editor:\n  3177\t            operation.database_forwards(\"test_alflin\", editor, project_state, new_state)\n  3178\t        # Index hasn't been dropped\n  3179\t        self.assertIndexExists(\"test_alflin_pony\", [\"pink\"])\n  3180\t        # And test reversal\n  3181\t        with connection.schema_editor() as editor:\n  3182\t            operation.database_backwards(\n  3183\t                \"test_alflin\", editor, new_state, project_state\n  3184\t            )\n  3185\t        # Ensure the index is still there\n  3186\t        self.assertIndexExists(\"test_alflin_pony\", [\"pink\"])\n  3187\t\n  3188\t    def test_alter_index_together(self):\n  3189\t        \"\"\"\n  3190\t        Tests the AlterIndexTogether operation.\n  3191\t        \"\"\"\n  3192\t        project_state = self.set_up_test_model(\"test_alinto\")\n  3193\t        # Test the state alteration\n  3194\t        operation = migrations.AlterIndexTogether(\"Pony\", [(\"pink\", \"weight\")])\n  3195\t        self.assertEqual(\n  3196\t            operation.describe(), \"Alter index_together for Pony (1 constraint(s))\"\n  3197\t        )\n  3198\t        self.assertEqual(\n  3199\t            operation.migration_name_fragment,\n  3200\t            \"alter_pony_index_together\",\n  3201\t        )\n  3202\t        new_state = project_state.clone()\n  3203\t        operation.state_forwards(\"test_alinto\", new_state)\n  3204\t        self.assertEqual(\n  3205\t            len(\n  3206\t                project_state.models[\"test_alinto\", \"pony\"].options.get(\n  3207\t                    \"index_together\", set()\n  3208\t                )\n  3209\t            ),\n  3210\t            0,\n  3211\t        )\n  3212\t        self.assertEqual(\n  3213\t            len(\n  3214\t                new_state.models[\"test_alinto\", \"pony\"].options.get(\n  3215\t                    \"index_together\", set()\n  3216\t                )\n  3217\t            ),\n  3218\t            1,\n  3219\t        )\n  3220\t        # Make sure there's no matching index\n  3221\t        self.assertIndexNotExists(\"test_alinto_pony\", [\"pink\", \"weight\"])\n  3222\t        # Test the database alteration\n  3223\t        with connection.schema_editor() as editor:\n  3224\t            operation.database_forwards(\"test_alinto\", editor, project_state, new_state)\n  3225\t        self.assertIndexExists(\"test_alinto_pony\", [\"pink\", \"weight\"])\n  3226\t        # And test reversal\n  3227\t        with connection.schema_editor() as editor:\n  3228\t            operation.database_backwards(\n  3229\t                \"test_alinto\", editor, new_state, project_state\n  3230\t            )\n  3231\t        self.assertIndexNotExists(\"test_alinto_pony\", [\"pink\", \"weight\"])\n  3232\t        # And deconstruction\n  3233\t        definition = operation.deconstruct()\n  3234\t        self.assertEqual(definition[0], \"AlterIndexTogether\")\n  3235\t        self.assertEqual(definition[1], [])\n  3236\t        self.assertEqual(\n  3237\t            definition[2], {\"name\": \"Pony\", \"index_together\": {(\"pink\", \"weight\")}}\n  3238\t        )\n  3239\t\n  3240\t    def test_alter_index_together_remove(self):\n  3241\t        operation = migrations.AlterIndexTogether(\"Pony\", None)\n  3242\t        self.assertEqual(\n  3243\t            operation.describe(), \"Alter index_together for Pony (0 constraint(s))\"\n  3244\t        )\n  3245\t\n  3246\t    @skipUnlessDBFeature(\"allows_multiple_constraints_on_same_fields\")\n  3247\t    def test_alter_index_together_remove_with_unique_together(self):\n  3248\t        app_label = \"test_alintoremove_wunto\"\n  3249\t        table_name = \"%s_pony\" % app_label\n  3250\t        project_state = self.set_up_test_model(app_label, unique_together=True)\n  3251\t        self.assertUniqueConstraintExists(table_name, [\"pink\", \"weight\"])\n  3252\t        # Add index together.\n  3253\t        new_state = project_state.clone()\n  3254\t        operation = migrations.AlterIndexTogether(\"Pony\", [(\"pink\", \"weight\")])\n  3255\t        operation.state_forwards(app_label, new_state)\n  3256\t        with connection.schema_editor() as editor:\n  3257\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3258\t        self.assertIndexExists(table_name, [\"pink\", \"weight\"])\n  3259\t        # Remove index together.\n  3260\t        project_state = new_state\n  3261\t        new_state = project_state.clone()\n  3262\t        operation = migrations.AlterIndexTogether(\"Pony\", set())\n  3263\t        operation.state_forwards(app_label, new_state)\n  3264\t        with connection.schema_editor() as editor:\n  3265\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3266\t        self.assertIndexNotExists(table_name, [\"pink\", \"weight\"])\n  3267\t        self.assertUniqueConstraintExists(table_name, [\"pink\", \"weight\"])\n  3268\t\n  3269\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3270\t    def test_add_constraint(self):\n  3271\t        project_state = self.set_up_test_model(\"test_addconstraint\")\n  3272\t        gt_check = models.Q(pink__gt=2)\n  3273\t        gt_constraint = models.CheckConstraint(\n  3274\t            check=gt_check, name=\"test_add_constraint_pony_pink_gt_2\"\n  3275\t        )\n  3276\t        gt_operation = migrations.AddConstraint(\"Pony\", gt_constraint)\n  3277\t        self.assertEqual(\n  3278\t            gt_operation.describe(),\n  3279\t            \"Create constraint test_add_constraint_pony_pink_gt_2 on model Pony\",\n  3280\t        )\n  3281\t        self.assertEqual(\n  3282\t            gt_operation.migration_name_fragment,\n  3283\t            \"pony_test_add_constraint_pony_pink_gt_2\",\n  3284\t        )\n  3285\t        # Test the state alteration\n  3286\t        new_state = project_state.clone()\n  3287\t        gt_operation.state_forwards(\"test_addconstraint\", new_state)\n  3288\t        self.assertEqual(\n  3289\t            len(new_state.models[\"test_addconstraint\", \"pony\"].options[\"constraints\"]),\n  3290\t            1,\n  3291\t        )\n  3292\t        Pony = new_state.apps.get_model(\"test_addconstraint\", \"Pony\")\n  3293\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3294\t        # Test the database alteration\n  3295\t        with connection.schema_editor() as editor:\n  3296\t            gt_operation.database_forwards(\n  3297\t                \"test_addconstraint\", editor, project_state, new_state\n  3298\t            )\n  3299\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3300\t            Pony.objects.create(pink=1, weight=1.0)\n  3301\t        # Add another one.\n  3302\t        lt_check = models.Q(pink__lt=100)\n  3303\t        lt_constraint = models.CheckConstraint(\n  3304\t            check=lt_check, name=\"test_add_constraint_pony_pink_lt_100\"\n  3305\t        )\n  3306\t        lt_operation = migrations.AddConstraint(\"Pony\", lt_constraint)\n  3307\t        lt_operation.state_forwards(\"test_addconstraint\", new_state)\n  3308\t        self.assertEqual(\n  3309\t            len(new_state.models[\"test_addconstraint\", \"pony\"].options[\"constraints\"]),\n  3310\t            2,\n  3311\t        )\n  3312\t        Pony = new_state.apps.get_model(\"test_addconstraint\", \"Pony\")\n  3313\t        self.assertEqual(len(Pony._meta.constraints), 2)\n  3314\t        with connection.schema_editor() as editor:\n  3315\t            lt_operation.database_forwards(\n  3316\t                \"test_addconstraint\", editor, project_state, new_state\n  3317\t            )\n  3318\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3319\t            Pony.objects.create(pink=100, weight=1.0)\n  3320\t        # Test reversal\n  3321\t        with connection.schema_editor() as editor:\n  3322\t            gt_operation.database_backwards(\n  3323\t                \"test_addconstraint\", editor, new_state, project_state\n  3324\t            )\n  3325\t        Pony.objects.create(pink=1, weight=1.0)\n  3326\t        # Test deconstruction\n  3327\t        definition = gt_operation.deconstruct()\n  3328\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3329\t        self.assertEqual(definition[1], [])\n  3330\t        self.assertEqual(\n  3331\t            definition[2], {\"model_name\": \"Pony\", \"constraint\": gt_constraint}\n  3332\t        )\n  3333\t\n  3334\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3335\t    def test_add_constraint_percent_escaping(self):\n  3336\t        app_label = \"add_constraint_string_quoting\"\n  3337\t        operations = [\n  3338\t            migrations.CreateModel(\n  3339\t                \"Author\",\n  3340\t                fields=[\n  3341\t                    (\"id\", models.AutoField(primary_key=True)),\n  3342\t                    (\"name\", models.CharField(max_length=100)),\n  3343\t                    (\"surname\", models.CharField(max_length=100, default=\"\")),\n  3344\t                    (\"rebate\", models.CharField(max_length=100)),\n  3345\t                ],\n  3346\t            ),\n  3347\t        ]\n  3348\t        from_state = self.apply_operations(app_label, ProjectState(), operations)\n  3349\t        # \"%\" generated in startswith lookup should be escaped in a way that is\n  3350\t        # considered a leading wildcard.\n  3351\t        check = models.Q(name__startswith=\"Albert\")\n  3352\t        constraint = models.CheckConstraint(check=check, name=\"name_constraint\")\n  3353\t        operation = migrations.AddConstraint(\"Author\", constraint)\n  3354\t        to_state = from_state.clone()\n  3355\t        operation.state_forwards(app_label, to_state)\n  3356\t        with connection.schema_editor() as editor:\n  3357\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3358\t        Author = to_state.apps.get_model(app_label, \"Author\")\n  3359\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3360\t            Author.objects.create(name=\"Artur\")\n  3361\t        # Literal \"%\" should be escaped in a way that is not a considered a\n  3362\t        # wildcard.\n  3363\t        check = models.Q(rebate__endswith=\"%\")\n  3364\t        constraint = models.CheckConstraint(check=check, name=\"rebate_constraint\")\n  3365\t        operation = migrations.AddConstraint(\"Author\", constraint)\n  3366\t        from_state = to_state\n  3367\t        to_state = from_state.clone()\n  3368\t        operation.state_forwards(app_label, to_state)\n  3369\t        Author = to_state.apps.get_model(app_label, \"Author\")\n  3370\t        with connection.schema_editor() as editor:\n  3371\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3372\t        Author = to_state.apps.get_model(app_label, \"Author\")\n  3373\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3374\t            Author.objects.create(name=\"Albert\", rebate=\"10$\")\n  3375\t        author = Author.objects.create(name=\"Albert\", rebate=\"10%\")\n  3376\t        self.assertEqual(Author.objects.get(), author)\n  3377\t        # Right-hand-side baked \"%\" literals should not be used for parameters\n  3378\t        # interpolation.\n  3379\t        check = ~models.Q(surname__startswith=models.F(\"name\"))\n  3380\t        constraint = models.CheckConstraint(check=check, name=\"name_constraint_rhs\")\n  3381\t        operation = migrations.AddConstraint(\"Author\", constraint)\n  3382\t        from_state = to_state\n  3383\t        to_state = from_state.clone()\n  3384\t        operation.state_forwards(app_label, to_state)\n  3385\t        with connection.schema_editor() as editor:\n  3386\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3387\t        Author = to_state.apps.get_model(app_label, \"Author\")\n  3388\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3389\t            Author.objects.create(name=\"Albert\", surname=\"Alberto\")\n  3390\t\n  3391\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3392\t    def test_add_or_constraint(self):\n  3393\t        app_label = \"test_addorconstraint\"\n  3394\t        constraint_name = \"add_constraint_or\"\n  3395\t        from_state = self.set_up_test_model(app_label)\n  3396\t        check = models.Q(pink__gt=2, weight__gt=2) | models.Q(weight__lt=0)\n  3397\t        constraint = models.CheckConstraint(check=check, name=constraint_name)\n  3398\t        operation = migrations.AddConstraint(\"Pony\", constraint)\n  3399\t        to_state = from_state.clone()\n  3400\t        operation.state_forwards(app_label, to_state)\n  3401\t        with connection.schema_editor() as editor:\n  3402\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3403\t        Pony = to_state.apps.get_model(app_label, \"Pony\")\n  3404\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3405\t            Pony.objects.create(pink=2, weight=3.0)\n  3406\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3407\t            Pony.objects.create(pink=3, weight=1.0)\n  3408\t        Pony.objects.bulk_create(\n  3409\t            [\n  3410\t                Pony(pink=3, weight=-1.0),\n  3411\t                Pony(pink=1, weight=-1.0),\n  3412\t                Pony(pink=3, weight=3.0),\n  3413\t            ]\n  3414\t        )\n  3415\t\n  3416\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3417\t    def test_add_constraint_combinable(self):\n  3418\t        app_label = \"test_addconstraint_combinable\"\n  3419\t        operations = [\n  3420\t            migrations.CreateModel(\n  3421\t                \"Book\",\n  3422\t                fields=[\n  3423\t                    (\"id\", models.AutoField(primary_key=True)),\n  3424\t                    (\"read\", models.PositiveIntegerField()),\n  3425\t                    (\"unread\", models.PositiveIntegerField()),\n  3426\t                ],\n  3427\t            ),\n  3428\t        ]\n  3429\t        from_state = self.apply_operations(app_label, ProjectState(), operations)\n  3430\t        constraint = models.CheckConstraint(\n  3431\t            check=models.Q(read=(100 - models.F(\"unread\"))),\n  3432\t            name=\"test_addconstraint_combinable_sum_100\",\n  3433\t        )\n  3434\t        operation = migrations.AddConstraint(\"Book\", constraint)\n  3435\t        to_state = from_state.clone()\n  3436\t        operation.state_forwards(app_label, to_state)\n  3437\t        with connection.schema_editor() as editor:\n  3438\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3439\t        Book = to_state.apps.get_model(app_label, \"Book\")\n  3440\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3441\t            Book.objects.create(read=70, unread=10)\n  3442\t        Book.objects.create(read=70, unread=30)\n  3443\t\n  3444\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3445\t    def test_remove_constraint(self):\n  3446\t        project_state = self.set_up_test_model(\n  3447\t            \"test_removeconstraint\",\n  3448\t            constraints=[\n  3449\t                models.CheckConstraint(\n  3450\t                    check=models.Q(pink__gt=2),\n  3451\t                    name=\"test_remove_constraint_pony_pink_gt_2\",\n  3452\t                ),\n  3453\t                models.CheckConstraint(\n  3454\t                    check=models.Q(pink__lt=100),\n  3455\t                    name=\"test_remove_constraint_pony_pink_lt_100\",\n  3456\t                ),\n  3457\t            ],\n  3458\t        )\n  3459\t        gt_operation = migrations.RemoveConstraint(\n  3460\t            \"Pony\", \"test_remove_constraint_pony_pink_gt_2\"\n  3461\t        )\n  3462\t        self.assertEqual(\n  3463\t            gt_operation.describe(),\n  3464\t            \"Remove constraint test_remove_constraint_pony_pink_gt_2 from model Pony\",\n  3465\t        )\n  3466\t        self.assertEqual(\n  3467\t            gt_operation.migration_name_fragment,\n  3468\t            \"remove_pony_test_remove_constraint_pony_pink_gt_2\",\n  3469\t        )\n  3470\t        # Test state alteration\n  3471\t        new_state = project_state.clone()\n  3472\t        gt_operation.state_forwards(\"test_removeconstraint\", new_state)\n  3473\t        self.assertEqual(\n  3474\t            len(\n  3475\t                new_state.models[\"test_removeconstraint\", \"pony\"].options[\"constraints\"]\n  3476\t            ),\n  3477\t            1,\n  3478\t        )\n  3479\t        Pony = new_state.apps.get_model(\"test_removeconstraint\", \"Pony\")\n  3480\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3481\t        # Test database alteration\n  3482\t        with connection.schema_editor() as editor:\n  3483\t            gt_operation.database_forwards(\n  3484\t                \"test_removeconstraint\", editor, project_state, new_state\n  3485\t            )\n  3486\t        Pony.objects.create(pink=1, weight=1.0).delete()\n  3487\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3488\t            Pony.objects.create(pink=100, weight=1.0)\n  3489\t        # Remove the other one.\n  3490\t        lt_operation = migrations.RemoveConstraint(\n  3491\t            \"Pony\", \"test_remove_constraint_pony_pink_lt_100\"\n  3492\t        )\n  3493\t        lt_operation.state_forwards(\"test_removeconstraint\", new_state)\n  3494\t        self.assertEqual(\n  3495\t            len(\n  3496\t                new_state.models[\"test_removeconstraint\", \"pony\"].options[\"constraints\"]\n  3497\t            ),\n  3498\t            0,\n  3499\t        )\n  3500\t        Pony = new_state.apps.get_model(\"test_removeconstraint\", \"Pony\")\n  3501\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3502\t        with connection.schema_editor() as editor:\n  3503\t            lt_operation.database_forwards(\n  3504\t                \"test_removeconstraint\", editor, project_state, new_state\n  3505\t            )\n  3506\t        Pony.objects.create(pink=100, weight=1.0).delete()\n  3507\t        # Test reversal\n  3508\t        with connection.schema_editor() as editor:\n  3509\t            gt_operation.database_backwards(\n  3510\t                \"test_removeconstraint\", editor, new_state, project_state\n  3511\t            )\n  3512\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3513\t            Pony.objects.create(pink=1, weight=1.0)\n  3514\t        # Test deconstruction\n  3515\t        definition = gt_operation.deconstruct()\n  3516\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3517\t        self.assertEqual(definition[1], [])\n  3518\t        self.assertEqual(\n  3519\t            definition[2],\n  3520\t            {\"model_name\": \"Pony\", \"name\": \"test_remove_constraint_pony_pink_gt_2\"},\n  3521\t        )\n  3522\t\n  3523\t    def test_add_partial_unique_constraint(self):\n  3524\t        project_state = self.set_up_test_model(\"test_addpartialuniqueconstraint\")\n  3525\t        partial_unique_constraint = models.UniqueConstraint(\n  3526\t            fields=[\"pink\"],\n  3527\t            condition=models.Q(weight__gt=5),\n  3528\t            name=\"test_constraint_pony_pink_for_weight_gt_5_uniq\",\n  3529\t        )\n  3530\t        operation = migrations.AddConstraint(\"Pony\", partial_unique_constraint)\n  3531\t        self.assertEqual(\n  3532\t            operation.describe(),\n  3533\t            \"Create constraint test_constraint_pony_pink_for_weight_gt_5_uniq \"\n  3534\t            \"on model Pony\",\n  3535\t        )\n  3536\t        # Test the state alteration\n  3537\t        new_state = project_state.clone()\n  3538\t        operation.state_forwards(\"test_addpartialuniqueconstraint\", new_state)\n  3539\t        self.assertEqual(\n  3540\t            len(\n  3541\t                new_state.models[\"test_addpartialuniqueconstraint\", \"pony\"].options[\n  3542\t                    \"constraints\"\n  3543\t                ]\n  3544\t            ),\n  3545\t            1,\n  3546\t        )\n  3547\t        Pony = new_state.apps.get_model(\"test_addpartialuniqueconstraint\", \"Pony\")\n  3548\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3549\t        # Test the database alteration\n  3550\t        with connection.schema_editor() as editor:\n  3551\t            operation.database_forwards(\n  3552\t                \"test_addpartialuniqueconstraint\", editor, project_state, new_state\n  3553\t            )\n  3554\t        # Test constraint works\n  3555\t        Pony.objects.create(pink=1, weight=4.0)\n  3556\t        Pony.objects.create(pink=1, weight=4.0)\n  3557\t        Pony.objects.create(pink=1, weight=6.0)\n  3558\t        if connection.features.supports_partial_indexes:\n  3559\t            with self.assertRaises(IntegrityError), transaction.atomic():\n  3560\t                Pony.objects.create(pink=1, weight=7.0)\n  3561\t        else:\n  3562\t            Pony.objects.create(pink=1, weight=7.0)\n  3563\t        # Test reversal\n  3564\t        with connection.schema_editor() as editor:\n  3565\t            operation.database_backwards(\n  3566\t                \"test_addpartialuniqueconstraint\", editor, new_state, project_state\n  3567\t            )\n  3568\t        # Test constraint doesn't work\n  3569\t        Pony.objects.create(pink=1, weight=7.0)\n  3570\t        # Test deconstruction\n  3571\t        definition = operation.deconstruct()\n  3572\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3573\t        self.assertEqual(definition[1], [])\n  3574\t        self.assertEqual(\n  3575\t            definition[2],\n  3576\t            {\"model_name\": \"Pony\", \"constraint\": partial_unique_constraint},\n  3577\t        )\n  3578\t\n  3579\t    def test_remove_partial_unique_constraint(self):\n  3580\t        project_state = self.set_up_test_model(\n  3581\t            \"test_removepartialuniqueconstraint\",\n  3582\t            constraints=[\n  3583\t                models.UniqueConstraint(\n  3584\t                    fields=[\"pink\"],\n  3585\t                    condition=models.Q(weight__gt=5),\n  3586\t                    name=\"test_constraint_pony_pink_for_weight_gt_5_uniq\",\n  3587\t                ),\n  3588\t            ],\n  3589\t        )\n  3590\t        gt_operation = migrations.RemoveConstraint(\n  3591\t            \"Pony\", \"test_constraint_pony_pink_for_weight_gt_5_uniq\"\n  3592\t        )\n  3593\t        self.assertEqual(\n  3594\t            gt_operation.describe(),\n  3595\t            \"Remove constraint test_constraint_pony_pink_for_weight_gt_5_uniq from \"\n  3596\t            \"model Pony\",\n  3597\t        )\n  3598\t        # Test state alteration\n  3599\t        new_state = project_state.clone()\n  3600\t        gt_operation.state_forwards(\"test_removepartialuniqueconstraint\", new_state)\n  3601\t        self.assertEqual(\n  3602\t            len(\n  3603\t                new_state.models[\"test_removepartialuniqueconstraint\", \"pony\"].options[\n  3604\t                    \"constraints\"\n  3605\t                ]\n  3606\t            ),\n  3607\t            0,\n  3608\t        )\n  3609\t        Pony = new_state.apps.get_model(\"test_removepartialuniqueconstraint\", \"Pony\")\n  3610\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3611\t        # Test database alteration\n  3612\t        with connection.schema_editor() as editor:\n  3613\t            gt_operation.database_forwards(\n  3614\t                \"test_removepartialuniqueconstraint\", editor, project_state, new_state\n  3615\t            )\n  3616\t        # Test constraint doesn't work\n  3617\t        Pony.objects.create(pink=1, weight=4.0)\n  3618\t        Pony.objects.create(pink=1, weight=4.0)\n  3619\t        Pony.objects.create(pink=1, weight=6.0)\n  3620\t        Pony.objects.create(pink=1, weight=7.0).delete()\n  3621\t        # Test reversal\n  3622\t        with connection.schema_editor() as editor:\n  3623\t            gt_operation.database_backwards(\n  3624\t                \"test_removepartialuniqueconstraint\", editor, new_state, project_state\n  3625\t            )\n  3626\t        # Test constraint works\n  3627\t        if connection.features.supports_partial_indexes:\n  3628\t            with self.assertRaises(IntegrityError), transaction.atomic():\n  3629\t                Pony.objects.create(pink=1, weight=7.0)\n  3630\t        else:\n  3631\t            Pony.objects.create(pink=1, weight=7.0)\n  3632\t        # Test deconstruction\n  3633\t        definition = gt_operation.deconstruct()\n  3634\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3635\t        self.assertEqual(definition[1], [])\n  3636\t        self.assertEqual(\n  3637\t            definition[2],\n  3638\t            {\n  3639\t                \"model_name\": \"Pony\",\n  3640\t                \"name\": \"test_constraint_pony_pink_for_weight_gt_5_uniq\",\n  3641\t            },\n  3642\t        )\n  3643\t\n  3644\t    def test_add_deferred_unique_constraint(self):\n  3645\t        app_label = \"test_adddeferred_uc\"\n  3646\t        project_state = self.set_up_test_model(app_label)\n  3647\t        deferred_unique_constraint = models.UniqueConstraint(\n  3648\t            fields=[\"pink\"],\n  3649\t            name=\"deferred_pink_constraint_add\",\n  3650\t            deferrable=models.Deferrable.DEFERRED,\n  3651\t        )\n  3652\t        operation = migrations.AddConstraint(\"Pony\", deferred_unique_constraint)\n  3653\t        self.assertEqual(\n  3654\t            operation.describe(),\n  3655\t            \"Create constraint deferred_pink_constraint_add on model Pony\",\n  3656\t        )\n  3657\t        # Add constraint.\n  3658\t        new_state = project_state.clone()\n  3659\t        operation.state_forwards(app_label, new_state)\n  3660\t        self.assertEqual(\n  3661\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 1\n  3662\t        )\n  3663\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3664\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3665\t        with connection.schema_editor() as editor, CaptureQueriesContext(\n  3666\t            connection\n  3667\t        ) as ctx:\n  3668\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3669\t        Pony.objects.create(pink=1, weight=4.0)\n  3670\t        if connection.features.supports_deferrable_unique_constraints:\n  3671\t            # Unique constraint is deferred.\n  3672\t            with transaction.atomic():\n  3673\t                obj = Pony.objects.create(pink=1, weight=4.0)\n  3674\t                obj.pink = 2\n  3675\t                obj.save()\n  3676\t            # Constraint behavior can be changed with SET CONSTRAINTS.\n  3677\t            with self.assertRaises(IntegrityError):\n  3678\t                with transaction.atomic(), connection.cursor() as cursor:\n  3679\t                    quoted_name = connection.ops.quote_name(\n  3680\t                        deferred_unique_constraint.name\n  3681\t                    )\n  3682\t                    cursor.execute(\"SET CONSTRAINTS %s IMMEDIATE\" % quoted_name)\n  3683\t                    obj = Pony.objects.create(pink=1, weight=4.0)\n  3684\t                    obj.pink = 3\n  3685\t                    obj.save()\n  3686\t        else:\n  3687\t            self.assertEqual(len(ctx), 0)\n  3688\t            Pony.objects.create(pink=1, weight=4.0)\n  3689\t        # Reversal.\n  3690\t        with connection.schema_editor() as editor:\n  3691\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3692\t        # Constraint doesn't work.\n  3693\t        Pony.objects.create(pink=1, weight=4.0)\n  3694\t        # Deconstruction.\n  3695\t        definition = operation.deconstruct()\n  3696\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3697\t        self.assertEqual(definition[1], [])\n  3698\t        self.assertEqual(\n  3699\t            definition[2],\n  3700\t            {\"model_name\": \"Pony\", \"constraint\": deferred_unique_constraint},\n  3701\t        )\n  3702\t\n  3703\t    def test_remove_deferred_unique_constraint(self):\n  3704\t        app_label = \"test_removedeferred_uc\"\n  3705\t        deferred_unique_constraint = models.UniqueConstraint(\n  3706\t            fields=[\"pink\"],\n  3707\t            name=\"deferred_pink_constraint_rm\",\n  3708\t            deferrable=models.Deferrable.DEFERRED,\n  3709\t        )\n  3710\t        project_state = self.set_up_test_model(\n  3711\t            app_label, constraints=[deferred_unique_constraint]\n  3712\t        )\n  3713\t        operation = migrations.RemoveConstraint(\"Pony\", deferred_unique_constraint.name)\n  3714\t        self.assertEqual(\n  3715\t            operation.describe(),\n  3716\t            \"Remove constraint deferred_pink_constraint_rm from model Pony\",\n  3717\t        )\n  3718\t        # Remove constraint.\n  3719\t        new_state = project_state.clone()\n  3720\t        operation.state_forwards(app_label, new_state)\n  3721\t        self.assertEqual(\n  3722\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 0\n  3723\t        )\n  3724\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3725\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3726\t        with connection.schema_editor() as editor, CaptureQueriesContext(\n  3727\t            connection\n  3728\t        ) as ctx:\n  3729\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3730\t        # Constraint doesn't work.\n  3731\t        Pony.objects.create(pink=1, weight=4.0)\n  3732\t        Pony.objects.create(pink=1, weight=4.0).delete()\n  3733\t        if not connection.features.supports_deferrable_unique_constraints:\n  3734\t            self.assertEqual(len(ctx), 0)\n  3735\t        # Reversal.\n  3736\t        with connection.schema_editor() as editor:\n  3737\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3738\t        if connection.features.supports_deferrable_unique_constraints:\n  3739\t            # Unique constraint is deferred.\n  3740\t            with transaction.atomic():\n  3741\t                obj = Pony.objects.create(pink=1, weight=4.0)\n  3742\t                obj.pink = 2\n  3743\t                obj.save()\n  3744\t            # Constraint behavior can be changed with SET CONSTRAINTS.\n  3745\t            with self.assertRaises(IntegrityError):\n  3746\t                with transaction.atomic(), connection.cursor() as cursor:\n  3747\t                    quoted_name = connection.ops.quote_name(\n  3748\t                        deferred_unique_constraint.name\n  3749\t                    )\n  3750\t                    cursor.execute(\"SET CONSTRAINTS %s IMMEDIATE\" % quoted_name)\n  3751\t                    obj = Pony.objects.create(pink=1, weight=4.0)\n  3752\t                    obj.pink = 3\n  3753\t                    obj.save()\n  3754\t        else:\n  3755\t            Pony.objects.create(pink=1, weight=4.0)\n  3756\t        # Deconstruction.\n  3757\t        definition = operation.deconstruct()\n  3758\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3759\t        self.assertEqual(definition[1], [])\n  3760\t        self.assertEqual(\n  3761\t            definition[2],\n  3762\t            {\n  3763\t                \"model_name\": \"Pony\",\n  3764\t                \"name\": \"deferred_pink_constraint_rm\",\n  3765\t            },\n  3766\t        )\n  3767\t\n  3768\t    def test_add_covering_unique_constraint(self):\n  3769\t        app_label = \"test_addcovering_uc\"\n  3770\t        project_state = self.set_up_test_model(app_label)\n  3771\t        covering_unique_constraint = models.UniqueConstraint(\n  3772\t            fields=[\"pink\"],\n  3773\t            name=\"covering_pink_constraint_add\",\n  3774\t            include=[\"weight\"],\n  3775\t        )\n  3776\t        operation = migrations.AddConstraint(\"Pony\", covering_unique_constraint)\n  3777\t        self.assertEqual(\n  3778\t            operation.describe(),\n  3779\t            \"Create constraint covering_pink_constraint_add on model Pony\",\n  3780\t        )\n  3781\t        # Add constraint.\n  3782\t        new_state = project_state.clone()\n  3783\t        operation.state_forwards(app_label, new_state)\n  3784\t        self.assertEqual(\n  3785\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 1\n  3786\t        )\n  3787\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3788\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3789\t        with connection.schema_editor() as editor, CaptureQueriesContext(\n  3790\t            connection\n  3791\t        ) as ctx:\n  3792\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3793\t        Pony.objects.create(pink=1, weight=4.0)\n  3794\t        if connection.features.supports_covering_indexes:\n  3795\t            with self.assertRaises(IntegrityError):\n  3796\t                Pony.objects.create(pink=1, weight=4.0)\n  3797\t        else:\n  3798\t            self.assertEqual(len(ctx), 0)\n  3799\t            Pony.objects.create(pink=1, weight=4.0)\n  3800\t        # Reversal.\n  3801\t        with connection.schema_editor() as editor:\n  3802\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3803\t        # Constraint doesn't work.\n  3804\t        Pony.objects.create(pink=1, weight=4.0)\n  3805\t        # Deconstruction.\n  3806\t        definition = operation.deconstruct()\n  3807\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3808\t        self.assertEqual(definition[1], [])\n  3809\t        self.assertEqual(\n  3810\t            definition[2],\n  3811\t            {\"model_name\": \"Pony\", \"constraint\": covering_unique_constraint},\n  3812\t        )\n  3813\t\n  3814\t    def test_remove_covering_unique_constraint(self):\n  3815\t        app_label = \"test_removecovering_uc\"\n  3816\t        covering_unique_constraint = models.UniqueConstraint(\n  3817\t            fields=[\"pink\"],\n  3818\t            name=\"covering_pink_constraint_rm\",\n  3819\t            include=[\"weight\"],\n  3820\t        )\n  3821\t        project_state = self.set_up_test_model(\n  3822\t            app_label, constraints=[covering_unique_constraint]\n  3823\t        )\n  3824\t        operation = migrations.RemoveConstraint(\"Pony\", covering_unique_constraint.name)\n  3825\t        self.assertEqual(\n  3826\t            operation.describe(),\n  3827\t            \"Remove constraint covering_pink_constraint_rm from model Pony\",\n  3828\t        )\n  3829\t        # Remove constraint.\n  3830\t        new_state = project_state.clone()\n  3831\t        operation.state_forwards(app_label, new_state)\n  3832\t        self.assertEqual(\n  3833\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 0\n  3834\t        )\n  3835\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3836\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3837\t        with connection.schema_editor() as editor, CaptureQueriesContext(\n  3838\t            connection\n  3839\t        ) as ctx:\n  3840\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3841\t        # Constraint doesn't work.\n  3842\t        Pony.objects.create(pink=1, weight=4.0)\n  3843\t        Pony.objects.create(pink=1, weight=4.0).delete()\n  3844\t        if not connection.features.supports_covering_indexes:\n  3845\t            self.assertEqual(len(ctx), 0)\n  3846\t        # Reversal.\n  3847\t        with connection.schema_editor() as editor:\n  3848\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3849\t        if connection.features.supports_covering_indexes:\n  3850\t            with self.assertRaises(IntegrityError):\n  3851\t                Pony.objects.create(pink=1, weight=4.0)\n  3852\t        else:\n  3853\t            Pony.objects.create(pink=1, weight=4.0)\n  3854\t        # Deconstruction.\n  3855\t        definition = operation.deconstruct()\n  3856\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3857\t        self.assertEqual(definition[1], [])\n  3858\t        self.assertEqual(\n  3859\t            definition[2],\n  3860\t            {\n  3861\t                \"model_name\": \"Pony\",\n  3862\t                \"name\": \"covering_pink_constraint_rm\",\n  3863\t            },\n  3864\t        )\n  3865\t\n  3866\t    def test_alter_field_with_func_unique_constraint(self):\n  3867\t        app_label = \"test_alfuncuc\"\n  3868\t        constraint_name = f\"{app_label}_pony_uq\"\n  3869\t        table_name = f\"{app_label}_pony\"\n  3870\t        project_state = self.set_up_test_model(\n  3871\t            app_label,\n  3872\t            constraints=[\n  3873\t                models.UniqueConstraint(\"pink\", \"weight\", name=constraint_name)\n  3874\t            ],\n  3875\t        )\n  3876\t        operation = migrations.AlterField(\n  3877\t            \"Pony\", \"pink\", models.IntegerField(null=True)\n  3878\t        )\n  3879\t        new_state = project_state.clone()\n  3880\t        operation.state_forwards(app_label, new_state)\n  3881\t        with connection.schema_editor() as editor:\n  3882\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3883\t        if connection.features.supports_expression_indexes:\n  3884\t            self.assertIndexNameExists(table_name, constraint_name)\n  3885\t        with connection.schema_editor() as editor:\n  3886\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3887\t        if connection.features.supports_expression_indexes:\n  3888\t            self.assertIndexNameExists(table_name, constraint_name)\n  3889\t\n  3890\t    def test_add_func_unique_constraint(self):\n  3891\t        app_label = \"test_adfuncuc\"\n  3892\t        constraint_name = f\"{app_label}_pony_abs_uq\"\n  3893\t        table_name = f\"{app_label}_pony\"\n  3894\t        project_state = self.set_up_test_model(app_label)\n  3895\t        constraint = models.UniqueConstraint(Abs(\"weight\"), name=constraint_name)\n  3896\t        operation = migrations.AddConstraint(\"Pony\", constraint)\n  3897\t        self.assertEqual(\n  3898\t            operation.describe(),\n  3899\t            \"Create constraint test_adfuncuc_pony_abs_uq on model Pony\",\n  3900\t        )\n  3901\t        self.assertEqual(\n  3902\t            operation.migration_name_fragment,\n  3903\t            \"pony_test_adfuncuc_pony_abs_uq\",\n  3904\t        )\n  3905\t        new_state = project_state.clone()\n  3906\t        operation.state_forwards(app_label, new_state)\n  3907\t        self.assertEqual(\n  3908\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 1\n  3909\t        )\n  3910\t        self.assertIndexNameNotExists(table_name, constraint_name)\n  3911\t        # Add constraint.\n  3912\t        with connection.schema_editor() as editor:\n  3913\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3914\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3915\t        Pony.objects.create(weight=4.0)\n  3916\t        if connection.features.supports_expression_indexes:\n  3917\t            self.assertIndexNameExists(table_name, constraint_name)\n  3918\t            with self.assertRaises(IntegrityError):\n  3919\t                Pony.objects.create(weight=-4.0)\n  3920\t        else:\n  3921\t            self.assertIndexNameNotExists(table_name, constraint_name)\n  3922\t            Pony.objects.create(weight=-4.0)\n  3923\t        # Reversal.\n  3924\t        with connection.schema_editor() as editor:\n  3925\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3926\t        self.assertIndexNameNotExists(table_name, constraint_name)\n  3927\t        # Constraint doesn't work.\n  3928\t        Pony.objects.create(weight=-4.0)\n  3929\t        # Deconstruction.\n  3930\t        definition = operation.deconstruct()\n  3931\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3932\t        self.assertEqual(definition[1], [])\n  3933\t        self.assertEqual(\n  3934\t            definition[2],\n  3935\t            {\"model_name\": \"Pony\", \"constraint\": constraint},\n  3936\t        )\n  3937\t\n  3938\t    def test_remove_func_unique_constraint(self):\n  3939\t        app_label = \"test_rmfuncuc\"\n  3940\t        constraint_name = f\"{app_label}_pony_abs_uq\"\n  3941\t        table_name = f\"{app_label}_pony\"\n  3942\t        project_state = self.set_up_test_model(\n  3943\t            app_label,\n  3944\t            constraints=[\n  3945\t                models.UniqueConstraint(Abs(\"weight\"), name=constraint_name),\n  3946\t            ],\n  3947\t        )\n  3948\t        self.assertTableExists(table_name)\n  3949\t        if connection.features.supports_expression_indexes:\n  3950\t            self.assertIndexNameExists(table_name, constraint_name)\n  3951\t        operation = migrations.RemoveConstraint(\"Pony\", constraint_name)\n  3952\t        self.assertEqual(\n  3953\t            operation.describe(),\n  3954\t            \"Remove constraint test_rmfuncuc_pony_abs_uq from model Pony\",\n  3955\t        )\n  3956\t        self.assertEqual(\n  3957\t            operation.migration_name_fragment,\n  3958\t            \"remove_pony_test_rmfuncuc_pony_abs_uq\",\n  3959\t        )\n  3960\t        new_state = project_state.clone()\n  3961\t        operation.state_forwards(app_label, new_state)\n  3962\t        self.assertEqual(\n  3963\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 0\n  3964\t        )\n  3965\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3966\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3967\t        # Remove constraint.\n  3968\t        with connection.schema_editor() as editor:\n  3969\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3970\t        self.assertIndexNameNotExists(table_name, constraint_name)\n  3971\t        # Constraint doesn't work.\n  3972\t        Pony.objects.create(pink=1, weight=4.0)\n  3973\t        Pony.objects.create(pink=1, weight=-4.0).delete()\n  3974\t        # Reversal.\n  3975\t        with connection.schema_editor() as editor:\n  3976\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3977\t        if connection.features.supports_expression_indexes:\n  3978\t            self.assertIndexNameExists(table_name, constraint_name)\n  3979\t            with self.assertRaises(IntegrityError):\n  3980\t                Pony.objects.create(weight=-4.0)\n  3981\t        else:\n  3982\t            self.assertIndexNameNotExists(table_name, constraint_name)\n  3983\t            Pony.objects.create(weight=-4.0)\n  3984\t        # Deconstruction.\n  3985\t        definition = operation.deconstruct()\n  3986\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3987\t        self.assertEqual(definition[1], [])\n  3988\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"name\": constraint_name})\n  3989\t\n  3990\t    def test_alter_model_options(self):\n  3991\t        \"\"\"\n  3992\t        Tests the AlterModelOptions operation.\n  3993\t        \"\"\"\n  3994\t        project_state = self.set_up_test_model(\"test_almoop\")\n  3995\t        # Test the state alteration (no DB alteration to test)\n  3996\t        operation = migrations.AlterModelOptions(\n  3997\t            \"Pony\", {\"permissions\": [(\"can_groom\", \"Can groom\")]}\n  3998\t        )\n  3999\t        self.assertEqual(operation.describe(), \"Change Meta options on Pony\")\n  4000\t        self.assertEqual(operation.migration_name_fragment, \"alter_pony_options\")\n  4001\t        new_state = project_state.clone()\n  4002\t        operation.state_forwards(\"test_almoop\", new_state)\n  4003\t        self.assertEqual(\n  4004\t            len(\n  4005\t                project_state.models[\"test_almoop\", \"pony\"].options.get(\n  4006\t                    \"permissions\", []\n  4007\t                )\n  4008\t            ),\n  4009\t            0,\n  4010\t        )\n  4011\t        self.assertEqual(\n  4012\t            len(new_state.models[\"test_almoop\", \"pony\"].options.get(\"permissions\", [])),\n  4013\t            1,\n  4014\t        )\n  4015\t        self.assertEqual(\n  4016\t            new_state.models[\"test_almoop\", \"pony\"].options[\"permissions\"][0][0],\n  4017\t            \"can_groom\",\n  4018\t        )\n  4019\t        # And deconstruction\n  4020\t        definition = operation.deconstruct()\n  4021\t        self.assertEqual(definition[0], \"AlterModelOptions\")\n  4022\t        self.assertEqual(definition[1], [])\n  4023\t        self.assertEqual(\n  4024\t            definition[2],\n  4025\t            {\"name\": \"Pony\", \"options\": {\"permissions\": [(\"can_groom\", \"Can groom\")]}},\n  4026\t        )\n  4027\t\n  4028\t    def test_alter_model_options_emptying(self):\n  4029\t        \"\"\"\n  4030\t        The AlterModelOptions operation removes keys from the dict (#23121)\n  4031\t        \"\"\"\n  4032\t        project_state = self.set_up_test_model(\"test_almoop\", options=True)\n  4033\t        # Test the state alteration (no DB alteration to test)\n  4034\t        operation = migrations.AlterModelOptions(\"Pony\", {})\n  4035\t        self.assertEqual(operation.describe(), \"Change Meta options on Pony\")\n  4036\t        new_state = project_state.clone()\n  4037\t        operation.state_forwards(\"test_almoop\", new_state)\n  4038\t        self.assertEqual(\n  4039\t            len(\n  4040\t                project_state.models[\"test_almoop\", \"pony\"].options.get(\n  4041\t                    \"permissions\", []\n  4042\t                )\n  4043\t            ),\n  4044\t            1,\n  4045\t        )\n  4046\t        self.assertEqual(\n  4047\t            len(new_state.models[\"test_almoop\", \"pony\"].options.get(\"permissions\", [])),\n  4048\t            0,\n  4049\t        )\n  4050\t        # And deconstruction\n  4051\t        definition = operation.deconstruct()\n  4052\t        self.assertEqual(definition[0], \"AlterModelOptions\")\n  4053\t        self.assertEqual(definition[1], [])\n  4054\t        self.assertEqual(definition[2], {\"name\": \"Pony\", \"options\": {}})\n  4055\t\n  4056\t    def test_alter_order_with_respect_to(self):\n  4057\t        \"\"\"\n  4058\t        Tests the AlterOrderWithRespectTo operation.\n  4059\t        \"\"\"\n  4060\t        project_state = self.set_up_test_model(\"test_alorwrtto\", related_model=True)\n  4061\t        # Test the state alteration\n  4062\t        operation = migrations.AlterOrderWithRespectTo(\"Rider\", \"pony\")\n  4063\t        self.assertEqual(\n  4064\t            operation.describe(), \"Set order_with_respect_to on Rider to pony\"\n  4065\t        )\n  4066\t        self.assertEqual(\n  4067\t            operation.migration_name_fragment,\n  4068\t            \"alter_rider_order_with_respect_to\",\n  4069\t        )\n  4070\t        new_state = project_state.clone()\n  4071\t        operation.state_forwards(\"test_alorwrtto\", new_state)\n  4072\t        self.assertIsNone(\n  4073\t            project_state.models[\"test_alorwrtto\", \"rider\"].options.get(\n  4074\t                \"order_with_respect_to\", None\n  4075\t            )\n  4076\t        )\n  4077\t        self.assertEqual(\n  4078\t            new_state.models[\"test_alorwrtto\", \"rider\"].options.get(\n  4079\t                \"order_with_respect_to\", None\n  4080\t            ),\n  4081\t            \"pony\",\n  4082\t        )\n  4083\t        # Make sure there's no matching index\n  4084\t        self.assertColumnNotExists(\"test_alorwrtto_rider\", \"_order\")\n  4085\t        # Create some rows before alteration\n  4086\t        rendered_state = project_state.apps\n  4087\t        pony = rendered_state.get_model(\"test_alorwrtto\", \"Pony\").objects.create(\n  4088\t            weight=50\n  4089\t        )\n  4090\t        rider1 = rendered_state.get_model(\"test_alorwrtto\", \"Rider\").objects.create(\n  4091\t            pony=pony\n  4092\t        )\n  4093\t        rider1.friend = rider1\n  4094\t        rider1.save()\n  4095\t        rider2 = rendered_state.get_model(\"test_alorwrtto\", \"Rider\").objects.create(\n  4096\t            pony=pony\n  4097\t        )\n  4098\t        rider2.friend = rider2\n  4099\t        rider2.save()\n  4100\t        # Test the database alteration\n  4101\t        with connection.schema_editor() as editor:\n  4102\t            operation.database_forwards(\n  4103\t                \"test_alorwrtto\", editor, project_state, new_state\n  4104\t            )\n  4105\t        self.assertColumnExists(\"test_alorwrtto_rider\", \"_order\")\n  4106\t        # Check for correct value in rows\n  4107\t        updated_riders = new_state.apps.get_model(\n  4108\t            \"test_alorwrtto\", \"Rider\"\n  4109\t        ).objects.all()\n  4110\t        self.assertEqual(updated_riders[0]._order, 0)\n  4111\t        self.assertEqual(updated_riders[1]._order, 0)\n  4112\t        # And test reversal\n  4113\t        with connection.schema_editor() as editor:\n  4114\t            operation.database_backwards(\n  4115\t                \"test_alorwrtto\", editor, new_state, project_state\n  4116\t            )\n  4117\t        self.assertColumnNotExists(\"test_alorwrtto_rider\", \"_order\")\n  4118\t        # And deconstruction\n  4119\t        definition = operation.deconstruct()\n  4120\t        self.assertEqual(definition[0], \"AlterOrderWithRespectTo\")\n  4121\t        self.assertEqual(definition[1], [])\n  4122\t        self.assertEqual(\n  4123\t            definition[2], {\"name\": \"Rider\", \"order_with_respect_to\": \"pony\"}\n  4124\t        )\n  4125\t\n  4126\t    def test_alter_model_managers(self):\n  4127\t        \"\"\"\n  4128\t        The managers on a model are set.\n  4129\t        \"\"\"\n  4130\t        project_state = self.set_up_test_model(\"test_almoma\")\n  4131\t        # Test the state alteration\n  4132\t        operation = migrations.AlterModelManagers(\n  4133\t            \"Pony\",\n  4134\t            managers=[\n  4135\t                (\"food_qs\", FoodQuerySet.as_manager()),\n  4136\t                (\"food_mgr\", FoodManager(\"a\", \"b\")),\n  4137\t                (\"food_mgr_kwargs\", FoodManager(\"x\", \"y\", 3, 4)),\n  4138\t            ],\n  4139\t        )\n  4140\t        self.assertEqual(operation.describe(), \"Change managers on Pony\")\n  4141\t        self.assertEqual(operation.migration_name_fragment, \"alter_pony_managers\")\n  4142\t        managers = project_state.models[\"test_almoma\", \"pony\"].managers\n  4143\t        self.assertEqual(managers, [])\n  4144\t\n  4145\t        new_state = project_state.clone()\n  4146\t        operation.state_forwards(\"test_almoma\", new_state)\n  4147\t        self.assertIn((\"test_almoma\", \"pony\"), new_state.models)\n  4148\t        managers = new_state.models[\"test_almoma\", \"pony\"].managers\n  4149\t        self.assertEqual(managers[0][0], \"food_qs\")\n  4150\t        self.assertIsInstance(managers[0][1], models.Manager)\n  4151\t        self.assertEqual(managers[1][0], \"food_mgr\")\n  4152\t        self.assertIsInstance(managers[1][1], FoodManager)\n  4153\t        self.assertEqual(managers[1][1].args, (\"a\", \"b\", 1, 2))\n  4154\t        self.assertEqual(managers[2][0], \"food_mgr_kwargs\")\n  4155\t        self.assertIsInstance(managers[2][1], FoodManager)\n  4156\t        self.assertEqual(managers[2][1].args, (\"x\", \"y\", 3, 4))\n  4157\t        rendered_state = new_state.apps\n  4158\t        model = rendered_state.get_model(\"test_almoma\", \"pony\")\n  4159\t        self.assertIsInstance(model.food_qs, models.Manager)\n  4160\t        self.assertIsInstance(model.food_mgr, FoodManager)\n  4161\t        self.assertIsInstance(model.food_mgr_kwargs, FoodManager)\n  4162\t\n  4163\t    def test_alter_model_managers_emptying(self):\n  4164\t        \"\"\"\n  4165\t        The managers on a model are set.\n  4166\t        \"\"\"\n  4167\t        project_state = self.set_up_test_model(\"test_almomae\", manager_model=True)\n  4168\t        # Test the state alteration\n  4169\t        operation = migrations.AlterModelManagers(\"Food\", managers=[])\n  4170\t        self.assertEqual(operation.describe(), \"Change managers on Food\")\n  4171\t        self.assertIn((\"test_almomae\", \"food\"), project_state.models)\n  4172\t        managers = project_state.models[\"test_almomae\", \"food\"].managers\n  4173\t        self.assertEqual(managers[0][0], \"food_qs\")\n  4174\t        self.assertIsInstance(managers[0][1], models.Manager)\n  4175\t        self.assertEqual(managers[1][0], \"food_mgr\")\n  4176\t        self.assertIsInstance(managers[1][1], FoodManager)\n  4177\t        self.assertEqual(managers[1][1].args, (\"a\", \"b\", 1, 2))\n  4178\t        self.assertEqual(managers[2][0], \"food_mgr_kwargs\")\n  4179\t        self.assertIsInstance(managers[2][1], FoodManager)\n  4180\t        self.assertEqual(managers[2][1].args, (\"x\", \"y\", 3, 4))\n  4181\t\n  4182\t        new_state = project_state.clone()\n  4183\t        operation.state_forwards(\"test_almomae\", new_state)\n  4184\t        managers = new_state.models[\"test_almomae\", \"food\"].managers\n  4185\t        self.assertEqual(managers, [])\n  4186\t\n  4187\t    def test_alter_fk(self):\n  4188\t        \"\"\"\n  4189\t        Creating and then altering an FK works correctly\n  4190\t        and deals with the pending SQL (#23091)\n  4191\t        \"\"\"\n  4192\t        project_state = self.set_up_test_model(\"test_alfk\")\n  4193\t        # Test adding and then altering the FK in one go\n  4194\t        create_operation = migrations.CreateModel(\n  4195\t            name=\"Rider\",\n  4196\t            fields=[\n  4197\t                (\"id\", models.AutoField(primary_key=True)),\n  4198\t                (\"pony\", models.ForeignKey(\"Pony\", models.CASCADE)),\n  4199\t            ],\n  4200\t        )\n  4201\t        create_state = project_state.clone()\n  4202\t        create_operation.state_forwards(\"test_alfk\", create_state)\n  4203\t        alter_operation = migrations.AlterField(\n  4204\t            model_name=\"Rider\",\n  4205\t            name=\"pony\",\n  4206\t            field=models.ForeignKey(\"Pony\", models.CASCADE, editable=False),\n  4207\t        )\n  4208\t        alter_state = create_state.clone()\n  4209\t        alter_operation.state_forwards(\"test_alfk\", alter_state)\n  4210\t        with connection.schema_editor() as editor:\n  4211\t            create_operation.database_forwards(\n  4212\t                \"test_alfk\", editor, project_state, create_state\n  4213\t            )\n  4214\t            alter_operation.database_forwards(\n  4215\t                \"test_alfk\", editor, create_state, alter_state\n  4216\t            )\n  4217\t\n  4218\t    def test_alter_fk_non_fk(self):\n  4219\t        \"\"\"\n  4220\t        Altering an FK to a non-FK works (#23244)\n  4221\t        \"\"\"\n  4222\t        # Test the state alteration\n  4223\t        operation = migrations.AlterField(\n  4224\t            model_name=\"Rider\",\n  4225\t            name=\"pony\",\n  4226\t            field=models.FloatField(),\n  4227\t        )\n  4228\t        project_state, new_state = self.make_test_state(\n  4229\t            \"test_afknfk\", operation, related_model=True\n  4230\t        )\n  4231\t        # Test the database alteration\n  4232\t        self.assertColumnExists(\"test_afknfk_rider\", \"pony_id\")\n  4233\t        self.assertColumnNotExists(\"test_afknfk_rider\", \"pony\")\n  4234\t        with connection.schema_editor() as editor:\n  4235\t            operation.database_forwards(\"test_afknfk\", editor, project_state, new_state)\n  4236\t        self.assertColumnExists(\"test_afknfk_rider\", \"pony\")\n  4237\t        self.assertColumnNotExists(\"test_afknfk_rider\", \"pony_id\")\n  4238\t        # And test reversal\n  4239\t        with connection.schema_editor() as editor:\n  4240\t            operation.database_backwards(\n  4241\t                \"test_afknfk\", editor, new_state, project_state\n  4242\t            )\n  4243\t        self.assertColumnExists(\"test_afknfk_rider\", \"pony_id\")\n  4244\t        self.assertColumnNotExists(\"test_afknfk_rider\", \"pony\")\n  4245\t\n  4246\t    def test_run_sql(self):\n  4247\t        \"\"\"\n  4248\t        Tests the RunSQL operation.\n  4249\t        \"\"\"\n  4250\t        project_state = self.set_up_test_model(\"test_runsql\")\n  4251\t        # Create the operation\n  4252\t        operation = migrations.RunSQL(\n  4253\t            # Use a multi-line string with a comment to test splitting on\n  4254\t            # SQLite and MySQL respectively.\n  4255\t            \"CREATE TABLE i_love_ponies (id int, special_thing varchar(15));\\n\"\n  4256\t            \"INSERT INTO i_love_ponies (id, special_thing) \"\n  4257\t            \"VALUES (1, 'i love ponies'); -- this is magic!\\n\"\n  4258\t            \"INSERT INTO i_love_ponies (id, special_thing) \"\n  4259\t            \"VALUES (2, 'i love django');\\n\"\n  4260\t            \"UPDATE i_love_ponies SET special_thing = 'Ponies' \"\n  4261\t            \"WHERE special_thing LIKE '%%ponies';\"\n  4262\t            \"UPDATE i_love_ponies SET special_thing = 'Django' \"\n  4263\t            \"WHERE special_thing LIKE '%django';\",\n  4264\t            # Run delete queries to test for parameter substitution failure\n  4265\t            # reported in #23426\n  4266\t            \"DELETE FROM i_love_ponies WHERE special_thing LIKE '%Django%';\"\n  4267\t            \"DELETE FROM i_love_ponies WHERE special_thing LIKE '%%Ponies%%';\"\n  4268\t            \"DROP TABLE i_love_ponies\",\n  4269\t            state_operations=[\n  4270\t                migrations.CreateModel(\n  4271\t                    \"SomethingElse\", [(\"id\", models.AutoField(primary_key=True))]\n  4272\t                )\n  4273\t            ],\n  4274\t        )\n  4275\t        self.assertEqual(operation.describe(), \"Raw SQL operation\")\n  4276\t        # Test the state alteration\n  4277\t        new_state = project_state.clone()\n  4278\t        operation.state_forwards(\"test_runsql\", new_state)\n  4279\t        self.assertEqual(\n  4280\t            len(new_state.models[\"test_runsql\", \"somethingelse\"].fields), 1\n  4281\t        )\n  4282\t        # Make sure there's no table\n  4283\t        self.assertTableNotExists(\"i_love_ponies\")\n  4284\t        # Test SQL collection\n  4285\t        with connection.schema_editor(collect_sql=True) as editor:\n  4286\t            operation.database_forwards(\"test_runsql\", editor, project_state, new_state)\n  4287\t            self.assertIn(\"LIKE '%%ponies';\", \"\\n\".join(editor.collected_sql))\n  4288\t            operation.database_backwards(\n  4289\t                \"test_runsql\", editor, project_state, new_state\n  4290\t            )\n  4291\t            self.assertIn(\"LIKE '%%Ponies%%';\", \"\\n\".join(editor.collected_sql))\n  4292\t        # Test the database alteration\n  4293\t        with connection.schema_editor() as editor:\n  4294\t            operation.database_forwards(\"test_runsql\", editor, project_state, new_state)\n  4295\t        self.assertTableExists(\"i_love_ponies\")\n  4296\t        # Make sure all the SQL was processed\n  4297\t        with connection.cursor() as cursor:\n  4298\t            cursor.execute(\"SELECT COUNT(*) FROM i_love_ponies\")\n  4299\t            self.assertEqual(cursor.fetchall()[0][0], 2)\n  4300\t            cursor.execute(\n  4301\t                \"SELECT COUNT(*) FROM i_love_ponies WHERE special_thing = 'Django'\"\n  4302\t            )\n  4303\t            self.assertEqual(cursor.fetchall()[0][0], 1)\n  4304\t            cursor.execute(\n  4305\t                \"SELECT COUNT(*) FROM i_love_ponies WHERE special_thing = 'Ponies'\"\n  4306\t            )\n  4307\t            self.assertEqual(cursor.fetchall()[0][0], 1)\n  4308\t        # And test reversal\n  4309\t        self.assertTrue(operation.reversible)\n  4310\t        with connection.schema_editor() as editor:\n  4311\t            operation.database_backwards(\n  4312\t                \"test_runsql\", editor, new_state, project_state\n  4313\t            )\n  4314\t        self.assertTableNotExists(\"i_love_ponies\")\n  4315\t        # And deconstruction\n  4316\t        definition = operation.deconstruct()\n  4317\t        self.assertEqual(definition[0], \"RunSQL\")\n  4318\t        self.assertEqual(definition[1], [])\n  4319\t        self.assertEqual(\n  4320\t            sorted(definition[2]), [\"reverse_sql\", \"sql\", \"state_operations\"]\n  4321\t        )\n  4322\t        # And elidable reduction\n  4323\t        self.assertIs(False, operation.reduce(operation, []))\n  4324\t        elidable_operation = migrations.RunSQL(\"SELECT 1 FROM void;\", elidable=True)\n  4325\t        self.assertEqual(elidable_operation.reduce(operation, []), [operation])\n  4326\t\n  4327\t    def test_run_sql_params(self):\n  4328\t        \"\"\"\n  4329\t        #23426 - RunSQL should accept parameters.\n  4330\t        \"\"\"\n  4331\t        project_state = self.set_up_test_model(\"test_runsql\")\n  4332\t        # Create the operation\n  4333\t        operation = migrations.RunSQL(\n  4334\t            [\"CREATE TABLE i_love_ponies (id int, special_thing varchar(15));\"],\n  4335\t            [\"DROP TABLE i_love_ponies\"],\n  4336\t        )\n  4337\t        param_operation = migrations.RunSQL(\n  4338\t            # forwards\n  4339\t            (\n  4340\t                \"INSERT INTO i_love_ponies (id, special_thing) VALUES (1, 'Django');\",\n  4341\t                [\n  4342\t                    \"INSERT INTO i_love_ponies (id, special_thing) VALUES (2, %s);\",\n  4343\t                    [\"Ponies\"],\n  4344\t                ],\n  4345\t                (\n  4346\t                    \"INSERT INTO i_love_ponies (id, special_thing) VALUES (%s, %s);\",\n  4347\t                    (\n  4348\t                        3,\n  4349\t                        \"Python\",\n  4350\t                    ),\n  4351\t                ),\n  4352\t            ),\n  4353\t            # backwards\n  4354\t            [\n  4355\t                \"DELETE FROM i_love_ponies WHERE special_thing = 'Django';\",\n  4356\t                [\"DELETE FROM i_love_ponies WHERE special_thing = 'Ponies';\", None],\n  4357\t                (\n  4358\t                    \"DELETE FROM i_love_ponies WHERE id = %s OR special_thing = %s;\",\n  4359\t                    [3, \"Python\"],\n  4360\t                ),\n  4361\t            ],\n  4362\t        )\n  4363\t\n  4364\t        # Make sure there's no table\n  4365\t        self.assertTableNotExists(\"i_love_ponies\")\n  4366\t        new_state = project_state.clone()\n  4367\t        # Test the database alteration\n  4368\t        with connection.schema_editor() as editor:\n  4369\t            operation.database_forwards(\"test_runsql\", editor, project_state, new_state)\n  4370\t\n  4371\t        # Test parameter passing\n  4372\t        with connection.schema_editor() as editor:\n  4373\t            param_operation.database_forwards(\n  4374\t                \"test_runsql\", editor, project_state, new_state\n  4375\t            )\n  4376\t        # Make sure all the SQL was processed\n  4377\t        with connection.cursor() as cursor:\n  4378\t            cursor.execute(\"SELECT COUNT(*) FROM i_love_ponies\")\n  4379\t            self.assertEqual(cursor.fetchall()[0][0], 3)\n  4380\t\n  4381\t        with connection.schema_editor() as editor:\n  4382\t            param_operation.database_backwards(\n  4383\t                \"test_runsql\", editor, new_state, project_state\n  4384\t            )\n  4385\t        with connection.cursor() as cursor:\n  4386\t            cursor.execute(\"SELECT COUNT(*) FROM i_love_ponies\")\n  4387\t            self.assertEqual(cursor.fetchall()[0][0], 0)\n  4388\t\n  4389\t        # And test reversal\n  4390\t        with connection.schema_editor() as editor:\n  4391\t            operation.database_backwards(\n  4392\t                \"test_runsql\", editor, new_state, project_state\n  4393\t            )\n  4394\t        self.assertTableNotExists(\"i_love_ponies\")\n  4395\t\n  4396\t    def test_run_sql_params_invalid(self):\n  4397\t        \"\"\"\n  4398\t        #23426 - RunSQL should fail when a list of statements with an incorrect\n  4399\t        number of tuples is given.\n  4400\t        \"\"\"\n  4401\t        project_state = self.set_up_test_model(\"test_runsql\")\n  4402\t        new_state = project_state.clone()\n  4403\t        operation = migrations.RunSQL(\n  4404\t            # forwards\n  4405\t            [[\"INSERT INTO foo (bar) VALUES ('buz');\"]],\n  4406\t            # backwards\n  4407\t            ((\"DELETE FROM foo WHERE bar = 'buz';\", \"invalid\", \"parameter count\"),),\n  4408\t        )\n  4409\t\n  4410\t        with connection.schema_editor() as editor:\n  4411\t            with self.assertRaisesMessage(ValueError, \"Expected a 2-tuple but got 1\"):\n  4412\t                operation.database_forwards(\n  4413\t                    \"test_runsql\", editor, project_state, new_state\n  4414\t                )\n  4415\t\n  4416\t        with connection.schema_editor() as editor:\n  4417\t            with self.assertRaisesMessage(ValueError, \"Expected a 2-tuple but got 3\"):\n  4418\t                operation.database_backwards(\n  4419\t                    \"test_runsql\", editor, new_state, project_state\n  4420\t                )\n  4421\t\n  4422\t    def test_run_sql_noop(self):\n  4423\t        \"\"\"\n  4424\t        #24098 - Tests no-op RunSQL operations.\n  4425\t        \"\"\"\n  4426\t        operation = migrations.RunSQL(migrations.RunSQL.noop, migrations.RunSQL.noop)\n  4427\t        with connection.schema_editor() as editor:\n  4428\t            operation.database_forwards(\"test_runsql\", editor, None, None)\n  4429\t            operation.database_backwards(\"test_runsql\", editor, None, None)\n  4430\t\n  4431\t    def test_run_sql_add_missing_semicolon_on_collect_sql(self):\n  4432\t        project_state = self.set_up_test_model(\"test_runsql\")\n  4433\t        new_state = project_state.clone()\n  4434\t        tests = [\n  4435\t            \"INSERT INTO test_runsql_pony (pink, weight) VALUES (1, 1);\\n\",\n  4436\t            \"INSERT INTO test_runsql_pony (pink, weight) VALUES (1, 1)\\n\",\n  4437\t        ]\n  4438\t        for sql in tests:\n  4439\t            with self.subTest(sql=sql):\n  4440\t                operation = migrations.RunSQL(sql, migrations.RunPython.noop)\n  4441\t                with connection.schema_editor(collect_sql=True) as editor:\n  4442\t                    operation.database_forwards(\n  4443\t                        \"test_runsql\", editor, project_state, new_state\n  4444\t                    )\n  4445\t                    collected_sql = \"\\n\".join(editor.collected_sql)\n  4446\t                    self.assertEqual(collected_sql.count(\";\"), 1)\n  4447\t\n  4448\t    def test_run_python(self):\n  4449\t        \"\"\"\n  4450\t        Tests the RunPython operation\n  4451\t        \"\"\"\n  4452\t\n  4453\t        project_state = self.set_up_test_model(\"test_runpython\", mti_model=True)\n  4454\t\n  4455\t        # Create the operation\n  4456\t        def inner_method(models, schema_editor):\n  4457\t            Pony = models.get_model(\"test_runpython\", \"Pony\")\n  4458\t            Pony.objects.create(pink=1, weight=3.55)\n  4459\t            Pony.objects.create(weight=5)\n  4460\t\n  4461\t        def inner_method_reverse(models, schema_editor):\n  4462\t            Pony = models.get_model(\"test_runpython\", \"Pony\")\n  4463\t            Pony.objects.filter(pink=1, weight=3.55).delete()\n  4464\t            Pony.objects.filter(weight=5).delete()\n  4465\t\n  4466\t        operation = migrations.RunPython(\n  4467\t            inner_method, reverse_code=inner_method_reverse\n  4468\t        )\n  4469\t        self.assertEqual(operation.describe(), \"Raw Python operation\")\n  4470\t        # Test the state alteration does nothing\n  4471\t        new_state = project_state.clone()\n  4472\t        operation.state_forwards(\"test_runpython\", new_state)\n  4473\t        self.assertEqual(new_state, project_state)\n  4474\t        # Test the database alteration\n  4475\t        self.assertEqual(\n  4476\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 0\n  4477\t        )\n  4478\t        with connection.schema_editor() as editor:\n  4479\t            operation.database_forwards(\n  4480\t                \"test_runpython\", editor, project_state, new_state\n  4481\t            )\n  4482\t        self.assertEqual(\n  4483\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 2\n  4484\t        )\n  4485\t        # Now test reversal\n  4486\t        self.assertTrue(operation.reversible)\n  4487\t        with connection.schema_editor() as editor:\n  4488\t            operation.database_backwards(\n  4489\t                \"test_runpython\", editor, project_state, new_state\n  4490\t            )\n  4491\t        self.assertEqual(\n  4492\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 0\n  4493\t        )\n  4494\t        # Now test we can't use a string\n  4495\t        with self.assertRaisesMessage(\n  4496\t            ValueError, \"RunPython must be supplied with a callable\"\n  4497\t        ):\n  4498\t            migrations.RunPython(\"print 'ahahaha'\")\n  4499\t        # And deconstruction\n  4500\t        definition = operation.deconstruct()\n  4501\t        self.assertEqual(definition[0], \"RunPython\")\n  4502\t        self.assertEqual(definition[1], [])\n  4503\t        self.assertEqual(sorted(definition[2]), [\"code\", \"reverse_code\"])\n  4504\t\n  4505\t        # Also test reversal fails, with an operation identical to above but\n  4506\t        # without reverse_code set.\n  4507\t        no_reverse_operation = migrations.RunPython(inner_method)\n  4508\t        self.assertFalse(no_reverse_operation.reversible)\n  4509\t        with connection.schema_editor() as editor:\n  4510\t            no_reverse_operation.database_forwards(\n  4511\t                \"test_runpython\", editor, project_state, new_state\n  4512\t            )\n  4513\t            with self.assertRaises(NotImplementedError):\n  4514\t                no_reverse_operation.database_backwards(\n  4515\t                    \"test_runpython\", editor, new_state, project_state\n  4516\t                )\n  4517\t        self.assertEqual(\n  4518\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 2\n  4519\t        )\n  4520\t\n  4521\t        def create_ponies(models, schema_editor):\n  4522\t            Pony = models.get_model(\"test_runpython\", \"Pony\")\n  4523\t            pony1 = Pony.objects.create(pink=1, weight=3.55)\n  4524\t            self.assertIsNot(pony1.pk, None)\n  4525\t            pony2 = Pony.objects.create(weight=5)\n  4526\t            self.assertIsNot(pony2.pk, None)\n  4527\t            self.assertNotEqual(pony1.pk, pony2.pk)\n  4528\t\n  4529\t        operation = migrations.RunPython(create_ponies)\n  4530\t        with connection.schema_editor() as editor:\n  4531\t            operation.database_forwards(\n  4532\t                \"test_runpython\", editor, project_state, new_state\n  4533\t            )\n  4534\t        self.assertEqual(\n  4535\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 4\n  4536\t        )\n  4537\t        # And deconstruction\n  4538\t        definition = operation.deconstruct()\n  4539\t        self.assertEqual(definition[0], \"RunPython\")\n  4540\t        self.assertEqual(definition[1], [])\n  4541\t        self.assertEqual(sorted(definition[2]), [\"code\"])\n  4542\t\n  4543\t        def create_shetlandponies(models, schema_editor):\n  4544\t            ShetlandPony = models.get_model(\"test_runpython\", \"ShetlandPony\")\n  4545\t            pony1 = ShetlandPony.objects.create(weight=4.0)\n  4546\t            self.assertIsNot(pony1.pk, None)\n  4547\t            pony2 = ShetlandPony.objects.create(weight=5.0)\n  4548\t            self.assertIsNot(pony2.pk, None)\n  4549\t            self.assertNotEqual(pony1.pk, pony2.pk)\n  4550\t\n  4551\t        operation = migrations.RunPython(create_shetlandponies)\n  4552\t        with connection.schema_editor() as editor:\n  4553\t            operation.database_forwards(\n  4554\t                \"test_runpython\", editor, project_state, new_state\n  4555\t            )\n  4556\t        self.assertEqual(\n  4557\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 6\n  4558\t        )\n  4559\t        self.assertEqual(\n  4560\t            project_state.apps.get_model(\n  4561\t                \"test_runpython\", \"ShetlandPony\"\n  4562\t            ).objects.count(),\n  4563\t            2,\n  4564\t        )\n  4565\t        # And elidable reduction\n  4566\t        self.assertIs(False, operation.reduce(operation, []))\n  4567\t        elidable_operation = migrations.RunPython(inner_method, elidable=True)\n  4568\t        self.assertEqual(elidable_operation.reduce(operation, []), [operation])\n  4569\t\n  4570\t    def test_run_python_atomic(self):\n  4571\t        \"\"\"\n  4572\t        Tests the RunPython operation correctly handles the \"atomic\" keyword\n  4573\t        \"\"\"\n  4574\t        project_state = self.set_up_test_model(\"test_runpythonatomic\", mti_model=True)\n  4575\t\n  4576\t        def inner_method(models, schema_editor):\n  4577\t            Pony = models.get_model(\"test_runpythonatomic\", \"Pony\")\n  4578\t            Pony.objects.create(pink=1, weight=3.55)\n  4579\t            raise ValueError(\"Adrian hates ponies.\")\n  4580\t\n  4581\t        # Verify atomicity when applying.\n  4582\t        atomic_migration = Migration(\"test\", \"test_runpythonatomic\")\n  4583\t        atomic_migration.operations = [\n  4584\t            migrations.RunPython(inner_method, reverse_code=inner_method)\n  4585\t        ]\n  4586\t        non_atomic_migration = Migration(\"test\", \"test_runpythonatomic\")\n  4587\t        non_atomic_migration.operations = [\n  4588\t            migrations.RunPython(inner_method, reverse_code=inner_method, atomic=False)\n  4589\t        ]\n  4590\t        # If we're a fully-transactional database, both versions should rollback\n  4591\t        if connection.features.can_rollback_ddl:\n  4592\t            self.assertEqual(\n  4593\t                project_state.apps.get_model(\n  4594\t                    \"test_runpythonatomic\", \"Pony\"\n  4595\t                ).objects.count(),\n  4596\t                0,\n  4597\t            )\n  4598\t            with self.assertRaises(ValueError):\n  4599\t                with connection.schema_editor() as editor:\n  4600\t                    atomic_migration.apply(project_state, editor)\n  4601\t            self.assertEqual(\n  4602\t                project_state.apps.get_model(\n  4603\t                    \"test_runpythonatomic\", \"Pony\"\n  4604\t                ).objects.count(),\n  4605\t                0,\n  4606\t            )\n  4607\t            with self.assertRaises(ValueError):\n  4608\t                with connection.schema_editor() as editor:\n  4609\t                    non_atomic_migration.apply(project_state, editor)\n  4610\t            self.assertEqual(\n  4611\t                project_state.apps.get_model(\n  4612\t                    \"test_runpythonatomic\", \"Pony\"\n  4613\t                ).objects.count(),\n  4614\t                0,\n  4615\t            )\n  4616\t        # Otherwise, the non-atomic operation should leave a row there\n  4617\t        else:\n  4618\t            self.assertEqual(\n  4619\t                project_state.apps.get_model(\n  4620\t                    \"test_runpythonatomic\", \"Pony\"\n  4621\t                ).objects.count(),\n  4622\t                0,\n  4623\t            )\n  4624\t            with self.assertRaises(ValueError):\n  4625\t                with connection.schema_editor() as editor:\n  4626\t                    atomic_migration.apply(project_state, editor)\n  4627\t            self.assertEqual(\n  4628\t                project_state.apps.get_model(\n  4629\t                    \"test_runpythonatomic\", \"Pony\"\n  4630\t                ).objects.count(),\n  4631\t                0,\n  4632\t            )\n  4633\t            with self.assertRaises(ValueError):\n  4634\t                with connection.schema_editor() as editor:\n  4635\t                    non_atomic_migration.apply(project_state, editor)\n  4636\t            self.assertEqual(\n  4637\t                project_state.apps.get_model(\n  4638\t                    \"test_runpythonatomic\", \"Pony\"\n  4639\t                ).objects.count(),\n  4640\t                1,\n  4641\t            )\n  4642\t        # Reset object count to zero and verify atomicity when unapplying.\n  4643\t        project_state.apps.get_model(\n  4644\t            \"test_runpythonatomic\", \"Pony\"\n  4645\t        ).objects.all().delete()\n  4646\t        # On a fully-transactional database, both versions rollback.\n  4647\t        if connection.features.can_rollback_ddl:\n  4648\t            self.assertEqual(\n  4649\t                project_state.apps.get_model(\n  4650\t                    \"test_runpythonatomic\", \"Pony\"\n  4651\t                ).objects.count(),\n  4652\t                0,\n  4653\t            )\n  4654\t            with self.assertRaises(ValueError):\n  4655\t                with connection.schema_editor() as editor:\n  4656\t                    atomic_migration.unapply(project_state, editor)\n  4657\t            self.assertEqual(\n  4658\t                project_state.apps.get_model(\n  4659\t                    \"test_runpythonatomic\", \"Pony\"\n  4660\t                ).objects.count(),\n  4661\t                0,\n  4662\t            )\n  4663\t            with self.assertRaises(ValueError):\n  4664\t                with connection.schema_editor() as editor:\n  4665\t                    non_atomic_migration.unapply(project_state, editor)\n  4666\t            self.assertEqual(\n  4667\t                project_state.apps.get_model(\n  4668\t                    \"test_runpythonatomic\", \"Pony\"\n  4669\t                ).objects.count(),\n  4670\t                0,\n  4671\t            )\n  4672\t        # Otherwise, the non-atomic operation leaves a row there.\n  4673\t        else:\n  4674\t            self.assertEqual(\n  4675\t                project_state.apps.get_model(\n  4676\t                    \"test_runpythonatomic\", \"Pony\"\n  4677\t                ).objects.count(),\n  4678\t                0,\n  4679\t            )\n  4680\t            with self.assertRaises(ValueError):\n  4681\t                with connection.schema_editor() as editor:\n  4682\t                    atomic_migration.unapply(project_state, editor)\n  4683\t            self.assertEqual(\n  4684\t                project_state.apps.get_model(\n  4685\t                    \"test_runpythonatomic\", \"Pony\"\n  4686\t                ).objects.count(),\n  4687\t                0,\n  4688\t            )\n  4689\t            with self.assertRaises(ValueError):\n  4690\t                with connection.schema_editor() as editor:\n  4691\t                    non_atomic_migration.unapply(project_state, editor)\n  4692\t            self.assertEqual(\n  4693\t                project_state.apps.get_model(\n  4694\t                    \"test_runpythonatomic\", \"Pony\"\n  4695\t                ).objects.count(),\n  4696\t                1,\n  4697\t            )\n  4698\t        # Verify deconstruction.\n  4699\t        definition = non_atomic_migration.operations[0].deconstruct()\n  4700\t        self.assertEqual(definition[0], \"RunPython\")\n  4701\t        self.assertEqual(definition[1], [])\n  4702\t        self.assertEqual(sorted(definition[2]), [\"atomic\", \"code\", \"reverse_code\"])\n  4703\t\n  4704\t    def test_run_python_related_assignment(self):\n  4705\t        \"\"\"\n  4706\t        #24282 - Model changes to a FK reverse side update the model\n  4707\t        on the FK side as well.\n  4708\t        \"\"\"\n  4709\t\n  4710\t        def inner_method(models, schema_editor):\n  4711\t            Author = models.get_model(\"test_authors\", \"Author\")\n  4712\t            Book = models.get_model(\"test_books\", \"Book\")\n  4713\t            author = Author.objects.create(name=\"Hemingway\")\n  4714\t            Book.objects.create(title=\"Old Man and The Sea\", author=author)\n  4715\t\n  4716\t        create_author = migrations.CreateModel(\n  4717\t            \"Author\",\n  4718\t            [\n  4719\t                (\"id\", models.AutoField(primary_key=True)),\n  4720\t                (\"name\", models.CharField(max_length=100)),\n  4721\t            ],\n  4722\t            options={},\n  4723\t        )\n  4724\t        create_book = migrations.CreateModel(\n  4725\t            \"Book\",\n  4726\t            [\n  4727\t                (\"id\", models.AutoField(primary_key=True)),\n  4728\t                (\"title\", models.CharField(max_length=100)),\n  4729\t                (\"author\", models.ForeignKey(\"test_authors.Author\", models.CASCADE)),\n  4730\t            ],\n  4731\t            options={},\n  4732\t        )\n  4733\t        add_hometown = migrations.AddField(\n  4734\t            \"Author\",\n  4735\t            \"hometown\",\n  4736\t            models.CharField(max_length=100),\n  4737\t        )\n  4738\t        create_old_man = migrations.RunPython(inner_method, inner_method)\n  4739\t\n  4740\t        project_state = ProjectState()\n  4741\t        new_state = project_state.clone()\n  4742\t        with connection.schema_editor() as editor:\n  4743\t            create_author.state_forwards(\"test_authors\", new_state)\n  4744\t            create_author.database_forwards(\n  4745\t                \"test_authors\", editor, project_state, new_state\n  4746\t            )\n  4747\t        project_state = new_state\n  4748\t        new_state = new_state.clone()\n  4749\t        with connection.schema_editor() as editor:\n  4750\t            create_book.state_forwards(\"test_books\", new_state)\n  4751\t            create_book.database_forwards(\n  4752\t                \"test_books\", editor, project_state, new_state\n  4753\t            )\n  4754\t        project_state = new_state\n  4755\t        new_state = new_state.clone()\n  4756\t        with connection.schema_editor() as editor:\n  4757\t            add_hometown.state_forwards(\"test_authors\", new_state)\n  4758\t            add_hometown.database_forwards(\n  4759\t                \"test_authors\", editor, project_state, new_state\n  4760\t            )\n  4761\t        project_state = new_state\n  4762\t        new_state = new_state.clone()\n  4763\t        with connection.schema_editor() as editor:\n  4764\t            create_old_man.state_forwards(\"test_books\", new_state)\n  4765\t            create_old_man.database_forwards(\n  4766\t                \"test_books\", editor, project_state, new_state\n  4767\t            )\n  4768\t\n  4769\t    def test_model_with_bigautofield(self):\n  4770\t        \"\"\"\n  4771\t        A model with BigAutoField can be created.\n  4772\t        \"\"\"\n  4773\t\n  4774\t        def create_data(models, schema_editor):\n  4775\t            Author = models.get_model(\"test_author\", \"Author\")\n  4776\t            Book = models.get_model(\"test_book\", \"Book\")\n  4777\t            author1 = Author.objects.create(name=\"Hemingway\")\n  4778\t            Book.objects.create(title=\"Old Man and The Sea\", author=author1)\n  4779\t            Book.objects.create(id=2**33, title=\"A farewell to arms\", author=author1)\n  4780\t\n  4781\t            author2 = Author.objects.create(id=2**33, name=\"Remarque\")\n  4782\t            Book.objects.create(title=\"All quiet on the western front\", author=author2)\n  4783\t            Book.objects.create(title=\"Arc de Triomphe\", author=author2)\n  4784\t\n  4785\t        create_author = migrations.CreateModel(\n  4786\t            \"Author\",\n  4787\t            [\n  4788\t                (\"id\", models.BigAutoField(primary_key=True)),\n  4789\t                (\"name\", models.CharField(max_length=100)),\n  4790\t            ],\n  4791\t            options={},\n  4792\t        )\n  4793\t        create_book = migrations.CreateModel(\n  4794\t            \"Book\",\n  4795\t            [\n  4796\t                (\"id\", models.BigAutoField(primary_key=True)),\n  4797\t                (\"title\", models.CharField(max_length=100)),\n  4798\t                (\n  4799\t                    \"author\",\n  4800\t                    models.ForeignKey(\n  4801\t                        to=\"test_author.Author\", on_delete=models.CASCADE\n  4802\t                    ),\n  4803\t                ),\n  4804\t            ],\n  4805\t            options={},\n  4806\t        )\n  4807\t        fill_data = migrations.RunPython(create_data)\n  4808\t\n  4809\t        project_state = ProjectState()\n  4810\t        new_state = project_state.clone()\n  4811\t        with connection.schema_editor() as editor:\n  4812\t            create_author.state_forwards(\"test_author\", new_state)\n  4813\t            create_author.database_forwards(\n  4814\t                \"test_author\", editor, project_state, new_state\n  4815\t            )\n  4816\t\n  4817\t        project_state = new_state\n  4818\t        new_state = new_state.clone()\n  4819\t        with connection.schema_editor() as editor:\n  4820\t            create_book.state_forwards(\"test_book\", new_state)\n  4821\t            create_book.database_forwards(\"test_book\", editor, project_state, new_state)\n  4822\t\n  4823\t        project_state = new_state\n  4824\t        new_state = new_state.clone()\n  4825\t        with connection.schema_editor() as editor:\n  4826\t            fill_data.state_forwards(\"fill_data\", new_state)\n  4827\t            fill_data.database_forwards(\"fill_data\", editor, project_state, new_state)\n  4828\t\n  4829\t    def _test_autofield_foreignfield_growth(\n  4830\t        self, source_field, target_field, target_value\n  4831\t    ):\n  4832\t        \"\"\"\n  4833\t        A field may be migrated in the following ways:\n  4834\t\n  4835\t        - AutoField to BigAutoField\n  4836\t        - SmallAutoField to AutoField\n  4837\t        - SmallAutoField to BigAutoField\n  4838\t        \"\"\"\n  4839\t\n  4840\t        def create_initial_data(models, schema_editor):\n  4841\t            Article = models.get_model(\"test_article\", \"Article\")\n  4842\t            Blog = models.get_model(\"test_blog\", \"Blog\")\n  4843\t            blog = Blog.objects.create(name=\"web development done right\")\n  4844\t            Article.objects.create(name=\"Frameworks\", blog=blog)\n  4845\t            Article.objects.create(name=\"Programming Languages\", blog=blog)\n  4846\t\n  4847\t        def create_big_data(models, schema_editor):\n  4848\t            Article = models.get_model(\"test_article\", \"Article\")\n  4849\t            Blog = models.get_model(\"test_blog\", \"Blog\")\n  4850\t            blog2 = Blog.objects.create(name=\"Frameworks\", id=target_value)\n  4851\t            Article.objects.create(name=\"Django\", blog=blog2)\n  4852\t            Article.objects.create(id=target_value, name=\"Django2\", blog=blog2)\n  4853\t\n  4854\t        create_blog = migrations.CreateModel(\n  4855\t            \"Blog\",\n  4856\t            [\n  4857\t                (\"id\", source_field(primary_key=True)),\n  4858\t                (\"name\", models.CharField(max_length=100)),\n  4859\t            ],\n  4860\t            options={},\n  4861\t        )\n  4862\t        create_article = migrations.CreateModel(\n  4863\t            \"Article\",\n  4864\t            [\n  4865\t                (\"id\", source_field(primary_key=True)),\n  4866\t                (\n  4867\t                    \"blog\",\n  4868\t                    models.ForeignKey(to=\"test_blog.Blog\", on_delete=models.CASCADE),\n  4869\t                ),\n  4870\t                (\"name\", models.CharField(max_length=100)),\n  4871\t                (\"data\", models.TextField(default=\"\")),\n  4872\t            ],\n  4873\t            options={},\n  4874\t        )\n  4875\t        fill_initial_data = migrations.RunPython(\n  4876\t            create_initial_data, create_initial_data\n  4877\t        )\n  4878\t        fill_big_data = migrations.RunPython(create_big_data, create_big_data)\n  4879\t\n  4880\t        grow_article_id = migrations.AlterField(\n  4881\t            \"Article\", \"id\", target_field(primary_key=True)\n  4882\t        )\n  4883\t        grow_blog_id = migrations.AlterField(\n  4884\t            \"Blog\", \"id\", target_field(primary_key=True)\n  4885\t        )\n  4886\t\n  4887\t        project_state = ProjectState()\n  4888\t        new_state = project_state.clone()\n  4889\t        with connection.schema_editor() as editor:\n  4890\t            create_blog.state_forwards(\"test_blog\", new_state)\n  4891\t            create_blog.database_forwards(\"test_blog\", editor, project_state, new_state)\n  4892\t\n  4893\t        project_state = new_state\n  4894\t        new_state = new_state.clone()\n  4895\t        with connection.schema_editor() as editor:\n  4896\t            create_article.state_forwards(\"test_article\", new_state)\n  4897\t            create_article.database_forwards(\n  4898\t                \"test_article\", editor, project_state, new_state\n  4899\t            )\n  4900\t\n  4901\t        project_state = new_state\n  4902\t        new_state = new_state.clone()\n  4903\t        with connection.schema_editor() as editor:\n  4904\t            fill_initial_data.state_forwards(\"fill_initial_data\", new_state)\n  4905\t            fill_initial_data.database_forwards(\n  4906\t                \"fill_initial_data\", editor, project_state, new_state\n  4907\t            )\n  4908\t\n  4909\t        project_state = new_state\n  4910\t        new_state = new_state.clone()\n  4911\t        with connection.schema_editor() as editor:\n  4912\t            grow_article_id.state_forwards(\"test_article\", new_state)\n  4913\t            grow_article_id.database_forwards(\n  4914\t                \"test_article\", editor, project_state, new_state\n  4915\t            )\n  4916\t\n  4917\t        state = new_state.clone()\n  4918\t        article = state.apps.get_model(\"test_article.Article\")\n  4919\t        self.assertIsInstance(article._meta.pk, target_field)\n  4920\t\n  4921\t        project_state = new_state\n  4922\t        new_state = new_state.clone()\n  4923\t        with connection.schema_editor() as editor:\n  4924\t            grow_blog_id.state_forwards(\"test_blog\", new_state)\n  4925\t            grow_blog_id.database_forwards(\n  4926\t                \"test_blog\", editor, project_state, new_state\n  4927\t            )\n  4928\t\n  4929\t        state = new_state.clone()\n  4930\t        blog = state.apps.get_model(\"test_blog.Blog\")\n  4931\t        self.assertIsInstance(blog._meta.pk, target_field)\n  4932\t\n  4933\t        project_state = new_state\n  4934\t        new_state = new_state.clone()\n  4935\t        with connection.schema_editor() as editor:\n  4936\t            fill_big_data.state_forwards(\"fill_big_data\", new_state)\n  4937\t            fill_big_data.database_forwards(\n  4938\t                \"fill_big_data\", editor, project_state, new_state\n  4939\t            )\n  4940\t\n  4941\t    def test_autofield__bigautofield_foreignfield_growth(self):\n  4942\t        \"\"\"A field may be migrated from AutoField to BigAutoField.\"\"\"\n  4943\t        self._test_autofield_foreignfield_growth(\n  4944\t            models.AutoField,\n  4945\t            models.BigAutoField,\n  4946\t            2**33,\n  4947\t        )\n  4948\t\n  4949\t    def test_smallfield_autofield_foreignfield_growth(self):\n  4950\t        \"\"\"A field may be migrated from SmallAutoField to AutoField.\"\"\"\n  4951\t        self._test_autofield_foreignfield_growth(\n  4952\t            models.SmallAutoField,\n  4953\t            models.AutoField,\n  4954\t            2**22,\n  4955\t        )\n  4956\t\n  4957\t    def test_smallfield_bigautofield_foreignfield_growth(self):\n  4958\t        \"\"\"A field may be migrated from SmallAutoField to BigAutoField.\"\"\"\n  4959\t        self._test_autofield_foreignfield_growth(\n  4960\t            models.SmallAutoField,\n  4961\t            models.BigAutoField,\n  4962\t            2**33,\n  4963\t        )\n  4964\t\n  4965\t    def test_run_python_noop(self):\n  4966\t        \"\"\"\n  4967\t        #24098 - Tests no-op RunPython operations.\n  4968\t        \"\"\"\n  4969\t        project_state = ProjectState()\n  4970\t        new_state = project_state.clone()\n  4971\t        operation = migrations.RunPython(\n  4972\t            migrations.RunPython.noop, migrations.RunPython.noop\n  4973\t        )\n  4974\t        with connection.schema_editor() as editor:\n  4975\t            operation.database_forwards(\n  4976\t                \"test_runpython\", editor, project_state, new_state\n  4977\t            )\n  4978\t            operation.database_backwards(\n  4979\t                \"test_runpython\", editor, new_state, project_state\n  4980\t            )\n  4981\t\n  4982\t    def test_separate_database_and_state(self):\n  4983\t        \"\"\"\n  4984\t        Tests the SeparateDatabaseAndState operation.\n  4985\t        \"\"\"\n  4986\t        project_state = self.set_up_test_model(\"test_separatedatabaseandstate\")\n  4987\t        # Create the operation\n  4988\t        database_operation = migrations.RunSQL(\n  4989\t            \"CREATE TABLE i_love_ponies (id int, special_thing int);\",\n  4990\t            \"DROP TABLE i_love_ponies;\",\n  4991\t        )\n  4992\t        state_operation = migrations.CreateModel(\n  4993\t            \"SomethingElse\", [(\"id\", models.AutoField(primary_key=True))]\n  4994\t        )\n  4995\t        operation = migrations.SeparateDatabaseAndState(\n  4996\t            state_operations=[state_operation], database_operations=[database_operation]\n  4997\t        )\n  4998\t        self.assertEqual(\n  4999\t            operation.describe(), \"Custom state/database change combination\"\n  5000\t        )\n  5001\t        # Test the state alteration\n  5002\t        new_state = project_state.clone()\n  5003\t        operation.state_forwards(\"test_separatedatabaseandstate\", new_state)\n  5004\t        self.assertEqual(\n  5005\t            len(\n  5006\t                new_state.models[\n  5007\t                    \"test_separatedatabaseandstate\", \"somethingelse\"\n  5008\t                ].fields\n  5009\t            ),\n  5010\t            1,\n  5011\t        )\n  5012\t        # Make sure there's no table\n  5013\t        self.assertTableNotExists(\"i_love_ponies\")\n  5014\t        # Test the database alteration\n  5015\t        with connection.schema_editor() as editor:\n  5016\t            operation.database_forwards(\n  5017\t                \"test_separatedatabaseandstate\", editor, project_state, new_state\n  5018\t            )\n  5019\t        self.assertTableExists(\"i_love_ponies\")\n  5020\t        # And test reversal\n  5021\t        self.assertTrue(operation.reversible)\n  5022\t        with connection.schema_editor() as editor:\n  5023\t            operation.database_backwards(\n  5024\t                \"test_separatedatabaseandstate\", editor, new_state, project_state\n  5025\t            )\n  5026\t        self.assertTableNotExists(\"i_love_ponies\")\n  5027\t        # And deconstruction\n  5028\t        definition = operation.deconstruct()\n  5029\t        self.assertEqual(definition[0], \"SeparateDatabaseAndState\")\n  5030\t        self.assertEqual(definition[1], [])\n  5031\t        self.assertEqual(\n  5032\t            sorted(definition[2]), [\"database_operations\", \"state_operations\"]\n  5033\t        )\n  5034\t\n  5035\t    def test_separate_database_and_state2(self):\n  5036\t        \"\"\"\n  5037\t        A complex SeparateDatabaseAndState operation: Multiple operations both\n  5038\t        for state and database. Verify the state dependencies within each list\n  5039\t        and that state ops don't affect the database.\n  5040\t        \"\"\"\n  5041\t        app_label = \"test_separatedatabaseandstate2\"\n  5042\t        project_state = self.set_up_test_model(app_label)\n  5043\t        # Create the operation\n  5044\t        database_operations = [\n  5045\t            migrations.CreateModel(\n  5046\t                \"ILovePonies\",\n  5047\t                [(\"id\", models.AutoField(primary_key=True))],\n  5048\t                options={\"db_table\": \"iloveponies\"},\n  5049\t            ),\n  5050\t            migrations.CreateModel(\n  5051\t                \"ILoveMorePonies\",\n  5052\t                # We use IntegerField and not AutoField because\n  5053\t                # the model is going to be deleted immediately\n  5054\t                # and with an AutoField this fails on Oracle\n  5055\t                [(\"id\", models.IntegerField(primary_key=True))],\n  5056\t                options={\"db_table\": \"ilovemoreponies\"},\n  5057\t            ),\n  5058\t            migrations.DeleteModel(\"ILoveMorePonies\"),\n  5059\t            migrations.CreateModel(\n  5060\t                \"ILoveEvenMorePonies\",\n  5061\t                [(\"id\", models.AutoField(primary_key=True))],\n  5062\t                options={\"db_table\": \"iloveevenmoreponies\"},\n  5063\t            ),\n  5064\t        ]\n  5065\t        state_operations = [\n  5066\t            migrations.CreateModel(\n  5067\t                \"SomethingElse\",\n  5068\t                [(\"id\", models.AutoField(primary_key=True))],\n  5069\t                options={\"db_table\": \"somethingelse\"},\n  5070\t            ),\n  5071\t            migrations.DeleteModel(\"SomethingElse\"),\n  5072\t            migrations.CreateModel(\n  5073\t                \"SomethingCompletelyDifferent\",\n  5074\t                [(\"id\", models.AutoField(primary_key=True))],\n  5075\t                options={\"db_table\": \"somethingcompletelydifferent\"},\n  5076\t            ),\n  5077\t        ]\n  5078\t        operation = migrations.SeparateDatabaseAndState(\n  5079\t            state_operations=state_operations,\n  5080\t            database_operations=database_operations,\n  5081\t        )\n  5082\t        # Test the state alteration\n  5083\t        new_state = project_state.clone()\n  5084\t        operation.state_forwards(app_label, new_state)\n  5085\t\n  5086\t        def assertModelsAndTables(after_db):\n  5087\t            # Tables and models exist, or don't, as they should:\n  5088\t            self.assertNotIn((app_label, \"somethingelse\"), new_state.models)\n  5089\t            self.assertEqual(\n  5090\t                len(new_state.models[app_label, \"somethingcompletelydifferent\"].fields),\n  5091\t                1,\n  5092\t            )\n  5093\t            self.assertNotIn((app_label, \"iloveponiesonies\"), new_state.models)\n  5094\t            self.assertNotIn((app_label, \"ilovemoreponies\"), new_state.models)\n  5095\t            self.assertNotIn((app_label, \"iloveevenmoreponies\"), new_state.models)\n  5096\t            self.assertTableNotExists(\"somethingelse\")\n  5097\t            self.assertTableNotExists(\"somethingcompletelydifferent\")\n  5098\t            self.assertTableNotExists(\"ilovemoreponies\")\n  5099\t            if after_db:\n  5100\t                self.assertTableExists(\"iloveponies\")\n  5101\t                self.assertTableExists(\"iloveevenmoreponies\")\n  5102\t            else:\n  5103\t                self.assertTableNotExists(\"iloveponies\")\n  5104\t                self.assertTableNotExists(\"iloveevenmoreponies\")\n  5105\t\n  5106\t        assertModelsAndTables(after_db=False)\n  5107\t        # Test the database alteration\n  5108\t        with connection.schema_editor() as editor:\n  5109\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  5110\t        assertModelsAndTables(after_db=True)\n  5111\t        # And test reversal\n  5112\t        self.assertTrue(operation.reversible)\n  5113\t        with connection.schema_editor() as editor:\n  5114\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  5115\t        assertModelsAndTables(after_db=False)\n  5116\t\n  5117\t\n  5118\tclass SwappableOperationTests(OperationTestBase):\n  5119\t    \"\"\"\n  5120\t    Key operations ignore swappable models\n  5121\t    (we don't want to replicate all of them here, as the functionality\n  5122\t    is in a common base class anyway)\n  5123\t    \"\"\"\n  5124\t\n  5125\t    available_apps = [\"migrations\"]\n  5126\t\n  5127\t    @override_settings(TEST_SWAP_MODEL=\"migrations.SomeFakeModel\")\n  5128\t    def test_create_ignore_swapped(self):\n  5129\t        \"\"\"\n  5130\t        The CreateTable operation ignores swapped models.\n  5131\t        \"\"\"\n  5132\t        operation = migrations.CreateModel(\n  5133\t            \"Pony\",\n  5134\t            [\n  5135\t                (\"id\", models.AutoField(primary_key=True)),\n  5136\t                (\"pink\", models.IntegerField(default=1)),\n  5137\t            ],\n  5138\t            options={\n  5139\t                \"swappable\": \"TEST_SWAP_MODEL\",\n  5140\t            },\n  5141\t        )\n  5142\t        # Test the state alteration (it should still be there!)\n  5143\t        project_state = ProjectState()\n  5144\t        new_state = project_state.clone()\n  5145\t        operation.state_forwards(\"test_crigsw\", new_state)\n  5146\t        self.assertEqual(new_state.models[\"test_crigsw\", \"pony\"].name, \"Pony\")\n  5147\t        self.assertEqual(len(new_state.models[\"test_crigsw\", \"pony\"].fields), 2)\n  5148\t        # Test the database alteration\n  5149\t        self.assertTableNotExists(\"test_crigsw_pony\")\n  5150\t        with connection.schema_editor() as editor:\n  5151\t            operation.database_forwards(\"test_crigsw\", editor, project_state, new_state)\n  5152\t        self.assertTableNotExists(\"test_crigsw_pony\")\n  5153\t        # And test reversal\n  5154\t        with connection.schema_editor() as editor:\n  5155\t            operation.database_backwards(\n  5156\t                \"test_crigsw\", editor, new_state, project_state\n  5157\t            )\n  5158\t        self.assertTableNotExists(\"test_crigsw_pony\")\n  5159\t\n  5160\t    @override_settings(TEST_SWAP_MODEL=\"migrations.SomeFakeModel\")\n  5161\t    def test_delete_ignore_swapped(self):\n  5162\t        \"\"\"\n  5163\t        Tests the DeleteModel operation ignores swapped models.\n  5164\t        \"\"\"\n  5165\t        operation = migrations.DeleteModel(\"Pony\")\n  5166\t        project_state, new_state = self.make_test_state(\"test_dligsw\", operation)\n  5167\t        # Test the database alteration\n  5168\t        self.assertTableNotExists(\"test_dligsw_pony\")\n  5169\t        with connection.schema_editor() as editor:\n  5170\t            operation.database_forwards(\"test_dligsw\", editor, project_state, new_state)\n  5171\t        self.assertTableNotExists(\"test_dligsw_pony\")\n  5172\t        # And test reversal\n  5173\t        with connection.schema_editor() as editor:\n  5174\t            operation.database_backwards(\n  5175\t                \"test_dligsw\", editor, new_state, project_state\n  5176\t            )\n  5177\t        self.assertTableNotExists(\"test_dligsw_pony\")\n  5178\t\n  5179\t    @override_settings(TEST_SWAP_MODEL=\"migrations.SomeFakeModel\")\n  5180\t    def test_add_field_ignore_swapped(self):\n  5181\t        \"\"\"\n  5182\t        Tests the AddField operation.\n  5183\t        \"\"\"\n  5184\t        # Test the state alteration\n  5185\t        operation = migrations.AddField(\n  5186\t            \"Pony\",\n  5187\t            \"height\",\n  5188\t            models.FloatField(null=True, default=5),\n  5189\t        )\n  5190\t        project_state, new_state = self.make_test_state(\"test_adfligsw\", operation)\n  5191\t        # Test the database alteration\n  5192\t        self.assertTableNotExists(\"test_adfligsw_pony\")\n  5193\t        with connection.schema_editor() as editor:\n  5194\t            operation.database_forwards(\n  5195\t                \"test_adfligsw\", editor, project_state, new_state\n  5196\t            )\n  5197\t        self.assertTableNotExists(\"test_adfligsw_pony\")\n  5198\t        # And test reversal\n  5199\t        with connection.schema_editor() as editor:\n  5200\t            operation.database_backwards(\n  5201\t                \"test_adfligsw\", editor, new_state, project_state\n  5202\t            )\n  5203\t        self.assertTableNotExists(\"test_adfligsw_pony\")\n  5204\t\n  5205\t    @override_settings(TEST_SWAP_MODEL=\"migrations.SomeFakeModel\")\n  5206\t    def test_indexes_ignore_swapped(self):\n  5207\t        \"\"\"\n  5208\t        Add/RemoveIndex operations ignore swapped models.\n  5209\t        \"\"\"\n  5210\t        operation = migrations.AddIndex(\n  5211\t            \"Pony\", models.Index(fields=[\"pink\"], name=\"my_name_idx\")\n  5212\t        )\n  5213\t        project_state, new_state = self.make_test_state(\"test_adinigsw\", operation)\n  5214\t        with connection.schema_editor() as editor:\n  5215\t            # No database queries should be run for swapped models\n  5216\t            operation.database_forwards(\n  5217\t                \"test_adinigsw\", editor, project_state, new_state\n  5218\t            )\n  5219\t            operation.database_backwards(\n  5220\t                \"test_adinigsw\", editor, new_state, project_state\n  5221\t            )\n  5222\t\n  5223\t        operation = migrations.RemoveIndex(\n  5224\t            \"Pony\", models.Index(fields=[\"pink\"], name=\"my_name_idx\")\n  5225\t        )\n  5226\t        project_state, new_state = self.make_test_state(\"test_rminigsw\", operation)\n  5227\t        with connection.schema_editor() as editor:\n  5228\t            operation.database_forwards(\n  5229\t                \"test_rminigsw\", editor, project_state, new_state\n  5230\t            )\n  5231\t            operation.database_backwards(\n  5232\t                \"test_rminigsw\", editor, new_state, project_state\n  5233\t            )\n  5234\t\n  5235\t\n  5236\tclass TestCreateModel(SimpleTestCase):\n  5237\t    def test_references_model_mixin(self):\n  5238\t        migrations.CreateModel(\n  5239\t            \"name\",\n  5240\t            fields=[],\n  5241\t            bases=(Mixin, models.Model),\n  5242\t        ).references_model(\"other_model\", \"migrations\")\n  5243\t\n  5244\t\n  5245\tclass FieldOperationTests(SimpleTestCase):\n  5246\t    def test_references_model(self):\n  5247\t        operation = FieldOperation(\n  5248\t            \"MoDel\", \"field\", models.ForeignKey(\"Other\", models.CASCADE)\n  5249\t        )\n  5250\t        # Model name match.\n  5251\t        self.assertIs(operation.references_model(\"mOdEl\", \"migrations\"), True)\n  5252\t        # Referenced field.\n  5253\t        self.assertIs(operation.references_model(\"oTher\", \"migrations\"), True)\n  5254\t        # Doesn't reference.\n  5255\t        self.assertIs(operation.references_model(\"Whatever\", \"migrations\"), False)\n  5256\t\n  5257\t    def test_references_field_by_name(self):\n  5258\t        operation = FieldOperation(\"MoDel\", \"field\", models.BooleanField(default=False))\n  5259\t        self.assertIs(operation.references_field(\"model\", \"field\", \"migrations\"), True)\n  5260\t\n  5261\t    def test_references_field_by_remote_field_model(self):\n  5262\t        operation = FieldOperation(\n  5263\t            \"Model\", \"field\", models.ForeignKey(\"Other\", models.CASCADE)\n  5264\t        )\n  5265\t        self.assertIs(\n  5266\t            operation.references_field(\"Other\", \"whatever\", \"migrations\"), True\n  5267\t        )\n  5268\t        self.assertIs(\n  5269\t            operation.references_field(\"Missing\", \"whatever\", \"migrations\"), False\n  5270\t        )\n  5271\t\n  5272\t    def test_references_field_by_from_fields(self):\n  5273\t        operation = FieldOperation(\n  5274\t            \"Model\",\n  5275\t            \"field\",\n  5276\t            models.fields.related.ForeignObject(\n  5277\t                \"Other\", models.CASCADE, [\"from\"], [\"to\"]\n  5278\t            ),\n  5279\t        )\n  5280\t        self.assertIs(operation.references_field(\"Model\", \"from\", \"migrations\"), True)\n  5281\t        self.assertIs(operation.references_field(\"Model\", \"to\", \"migrations\"), False)\n  5282\t        self.assertIs(operation.references_field(\"Other\", \"from\", \"migrations\"), False)\n  5283\t        self.assertIs(operation.references_field(\"Model\", \"to\", \"migrations\"), False)\n  5284\t\n  5285\t    def test_references_field_by_to_fields(self):\n  5286\t        operation = FieldOperation(\n  5287\t            \"Model\",\n  5288\t            \"field\",\n  5289\t            models.ForeignKey(\"Other\", models.CASCADE, to_field=\"field\"),\n  5290\t        )\n  5291\t        self.assertIs(operation.references_field(\"Other\", \"field\", \"migrations\"), True)\n  5292\t        self.assertIs(\n  5293\t            operation.references_field(\"Other\", \"whatever\", \"migrations\"), False\n  5294\t        )\n  5295\t        self.assertIs(\n  5296\t            operation.references_field(\"Missing\", \"whatever\", \"migrations\"), False\n  5297\t        )\n  5298\t\n  5299\t    def test_references_field_by_through(self):\n  5300\t        operation = FieldOperation(\n  5301\t            \"Model\", \"field\", models.ManyToManyField(\"Other\", through=\"Through\")\n  5302\t        )\n  5303\t        self.assertIs(\n  5304\t            operation.references_field(\"Other\", \"whatever\", \"migrations\"), True\n  5305\t        )\n  5306\t        self.assertIs(\n  5307\t            operation.references_field(\"Through\", \"whatever\", \"migrations\"), True\n  5308\t        )\n  5309\t        self.assertIs(\n  5310\t            operation.references_field(\"Missing\", \"whatever\", \"migrations\"), False\n  5311\t        )\n  5312\t\n  5313\t    def test_reference_field_by_through_fields(self):\n  5314\t        operation = FieldOperation(\n  5315\t            \"Model\",\n  5316\t            \"field\",\n  5317\t            models.ManyToManyField(\n  5318\t                \"Other\", through=\"Through\", through_fields=(\"first\", \"second\")\n  5319\t            ),\n  5320\t        )\n  5321\t        self.assertIs(\n  5322\t            operation.references_field(\"Other\", \"whatever\", \"migrations\"), True\n  5323\t        )\n  5324\t        self.assertIs(\n  5325\t            operation.references_field(\"Through\", \"whatever\", \"migrations\"), False\n  5326\t        )\n  5327\t        self.assertIs(\n  5328\t            operation.references_field(\"Through\", \"first\", \"migrations\"), True\n  5329\t        )\n  5330\t        self.assertIs(\n  5331\t            operation.references_field(\"Through\", \"second\", \"migrations\"), True\n  5332\t        )\n  5333\t\n```\n",
        "summary": "Showed the following code spans:\n\nFile: tests/migrations/test_operations.py\n- Showing all code in file\n",
        "terminal": false,
        "expect_correction": false,
        "properties": {
          "files": {
            "tests/migrations/test_operations.py": {
              "new_span_ids": [
                "imports"
              ]
            }
          }
        }
      },
      "parent_id": 0
    },
    {
      "node_id": 2,
      "action": {
        "scratch_pad": "1. From the test file, I can see this is related to the RenameIndex operation and how it handles unnamed indexes when moving backward and forward.\n\n2. Let me search for the RenameIndex operation implementation to understand how it currently works.",
        "query": "RenameIndex operation implementation",
        "category": "implementation",
        "action_args_class": "moatless.actions.semantic_search.SemanticSearchArgs"
      },
      "observation": {
        "message": "Found 15 code sections.\n\nViewed relevant code:\ndjango/db/migrations/operations/models.py\n```\n     1\tfrom django.db import models\n     2\tfrom django.db.migrations.operations.base import Operation\n     3\tfrom django.db.migrations.state import ModelState\n     4\tfrom django.db.migrations.utils import field_references, resolve_relation\n     5\tfrom django.db.models.options import normalize_together\n     6\tfrom django.utils.functional import cached_property\n     7\t\n     8\tfrom .fields import AddField, AlterField, FieldOperation, RemoveField, RenameField\n      # ...\n   877\t\n   878\t\n   879\tclass RenameIndex(IndexOperation):\n   880\t    \"\"\"Rename an index.\"\"\"\n   881\t\n   882\t    def __init__(self, model_name, new_name, old_name=None, old_fields=None):\n   883\t        if not old_name and not old_fields:\n   884\t            raise ValueError(\n   885\t                \"RenameIndex requires one of old_name and old_fields arguments to be \"\n   886\t                \"set.\"\n   887\t            )\n   888\t        if old_name and old_fields:\n   889\t            raise ValueError(\n   890\t                \"RenameIndex.old_name and old_fields are mutually exclusive.\"\n   891\t            )\n   892\t        self.model_name = model_name\n   893\t        self.new_name = new_name\n   894\t        self.old_name = old_name\n   895\t        self.old_fields = old_fields\n   896\t\n   897\t    @cached_property\n   898\t    def old_name_lower(self):\n   899\t        return self.old_name.lower()\n   900\t\n   901\t    @cached_property\n   902\t    def new_name_lower(self):\n   903\t        return self.new_name.lower()\n   904\t\n   905\t    def deconstruct(self):\n   906\t        kwargs = {\n   907\t            \"model_name\": self.model_name,\n   908\t            \"new_name\": self.new_name,\n   909\t        }\n   910\t        if self.old_name:\n   911\t            kwargs[\"old_name\"] = self.old_name\n   912\t        if self.old_fields:\n   913\t            kwargs[\"old_fields\"] = self.old_fields\n   914\t        return (self.__class__.__qualname__, [], kwargs)\n   915\t\n   916\t    def state_forwards(self, app_label, state):\n   917\t        if self.old_fields:\n   918\t            state.add_index(\n   919\t                app_label,\n   920\t                self.model_name_lower,\n   921\t                models.Index(fields=self.old_fields, name=self.new_name),\n   922\t            )\n   923\t            state.remove_model_options(\n   924\t                app_label,\n   925\t                self.model_name_lower,\n   926\t                AlterIndexTogether.option_name,\n   927\t                self.old_fields,\n   928\t            )\n   929\t        else:\n   930\t            state.rename_index(\n   931\t                app_label, self.model_name_lower, self.old_name, self.new_name\n   932\t            )\n   933\t\n   934\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n   935\t        model = to_state.apps.get_model(app_label, self.model_name)\n   936\t        if not self.allow_migrate_model(schema_editor.connection.alias, model):\n   937\t            return\n   938\t\n   939\t        if self.old_fields:\n   940\t            from_model = from_state.apps.get_model(app_label, self.model_name)\n   941\t            columns = [\n   942\t                from_model._meta.get_field(field).column for field in self.old_fields\n   943\t            ]\n   944\t            matching_index_name = schema_editor._constraint_names(\n   945\t                from_model, column_names=columns, index=True\n   946\t            )\n   947\t            if len(matching_index_name) != 1:\n   948\t                raise ValueError(\n   949\t                    \"Found wrong number (%s) of indexes for %s(%s).\"\n   950\t                    % (\n   951\t                        len(matching_index_name),\n   952\t                        from_model._meta.db_table,\n   953\t                        \", \".join(columns),\n   954\t                    )\n   955\t                )\n   956\t            old_index = models.Index(\n   957\t                fields=self.old_fields,\n   958\t                name=matching_index_name[0],\n   959\t            )\n   960\t        else:\n   961\t            from_model_state = from_state.models[app_label, self.model_name_lower]\n   962\t            old_index = from_model_state.get_index_by_name(self.old_name)\n   963\t\n   964\t        to_model_state = to_state.models[app_label, self.model_name_lower]\n   965\t        new_index = to_model_state.get_index_by_name(self.new_name)\n   966\t        schema_editor.rename_index(model, old_index, new_index)\n   967\t\n   968\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n   969\t        if self.old_fields:\n   970\t            # Backward operation with unnamed index is a no-op.\n   971\t            return\n   972\t\n   973\t        self.new_name_lower, self.old_name_lower = (\n   974\t            self.old_name_lower,\n   975\t            self.new_name_lower,\n   976\t        )\n   977\t        self.new_name, self.old_name = self.old_name, self.new_name\n   978\t\n   979\t        self.database_forwards(app_label, schema_editor, from_state, to_state)\n   980\t\n   981\t        self.new_name_lower, self.old_name_lower = (\n   982\t            self.old_name_lower,\n   983\t            self.new_name_lower,\n   984\t        )\n   985\t        self.new_name, self.old_name = self.old_name, self.new_name\n   986\t\n   987\t    def describe(self):\n   988\t        if self.old_name:\n   989\t            return (\n   990\t                f\"Rename index {self.old_name} on {self.model_name} to {self.new_name}\"\n   991\t            )\n   992\t        return (\n   993\t            f\"Rename unnamed index for {self.old_fields} on {self.model_name} to \"\n   994\t            f\"{self.new_name}\"\n   995\t        )\n   996\t\n   997\t    @property\n   998\t    def migration_name_fragment(self):\n   999\t        if self.old_name:\n  1000\t            return \"rename_%s_%s\" % (self.old_name_lower, self.new_name_lower)\n  1001\t        return \"rename_%s_%s_%s\" % (\n  1002\t            self.model_name_lower,\n  1003\t            \"_\".join(self.old_fields),\n  1004\t            self.new_name_lower,\n  1005\t        )\n  1006\t\n  1007\t    def reduce(self, operation, app_label):\n  1008\t        if (\n  1009\t            isinstance(operation, RenameIndex)\n  1010\t            and self.model_name_lower == operation.model_name_lower\n  1011\t            and operation.old_name\n  1012\t            and self.new_name_lower == operation.old_name_lower\n  1013\t        ):\n  1014\t            return [\n  1015\t                RenameIndex(\n  1016\t                    self.model_name,\n  1017\t                    new_name=operation.new_name,\n  1018\t                    old_name=self.old_name,\n  1019\t                    old_fields=self.old_fields,\n  1020\t                )\n  1021\t            ]\n  1022\t        return super().reduce(operation, app_label)\n      # ...\n```\n\n\ndjango/db/backends/base/schema.py\n```\n     1\timport logging\n     2\timport operator\n     3\tfrom datetime import datetime\n     4\t\n     5\tfrom django.db.backends.ddl_references import (\n     6\t    Columns,\n     7\t    Expressions,\n     8\t    ForeignKeyName,\n     9\t    IndexName,\n    10\t    Statement,\n    11\t    Table,\n    12\t)\n    13\tfrom django.db.backends.utils import names_digest, split_identifier\n    14\tfrom django.db.models import Deferrable, Index\n    15\tfrom django.db.models.sql import Query\n    16\tfrom django.db.transaction import TransactionManagementError, atomic\n    17\tfrom django.utils import timezone\n    18\t\n    19\tlogger = logging.getLogger(\"django.db.backends.schema\")\n      # ...\n    72\t\n    73\t\n    74\tclass BaseDatabaseSchemaEditor:\n    75\t    \"\"\"\n    76\t    This class and its subclasses are responsible for emitting schema-changing\n    77\t    statements to the databases - model creation/removal/alteration, field\n    78\t    renaming, index fiddling, and so on.\n    79\t    \"\"\"\n    80\t\n    81\t    # Overrideable SQL templates\n    82\t    sql_create_table = \"CREATE TABLE %(table)s (%(definition)s)\"\n    83\t    sql_rename_table = \"ALTER TABLE %(old_table)s RENAME TO %(new_table)s\"\n    84\t    sql_retablespace_table = \"ALTER TABLE %(table)s SET TABLESPACE %(new_tablespace)s\"\n    85\t    sql_delete_table = \"DROP TABLE %(table)s CASCADE\"\n    86\t\n    87\t    sql_create_column = \"ALTER TABLE %(table)s ADD COLUMN %(column)s %(definition)s\"\n    88\t    sql_alter_column = \"ALTER TABLE %(table)s %(changes)s\"\n    89\t    sql_alter_column_type = \"ALTER COLUMN %(column)s TYPE %(type)s\"\n    90\t    sql_alter_column_null = \"ALTER COLUMN %(column)s DROP NOT NULL\"\n    91\t    sql_alter_column_not_null = \"ALTER COLUMN %(column)s SET NOT NULL\"\n    92\t    sql_alter_column_default = \"ALTER COLUMN %(column)s SET DEFAULT %(default)s\"\n    93\t    sql_alter_column_no_default = \"ALTER COLUMN %(column)s DROP DEFAULT\"\n    94\t    sql_alter_column_no_default_null = sql_alter_column_no_default\n    95\t    sql_alter_column_collate = \"ALTER COLUMN %(column)s TYPE %(type)s%(collation)s\"\n    96\t    sql_delete_column = \"ALTER TABLE %(table)s DROP COLUMN %(column)s CASCADE\"\n    97\t    sql_rename_column = (\n    98\t        \"ALTER TABLE %(table)s RENAME COLUMN %(old_column)s TO %(new_column)s\"\n    99\t    )\n   100\t    sql_update_with_default = (\n   101\t        \"UPDATE %(table)s SET %(column)s = %(default)s WHERE %(column)s IS NULL\"\n   102\t    )\n   103\t\n   104\t    sql_unique_constraint = \"UNIQUE (%(columns)s)%(deferrable)s\"\n   105\t    sql_check_constraint = \"CHECK (%(check)s)\"\n   106\t    sql_delete_constraint = \"ALTER TABLE %(table)s DROP CONSTRAINT %(name)s\"\n   107\t    sql_constraint = \"CONSTRAINT %(name)s %(constraint)s\"\n   108\t\n   109\t    sql_create_check = \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s CHECK (%(check)s)\"\n   110\t    sql_delete_check = sql_delete_constraint\n   111\t\n   112\t    sql_create_unique = (\n   113\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s \"\n   114\t        \"UNIQUE (%(columns)s)%(deferrable)s\"\n   115\t    )\n   116\t    sql_delete_unique = sql_delete_constraint\n   117\t\n   118\t    sql_create_fk = (\n   119\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s FOREIGN KEY (%(column)s) \"\n   120\t        \"REFERENCES %(to_table)s (%(to_column)s)%(deferrable)s\"\n   121\t    )\n   122\t    sql_create_inline_fk = None\n   123\t    sql_create_column_inline_fk = None\n   124\t    sql_delete_fk = sql_delete_constraint\n   125\t\n   126\t    sql_create_index = (\n   127\t        \"CREATE INDEX %(name)s ON %(table)s \"\n   128\t        \"(%(columns)s)%(include)s%(extra)s%(condition)s\"\n   129\t    )\n   130\t    sql_create_unique_index = (\n   131\t        \"CREATE UNIQUE INDEX %(name)s ON %(table)s \"\n   132\t        \"(%(columns)s)%(include)s%(condition)s\"\n   133\t    )\n   134\t    sql_rename_index = \"ALTER INDEX %(old_name)s RENAME TO %(new_name)s\"\n   135\t    sql_delete_index = \"DROP INDEX %(name)s\"\n   136\t\n   137\t    sql_create_pk = (\n   138\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s PRIMARY KEY (%(columns)s)\"\n   139\t    )\n   140\t    sql_delete_pk = sql_delete_constraint\n   141\t\n   142\t    sql_delete_procedure = \"DROP PROCEDURE %(procedure)s\"\n          # ...\n  1374\t\n  1375\t    def _rename_index_sql(self, model, old_name, new_name):\n  1376\t        return Statement(\n  1377\t            self.sql_rename_index,\n  1378\t            table=Table(model._meta.db_table, self.quote_name),\n  1379\t            old_name=self.quote_name(old_name),\n  1380\t            new_name=self.quote_name(new_name),\n  1381\t        )\n          # ...\n```\n",
        "summary": "Found relevant code sections in the search results.",
        "terminal": false,
        "expect_correction": false,
        "properties": {
          "search_hits": [],
          "search_tokens": 1804,
          "new_span_ids": [
            "RenameIndex",
            "RenameIndex.__init__",
            "RenameIndex.old_name_lower",
            "RenameIndex.new_name_lower",
            "RenameIndex.deconstruct",
            "RenameIndex.state_forwards",
            "RenameIndex.database_forwards",
            "RenameIndex.database_backwards",
            "RenameIndex.describe",
            "RenameIndex.migration_name_fragment",
            "RenameIndex.reduce",
            "BaseDatabaseSchemaEditor",
            "BaseDatabaseSchemaEditor._rename_index_sql"
          ]
        },
        "execution_completion": {
          "model": "claude-3-5-sonnet-20241022",
          "input": [
            {
              "role": "user",
              "content": "Search request:\nSearching for code using the query: RenameIndex operation implementation\n\nIdentify the relevant code sections in the search results to use them. \n\n<search_results>\ndjango/db/migrations/operations/models.py\n```\n\n\n\n<span id='imports'>\n     1\tfrom django.db import models\n     2\tfrom django.db.migrations.operations.base import Operation\n     3\tfrom django.db.migrations.state import ModelState\n     4\tfrom django.db.migrations.utils import field_references, resolve_relation\n     5\tfrom django.db.models.options import normalize_together\n     6\tfrom django.utils.functional import cached_property\n     7\t\n     8\tfrom .fields import AddField, AlterField, FieldOperation, RemoveField, RenameField\n      # ...\n\n\n<span id='RenameIndex'>\n   877\t\n   878\t\n   879\tclass RenameIndex(IndexOperation):\n   880\t    \"\"\"Rename an index.\"\"\"\n          # ...\n\n\n<span id='RenameIndex.old_name_lower'>\n   896\t\n   897\t    @cached_property\n   898\t    def old_name_lower(self):\n   899\t        return self.old_name.lower()\n\n\n<span id='RenameIndex.new_name_lower'>\n   900\t\n   901\t    @cached_property\n   902\t    def new_name_lower(self):\n   903\t        return self.new_name.lower()\n\n\n<span id='RenameIndex.deconstruct'>\n   904\t\n   905\t    def deconstruct(self):\n   906\t        kwargs = {\n   907\t            \"model_name\": self.model_name,\n   908\t            \"new_name\": self.new_name,\n   909\t        }\n   910\t        if self.old_name:\n   911\t            kwargs[\"old_name\"] = self.old_name\n   912\t        if self.old_fields:\n   913\t            kwargs[\"old_fields\"] = self.old_fields\n   914\t        return (self.__class__.__qualname__, [], kwargs)\n\n\n<span id='RenameIndex.state_forwards'>\n   915\t\n   916\t    def state_forwards(self, app_label, state):\n   917\t        if self.old_fields:\n   918\t            state.add_index(\n   919\t                app_label,\n   920\t                self.model_name_lower,\n   921\t                models.Index(fields=self.old_fields, name=self.new_name),\n   922\t            )\n   923\t            state.remove_model_options(\n   924\t                app_label,\n   925\t                self.model_name_lower,\n   926\t                AlterIndexTogether.option_name,\n   927\t                self.old_fields,\n   928\t            )\n   929\t        else:\n   930\t            state.rename_index(\n   931\t                app_label, self.model_name_lower, self.old_name, self.new_name\n   932\t            )\n\n\n<span id='RenameIndex.database_forwards'>\n   933\t\n   934\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n   935\t        model = to_state.apps.get_model(app_label, self.model_name)\n   936\t        if not self.allow_migrate_model(schema_editor.connection.alias, model):\n   937\t            return\n   938\t\n   939\t        if self.old_fields:\n   940\t            from_model = from_state.apps.get_model(app_label, self.model_name)\n   941\t            columns = [\n   942\t                from_model._meta.get_field(field).column for field in self.old_fields\n   943\t            ]\n   944\t            matching_index_name = schema_editor._constraint_names(\n   945\t                from_model, column_names=columns, index=True\n   946\t            )\n   947\t            if len(matching_index_name) != 1:\n   948\t                raise ValueError(\n   949\t                    \"Found wrong number (%s) of indexes for %s(%s).\"\n   950\t                    % (\n   951\t                        len(matching_index_name),\n   952\t                        from_model._meta.db_table,\n   953\t                        \", \".join(columns),\n   954\t                    )\n   955\t                )\n   956\t            old_index = models.Index(\n   957\t                fields=self.old_fields,\n   958\t                name=matching_index_name[0],\n   959\t            )\n   960\t        else:\n   961\t            from_model_state = from_state.models[app_label, self.model_name_lower]\n   962\t            old_index = from_model_state.get_index_by_name(self.old_name)\n   963\t\n   964\t        to_model_state = to_state.models[app_label, self.model_name_lower]\n   965\t        new_index = to_model_state.get_index_by_name(self.new_name)\n   966\t        schema_editor.rename_index(model, old_index, new_index)\n\n\n<span id='RenameIndex.database_backwards'>\n   967\t\n   968\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n   969\t        if self.old_fields:\n   970\t            # Backward operation with unnamed index is a no-op.\n   971\t            return\n   972\t\n   973\t        self.new_name_lower, self.old_name_lower = (\n   974\t            self.old_name_lower,\n   975\t            self.new_name_lower,\n   976\t        )\n   977\t        self.new_name, self.old_name = self.old_name, self.new_name\n   978\t\n   979\t        self.database_forwards(app_label, schema_editor, from_state, to_state)\n   980\t\n   981\t        self.new_name_lower, self.old_name_lower = (\n   982\t            self.old_name_lower,\n   983\t            self.new_name_lower,\n   984\t        )\n   985\t        self.new_name, self.old_name = self.old_name, self.new_name\n\n\n<span id='RenameIndex.describe'>\n   986\t\n   987\t    def describe(self):\n   988\t        if self.old_name:\n   989\t            return (\n   990\t                f\"Rename index {self.old_name} on {self.model_name} to {self.new_name}\"\n   991\t            )\n   992\t        return (\n   993\t            f\"Rename unnamed index for {self.old_fields} on {self.model_name} to \"\n   994\t            f\"{self.new_name}\"\n   995\t        )\n\n\n<span id='RenameIndex.migration_name_fragment'>\n   996\t\n   997\t    @property\n   998\t    def migration_name_fragment(self):\n   999\t        if self.old_name:\n  1000\t            return \"rename_%s_%s\" % (self.old_name_lower, self.new_name_lower)\n  1001\t        return \"rename_%s_%s_%s\" % (\n  1002\t            self.model_name_lower,\n  1003\t            \"_\".join(self.old_fields),\n  1004\t            self.new_name_lower,\n  1005\t        )\n\n\n<span id='RenameIndex.reduce'>\n  1006\t\n  1007\t    def reduce(self, operation, app_label):\n  1008\t        if (\n  1009\t            isinstance(operation, RenameIndex)\n  1010\t            and self.model_name_lower == operation.model_name_lower\n  1011\t            and operation.old_name\n  1012\t            and self.new_name_lower == operation.old_name_lower\n  1013\t        ):\n  1014\t            return [\n  1015\t                RenameIndex(\n  1016\t                    self.model_name,\n  1017\t                    new_name=operation.new_name,\n  1018\t                    old_name=self.old_name,\n  1019\t                    old_fields=self.old_fields,\n  1020\t                )\n  1021\t            ]\n  1022\t        return super().reduce(operation, app_label)\n      # ...\n```\n\n\ndjango/db/backends/base/schema.py\n```\n\n\n\n<span id='imports'>\n     1\timport logging\n     2\timport operator\n     3\tfrom datetime import datetime\n     4\t\n     5\tfrom django.db.backends.ddl_references import (\n     6\t    Columns,\n     7\t    Expressions,\n     8\t    ForeignKeyName,\n     9\t    IndexName,\n    10\t    Statement,\n    11\t    Table,\n    12\t)\n    13\tfrom django.db.backends.utils import names_digest, split_identifier\n    14\tfrom django.db.models import Deferrable, Index\n    15\tfrom django.db.models.sql import Query\n    16\tfrom django.db.transaction import TransactionManagementError, atomic\n    17\tfrom django.utils import timezone\n    18\t\n    19\tlogger = logging.getLogger(\"django.db.backends.schema\")\n      # ...\n\n\n<span id='BaseDatabaseSchemaEditor'>\n    72\t\n    73\t\n    74\tclass BaseDatabaseSchemaEditor:\n    75\t    \"\"\"\n    76\t    This class and its subclasses are responsible for emitting schema-changing\n    77\t    statements to the databases - model creation/removal/alteration, field\n    78\t    renaming, index fiddling, and so on.\n    79\t    \"\"\"\n    80\t\n    81\t    # Overrideable SQL templates\n    82\t    sql_create_table = \"CREATE TABLE %(table)s (%(definition)s)\"\n    83\t    sql_rename_table = \"ALTER TABLE %(old_table)s RENAME TO %(new_table)s\"\n    84\t    sql_retablespace_table = \"ALTER TABLE %(table)s SET TABLESPACE %(new_tablespace)s\"\n    85\t    sql_delete_table = \"DROP TABLE %(table)s CASCADE\"\n    86\t\n    87\t    sql_create_column = \"ALTER TABLE %(table)s ADD COLUMN %(column)s %(definition)s\"\n    88\t    sql_alter_column = \"ALTER TABLE %(table)s %(changes)s\"\n    89\t    sql_alter_column_type = \"ALTER COLUMN %(column)s TYPE %(type)s\"\n    90\t    sql_alter_column_null = \"ALTER COLUMN %(column)s DROP NOT NULL\"\n    91\t    sql_alter_column_not_null = \"ALTER COLUMN %(column)s SET NOT NULL\"\n    92\t    sql_alter_column_default = \"ALTER COLUMN %(column)s SET DEFAULT %(default)s\"\n    93\t    sql_alter_column_no_default = \"ALTER COLUMN %(column)s DROP DEFAULT\"\n    94\t    sql_alter_column_no_default_null = sql_alter_column_no_default\n    95\t    sql_alter_column_collate = \"ALTER COLUMN %(column)s TYPE %(type)s%(collation)s\"\n    96\t    sql_delete_column = \"ALTER TABLE %(table)s DROP COLUMN %(column)s CASCADE\"\n    97\t    sql_rename_column = (\n    98\t        \"ALTER TABLE %(table)s RENAME COLUMN %(old_column)s TO %(new_column)s\"\n    99\t    )\n   100\t    sql_update_with_default = (\n   101\t        \"UPDATE %(table)s SET %(column)s = %(default)s WHERE %(column)s IS NULL\"\n   102\t    )\n   103\t\n   104\t    sql_unique_constraint = \"UNIQUE (%(columns)s)%(deferrable)s\"\n   105\t    sql_check_constraint = \"CHECK (%(check)s)\"\n   106\t    sql_delete_constraint = \"ALTER TABLE %(table)s DROP CONSTRAINT %(name)s\"\n   107\t    sql_constraint = \"CONSTRAINT %(name)s %(constraint)s\"\n   108\t\n   109\t    sql_create_check = \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s CHECK (%(check)s)\"\n   110\t    sql_delete_check = sql_delete_constraint\n   111\t\n   112\t    sql_create_unique = (\n   113\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s \"\n   114\t        \"UNIQUE (%(columns)s)%(deferrable)s\"\n   115\t    )\n   116\t    sql_delete_unique = sql_delete_constraint\n   117\t\n   118\t    sql_create_fk = (\n   119\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s FOREIGN KEY (%(column)s) \"\n   120\t        \"REFERENCES %(to_table)s (%(to_column)s)%(deferrable)s\"\n   121\t    )\n   122\t    sql_create_inline_fk = None\n   123\t    sql_create_column_inline_fk = None\n   124\t    sql_delete_fk = sql_delete_constraint\n   125\t\n   126\t    sql_create_index = (\n   127\t        \"CREATE INDEX %(name)s ON %(table)s \"\n   128\t        \"(%(columns)s)%(include)s%(extra)s%(condition)s\"\n   129\t    )\n   130\t    sql_create_unique_index = (\n   131\t        \"CREATE UNIQUE INDEX %(name)s ON %(table)s \"\n   132\t        \"(%(columns)s)%(include)s%(condition)s\"\n   133\t    )\n   134\t    sql_rename_index = \"ALTER INDEX %(old_name)s RENAME TO %(new_name)s\"\n   135\t    sql_delete_index = \"DROP INDEX %(name)s\"\n   136\t\n   137\t    sql_create_pk = (\n   138\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s PRIMARY KEY (%(columns)s)\"\n   139\t    )\n   140\t    sql_delete_pk = sql_delete_constraint\n   141\t\n   142\t    sql_delete_procedure = \"DROP PROCEDURE %(procedure)s\"\n\n\n<span id='BaseDatabaseSchemaEditor.__init__'>\n   143\t\n   144\t    def __init__(self, connection, collect_sql=False, atomic=True):\n   145\t        self.connection = connection\n   146\t        self.collect_sql = collect_sql\n   147\t        if self.collect_sql:\n   148\t            self.collected_sql = []\n   149\t        self.atomic_migration = self.connection.features.can_rollback_ddl and atomic\n   150\t\n   151\t    # State-managing methods\n          # ...\n\n\n<span id='BaseDatabaseSchemaEditor._rename_index_sql'>\n  1374\t\n  1375\t    def _rename_index_sql(self, model, old_name, new_name):\n  1376\t        return Statement(\n  1377\t            self.sql_rename_index,\n  1378\t            table=Table(model._meta.db_table, self.quote_name),\n  1379\t            old_name=self.quote_name(old_name),\n  1380\t            new_name=self.quote_name(new_name),\n  1381\t        )\n          # ...\n```\n\n</search_result>\n"
            }
          ],
          "response": {
            "id": "msg_011MMxSWNenFY8oMfoYJMLhV",
            "content": [
              {
                "text": "I'll help identify the relevant code sections for the RenameIndex operation implementation. Let me analyze the search results and mark the relevant sections.",
                "type": "text"
              },
              {
                "id": "toolu_01XYLWrkinSybrWf6Ef9tXS9",
                "input": {
                  "scratch_pad": "The search results contain the complete implementation of the RenameIndex operation in Django's migration system. The relevant sections include:\n\n1. Main RenameIndex class definition and its methods (lines 879-1022 in migrations/operations/models.py):\n- Class definition and core functionality\n- Property methods for name handling\n- Key operation methods like state_forwards, database_forwards, database_backwards\n- Support methods like describe, deconstruct, reduce\n\n2. Supporting implementation in schema.py (lines 134, 1374-1381):\n- SQL template for rename index operation\n- Method to generate the SQL for renaming an index\n\nThese sections show the complete implementation of how Django handles index renaming operations in database migrations.",
                  "identified_spans": [
                    {
                      "file_path": "django/db/migrations/operations/models.py",
                      "start_line": 879,
                      "end_line": 1022
                    },
                    {
                      "file_path": "django/db/backends/base/schema.py",
                      "start_line": 134,
                      "end_line": 134
                    },
                    {
                      "file_path": "django/db/backends/base/schema.py",
                      "start_line": 1374,
                      "end_line": 1381
                    }
                  ]
                },
                "name": "Action",
                "type": "tool_use"
              }
            ],
            "model": "claude-3-5-sonnet-20241022",
            "role": "assistant",
            "stop_reason": "tool_use",
            "stop_sequence": null,
            "type": "message",
            "usage": {
              "cache_creation_input_tokens": 0,
              "cache_read_input_tokens": 0,
              "input_tokens": 4668,
              "output_tokens": 398
            }
          },
          "usage": {
            "completion_cost": 0.019974000000000002,
            "completion_tokens": 398,
            "prompt_tokens": 4668,
            "cached_tokens": 0
          }
        }
      },
      "file_context": {
        "max_tokens": 8000,
        "files": [
          {
            "file_path": "tests/migrations/test_operations.py",
            "spans": [
              {
                "span_id": "imports",
                "pinned": false
              }
            ],
            "show_all_spans": true,
            "patch": null
          },
          {
            "file_path": "django/db/migrations/operations/models.py",
            "spans": [
              {
                "span_id": "imports",
                "pinned": false
              },
              {
                "span_id": "RenameIndex",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.__init__",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.old_name_lower",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.new_name_lower",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.deconstruct",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.state_forwards",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.database_forwards",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.database_backwards",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.describe",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.migration_name_fragment",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.reduce",
                "pinned": false
              }
            ],
            "show_all_spans": false,
            "patch": null
          },
          {
            "file_path": "django/db/backends/base/schema.py",
            "spans": [
              {
                "span_id": "imports",
                "pinned": false
              },
              {
                "span_id": "BaseDatabaseSchemaEditor",
                "pinned": false
              },
              {
                "span_id": "BaseDatabaseSchemaEditor._rename_index_sql",
                "pinned": false
              }
            ],
            "show_all_spans": false,
            "patch": null
          }
        ]
      },
      "completions": {
        "build_action": {
          "model": "claude-3-5-sonnet-20241022",
          "input": [
            {
              "role": "user",
              "content": "<task>\nRenameIndex() crashes when unnamed index is moving backward and forward.\nDescription\n\t\nRenameIndex() should restore the old auto-generated name when an unnamed index for unique_together is moving backward. Now re-applying RenameIndex() crashes. For example:\ntests/migrations/test_operations.py\ndiff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex cfd28b1b39..c0a55023bb 100644\n\t\t\t\t\t\n\t\t\t\t\t a\n\t\t\t\t \n\t\t\t\t\t\n\t\t\t\t\t b\n\t\t\t\t \n class OperationTests(OperationTestBase):\u00a0\n29882988\u00a0 \u00a0 \u00a0 \u00a0 with connection.schema_editor() as editor, self.assertNumQueries(0):\n29892989\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 operation.database_backwards(app_label, editor, new_state, project_state)\n29902990\u00a0 \u00a0 \u00a0 \u00a0 self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n\u00a02991\u00a0 \u00a0 \u00a0 \u00a0 # Re-apply renaming.\n\u00a02992\u00a0 \u00a0 \u00a0 \u00a0 with connection.schema_editor() as editor:\n\u00a02993\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 operation.database_forwards(app_label, editor, project_state, new_state)\n\u00a02994\u00a0 \u00a0 \u00a0 \u00a0 self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n29912995\u00a0 \u00a0 \u00a0 \u00a0 # Deconstruction.\n29922996\u00a0 \u00a0 \u00a0 \u00a0 definition = operation.deconstruct()\n29932997\u00a0 \u00a0 \u00a0 \u00a0 self.assertEqual(definition[0], \"RenameIndex\")\ncrashes on PostgreSQL:\ndjango.db.utils.ProgrammingError: relation \"new_pony_test_idx\" already exists\n\n</task>"
            },
            {
              "role": "assistant",
              "content": [
                {
                  "type": "text",
                  "text": "<thoughts>\n1. First, I need to understand the context better by:\n   - Looking at the test file to see the full test case\n   - Finding the RenameIndex operation implementation\n   - Understanding how index naming works in this context\n\n2. Let's start by viewing the test file to see the full test case context.\n</thoughts>"
                },
                {
                  "id": "call_8635dcc7",
                  "input": {
                    "files": [
                      {
                        "file_path": "tests/migrations/test_operations.py",
                        "start_line": null,
                        "end_line": null,
                        "span_ids": []
                      }
                    ]
                  },
                  "type": "tool_use",
                  "name": "ViewCode",
                  "cache_control": {
                    "type": "ephemeral"
                  }
                }
              ]
            },
            {
              "role": "user",
              "content": [
                {
                  "tool_use_id": "call_8635dcc7",
                  "content": "<observation>\nHere's the contents of the requested code spans:\ntests/migrations/test_operations.py\n```\n     1\tfrom django.core.exceptions import FieldDoesNotExist\n     2\tfrom django.db import IntegrityError, connection, migrations, models, transaction\n     3\tfrom django.db.migrations.migration import Migration\n     4\tfrom django.db.migrations.operations.fields import FieldOperation\n     5\tfrom django.db.migrations.state import ModelState, ProjectState\n     6\tfrom django.db.models.functions import Abs\n     7\tfrom django.db.transaction import atomic\n     8\tfrom django.test import SimpleTestCase, override_settings, skipUnlessDBFeature\n     9\tfrom django.test.utils import CaptureQueriesContext\n    10\t\n    11\tfrom .models import FoodManager, FoodQuerySet, UnicodeModel\n    12\tfrom .test_base import OperationTestBase\n    13\t\n    14\t\n    15\tclass Mixin:\n    16\t    pass\n    17\t\n    18\t\n    19\tclass OperationTests(OperationTestBase):\n    20\t    \"\"\"\n    21\t    Tests running the operations and making sure they do what they say they do.\n    22\t    Each test looks at their state changing, and then their database operation -\n    23\t    both forwards and backwards.\n    24\t    \"\"\"\n    25\t\n    26\t    def test_create_model(self):\n    27\t        \"\"\"\n    28\t        Tests the CreateModel operation.\n    29\t        Most other tests use this operation as part of setup, so check failures\n    30\t        here first.\n    31\t        \"\"\"\n    32\t        operation = migrations.CreateModel(\n    33\t            \"Pony\",\n    34\t            [\n    35\t                (\"id\", models.AutoField(primary_key=True)),\n    36\t                (\"pink\", models.IntegerField(default=1)),\n    37\t            ],\n    38\t        )\n    39\t        self.assertEqual(operation.describe(), \"Create model Pony\")\n    40\t        self.assertEqual(operation.migration_name_fragment, \"pony\")\n    41\t        # Test the state alteration\n    42\t        project_state = ProjectState()\n    43\t        new_state = project_state.clone()\n    44\t        operation.state_forwards(\"test_crmo\", new_state)\n    45\t        self.assertEqual(new_state.models[\"test_crmo\", \"pony\"].name, \"Pony\")\n    46\t        self.assertEqual(len(new_state.models[\"test_crmo\", \"pony\"].fields), 2)\n    47\t        # Test the database alteration\n    48\t        self.assertTableNotExists(\"test_crmo_pony\")\n    49\t        with connection.schema_editor() as editor:\n    50\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n    51\t        self.assertTableExists(\"test_crmo_pony\")\n    52\t        # And test reversal\n    53\t        with connection.schema_editor() as editor:\n    54\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n    55\t        self.assertTableNotExists(\"test_crmo_pony\")\n    56\t        # And deconstruction\n    57\t        definition = operation.deconstruct()\n    58\t        self.assertEqual(definition[0], \"CreateModel\")\n    59\t        self.assertEqual(definition[1], [])\n    60\t        self.assertEqual(sorted(definition[2]), [\"fields\", \"name\"])\n    61\t        # And default manager not in set\n    62\t        operation = migrations.CreateModel(\n    63\t            \"Foo\", fields=[], managers=[(\"objects\", models.Manager())]\n    64\t        )\n    65\t        definition = operation.deconstruct()\n    66\t        self.assertNotIn(\"managers\", definition[2])\n    67\t\n    68\t    def test_create_model_with_duplicate_field_name(self):\n    69\t        with self.assertRaisesMessage(\n    70\t            ValueError, \"Found duplicate value pink in CreateModel fields argument.\"\n    71\t        ):\n    72\t            migrations.CreateModel(\n    73\t                \"Pony\",\n    74\t                [\n    75\t                    (\"id\", models.AutoField(primary_key=True)),\n    76\t                    (\"pink\", models.TextField()),\n    77\t                    (\"pink\", models.IntegerField(default=1)),\n    78\t                ],\n    79\t            )\n    80\t\n    81\t    def test_create_model_with_duplicate_base(self):\n    82\t        message = \"Found duplicate value test_crmo.pony in CreateModel bases argument.\"\n    83\t        with self.assertRaisesMessage(ValueError, message):\n    84\t            migrations.CreateModel(\n    85\t                \"Pony\",\n    86\t                fields=[],\n    87\t                bases=(\n    88\t                    \"test_crmo.Pony\",\n    89\t                    \"test_crmo.Pony\",\n    90\t                ),\n    91\t            )\n    92\t        with self.assertRaisesMessage(ValueError, message):\n    93\t            migrations.CreateModel(\n    94\t                \"Pony\",\n    95\t                fields=[],\n    96\t                bases=(\n    97\t                    \"test_crmo.Pony\",\n    98\t                    \"test_crmo.pony\",\n    99\t                ),\n   100\t            )\n   101\t        message = (\n   102\t            \"Found duplicate value migrations.unicodemodel in CreateModel bases \"\n   103\t            \"argument.\"\n   104\t        )\n   105\t        with self.assertRaisesMessage(ValueError, message):\n   106\t            migrations.CreateModel(\n   107\t                \"Pony\",\n   108\t                fields=[],\n   109\t                bases=(\n   110\t                    UnicodeModel,\n   111\t                    UnicodeModel,\n   112\t                ),\n   113\t            )\n   114\t        with self.assertRaisesMessage(ValueError, message):\n   115\t            migrations.CreateModel(\n   116\t                \"Pony\",\n   117\t                fields=[],\n   118\t                bases=(\n   119\t                    UnicodeModel,\n   120\t                    \"migrations.unicodemodel\",\n   121\t                ),\n   122\t            )\n   123\t        with self.assertRaisesMessage(ValueError, message):\n   124\t            migrations.CreateModel(\n   125\t                \"Pony\",\n   126\t                fields=[],\n   127\t                bases=(\n   128\t                    UnicodeModel,\n   129\t                    \"migrations.UnicodeModel\",\n   130\t                ),\n   131\t            )\n   132\t        message = (\n   133\t            \"Found duplicate value <class 'django.db.models.base.Model'> in \"\n   134\t            \"CreateModel bases argument.\"\n   135\t        )\n   136\t        with self.assertRaisesMessage(ValueError, message):\n   137\t            migrations.CreateModel(\n   138\t                \"Pony\",\n   139\t                fields=[],\n   140\t                bases=(\n   141\t                    models.Model,\n   142\t                    models.Model,\n   143\t                ),\n   144\t            )\n   145\t        message = (\n   146\t            \"Found duplicate value <class 'migrations.test_operations.Mixin'> in \"\n   147\t            \"CreateModel bases argument.\"\n   148\t        )\n   149\t        with self.assertRaisesMessage(ValueError, message):\n   150\t            migrations.CreateModel(\n   151\t                \"Pony\",\n   152\t                fields=[],\n   153\t                bases=(\n   154\t                    Mixin,\n   155\t                    Mixin,\n   156\t                ),\n   157\t            )\n   158\t\n   159\t    def test_create_model_with_duplicate_manager_name(self):\n   160\t        with self.assertRaisesMessage(\n   161\t            ValueError,\n   162\t            \"Found duplicate value objects in CreateModel managers argument.\",\n   163\t        ):\n   164\t            migrations.CreateModel(\n   165\t                \"Pony\",\n   166\t                fields=[],\n   167\t                managers=[\n   168\t                    (\"objects\", models.Manager()),\n   169\t                    (\"objects\", models.Manager()),\n   170\t                ],\n   171\t            )\n   172\t\n   173\t    def test_create_model_with_unique_after(self):\n   174\t        \"\"\"\n   175\t        Tests the CreateModel operation directly followed by an\n   176\t        AlterUniqueTogether (bug #22844 - sqlite remake issues)\n   177\t        \"\"\"\n   178\t        operation1 = migrations.CreateModel(\n   179\t            \"Pony\",\n   180\t            [\n   181\t                (\"id\", models.AutoField(primary_key=True)),\n   182\t                (\"pink\", models.IntegerField(default=1)),\n   183\t            ],\n   184\t        )\n   185\t        operation2 = migrations.CreateModel(\n   186\t            \"Rider\",\n   187\t            [\n   188\t                (\"id\", models.AutoField(primary_key=True)),\n   189\t                (\"number\", models.IntegerField(default=1)),\n   190\t                (\"pony\", models.ForeignKey(\"test_crmoua.Pony\", models.CASCADE)),\n   191\t            ],\n   192\t        )\n   193\t        operation3 = migrations.AlterUniqueTogether(\n   194\t            \"Rider\",\n   195\t            [\n   196\t                (\"number\", \"pony\"),\n   197\t            ],\n   198\t        )\n   199\t        # Test the database alteration\n   200\t        project_state = ProjectState()\n   201\t        self.assertTableNotExists(\"test_crmoua_pony\")\n   202\t        self.assertTableNotExists(\"test_crmoua_rider\")\n   203\t        with connection.schema_editor() as editor:\n   204\t            new_state = project_state.clone()\n   205\t            operation1.state_forwards(\"test_crmoua\", new_state)\n   206\t            operation1.database_forwards(\n   207\t                \"test_crmoua\", editor, project_state, new_state\n   208\t            )\n   209\t            project_state, new_state = new_state, new_state.clone()\n   210\t            operation2.state_forwards(\"test_crmoua\", new_state)\n   211\t            operation2.database_forwards(\n   212\t                \"test_crmoua\", editor, project_state, new_state\n   213\t            )\n   214\t            project_state, new_state = new_state, new_state.clone()\n   215\t            operation3.state_forwards(\"test_crmoua\", new_state)\n   216\t            operation3.database_forwards(\n   217\t                \"test_crmoua\", editor, project_state, new_state\n   218\t            )\n   219\t        self.assertTableExists(\"test_crmoua_pony\")\n   220\t        self.assertTableExists(\"test_crmoua_rider\")\n   221\t\n   222\t    def test_create_model_m2m(self):\n   223\t        \"\"\"\n   224\t        Test the creation of a model with a ManyToMany field and the\n   225\t        auto-created \"through\" model.\n   226\t        \"\"\"\n   227\t        project_state = self.set_up_test_model(\"test_crmomm\")\n   228\t        operation = migrations.CreateModel(\n   229\t            \"Stable\",\n   230\t            [\n   231\t                (\"id\", models.AutoField(primary_key=True)),\n   232\t                (\"ponies\", models.ManyToManyField(\"Pony\", related_name=\"stables\")),\n   233\t            ],\n   234\t        )\n   235\t        # Test the state alteration\n   236\t        new_state = project_state.clone()\n   237\t        operation.state_forwards(\"test_crmomm\", new_state)\n   238\t        # Test the database alteration\n   239\t        self.assertTableNotExists(\"test_crmomm_stable_ponies\")\n   240\t        with connection.schema_editor() as editor:\n   241\t            operation.database_forwards(\"test_crmomm\", editor, project_state, new_state)\n   242\t        self.assertTableExists(\"test_crmomm_stable\")\n   243\t        self.assertTableExists(\"test_crmomm_stable_ponies\")\n   244\t        self.assertColumnNotExists(\"test_crmomm_stable\", \"ponies\")\n   245\t        # Make sure the M2M field actually works\n   246\t        with atomic():\n   247\t            Pony = new_state.apps.get_model(\"test_crmomm\", \"Pony\")\n   248\t            Stable = new_state.apps.get_model(\"test_crmomm\", \"Stable\")\n   249\t            stable = Stable.objects.create()\n   250\t            p1 = Pony.objects.create(pink=False, weight=4.55)\n   251\t            p2 = Pony.objects.create(pink=True, weight=5.43)\n   252\t            stable.ponies.add(p1, p2)\n   253\t            self.assertEqual(stable.ponies.count(), 2)\n   254\t            stable.ponies.all().delete()\n   255\t        # And test reversal\n   256\t        with connection.schema_editor() as editor:\n   257\t            operation.database_backwards(\n   258\t                \"test_crmomm\", editor, new_state, project_state\n   259\t            )\n   260\t        self.assertTableNotExists(\"test_crmomm_stable\")\n   261\t        self.assertTableNotExists(\"test_crmomm_stable_ponies\")\n   262\t\n   263\t    @skipUnlessDBFeature(\"supports_collation_on_charfield\", \"supports_foreign_keys\")\n   264\t    def test_create_fk_models_to_pk_field_db_collation(self):\n   265\t        \"\"\"Creation of models with a FK to a PK with db_collation.\"\"\"\n   266\t        collation = connection.features.test_collations.get(\"non_default\")\n   267\t        if not collation:\n   268\t            self.skipTest(\"Language collations are not supported.\")\n   269\t\n   270\t        app_label = \"test_cfkmtopkfdbc\"\n   271\t        operations = [\n   272\t            migrations.CreateModel(\n   273\t                \"Pony\",\n   274\t                [\n   275\t                    (\n   276\t                        \"id\",\n   277\t                        models.CharField(\n   278\t                            primary_key=True,\n   279\t                            max_length=10,\n   280\t                            db_collation=collation,\n   281\t                        ),\n   282\t                    ),\n   283\t                ],\n   284\t            )\n   285\t        ]\n   286\t        project_state = self.apply_operations(app_label, ProjectState(), operations)\n   287\t        # ForeignKey.\n   288\t        new_state = project_state.clone()\n   289\t        operation = migrations.CreateModel(\n   290\t            \"Rider\",\n   291\t            [\n   292\t                (\"id\", models.AutoField(primary_key=True)),\n   293\t                (\"pony\", models.ForeignKey(\"Pony\", models.CASCADE)),\n   294\t            ],\n   295\t        )\n   296\t        operation.state_forwards(app_label, new_state)\n   297\t        with connection.schema_editor() as editor:\n   298\t            operation.database_forwards(app_label, editor, project_state, new_state)\n   299\t        self.assertColumnCollation(f\"{app_label}_rider\", \"pony_id\", collation)\n   300\t        # Reversal.\n   301\t        with connection.schema_editor() as editor:\n   302\t            operation.database_backwards(app_label, editor, new_state, project_state)\n   303\t        # OneToOneField.\n   304\t        new_state = project_state.clone()\n   305\t        operation = migrations.CreateModel(\n   306\t            \"ShetlandPony\",\n   307\t            [\n   308\t                (\n   309\t                    \"pony\",\n   310\t                    models.OneToOneField(\"Pony\", models.CASCADE, primary_key=True),\n   311\t                ),\n   312\t                (\"cuteness\", models.IntegerField(default=1)),\n   313\t            ],\n   314\t        )\n   315\t        operation.state_forwards(app_label, new_state)\n   316\t        with connection.schema_editor() as editor:\n   317\t            operation.database_forwards(app_label, editor, project_state, new_state)\n   318\t        self.assertColumnCollation(f\"{app_label}_shetlandpony\", \"pony_id\", collation)\n   319\t        # Reversal.\n   320\t        with connection.schema_editor() as editor:\n   321\t            operation.database_backwards(app_label, editor, new_state, project_state)\n   322\t\n   323\t    def test_create_model_inheritance(self):\n   324\t        \"\"\"\n   325\t        Tests the CreateModel operation on a multi-table inheritance setup.\n   326\t        \"\"\"\n   327\t        project_state = self.set_up_test_model(\"test_crmoih\")\n   328\t        # Test the state alteration\n   329\t        operation = migrations.CreateModel(\n   330\t            \"ShetlandPony\",\n   331\t            [\n   332\t                (\n   333\t                    \"pony_ptr\",\n   334\t                    models.OneToOneField(\n   335\t                        \"test_crmoih.Pony\",\n   336\t                        models.CASCADE,\n   337\t                        auto_created=True,\n   338\t                        primary_key=True,\n   339\t                        to_field=\"id\",\n   340\t                        serialize=False,\n   341\t                    ),\n   342\t                ),\n   343\t                (\"cuteness\", models.IntegerField(default=1)),\n   344\t            ],\n   345\t        )\n   346\t        new_state = project_state.clone()\n   347\t        operation.state_forwards(\"test_crmoih\", new_state)\n   348\t        self.assertIn((\"test_crmoih\", \"shetlandpony\"), new_state.models)\n   349\t        # Test the database alteration\n   350\t        self.assertTableNotExists(\"test_crmoih_shetlandpony\")\n   351\t        with connection.schema_editor() as editor:\n   352\t            operation.database_forwards(\"test_crmoih\", editor, project_state, new_state)\n   353\t        self.assertTableExists(\"test_crmoih_shetlandpony\")\n   354\t        # And test reversal\n   355\t        with connection.schema_editor() as editor:\n   356\t            operation.database_backwards(\n   357\t                \"test_crmoih\", editor, new_state, project_state\n   358\t            )\n   359\t        self.assertTableNotExists(\"test_crmoih_shetlandpony\")\n   360\t\n   361\t    def test_create_proxy_model(self):\n   362\t        \"\"\"\n   363\t        CreateModel ignores proxy models.\n   364\t        \"\"\"\n   365\t        project_state = self.set_up_test_model(\"test_crprmo\")\n   366\t        # Test the state alteration\n   367\t        operation = migrations.CreateModel(\n   368\t            \"ProxyPony\",\n   369\t            [],\n   370\t            options={\"proxy\": True},\n   371\t            bases=(\"test_crprmo.Pony\",),\n   372\t        )\n   373\t        self.assertEqual(operation.describe(), \"Create proxy model ProxyPony\")\n   374\t        new_state = project_state.clone()\n   375\t        operation.state_forwards(\"test_crprmo\", new_state)\n   376\t        self.assertIn((\"test_crprmo\", \"proxypony\"), new_state.models)\n   377\t        # Test the database alteration\n   378\t        self.assertTableNotExists(\"test_crprmo_proxypony\")\n   379\t        self.assertTableExists(\"test_crprmo_pony\")\n   380\t        with connection.schema_editor() as editor:\n   381\t            operation.database_forwards(\"test_crprmo\", editor, project_state, new_state)\n   382\t        self.assertTableNotExists(\"test_crprmo_proxypony\")\n   383\t        self.assertTableExists(\"test_crprmo_pony\")\n   384\t        # And test reversal\n   385\t        with connection.schema_editor() as editor:\n   386\t            operation.database_backwards(\n   387\t                \"test_crprmo\", editor, new_state, project_state\n   388\t            )\n   389\t        self.assertTableNotExists(\"test_crprmo_proxypony\")\n   390\t        self.assertTableExists(\"test_crprmo_pony\")\n   391\t        # And deconstruction\n   392\t        definition = operation.deconstruct()\n   393\t        self.assertEqual(definition[0], \"CreateModel\")\n   394\t        self.assertEqual(definition[1], [])\n   395\t        self.assertEqual(sorted(definition[2]), [\"bases\", \"fields\", \"name\", \"options\"])\n   396\t\n   397\t    def test_create_unmanaged_model(self):\n   398\t        \"\"\"\n   399\t        CreateModel ignores unmanaged models.\n   400\t        \"\"\"\n   401\t        project_state = self.set_up_test_model(\"test_crummo\")\n   402\t        # Test the state alteration\n   403\t        operation = migrations.CreateModel(\n   404\t            \"UnmanagedPony\",\n   405\t            [],\n   406\t            options={\"proxy\": True},\n   407\t            bases=(\"test_crummo.Pony\",),\n   408\t        )\n   409\t        self.assertEqual(operation.describe(), \"Create proxy model UnmanagedPony\")\n   410\t        new_state = project_state.clone()\n   411\t        operation.state_forwards(\"test_crummo\", new_state)\n   412\t        self.assertIn((\"test_crummo\", \"unmanagedpony\"), new_state.models)\n   413\t        # Test the database alteration\n   414\t        self.assertTableNotExists(\"test_crummo_unmanagedpony\")\n   415\t        self.assertTableExists(\"test_crummo_pony\")\n   416\t        with connection.schema_editor() as editor:\n   417\t            operation.database_forwards(\"test_crummo\", editor, project_state, new_state)\n   418\t        self.assertTableNotExists(\"test_crummo_unmanagedpony\")\n   419\t        self.assertTableExists(\"test_crummo_pony\")\n   420\t        # And test reversal\n   421\t        with connection.schema_editor() as editor:\n   422\t            operation.database_backwards(\n   423\t                \"test_crummo\", editor, new_state, project_state\n   424\t            )\n   425\t        self.assertTableNotExists(\"test_crummo_unmanagedpony\")\n   426\t        self.assertTableExists(\"test_crummo_pony\")\n   427\t\n   428\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n   429\t    def test_create_model_with_constraint(self):\n   430\t        where = models.Q(pink__gt=2)\n   431\t        check_constraint = models.CheckConstraint(\n   432\t            check=where, name=\"test_constraint_pony_pink_gt_2\"\n   433\t        )\n   434\t        operation = migrations.CreateModel(\n   435\t            \"Pony\",\n   436\t            [\n   437\t                (\"id\", models.AutoField(primary_key=True)),\n   438\t                (\"pink\", models.IntegerField(default=3)),\n   439\t            ],\n   440\t            options={\"constraints\": [check_constraint]},\n   441\t        )\n   442\t\n   443\t        # Test the state alteration\n   444\t        project_state = ProjectState()\n   445\t        new_state = project_state.clone()\n   446\t        operation.state_forwards(\"test_crmo\", new_state)\n   447\t        self.assertEqual(\n   448\t            len(new_state.models[\"test_crmo\", \"pony\"].options[\"constraints\"]), 1\n   449\t        )\n   450\t\n   451\t        # Test database alteration\n   452\t        self.assertTableNotExists(\"test_crmo_pony\")\n   453\t        with connection.schema_editor() as editor:\n   454\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n   455\t        self.assertTableExists(\"test_crmo_pony\")\n   456\t        with connection.cursor() as cursor:\n   457\t            with self.assertRaises(IntegrityError):\n   458\t                cursor.execute(\"INSERT INTO test_crmo_pony (id, pink) VALUES (1, 1)\")\n   459\t\n   460\t        # Test reversal\n   461\t        with connection.schema_editor() as editor:\n   462\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n   463\t        self.assertTableNotExists(\"test_crmo_pony\")\n   464\t\n   465\t        # Test deconstruction\n   466\t        definition = operation.deconstruct()\n   467\t        self.assertEqual(definition[0], \"CreateModel\")\n   468\t        self.assertEqual(definition[1], [])\n   469\t        self.assertEqual(definition[2][\"options\"][\"constraints\"], [check_constraint])\n   470\t\n   471\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n   472\t    def test_create_model_with_boolean_expression_in_check_constraint(self):\n   473\t        app_label = \"test_crmobechc\"\n   474\t        rawsql_constraint = models.CheckConstraint(\n   475\t            check=models.expressions.RawSQL(\n   476\t                \"price < %s\", (1000,), output_field=models.BooleanField()\n   477\t            ),\n   478\t            name=f\"{app_label}_price_lt_1000_raw\",\n   479\t        )\n   480\t        wrapper_constraint = models.CheckConstraint(\n   481\t            check=models.expressions.ExpressionWrapper(\n   482\t                models.Q(price__gt=500) | models.Q(price__lt=500),\n   483\t                output_field=models.BooleanField(),\n   484\t            ),\n   485\t            name=f\"{app_label}_price_neq_500_wrap\",\n   486\t        )\n   487\t        operation = migrations.CreateModel(\n   488\t            \"Product\",\n   489\t            [\n   490\t                (\"id\", models.AutoField(primary_key=True)),\n   491\t                (\"price\", models.IntegerField(null=True)),\n   492\t            ],\n   493\t            options={\"constraints\": [rawsql_constraint, wrapper_constraint]},\n   494\t        )\n   495\t\n   496\t        project_state = ProjectState()\n   497\t        new_state = project_state.clone()\n   498\t        operation.state_forwards(app_label, new_state)\n   499\t        # Add table.\n   500\t        self.assertTableNotExists(app_label)\n   501\t        with connection.schema_editor() as editor:\n   502\t            operation.database_forwards(app_label, editor, project_state, new_state)\n   503\t        self.assertTableExists(f\"{app_label}_product\")\n   504\t        insert_sql = f\"INSERT INTO {app_label}_product (id, price) VALUES (%d, %d)\"\n   505\t        with connection.cursor() as cursor:\n   506\t            with self.assertRaises(IntegrityError):\n   507\t                cursor.execute(insert_sql % (1, 1000))\n   508\t            cursor.execute(insert_sql % (1, 999))\n   509\t            with self.assertRaises(IntegrityError):\n   510\t                cursor.execute(insert_sql % (2, 500))\n   511\t            cursor.execute(insert_sql % (2, 499))\n   512\t\n   513\t    def test_create_model_with_partial_unique_constraint(self):\n   514\t        partial_unique_constraint = models.UniqueConstraint(\n   515\t            fields=[\"pink\"],\n   516\t            condition=models.Q(weight__gt=5),\n   517\t            name=\"test_constraint_pony_pink_for_weight_gt_5_uniq\",\n   518\t        )\n   519\t        operation = migrations.CreateModel(\n   520\t            \"Pony\",\n   521\t            [\n   522\t                (\"id\", models.AutoField(primary_key=True)),\n   523\t                (\"pink\", models.IntegerField(default=3)),\n   524\t                (\"weight\", models.FloatField()),\n   525\t            ],\n   526\t            options={\"constraints\": [partial_unique_constraint]},\n   527\t        )\n   528\t        # Test the state alteration\n   529\t        project_state = ProjectState()\n   530\t        new_state = project_state.clone()\n   531\t        operation.state_forwards(\"test_crmo\", new_state)\n   532\t        self.assertEqual(\n   533\t            len(new_state.models[\"test_crmo\", \"pony\"].options[\"constraints\"]), 1\n   534\t        )\n   535\t        # Test database alteration\n   536\t        self.assertTableNotExists(\"test_crmo_pony\")\n   537\t        with connection.schema_editor() as editor:\n   538\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n   539\t        self.assertTableExists(\"test_crmo_pony\")\n   540\t        # Test constraint works\n   541\t        Pony = new_state.apps.get_model(\"test_crmo\", \"Pony\")\n   542\t        Pony.objects.create(pink=1, weight=4.0)\n   543\t        Pony.objects.create(pink=1, weight=4.0)\n   544\t        Pony.objects.create(pink=1, weight=6.0)\n   545\t        if connection.features.supports_partial_indexes:\n   546\t            with self.assertRaises(IntegrityError):\n   547\t                Pony.objects.create(pink=1, weight=7.0)\n   548\t        else:\n   549\t            Pony.objects.create(pink=1, weight=7.0)\n   550\t        # Test reversal\n   551\t        with connection.schema_editor() as editor:\n   552\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n   553\t        self.assertTableNotExists(\"test_crmo_pony\")\n   554\t        # Test deconstruction\n   555\t        definition = operation.deconstruct()\n   556\t        self.assertEqual(definition[0], \"CreateModel\")\n   557\t        self.assertEqual(definition[1], [])\n   558\t        self.assertEqual(\n   559\t            definition[2][\"options\"][\"constraints\"], [partial_unique_constraint]\n   560\t        )\n   561\t\n   562\t    def test_create_model_with_deferred_unique_constraint(self):\n   563\t        deferred_unique_constraint = models.UniqueConstraint(\n   564\t            fields=[\"pink\"],\n   565\t            name=\"deferrable_pink_constraint\",\n   566\t            deferrable=models.Deferrable.DEFERRED,\n   567\t        )\n   568\t        operation = migrations.CreateModel(\n   569\t            \"Pony\",\n   570\t            [\n   571\t                (\"id\", models.AutoField(primary_key=True)),\n   572\t                (\"pink\", models.IntegerField(default=3)),\n   573\t            ],\n   574\t            options={\"constraints\": [deferred_unique_constraint]},\n   575\t        )\n   576\t        project_state = ProjectState()\n   577\t        new_state = project_state.clone()\n   578\t        operation.state_forwards(\"test_crmo\", new_state)\n   579\t        self.assertEqual(\n   580\t            len(new_state.models[\"test_crmo\", \"pony\"].options[\"constraints\"]), 1\n   581\t        )\n   582\t        self.assertTableNotExists(\"test_crmo_pony\")\n   583\t        # Create table.\n   584\t        with connection.schema_editor() as editor:\n   585\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n   586\t        self.assertTableExists(\"test_crmo_pony\")\n   587\t        Pony = new_state.apps.get_model(\"test_crmo\", \"Pony\")\n   588\t        Pony.objects.create(pink=1)\n   589\t        if connection.features.supports_deferrable_unique_constraints:\n   590\t            # Unique constraint is deferred.\n   591\t            with transaction.atomic():\n   592\t                obj = Pony.objects.create(pink=1)\n   593\t                obj.pink = 2\n   594\t                obj.save()\n   595\t            # Constraint behavior can be changed with SET CONSTRAINTS.\n   596\t            with self.assertRaises(IntegrityError):\n   597\t                with transaction.atomic(), connection.cursor() as cursor:\n   598\t                    quoted_name = connection.ops.quote_name(\n   599\t                        deferred_unique_constraint.name\n   600\t                    )\n   601\t                    cursor.execute(\"SET CONSTRAINTS %s IMMEDIATE\" % quoted_name)\n   602\t                    obj = Pony.objects.create(pink=1)\n   603\t                    obj.pink = 3\n   604\t                    obj.save()\n   605\t        else:\n   606\t            Pony.objects.create(pink=1)\n   607\t        # Reversal.\n   608\t        with connection.schema_editor() as editor:\n   609\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n   610\t        self.assertTableNotExists(\"test_crmo_pony\")\n   611\t        # Deconstruction.\n   612\t        definition = operation.deconstruct()\n   613\t        self.assertEqual(definition[0], \"CreateModel\")\n   614\t        self.assertEqual(definition[1], [])\n   615\t        self.assertEqual(\n   616\t            definition[2][\"options\"][\"constraints\"],\n   617\t            [deferred_unique_constraint],\n   618\t        )\n   619\t\n   620\t    @skipUnlessDBFeature(\"supports_covering_indexes\")\n   621\t    def test_create_model_with_covering_unique_constraint(self):\n   622\t        covering_unique_constraint = models.UniqueConstraint(\n   623\t            fields=[\"pink\"],\n   624\t            include=[\"weight\"],\n   625\t            name=\"test_constraint_pony_pink_covering_weight\",\n   626\t        )\n   627\t        operation = migrations.CreateModel(\n   628\t            \"Pony\",\n   629\t            [\n   630\t                (\"id\", models.AutoField(primary_key=True)),\n   631\t                (\"pink\", models.IntegerField(default=3)),\n   632\t                (\"weight\", models.FloatField()),\n   633\t            ],\n   634\t            options={\"constraints\": [covering_unique_constraint]},\n   635\t        )\n   636\t        project_state = ProjectState()\n   637\t        new_state = project_state.clone()\n   638\t        operation.state_forwards(\"test_crmo\", new_state)\n   639\t        self.assertEqual(\n   640\t            len(new_state.models[\"test_crmo\", \"pony\"].options[\"constraints\"]), 1\n   641\t        )\n   642\t        self.assertTableNotExists(\"test_crmo_pony\")\n   643\t        # Create table.\n   644\t        with connection.schema_editor() as editor:\n   645\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n   646\t        self.assertTableExists(\"test_crmo_pony\")\n   647\t        Pony = new_state.apps.get_model(\"test_crmo\", \"Pony\")\n   648\t        Pony.objects.create(pink=1, weight=4.0)\n   649\t        with self.assertRaises(IntegrityError):\n   650\t            Pony.objects.create(pink=1, weight=7.0)\n   651\t        # Reversal.\n   652\t        with connection.schema_editor() as editor:\n   653\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n   654\t        self.assertTableNotExists(\"test_crmo_pony\")\n   655\t        # Deconstruction.\n   656\t        definition = operation.deconstruct()\n   657\t        self.assertEqual(definition[0], \"CreateModel\")\n   658\t        self.assertEqual(definition[1], [])\n   659\t        self.assertEqual(\n   660\t            definition[2][\"options\"][\"constraints\"],\n   661\t            [covering_unique_constraint],\n   662\t        )\n   663\t\n   664\t    def test_create_model_managers(self):\n   665\t        \"\"\"\n   666\t        The managers on a model are set.\n   667\t        \"\"\"\n   668\t        project_state = self.set_up_test_model(\"test_cmoma\")\n   669\t        # Test the state alteration\n   670\t        operation = migrations.CreateModel(\n   671\t            \"Food\",\n   672\t            fields=[\n   673\t                (\"id\", models.AutoField(primary_key=True)),\n   674\t            ],\n   675\t            managers=[\n   676\t                (\"food_qs\", FoodQuerySet.as_manager()),\n   677\t                (\"food_mgr\", FoodManager(\"a\", \"b\")),\n   678\t                (\"food_mgr_kwargs\", FoodManager(\"x\", \"y\", 3, 4)),\n   679\t            ],\n   680\t        )\n   681\t        self.assertEqual(operation.describe(), \"Create model Food\")\n   682\t        new_state = project_state.clone()\n   683\t        operation.state_forwards(\"test_cmoma\", new_state)\n   684\t        self.assertIn((\"test_cmoma\", \"food\"), new_state.models)\n   685\t        managers = new_state.models[\"test_cmoma\", \"food\"].managers\n   686\t        self.assertEqual(managers[0][0], \"food_qs\")\n   687\t        self.assertIsInstance(managers[0][1], models.Manager)\n   688\t        self.assertEqual(managers[1][0], \"food_mgr\")\n   689\t        self.assertIsInstance(managers[1][1], FoodManager)\n   690\t        self.assertEqual(managers[1][1].args, (\"a\", \"b\", 1, 2))\n   691\t        self.assertEqual(managers[2][0], \"food_mgr_kwargs\")\n   692\t        self.assertIsInstance(managers[2][1], FoodManager)\n   693\t        self.assertEqual(managers[2][1].args, (\"x\", \"y\", 3, 4))\n   694\t\n   695\t    def test_delete_model(self):\n   696\t        \"\"\"\n   697\t        Tests the DeleteModel operation.\n   698\t        \"\"\"\n   699\t        project_state = self.set_up_test_model(\"test_dlmo\")\n   700\t        # Test the state alteration\n   701\t        operation = migrations.DeleteModel(\"Pony\")\n   702\t        self.assertEqual(operation.describe(), \"Delete model Pony\")\n   703\t        self.assertEqual(operation.migration_name_fragment, \"delete_pony\")\n   704\t        new_state = project_state.clone()\n   705\t        operation.state_forwards(\"test_dlmo\", new_state)\n   706\t        self.assertNotIn((\"test_dlmo\", \"pony\"), new_state.models)\n   707\t        # Test the database alteration\n   708\t        self.assertTableExists(\"test_dlmo_pony\")\n   709\t        with connection.schema_editor() as editor:\n   710\t            operation.database_forwards(\"test_dlmo\", editor, project_state, new_state)\n   711\t        self.assertTableNotExists(\"test_dlmo_pony\")\n   712\t        # And test reversal\n   713\t        with connection.schema_editor() as editor:\n   714\t            operation.database_backwards(\"test_dlmo\", editor, new_state, project_state)\n   715\t        self.assertTableExists(\"test_dlmo_pony\")\n   716\t        # And deconstruction\n   717\t        definition = operation.deconstruct()\n   718\t        self.assertEqual(definition[0], \"DeleteModel\")\n   719\t        self.assertEqual(definition[1], [])\n   720\t        self.assertEqual(list(definition[2]), [\"name\"])\n   721\t\n   722\t    def test_delete_proxy_model(self):\n   723\t        \"\"\"\n   724\t        Tests the DeleteModel operation ignores proxy models.\n   725\t        \"\"\"\n   726\t        project_state = self.set_up_test_model(\"test_dlprmo\", proxy_model=True)\n   727\t        # Test the state alteration\n   728\t        operation = migrations.DeleteModel(\"ProxyPony\")\n   729\t        new_state = project_state.clone()\n   730\t        operation.state_forwards(\"test_dlprmo\", new_state)\n   731\t        self.assertIn((\"test_dlprmo\", \"proxypony\"), project_state.models)\n   732\t        self.assertNotIn((\"test_dlprmo\", \"proxypony\"), new_state.models)\n   733\t        # Test the database alteration\n   734\t        self.assertTableExists(\"test_dlprmo_pony\")\n   735\t        self.assertTableNotExists(\"test_dlprmo_proxypony\")\n   736\t        with connection.schema_editor() as editor:\n   737\t            operation.database_forwards(\"test_dlprmo\", editor, project_state, new_state)\n   738\t        self.assertTableExists(\"test_dlprmo_pony\")\n   739\t        self.assertTableNotExists(\"test_dlprmo_proxypony\")\n   740\t        # And test reversal\n   741\t        with connection.schema_editor() as editor:\n   742\t            operation.database_backwards(\n   743\t                \"test_dlprmo\", editor, new_state, project_state\n   744\t            )\n   745\t        self.assertTableExists(\"test_dlprmo_pony\")\n   746\t        self.assertTableNotExists(\"test_dlprmo_proxypony\")\n   747\t\n   748\t    def test_delete_mti_model(self):\n   749\t        project_state = self.set_up_test_model(\"test_dlmtimo\", mti_model=True)\n   750\t        # Test the state alteration\n   751\t        operation = migrations.DeleteModel(\"ShetlandPony\")\n   752\t        new_state = project_state.clone()\n   753\t        operation.state_forwards(\"test_dlmtimo\", new_state)\n   754\t        self.assertIn((\"test_dlmtimo\", \"shetlandpony\"), project_state.models)\n   755\t        self.assertNotIn((\"test_dlmtimo\", \"shetlandpony\"), new_state.models)\n   756\t        # Test the database alteration\n   757\t        self.assertTableExists(\"test_dlmtimo_pony\")\n   758\t        self.assertTableExists(\"test_dlmtimo_shetlandpony\")\n   759\t        self.assertColumnExists(\"test_dlmtimo_shetlandpony\", \"pony_ptr_id\")\n   760\t        with connection.schema_editor() as editor:\n   761\t            operation.database_forwards(\n   762\t                \"test_dlmtimo\", editor, project_state, new_state\n   763\t            )\n   764\t        self.assertTableExists(\"test_dlmtimo_pony\")\n   765\t        self.assertTableNotExists(\"test_dlmtimo_shetlandpony\")\n   766\t        # And test reversal\n   767\t        with connection.schema_editor() as editor:\n   768\t            operation.database_backwards(\n   769\t                \"test_dlmtimo\", editor, new_state, project_state\n   770\t            )\n   771\t        self.assertTableExists(\"test_dlmtimo_pony\")\n   772\t        self.assertTableExists(\"test_dlmtimo_shetlandpony\")\n   773\t        self.assertColumnExists(\"test_dlmtimo_shetlandpony\", \"pony_ptr_id\")\n   774\t\n   775\t    def test_rename_model(self):\n   776\t        \"\"\"\n   777\t        Tests the RenameModel operation.\n   778\t        \"\"\"\n   779\t        project_state = self.set_up_test_model(\"test_rnmo\", related_model=True)\n   780\t        # Test the state alteration\n   781\t        operation = migrations.RenameModel(\"Pony\", \"Horse\")\n   782\t        self.assertEqual(operation.describe(), \"Rename model Pony to Horse\")\n   783\t        self.assertEqual(operation.migration_name_fragment, \"rename_pony_horse\")\n   784\t        # Test initial state and database\n   785\t        self.assertIn((\"test_rnmo\", \"pony\"), project_state.models)\n   786\t        self.assertNotIn((\"test_rnmo\", \"horse\"), project_state.models)\n   787\t        self.assertTableExists(\"test_rnmo_pony\")\n   788\t        self.assertTableNotExists(\"test_rnmo_horse\")\n   789\t        if connection.features.supports_foreign_keys:\n   790\t            self.assertFKExists(\n   791\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_pony\", \"id\")\n   792\t            )\n   793\t            self.assertFKNotExists(\n   794\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_horse\", \"id\")\n   795\t            )\n   796\t        # Migrate forwards\n   797\t        new_state = project_state.clone()\n   798\t        atomic_rename = connection.features.supports_atomic_references_rename\n   799\t        new_state = self.apply_operations(\n   800\t            \"test_rnmo\", new_state, [operation], atomic=atomic_rename\n   801\t        )\n   802\t        # Test new state and database\n   803\t        self.assertNotIn((\"test_rnmo\", \"pony\"), new_state.models)\n   804\t        self.assertIn((\"test_rnmo\", \"horse\"), new_state.models)\n   805\t        # RenameModel also repoints all incoming FKs and M2Ms\n   806\t        self.assertEqual(\n   807\t            new_state.models[\"test_rnmo\", \"rider\"].fields[\"pony\"].remote_field.model,\n   808\t            \"test_rnmo.Horse\",\n   809\t        )\n   810\t        self.assertTableNotExists(\"test_rnmo_pony\")\n   811\t        self.assertTableExists(\"test_rnmo_horse\")\n   812\t        if connection.features.supports_foreign_keys:\n   813\t            self.assertFKNotExists(\n   814\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_pony\", \"id\")\n   815\t            )\n   816\t            self.assertFKExists(\n   817\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_horse\", \"id\")\n   818\t            )\n   819\t        # Migrate backwards\n   820\t        original_state = self.unapply_operations(\n   821\t            \"test_rnmo\", project_state, [operation], atomic=atomic_rename\n   822\t        )\n   823\t        # Test original state and database\n   824\t        self.assertIn((\"test_rnmo\", \"pony\"), original_state.models)\n   825\t        self.assertNotIn((\"test_rnmo\", \"horse\"), original_state.models)\n   826\t        self.assertEqual(\n   827\t            original_state.models[\"test_rnmo\", \"rider\"]\n   828\t            .fields[\"pony\"]\n   829\t            .remote_field.model,\n   830\t            \"Pony\",\n   831\t        )\n   832\t        self.assertTableExists(\"test_rnmo_pony\")\n   833\t        self.assertTableNotExists(\"test_rnmo_horse\")\n   834\t        if connection.features.supports_foreign_keys:\n   835\t            self.assertFKExists(\n   836\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_pony\", \"id\")\n   837\t            )\n   838\t            self.assertFKNotExists(\n   839\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_horse\", \"id\")\n   840\t            )\n   841\t        # And deconstruction\n   842\t        definition = operation.deconstruct()\n   843\t        self.assertEqual(definition[0], \"RenameModel\")\n   844\t        self.assertEqual(definition[1], [])\n   845\t        self.assertEqual(definition[2], {\"old_name\": \"Pony\", \"new_name\": \"Horse\"})\n   846\t\n   847\t    def test_rename_model_state_forwards(self):\n   848\t        \"\"\"\n   849\t        RenameModel operations shouldn't trigger the caching of rendered apps\n   850\t        on state without prior apps.\n   851\t        \"\"\"\n   852\t        state = ProjectState()\n   853\t        state.add_model(ModelState(\"migrations\", \"Foo\", []))\n   854\t        operation = migrations.RenameModel(\"Foo\", \"Bar\")\n   855\t        operation.state_forwards(\"migrations\", state)\n   856\t        self.assertNotIn(\"apps\", state.__dict__)\n   857\t        self.assertNotIn((\"migrations\", \"foo\"), state.models)\n   858\t        self.assertIn((\"migrations\", \"bar\"), state.models)\n   859\t        # Now with apps cached.\n   860\t        apps = state.apps\n   861\t        operation = migrations.RenameModel(\"Bar\", \"Foo\")\n   862\t        operation.state_forwards(\"migrations\", state)\n   863\t        self.assertIs(state.apps, apps)\n   864\t        self.assertNotIn((\"migrations\", \"bar\"), state.models)\n   865\t        self.assertIn((\"migrations\", \"foo\"), state.models)\n   866\t\n   867\t    def test_rename_model_with_self_referential_fk(self):\n   868\t        \"\"\"\n   869\t        Tests the RenameModel operation on model with self referential FK.\n   870\t        \"\"\"\n   871\t        project_state = self.set_up_test_model(\"test_rmwsrf\", related_model=True)\n   872\t        # Test the state alteration\n   873\t        operation = migrations.RenameModel(\"Rider\", \"HorseRider\")\n   874\t        self.assertEqual(operation.describe(), \"Rename model Rider to HorseRider\")\n   875\t        new_state = project_state.clone()\n   876\t        operation.state_forwards(\"test_rmwsrf\", new_state)\n   877\t        self.assertNotIn((\"test_rmwsrf\", \"rider\"), new_state.models)\n   878\t        self.assertIn((\"test_rmwsrf\", \"horserider\"), new_state.models)\n   879\t        # Remember, RenameModel also repoints all incoming FKs and M2Ms\n   880\t        self.assertEqual(\n   881\t            \"self\",\n   882\t            new_state.models[\"test_rmwsrf\", \"horserider\"]\n   883\t            .fields[\"friend\"]\n   884\t            .remote_field.model,\n   885\t        )\n   886\t        HorseRider = new_state.apps.get_model(\"test_rmwsrf\", \"horserider\")\n   887\t        self.assertIs(\n   888\t            HorseRider._meta.get_field(\"horserider\").remote_field.model, HorseRider\n   889\t        )\n   890\t        # Test the database alteration\n   891\t        self.assertTableExists(\"test_rmwsrf_rider\")\n   892\t        self.assertTableNotExists(\"test_rmwsrf_horserider\")\n   893\t        if connection.features.supports_foreign_keys:\n   894\t            self.assertFKExists(\n   895\t                \"test_rmwsrf_rider\", [\"friend_id\"], (\"test_rmwsrf_rider\", \"id\")\n   896\t            )\n   897\t            self.assertFKNotExists(\n   898\t                \"test_rmwsrf_rider\", [\"friend_id\"], (\"test_rmwsrf_horserider\", \"id\")\n   899\t            )\n   900\t        atomic_rename = connection.features.supports_atomic_references_rename\n   901\t        with connection.schema_editor(atomic=atomic_rename) as editor:\n   902\t            operation.database_forwards(\"test_rmwsrf\", editor, project_state, new_state)\n   903\t        self.assertTableNotExists(\"test_rmwsrf_rider\")\n   904\t        self.assertTableExists(\"test_rmwsrf_horserider\")\n   905\t        if connection.features.supports_foreign_keys:\n   906\t            self.assertFKNotExists(\n   907\t                \"test_rmwsrf_horserider\", [\"friend_id\"], (\"test_rmwsrf_rider\", \"id\")\n   908\t            )\n   909\t            self.assertFKExists(\n   910\t                \"test_rmwsrf_horserider\",\n   911\t                [\"friend_id\"],\n   912\t                (\"test_rmwsrf_horserider\", \"id\"),\n   913\t            )\n   914\t        # And test reversal\n   915\t        with connection.schema_editor(atomic=atomic_rename) as editor:\n   916\t            operation.database_backwards(\n   917\t                \"test_rmwsrf\", editor, new_state, project_state\n   918\t            )\n   919\t        self.assertTableExists(\"test_rmwsrf_rider\")\n   920\t        self.assertTableNotExists(\"test_rmwsrf_horserider\")\n   921\t        if connection.features.supports_foreign_keys:\n   922\t            self.assertFKExists(\n   923\t                \"test_rmwsrf_rider\", [\"friend_id\"], (\"test_rmwsrf_rider\", \"id\")\n   924\t            )\n   925\t            self.assertFKNotExists(\n   926\t                \"test_rmwsrf_rider\", [\"friend_id\"], (\"test_rmwsrf_horserider\", \"id\")\n   927\t            )\n   928\t\n   929\t    def test_rename_model_with_superclass_fk(self):\n   930\t        \"\"\"\n   931\t        Tests the RenameModel operation on a model which has a superclass that\n   932\t        has a foreign key.\n   933\t        \"\"\"\n   934\t        project_state = self.set_up_test_model(\n   935\t            \"test_rmwsc\", related_model=True, mti_model=True\n   936\t        )\n   937\t        # Test the state alteration\n   938\t        operation = migrations.RenameModel(\"ShetlandPony\", \"LittleHorse\")\n   939\t        self.assertEqual(\n   940\t            operation.describe(), \"Rename model ShetlandPony to LittleHorse\"\n   941\t        )\n   942\t        new_state = project_state.clone()\n   943\t        operation.state_forwards(\"test_rmwsc\", new_state)\n   944\t        self.assertNotIn((\"test_rmwsc\", \"shetlandpony\"), new_state.models)\n   945\t        self.assertIn((\"test_rmwsc\", \"littlehorse\"), new_state.models)\n   946\t        # RenameModel shouldn't repoint the superclass's relations, only local ones\n   947\t        self.assertEqual(\n   948\t            project_state.models[\"test_rmwsc\", \"rider\"]\n   949\t            .fields[\"pony\"]\n   950\t            .remote_field.model,\n   951\t            new_state.models[\"test_rmwsc\", \"rider\"].fields[\"pony\"].remote_field.model,\n   952\t        )\n   953\t        # Before running the migration we have a table for Shetland Pony, not\n   954\t        # Little Horse.\n   955\t        self.assertTableExists(\"test_rmwsc_shetlandpony\")\n   956\t        self.assertTableNotExists(\"test_rmwsc_littlehorse\")\n   957\t        if connection.features.supports_foreign_keys:\n   958\t            # and the foreign key on rider points to pony, not shetland pony\n   959\t            self.assertFKExists(\n   960\t                \"test_rmwsc_rider\", [\"pony_id\"], (\"test_rmwsc_pony\", \"id\")\n   961\t            )\n   962\t            self.assertFKNotExists(\n   963\t                \"test_rmwsc_rider\", [\"pony_id\"], (\"test_rmwsc_shetlandpony\", \"id\")\n   964\t            )\n   965\t        with connection.schema_editor(\n   966\t            atomic=connection.features.supports_atomic_references_rename\n   967\t        ) as editor:\n   968\t            operation.database_forwards(\"test_rmwsc\", editor, project_state, new_state)\n   969\t        # Now we have a little horse table, not shetland pony\n   970\t        self.assertTableNotExists(\"test_rmwsc_shetlandpony\")\n   971\t        self.assertTableExists(\"test_rmwsc_littlehorse\")\n   972\t        if connection.features.supports_foreign_keys:\n   973\t            # but the Foreign keys still point at pony, not little horse\n   974\t            self.assertFKExists(\n   975\t                \"test_rmwsc_rider\", [\"pony_id\"], (\"test_rmwsc_pony\", \"id\")\n   976\t            )\n   977\t            self.assertFKNotExists(\n   978\t                \"test_rmwsc_rider\", [\"pony_id\"], (\"test_rmwsc_littlehorse\", \"id\")\n   979\t            )\n   980\t\n   981\t    def test_rename_model_with_self_referential_m2m(self):\n   982\t        app_label = \"test_rename_model_with_self_referential_m2m\"\n   983\t\n   984\t        project_state = self.apply_operations(\n   985\t            app_label,\n   986\t            ProjectState(),\n   987\t            operations=[\n   988\t                migrations.CreateModel(\n   989\t                    \"ReflexivePony\",\n   990\t                    fields=[\n   991\t                        (\"id\", models.AutoField(primary_key=True)),\n   992\t                        (\"ponies\", models.ManyToManyField(\"self\")),\n   993\t                    ],\n   994\t                ),\n   995\t            ],\n   996\t        )\n   997\t        project_state = self.apply_operations(\n   998\t            app_label,\n   999\t            project_state,\n  1000\t            operations=[\n  1001\t                migrations.RenameModel(\"ReflexivePony\", \"ReflexivePony2\"),\n  1002\t            ],\n  1003\t            atomic=connection.features.supports_atomic_references_rename,\n  1004\t        )\n  1005\t        Pony = project_state.apps.get_model(app_label, \"ReflexivePony2\")\n  1006\t        pony = Pony.objects.create()\n  1007\t        pony.ponies.add(pony)\n  1008\t\n  1009\t    def test_rename_model_with_m2m(self):\n  1010\t        app_label = \"test_rename_model_with_m2m\"\n  1011\t        project_state = self.apply_operations(\n  1012\t            app_label,\n  1013\t            ProjectState(),\n  1014\t            operations=[\n  1015\t                migrations.CreateModel(\n  1016\t                    \"Rider\",\n  1017\t                    fields=[\n  1018\t                        (\"id\", models.AutoField(primary_key=True)),\n  1019\t                    ],\n  1020\t                ),\n  1021\t                migrations.CreateModel(\n  1022\t                    \"Pony\",\n  1023\t                    fields=[\n  1024\t                        (\"id\", models.AutoField(primary_key=True)),\n  1025\t                        (\"riders\", models.ManyToManyField(\"Rider\")),\n  1026\t                    ],\n  1027\t                ),\n  1028\t            ],\n  1029\t        )\n  1030\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1031\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1032\t        pony = Pony.objects.create()\n  1033\t        rider = Rider.objects.create()\n  1034\t        pony.riders.add(rider)\n  1035\t\n  1036\t        project_state = self.apply_operations(\n  1037\t            app_label,\n  1038\t            project_state,\n  1039\t            operations=[\n  1040\t                migrations.RenameModel(\"Pony\", \"Pony2\"),\n  1041\t            ],\n  1042\t            atomic=connection.features.supports_atomic_references_rename,\n  1043\t        )\n  1044\t        Pony = project_state.apps.get_model(app_label, \"Pony2\")\n  1045\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1046\t        pony = Pony.objects.create()\n  1047\t        rider = Rider.objects.create()\n  1048\t        pony.riders.add(rider)\n  1049\t        self.assertEqual(Pony.objects.count(), 2)\n  1050\t        self.assertEqual(Rider.objects.count(), 2)\n  1051\t        self.assertEqual(\n  1052\t            Pony._meta.get_field(\"riders\").remote_field.through.objects.count(), 2\n  1053\t        )\n  1054\t\n  1055\t    def test_rename_model_with_db_table_noop(self):\n  1056\t        app_label = \"test_rmwdbtn\"\n  1057\t        project_state = self.apply_operations(\n  1058\t            app_label,\n  1059\t            ProjectState(),\n  1060\t            operations=[\n  1061\t                migrations.CreateModel(\n  1062\t                    \"Rider\",\n  1063\t                    fields=[\n  1064\t                        (\"id\", models.AutoField(primary_key=True)),\n  1065\t                    ],\n  1066\t                    options={\"db_table\": \"rider\"},\n  1067\t                ),\n  1068\t                migrations.CreateModel(\n  1069\t                    \"Pony\",\n  1070\t                    fields=[\n  1071\t                        (\"id\", models.AutoField(primary_key=True)),\n  1072\t                        (\n  1073\t                            \"rider\",\n  1074\t                            models.ForeignKey(\"%s.Rider\" % app_label, models.CASCADE),\n  1075\t                        ),\n  1076\t                    ],\n  1077\t                ),\n  1078\t            ],\n  1079\t        )\n  1080\t        new_state = project_state.clone()\n  1081\t        operation = migrations.RenameModel(\"Rider\", \"Runner\")\n  1082\t        operation.state_forwards(app_label, new_state)\n  1083\t\n  1084\t        with connection.schema_editor() as editor:\n  1085\t            with self.assertNumQueries(0):\n  1086\t                operation.database_forwards(app_label, editor, project_state, new_state)\n  1087\t        with connection.schema_editor() as editor:\n  1088\t            with self.assertNumQueries(0):\n  1089\t                operation.database_backwards(\n  1090\t                    app_label, editor, new_state, project_state\n  1091\t                )\n  1092\t\n  1093\t    def test_rename_m2m_target_model(self):\n  1094\t        app_label = \"test_rename_m2m_target_model\"\n  1095\t        project_state = self.apply_operations(\n  1096\t            app_label,\n  1097\t            ProjectState(),\n  1098\t            operations=[\n  1099\t                migrations.CreateModel(\n  1100\t                    \"Rider\",\n  1101\t                    fields=[\n  1102\t                        (\"id\", models.AutoField(primary_key=True)),\n  1103\t                    ],\n  1104\t                ),\n  1105\t                migrations.CreateModel(\n  1106\t                    \"Pony\",\n  1107\t                    fields=[\n  1108\t                        (\"id\", models.AutoField(primary_key=True)),\n  1109\t                        (\"riders\", models.ManyToManyField(\"Rider\")),\n  1110\t                    ],\n  1111\t                ),\n  1112\t            ],\n  1113\t        )\n  1114\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1115\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1116\t        pony = Pony.objects.create()\n  1117\t        rider = Rider.objects.create()\n  1118\t        pony.riders.add(rider)\n  1119\t\n  1120\t        project_state = self.apply_operations(\n  1121\t            app_label,\n  1122\t            project_state,\n  1123\t            operations=[\n  1124\t                migrations.RenameModel(\"Rider\", \"Rider2\"),\n  1125\t            ],\n  1126\t            atomic=connection.features.supports_atomic_references_rename,\n  1127\t        )\n  1128\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1129\t        Rider = project_state.apps.get_model(app_label, \"Rider2\")\n  1130\t        pony = Pony.objects.create()\n  1131\t        rider = Rider.objects.create()\n  1132\t        pony.riders.add(rider)\n  1133\t        self.assertEqual(Pony.objects.count(), 2)\n  1134\t        self.assertEqual(Rider.objects.count(), 2)\n  1135\t        self.assertEqual(\n  1136\t            Pony._meta.get_field(\"riders\").remote_field.through.objects.count(), 2\n  1137\t        )\n  1138\t\n  1139\t    def test_rename_m2m_through_model(self):\n  1140\t        app_label = \"test_rename_through\"\n  1141\t        project_state = self.apply_operations(\n  1142\t            app_label,\n  1143\t            ProjectState(),\n  1144\t            operations=[\n  1145\t                migrations.CreateModel(\n  1146\t                    \"Rider\",\n  1147\t                    fields=[\n  1148\t                        (\"id\", models.AutoField(primary_key=True)),\n  1149\t                    ],\n  1150\t                ),\n  1151\t                migrations.CreateModel(\n  1152\t                    \"Pony\",\n  1153\t                    fields=[\n  1154\t                        (\"id\", models.AutoField(primary_key=True)),\n  1155\t                    ],\n  1156\t                ),\n  1157\t                migrations.CreateModel(\n  1158\t                    \"PonyRider\",\n  1159\t                    fields=[\n  1160\t                        (\"id\", models.AutoField(primary_key=True)),\n  1161\t                        (\n  1162\t                            \"rider\",\n  1163\t                            models.ForeignKey(\n  1164\t                                \"test_rename_through.Rider\", models.CASCADE\n  1165\t                            ),\n  1166\t                        ),\n  1167\t                        (\n  1168\t                            \"pony\",\n  1169\t                            models.ForeignKey(\n  1170\t                                \"test_rename_through.Pony\", models.CASCADE\n  1171\t                            ),\n  1172\t                        ),\n  1173\t                    ],\n  1174\t                ),\n  1175\t                migrations.AddField(\n  1176\t                    \"Pony\",\n  1177\t                    \"riders\",\n  1178\t                    models.ManyToManyField(\n  1179\t                        \"test_rename_through.Rider\",\n  1180\t                        through=\"test_rename_through.PonyRider\",\n  1181\t                    ),\n  1182\t                ),\n  1183\t            ],\n  1184\t        )\n  1185\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1186\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1187\t        PonyRider = project_state.apps.get_model(app_label, \"PonyRider\")\n  1188\t        pony = Pony.objects.create()\n  1189\t        rider = Rider.objects.create()\n  1190\t        PonyRider.objects.create(pony=pony, rider=rider)\n  1191\t\n  1192\t        project_state = self.apply_operations(\n  1193\t            app_label,\n  1194\t            project_state,\n  1195\t            operations=[\n  1196\t                migrations.RenameModel(\"PonyRider\", \"PonyRider2\"),\n  1197\t            ],\n  1198\t        )\n  1199\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1200\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1201\t        PonyRider = project_state.apps.get_model(app_label, \"PonyRider2\")\n  1202\t        pony = Pony.objects.first()\n  1203\t        rider = Rider.objects.create()\n  1204\t        PonyRider.objects.create(pony=pony, rider=rider)\n  1205\t        self.assertEqual(Pony.objects.count(), 1)\n  1206\t        self.assertEqual(Rider.objects.count(), 2)\n  1207\t        self.assertEqual(PonyRider.objects.count(), 2)\n  1208\t        self.assertEqual(pony.riders.count(), 2)\n  1209\t\n  1210\t    def test_rename_m2m_model_after_rename_field(self):\n  1211\t        \"\"\"RenameModel renames a many-to-many column after a RenameField.\"\"\"\n  1212\t        app_label = \"test_rename_multiple\"\n  1213\t        project_state = self.apply_operations(\n  1214\t            app_label,\n  1215\t            ProjectState(),\n  1216\t            operations=[\n  1217\t                migrations.CreateModel(\n  1218\t                    \"Pony\",\n  1219\t                    fields=[\n  1220\t                        (\"id\", models.AutoField(primary_key=True)),\n  1221\t                        (\"name\", models.CharField(max_length=20)),\n  1222\t                    ],\n  1223\t                ),\n  1224\t                migrations.CreateModel(\n  1225\t                    \"Rider\",\n  1226\t                    fields=[\n  1227\t                        (\"id\", models.AutoField(primary_key=True)),\n  1228\t                        (\n  1229\t                            \"pony\",\n  1230\t                            models.ForeignKey(\n  1231\t                                \"test_rename_multiple.Pony\", models.CASCADE\n  1232\t                            ),\n  1233\t                        ),\n  1234\t                    ],\n  1235\t                ),\n  1236\t                migrations.CreateModel(\n  1237\t                    \"PonyRider\",\n  1238\t                    fields=[\n  1239\t                        (\"id\", models.AutoField(primary_key=True)),\n  1240\t                        (\"riders\", models.ManyToManyField(\"Rider\")),\n  1241\t                    ],\n  1242\t                ),\n  1243\t                migrations.RenameField(\n  1244\t                    model_name=\"pony\", old_name=\"name\", new_name=\"fancy_name\"\n  1245\t                ),\n  1246\t                migrations.RenameModel(old_name=\"Rider\", new_name=\"Jockey\"),\n  1247\t            ],\n  1248\t            atomic=connection.features.supports_atomic_references_rename,\n  1249\t        )\n  1250\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1251\t        Jockey = project_state.apps.get_model(app_label, \"Jockey\")\n  1252\t        PonyRider = project_state.apps.get_model(app_label, \"PonyRider\")\n  1253\t        # No \"no such column\" error means the column was renamed correctly.\n  1254\t        pony = Pony.objects.create(fancy_name=\"a good name\")\n  1255\t        jockey = Jockey.objects.create(pony=pony)\n  1256\t        ponyrider = PonyRider.objects.create()\n  1257\t        ponyrider.riders.add(jockey)\n  1258\t\n  1259\t    def test_add_field(self):\n  1260\t        \"\"\"\n  1261\t        Tests the AddField operation.\n  1262\t        \"\"\"\n  1263\t        # Test the state alteration\n  1264\t        operation = migrations.AddField(\n  1265\t            \"Pony\",\n  1266\t            \"height\",\n  1267\t            models.FloatField(null=True, default=5),\n  1268\t        )\n  1269\t        self.assertEqual(operation.describe(), \"Add field height to Pony\")\n  1270\t        self.assertEqual(operation.migration_name_fragment, \"pony_height\")\n  1271\t        project_state, new_state = self.make_test_state(\"test_adfl\", operation)\n  1272\t        self.assertEqual(len(new_state.models[\"test_adfl\", \"pony\"].fields), 4)\n  1273\t        field = new_state.models[\"test_adfl\", \"pony\"].fields[\"height\"]\n  1274\t        self.assertEqual(field.default, 5)\n  1275\t        # Test the database alteration\n  1276\t        self.assertColumnNotExists(\"test_adfl_pony\", \"height\")\n  1277\t        with connection.schema_editor() as editor:\n  1278\t            operation.database_forwards(\"test_adfl\", editor, project_state, new_state)\n  1279\t        self.assertColumnExists(\"test_adfl_pony\", \"height\")\n  1280\t        # And test reversal\n  1281\t        with connection.schema_editor() as editor:\n  1282\t            operation.database_backwards(\"test_adfl\", editor, new_state, project_state)\n  1283\t        self.assertColumnNotExists(\"test_adfl_pony\", \"height\")\n  1284\t        # And deconstruction\n  1285\t        definition = operation.deconstruct()\n  1286\t        self.assertEqual(definition[0], \"AddField\")\n  1287\t        self.assertEqual(definition[1], [])\n  1288\t        self.assertEqual(sorted(definition[2]), [\"field\", \"model_name\", \"name\"])\n  1289\t\n  1290\t    def test_add_charfield(self):\n  1291\t        \"\"\"\n  1292\t        Tests the AddField operation on TextField.\n  1293\t        \"\"\"\n  1294\t        project_state = self.set_up_test_model(\"test_adchfl\")\n  1295\t\n  1296\t        Pony = project_state.apps.get_model(\"test_adchfl\", \"Pony\")\n  1297\t        pony = Pony.objects.create(weight=42)\n  1298\t\n  1299\t        new_state = self.apply_operations(\n  1300\t            \"test_adchfl\",\n  1301\t            project_state,\n  1302\t            [\n  1303\t                migrations.AddField(\n  1304\t                    \"Pony\",\n  1305\t                    \"text\",\n  1306\t                    models.CharField(max_length=10, default=\"some text\"),\n  1307\t                ),\n  1308\t                migrations.AddField(\n  1309\t                    \"Pony\",\n  1310\t                    \"empty\",\n  1311\t                    models.CharField(max_length=10, default=\"\"),\n  1312\t                ),\n  1313\t                # If not properly quoted digits would be interpreted as an int.\n  1314\t                migrations.AddField(\n  1315\t                    \"Pony\",\n  1316\t                    \"digits\",\n  1317\t                    models.CharField(max_length=10, default=\"42\"),\n  1318\t                ),\n  1319\t                # Manual quoting is fragile and could trip on quotes. Refs #xyz.\n  1320\t                migrations.AddField(\n  1321\t                    \"Pony\",\n  1322\t                    \"quotes\",\n  1323\t                    models.CharField(max_length=10, default='\"\\'\"'),\n  1324\t                ),\n  1325\t            ],\n  1326\t        )\n  1327\t\n  1328\t        Pony = new_state.apps.get_model(\"test_adchfl\", \"Pony\")\n  1329\t        pony = Pony.objects.get(pk=pony.pk)\n  1330\t        self.assertEqual(pony.text, \"some text\")\n  1331\t        self.assertEqual(pony.empty, \"\")\n  1332\t        self.assertEqual(pony.digits, \"42\")\n  1333\t        self.assertEqual(pony.quotes, '\"\\'\"')\n  1334\t\n  1335\t    def test_add_textfield(self):\n  1336\t        \"\"\"\n  1337\t        Tests the AddField operation on TextField.\n  1338\t        \"\"\"\n  1339\t        project_state = self.set_up_test_model(\"test_adtxtfl\")\n  1340\t\n  1341\t        Pony = project_state.apps.get_model(\"test_adtxtfl\", \"Pony\")\n  1342\t        pony = Pony.objects.create(weight=42)\n  1343\t\n  1344\t        new_state = self.apply_operations(\n  1345\t            \"test_adtxtfl\",\n  1346\t            project_state,\n  1347\t            [\n  1348\t                migrations.AddField(\n  1349\t                    \"Pony\",\n  1350\t                    \"text\",\n  1351\t                    models.TextField(default=\"some text\"),\n  1352\t                ),\n  1353\t                migrations.AddField(\n  1354\t                    \"Pony\",\n  1355\t                    \"empty\",\n  1356\t                    models.TextField(default=\"\"),\n  1357\t                ),\n  1358\t                # If not properly quoted digits would be interpreted as an int.\n  1359\t                migrations.AddField(\n  1360\t                    \"Pony\",\n  1361\t                    \"digits\",\n  1362\t                    models.TextField(default=\"42\"),\n  1363\t                ),\n  1364\t                # Manual quoting is fragile and could trip on quotes. Refs #xyz.\n  1365\t                migrations.AddField(\n  1366\t                    \"Pony\",\n  1367\t                    \"quotes\",\n  1368\t                    models.TextField(default='\"\\'\"'),\n  1369\t                ),\n  1370\t            ],\n  1371\t        )\n  1372\t\n  1373\t        Pony = new_state.apps.get_model(\"test_adtxtfl\", \"Pony\")\n  1374\t        pony = Pony.objects.get(pk=pony.pk)\n  1375\t        self.assertEqual(pony.text, \"some text\")\n  1376\t        self.assertEqual(pony.empty, \"\")\n  1377\t        self.assertEqual(pony.digits, \"42\")\n  1378\t        self.assertEqual(pony.quotes, '\"\\'\"')\n  1379\t\n  1380\t    def test_add_binaryfield(self):\n  1381\t        \"\"\"\n  1382\t        Tests the AddField operation on TextField/BinaryField.\n  1383\t        \"\"\"\n  1384\t        project_state = self.set_up_test_model(\"test_adbinfl\")\n  1385\t\n  1386\t        Pony = project_state.apps.get_model(\"test_adbinfl\", \"Pony\")\n  1387\t        pony = Pony.objects.create(weight=42)\n  1388\t\n  1389\t        new_state = self.apply_operations(\n  1390\t            \"test_adbinfl\",\n  1391\t            project_state,\n  1392\t            [\n  1393\t                migrations.AddField(\n  1394\t                    \"Pony\",\n  1395\t                    \"blob\",\n  1396\t                    models.BinaryField(default=b\"some text\"),\n  1397\t                ),\n  1398\t                migrations.AddField(\n  1399\t                    \"Pony\",\n  1400\t                    \"empty\",\n  1401\t                    models.BinaryField(default=b\"\"),\n  1402\t                ),\n  1403\t                # If not properly quoted digits would be interpreted as an int.\n  1404\t                migrations.AddField(\n  1405\t                    \"Pony\",\n  1406\t                    \"digits\",\n  1407\t                    models.BinaryField(default=b\"42\"),\n  1408\t                ),\n  1409\t                # Manual quoting is fragile and could trip on quotes. Refs #xyz.\n  1410\t                migrations.AddField(\n  1411\t                    \"Pony\",\n  1412\t                    \"quotes\",\n  1413\t                    models.BinaryField(default=b'\"\\'\"'),\n  1414\t                ),\n  1415\t            ],\n  1416\t        )\n  1417\t\n  1418\t        Pony = new_state.apps.get_model(\"test_adbinfl\", \"Pony\")\n  1419\t        pony = Pony.objects.get(pk=pony.pk)\n  1420\t        # SQLite returns buffer/memoryview, cast to bytes for checking.\n  1421\t        self.assertEqual(bytes(pony.blob), b\"some text\")\n  1422\t        self.assertEqual(bytes(pony.empty), b\"\")\n  1423\t        self.assertEqual(bytes(pony.digits), b\"42\")\n  1424\t        self.assertEqual(bytes(pony.quotes), b'\"\\'\"')\n  1425\t\n  1426\t    def test_column_name_quoting(self):\n  1427\t        \"\"\"\n  1428\t        Column names that are SQL keywords shouldn't cause problems when used\n  1429\t        in migrations (#22168).\n  1430\t        \"\"\"\n  1431\t        project_state = self.set_up_test_model(\"test_regr22168\")\n  1432\t        operation = migrations.AddField(\n  1433\t            \"Pony\",\n  1434\t            \"order\",\n  1435\t            models.IntegerField(default=0),\n  1436\t        )\n  1437\t        new_state = project_state.clone()\n  1438\t        operation.state_forwards(\"test_regr22168\", new_state)\n  1439\t        with connection.schema_editor() as editor:\n  1440\t            operation.database_forwards(\n  1441\t                \"test_regr22168\", editor, project_state, new_state\n  1442\t            )\n  1443\t        self.assertColumnExists(\"test_regr22168_pony\", \"order\")\n  1444\t\n  1445\t    def test_add_field_preserve_default(self):\n  1446\t        \"\"\"\n  1447\t        Tests the AddField operation's state alteration\n  1448\t        when preserve_default = False.\n  1449\t        \"\"\"\n  1450\t        project_state = self.set_up_test_model(\"test_adflpd\")\n  1451\t        # Test the state alteration\n  1452\t        operation = migrations.AddField(\n  1453\t            \"Pony\",\n  1454\t            \"height\",\n  1455\t            models.FloatField(null=True, default=4),\n  1456\t            preserve_default=False,\n  1457\t        )\n  1458\t        new_state = project_state.clone()\n  1459\t        operation.state_forwards(\"test_adflpd\", new_state)\n  1460\t        self.assertEqual(len(new_state.models[\"test_adflpd\", \"pony\"].fields), 4)\n  1461\t        field = new_state.models[\"test_adflpd\", \"pony\"].fields[\"height\"]\n  1462\t        self.assertEqual(field.default, models.NOT_PROVIDED)\n  1463\t        # Test the database alteration\n  1464\t        project_state.apps.get_model(\"test_adflpd\", \"pony\").objects.create(\n  1465\t            weight=4,\n  1466\t        )\n  1467\t        self.assertColumnNotExists(\"test_adflpd_pony\", \"height\")\n  1468\t        with connection.schema_editor() as editor:\n  1469\t            operation.database_forwards(\"test_adflpd\", editor, project_state, new_state)\n  1470\t        self.assertColumnExists(\"test_adflpd_pony\", \"height\")\n  1471\t        # And deconstruction\n  1472\t        definition = operation.deconstruct()\n  1473\t        self.assertEqual(definition[0], \"AddField\")\n  1474\t        self.assertEqual(definition[1], [])\n  1475\t        self.assertEqual(\n  1476\t            sorted(definition[2]), [\"field\", \"model_name\", \"name\", \"preserve_default\"]\n  1477\t        )\n  1478\t\n  1479\t    def test_add_field_m2m(self):\n  1480\t        \"\"\"\n  1481\t        Tests the AddField operation with a ManyToManyField.\n  1482\t        \"\"\"\n  1483\t        project_state = self.set_up_test_model(\"test_adflmm\", second_model=True)\n  1484\t        # Test the state alteration\n  1485\t        operation = migrations.AddField(\n  1486\t            \"Pony\", \"stables\", models.ManyToManyField(\"Stable\", related_name=\"ponies\")\n  1487\t        )\n  1488\t        new_state = project_state.clone()\n  1489\t        operation.state_forwards(\"test_adflmm\", new_state)\n  1490\t        self.assertEqual(len(new_state.models[\"test_adflmm\", \"pony\"].fields), 4)\n  1491\t        # Test the database alteration\n  1492\t        self.assertTableNotExists(\"test_adflmm_pony_stables\")\n  1493\t        with connection.schema_editor() as editor:\n  1494\t            operation.database_forwards(\"test_adflmm\", editor, project_state, new_state)\n  1495\t        self.assertTableExists(\"test_adflmm_pony_stables\")\n  1496\t        self.assertColumnNotExists(\"test_adflmm_pony\", \"stables\")\n  1497\t        # Make sure the M2M field actually works\n  1498\t        with atomic():\n  1499\t            Pony = new_state.apps.get_model(\"test_adflmm\", \"Pony\")\n  1500\t            p = Pony.objects.create(pink=False, weight=4.55)\n  1501\t            p.stables.create()\n  1502\t            self.assertEqual(p.stables.count(), 1)\n  1503\t            p.stables.all().delete()\n  1504\t        # And test reversal\n  1505\t        with connection.schema_editor() as editor:\n  1506\t            operation.database_backwards(\n  1507\t                \"test_adflmm\", editor, new_state, project_state\n  1508\t            )\n  1509\t        self.assertTableNotExists(\"test_adflmm_pony_stables\")\n  1510\t\n  1511\t    def test_alter_field_m2m(self):\n  1512\t        project_state = self.set_up_test_model(\"test_alflmm\", second_model=True)\n  1513\t\n  1514\t        project_state = self.apply_operations(\n  1515\t            \"test_alflmm\",\n  1516\t            project_state,\n  1517\t            operations=[\n  1518\t                migrations.AddField(\n  1519\t                    \"Pony\",\n  1520\t                    \"stables\",\n  1521\t                    models.ManyToManyField(\"Stable\", related_name=\"ponies\"),\n  1522\t                )\n  1523\t            ],\n  1524\t        )\n  1525\t        Pony = project_state.apps.get_model(\"test_alflmm\", \"Pony\")\n  1526\t        self.assertFalse(Pony._meta.get_field(\"stables\").blank)\n  1527\t\n  1528\t        project_state = self.apply_operations(\n  1529\t            \"test_alflmm\",\n  1530\t            project_state,\n  1531\t            operations=[\n  1532\t                migrations.AlterField(\n  1533\t                    \"Pony\",\n  1534\t                    \"stables\",\n  1535\t                    models.ManyToManyField(\n  1536\t                        to=\"Stable\", related_name=\"ponies\", blank=True\n  1537\t                    ),\n  1538\t                )\n  1539\t            ],\n  1540\t        )\n  1541\t        Pony = project_state.apps.get_model(\"test_alflmm\", \"Pony\")\n  1542\t        self.assertTrue(Pony._meta.get_field(\"stables\").blank)\n  1543\t\n  1544\t    def test_repoint_field_m2m(self):\n  1545\t        project_state = self.set_up_test_model(\n  1546\t            \"test_alflmm\", second_model=True, third_model=True\n  1547\t        )\n  1548\t\n  1549\t        project_state = self.apply_operations(\n  1550\t            \"test_alflmm\",\n  1551\t            project_state,\n  1552\t            operations=[\n  1553\t                migrations.AddField(\n  1554\t                    \"Pony\",\n  1555\t                    \"places\",\n  1556\t                    models.ManyToManyField(\"Stable\", related_name=\"ponies\"),\n  1557\t                )\n  1558\t            ],\n  1559\t        )\n  1560\t        Pony = project_state.apps.get_model(\"test_alflmm\", \"Pony\")\n  1561\t\n  1562\t        project_state = self.apply_operations(\n  1563\t            \"test_alflmm\",\n  1564\t            project_state,\n  1565\t            operations=[\n  1566\t                migrations.AlterField(\n  1567\t                    \"Pony\",\n  1568\t                    \"places\",\n  1569\t                    models.ManyToManyField(to=\"Van\", related_name=\"ponies\"),\n  1570\t                )\n  1571\t            ],\n  1572\t        )\n  1573\t\n  1574\t        # Ensure the new field actually works\n  1575\t        Pony = project_state.apps.get_model(\"test_alflmm\", \"Pony\")\n  1576\t        p = Pony.objects.create(pink=False, weight=4.55)\n  1577\t        p.places.create()\n  1578\t        self.assertEqual(p.places.count(), 1)\n  1579\t        p.places.all().delete()\n  1580\t\n  1581\t    def test_remove_field_m2m(self):\n  1582\t        project_state = self.set_up_test_model(\"test_rmflmm\", second_model=True)\n  1583\t\n  1584\t        project_state = self.apply_operations(\n  1585\t            \"test_rmflmm\",\n  1586\t            project_state,\n  1587\t            operations=[\n  1588\t                migrations.AddField(\n  1589\t                    \"Pony\",\n  1590\t                    \"stables\",\n  1591\t                    models.ManyToManyField(\"Stable\", related_name=\"ponies\"),\n  1592\t                )\n  1593\t            ],\n  1594\t        )\n  1595\t        self.assertTableExists(\"test_rmflmm_pony_stables\")\n  1596\t\n  1597\t        with_field_state = project_state.clone()\n  1598\t        operations = [migrations.RemoveField(\"Pony\", \"stables\")]\n  1599\t        project_state = self.apply_operations(\n  1600\t            \"test_rmflmm\", project_state, operations=operations\n  1601\t        )\n  1602\t        self.assertTableNotExists(\"test_rmflmm_pony_stables\")\n  1603\t\n  1604\t        # And test reversal\n  1605\t        self.unapply_operations(\"test_rmflmm\", with_field_state, operations=operations)\n  1606\t        self.assertTableExists(\"test_rmflmm_pony_stables\")\n  1607\t\n  1608\t    def test_remove_field_m2m_with_through(self):\n  1609\t        project_state = self.set_up_test_model(\"test_rmflmmwt\", second_model=True)\n  1610\t\n  1611\t        self.assertTableNotExists(\"test_rmflmmwt_ponystables\")\n  1612\t        project_state = self.apply_operations(\n  1613\t            \"test_rmflmmwt\",\n  1614\t            project_state,\n  1615\t            operations=[\n  1616\t                migrations.CreateModel(\n  1617\t                    \"PonyStables\",\n  1618\t                    fields=[\n  1619\t                        (\n  1620\t                            \"pony\",\n  1621\t                            models.ForeignKey(\"test_rmflmmwt.Pony\", models.CASCADE),\n  1622\t                        ),\n  1623\t                        (\n  1624\t                            \"stable\",\n  1625\t                            models.ForeignKey(\"test_rmflmmwt.Stable\", models.CASCADE),\n  1626\t                        ),\n  1627\t                    ],\n  1628\t                ),\n  1629\t                migrations.AddField(\n  1630\t                    \"Pony\",\n  1631\t                    \"stables\",\n  1632\t                    models.ManyToManyField(\n  1633\t                        \"Stable\",\n  1634\t                        related_name=\"ponies\",\n  1635\t                        through=\"test_rmflmmwt.PonyStables\",\n  1636\t                    ),\n  1637\t                ),\n  1638\t            ],\n  1639\t        )\n  1640\t        self.assertTableExists(\"test_rmflmmwt_ponystables\")\n  1641\t\n  1642\t        operations = [\n  1643\t            migrations.RemoveField(\"Pony\", \"stables\"),\n  1644\t            migrations.DeleteModel(\"PonyStables\"),\n  1645\t        ]\n  1646\t        self.apply_operations(\"test_rmflmmwt\", project_state, operations=operations)\n  1647\t\n  1648\t    def test_remove_field(self):\n  1649\t        \"\"\"\n  1650\t        Tests the RemoveField operation.\n  1651\t        \"\"\"\n  1652\t        project_state = self.set_up_test_model(\"test_rmfl\")\n  1653\t        # Test the state alteration\n  1654\t        operation = migrations.RemoveField(\"Pony\", \"pink\")\n  1655\t        self.assertEqual(operation.describe(), \"Remove field pink from Pony\")\n  1656\t        self.assertEqual(operation.migration_name_fragment, \"remove_pony_pink\")\n  1657\t        new_state = project_state.clone()\n  1658\t        operation.state_forwards(\"test_rmfl\", new_state)\n  1659\t        self.assertEqual(len(new_state.models[\"test_rmfl\", \"pony\"].fields), 2)\n  1660\t        # Test the database alteration\n  1661\t        self.assertColumnExists(\"test_rmfl_pony\", \"pink\")\n  1662\t        with connection.schema_editor() as editor:\n  1663\t            operation.database_forwards(\"test_rmfl\", editor, project_state, new_state)\n  1664\t        self.assertColumnNotExists(\"test_rmfl_pony\", \"pink\")\n  1665\t        # And test reversal\n  1666\t        with connection.schema_editor() as editor:\n  1667\t            operation.database_backwards(\"test_rmfl\", editor, new_state, project_state)\n  1668\t        self.assertColumnExists(\"test_rmfl_pony\", \"pink\")\n  1669\t        # And deconstruction\n  1670\t        definition = operation.deconstruct()\n  1671\t        self.assertEqual(definition[0], \"RemoveField\")\n  1672\t        self.assertEqual(definition[1], [])\n  1673\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"name\": \"pink\"})\n  1674\t\n  1675\t    def test_remove_fk(self):\n  1676\t        \"\"\"\n  1677\t        Tests the RemoveField operation on a foreign key.\n  1678\t        \"\"\"\n  1679\t        project_state = self.set_up_test_model(\"test_rfk\", related_model=True)\n  1680\t        self.assertColumnExists(\"test_rfk_rider\", \"pony_id\")\n  1681\t        operation = migrations.RemoveField(\"Rider\", \"pony\")\n  1682\t\n  1683\t        new_state = project_state.clone()\n  1684\t        operation.state_forwards(\"test_rfk\", new_state)\n  1685\t        with connection.schema_editor() as editor:\n  1686\t            operation.database_forwards(\"test_rfk\", editor, project_state, new_state)\n  1687\t        self.assertColumnNotExists(\"test_rfk_rider\", \"pony_id\")\n  1688\t        with connection.schema_editor() as editor:\n  1689\t            operation.database_backwards(\"test_rfk\", editor, new_state, project_state)\n  1690\t        self.assertColumnExists(\"test_rfk_rider\", \"pony_id\")\n  1691\t\n  1692\t    def test_alter_model_table(self):\n  1693\t        \"\"\"\n  1694\t        Tests the AlterModelTable operation.\n  1695\t        \"\"\"\n  1696\t        project_state = self.set_up_test_model(\"test_almota\")\n  1697\t        # Test the state alteration\n  1698\t        operation = migrations.AlterModelTable(\"Pony\", \"test_almota_pony_2\")\n  1699\t        self.assertEqual(\n  1700\t            operation.describe(), \"Rename table for Pony to test_almota_pony_2\"\n  1701\t        )\n  1702\t        self.assertEqual(operation.migration_name_fragment, \"alter_pony_table\")\n  1703\t        new_state = project_state.clone()\n  1704\t        operation.state_forwards(\"test_almota\", new_state)\n  1705\t        self.assertEqual(\n  1706\t            new_state.models[\"test_almota\", \"pony\"].options[\"db_table\"],\n  1707\t            \"test_almota_pony_2\",\n  1708\t        )\n  1709\t        # Test the database alteration\n  1710\t        self.assertTableExists(\"test_almota_pony\")\n  1711\t        self.assertTableNotExists(\"test_almota_pony_2\")\n  1712\t        with connection.schema_editor() as editor:\n  1713\t            operation.database_forwards(\"test_almota\", editor, project_state, new_state)\n  1714\t        self.assertTableNotExists(\"test_almota_pony\")\n  1715\t        self.assertTableExists(\"test_almota_pony_2\")\n  1716\t        # And test reversal\n  1717\t        with connection.schema_editor() as editor:\n  1718\t            operation.database_backwards(\n  1719\t                \"test_almota\", editor, new_state, project_state\n  1720\t            )\n  1721\t        self.assertTableExists(\"test_almota_pony\")\n  1722\t        self.assertTableNotExists(\"test_almota_pony_2\")\n  1723\t        # And deconstruction\n  1724\t        definition = operation.deconstruct()\n  1725\t        self.assertEqual(definition[0], \"AlterModelTable\")\n  1726\t        self.assertEqual(definition[1], [])\n  1727\t        self.assertEqual(definition[2], {\"name\": \"Pony\", \"table\": \"test_almota_pony_2\"})\n  1728\t\n  1729\t    def test_alter_model_table_none(self):\n  1730\t        \"\"\"\n  1731\t        Tests the AlterModelTable operation if the table name is set to None.\n  1732\t        \"\"\"\n  1733\t        operation = migrations.AlterModelTable(\"Pony\", None)\n  1734\t        self.assertEqual(operation.describe(), \"Rename table for Pony to (default)\")\n  1735\t\n  1736\t    def test_alter_model_table_noop(self):\n  1737\t        \"\"\"\n  1738\t        Tests the AlterModelTable operation if the table name is not changed.\n  1739\t        \"\"\"\n  1740\t        project_state = self.set_up_test_model(\"test_almota\")\n  1741\t        # Test the state alteration\n  1742\t        operation = migrations.AlterModelTable(\"Pony\", \"test_almota_pony\")\n  1743\t        new_state = project_state.clone()\n  1744\t        operation.state_forwards(\"test_almota\", new_state)\n  1745\t        self.assertEqual(\n  1746\t            new_state.models[\"test_almota\", \"pony\"].options[\"db_table\"],\n  1747\t            \"test_almota_pony\",\n  1748\t        )\n  1749\t        # Test the database alteration\n  1750\t        self.assertTableExists(\"test_almota_pony\")\n  1751\t        with connection.schema_editor() as editor:\n  1752\t            operation.database_forwards(\"test_almota\", editor, project_state, new_state)\n  1753\t        self.assertTableExists(\"test_almota_pony\")\n  1754\t        # And test reversal\n  1755\t        with connection.schema_editor() as editor:\n  1756\t            operation.database_backwards(\n  1757\t                \"test_almota\", editor, new_state, project_state\n  1758\t            )\n  1759\t        self.assertTableExists(\"test_almota_pony\")\n  1760\t\n  1761\t    def test_alter_model_table_m2m(self):\n  1762\t        \"\"\"\n  1763\t        AlterModelTable should rename auto-generated M2M tables.\n  1764\t        \"\"\"\n  1765\t        app_label = \"test_talflmltlm2m\"\n  1766\t        pony_db_table = \"pony_foo\"\n  1767\t        project_state = self.set_up_test_model(\n  1768\t            app_label, second_model=True, db_table=pony_db_table\n  1769\t        )\n  1770\t        # Add the M2M field\n  1771\t        first_state = project_state.clone()\n  1772\t        operation = migrations.AddField(\n  1773\t            \"Pony\", \"stables\", models.ManyToManyField(\"Stable\")\n  1774\t        )\n  1775\t        operation.state_forwards(app_label, first_state)\n  1776\t        with connection.schema_editor() as editor:\n  1777\t            operation.database_forwards(app_label, editor, project_state, first_state)\n  1778\t        original_m2m_table = \"%s_%s\" % (pony_db_table, \"stables\")\n  1779\t        new_m2m_table = \"%s_%s\" % (app_label, \"pony_stables\")\n  1780\t        self.assertTableExists(original_m2m_table)\n  1781\t        self.assertTableNotExists(new_m2m_table)\n  1782\t        # Rename the Pony db_table which should also rename the m2m table.\n  1783\t        second_state = first_state.clone()\n  1784\t        operation = migrations.AlterModelTable(name=\"pony\", table=None)\n  1785\t        operation.state_forwards(app_label, second_state)\n  1786\t        atomic_rename = connection.features.supports_atomic_references_rename\n  1787\t        with connection.schema_editor(atomic=atomic_rename) as editor:\n  1788\t            operation.database_forwards(app_label, editor, first_state, second_state)\n  1789\t        self.assertTableExists(new_m2m_table)\n  1790\t        self.assertTableNotExists(original_m2m_table)\n  1791\t        # And test reversal\n  1792\t        with connection.schema_editor(atomic=atomic_rename) as editor:\n  1793\t            operation.database_backwards(app_label, editor, second_state, first_state)\n  1794\t        self.assertTableExists(original_m2m_table)\n  1795\t        self.assertTableNotExists(new_m2m_table)\n  1796\t\n  1797\t    def test_alter_field(self):\n  1798\t        \"\"\"\n  1799\t        Tests the AlterField operation.\n  1800\t        \"\"\"\n  1801\t        project_state = self.set_up_test_model(\"test_alfl\")\n  1802\t        # Test the state alteration\n  1803\t        operation = migrations.AlterField(\n  1804\t            \"Pony\", \"pink\", models.IntegerField(null=True)\n  1805\t        )\n  1806\t        self.assertEqual(operation.describe(), \"Alter field pink on Pony\")\n  1807\t        self.assertEqual(operation.migration_name_fragment, \"alter_pony_pink\")\n  1808\t        new_state = project_state.clone()\n  1809\t        operation.state_forwards(\"test_alfl\", new_state)\n  1810\t        self.assertIs(\n  1811\t            project_state.models[\"test_alfl\", \"pony\"].fields[\"pink\"].null, False\n  1812\t        )\n  1813\t        self.assertIs(new_state.models[\"test_alfl\", \"pony\"].fields[\"pink\"].null, True)\n  1814\t        # Test the database alteration\n  1815\t        self.assertColumnNotNull(\"test_alfl_pony\", \"pink\")\n  1816\t        with connection.schema_editor() as editor:\n  1817\t            operation.database_forwards(\"test_alfl\", editor, project_state, new_state)\n  1818\t        self.assertColumnNull(\"test_alfl_pony\", \"pink\")\n  1819\t        # And test reversal\n  1820\t        with connection.schema_editor() as editor:\n  1821\t            operation.database_backwards(\"test_alfl\", editor, new_state, project_state)\n  1822\t        self.assertColumnNotNull(\"test_alfl_pony\", \"pink\")\n  1823\t        # And deconstruction\n  1824\t        definition = operation.deconstruct()\n  1825\t        self.assertEqual(definition[0], \"AlterField\")\n  1826\t        self.assertEqual(definition[1], [])\n  1827\t        self.assertEqual(sorted(definition[2]), [\"field\", \"model_name\", \"name\"])\n  1828\t\n  1829\t    def test_alter_field_add_db_column_noop(self):\n  1830\t        \"\"\"\n  1831\t        AlterField operation is a noop when adding only a db_column and the\n  1832\t        column name is not changed.\n  1833\t        \"\"\"\n  1834\t        app_label = \"test_afadbn\"\n  1835\t        project_state = self.set_up_test_model(app_label, related_model=True)\n  1836\t        pony_table = \"%s_pony\" % app_label\n  1837\t        new_state = project_state.clone()\n  1838\t        operation = migrations.AlterField(\n  1839\t            \"Pony\", \"weight\", models.FloatField(db_column=\"weight\")\n  1840\t        )\n  1841\t        operation.state_forwards(app_label, new_state)\n  1842\t        self.assertIsNone(\n  1843\t            project_state.models[app_label, \"pony\"].fields[\"weight\"].db_column,\n  1844\t        )\n  1845\t        self.assertEqual(\n  1846\t            new_state.models[app_label, \"pony\"].fields[\"weight\"].db_column,\n  1847\t            \"weight\",\n  1848\t        )\n  1849\t        self.assertColumnExists(pony_table, \"weight\")\n  1850\t        with connection.schema_editor() as editor:\n  1851\t            with self.assertNumQueries(0):\n  1852\t                operation.database_forwards(app_label, editor, project_state, new_state)\n  1853\t        self.assertColumnExists(pony_table, \"weight\")\n  1854\t        with connection.schema_editor() as editor:\n  1855\t            with self.assertNumQueries(0):\n  1856\t                operation.database_backwards(\n  1857\t                    app_label, editor, new_state, project_state\n  1858\t                )\n  1859\t        self.assertColumnExists(pony_table, \"weight\")\n  1860\t\n  1861\t        rider_table = \"%s_rider\" % app_label\n  1862\t        new_state = project_state.clone()\n  1863\t        operation = migrations.AlterField(\n  1864\t            \"Rider\",\n  1865\t            \"pony\",\n  1866\t            models.ForeignKey(\"Pony\", models.CASCADE, db_column=\"pony_id\"),\n  1867\t        )\n  1868\t        operation.state_forwards(app_label, new_state)\n  1869\t        self.assertIsNone(\n  1870\t            project_state.models[app_label, \"rider\"].fields[\"pony\"].db_column,\n  1871\t        )\n  1872\t        self.assertIs(\n  1873\t            new_state.models[app_label, \"rider\"].fields[\"pony\"].db_column,\n  1874\t            \"pony_id\",\n  1875\t        )\n  1876\t        self.assertColumnExists(rider_table, \"pony_id\")\n  1877\t        with connection.schema_editor() as editor:\n  1878\t            with self.assertNumQueries(0):\n  1879\t                operation.database_forwards(app_label, editor, project_state, new_state)\n  1880\t        self.assertColumnExists(rider_table, \"pony_id\")\n  1881\t        with connection.schema_editor() as editor:\n  1882\t            with self.assertNumQueries(0):\n  1883\t                operation.database_forwards(app_label, editor, new_state, project_state)\n  1884\t        self.assertColumnExists(rider_table, \"pony_id\")\n  1885\t\n  1886\t    def test_alter_field_pk(self):\n  1887\t        \"\"\"\n  1888\t        The AlterField operation on primary keys (things like PostgreSQL's\n  1889\t        SERIAL weirdness).\n  1890\t        \"\"\"\n  1891\t        project_state = self.set_up_test_model(\"test_alflpk\")\n  1892\t        # Test the state alteration\n  1893\t        operation = migrations.AlterField(\n  1894\t            \"Pony\", \"id\", models.IntegerField(primary_key=True)\n  1895\t        )\n  1896\t        new_state = project_state.clone()\n  1897\t        operation.state_forwards(\"test_alflpk\", new_state)\n  1898\t        self.assertIsInstance(\n  1899\t            project_state.models[\"test_alflpk\", \"pony\"].fields[\"id\"],\n  1900\t            models.AutoField,\n  1901\t        )\n  1902\t        self.assertIsInstance(\n  1903\t            new_state.models[\"test_alflpk\", \"pony\"].fields[\"id\"],\n  1904\t            models.IntegerField,\n  1905\t        )\n  1906\t        # Test the database alteration\n  1907\t        with connection.schema_editor() as editor:\n  1908\t            operation.database_forwards(\"test_alflpk\", editor, project_state, new_state)\n  1909\t        # And test reversal\n  1910\t        with connection.schema_editor() as editor:\n  1911\t            operation.database_backwards(\n  1912\t                \"test_alflpk\", editor, new_state, project_state\n  1913\t            )\n  1914\t\n  1915\t    @skipUnlessDBFeature(\"supports_foreign_keys\")\n  1916\t    def test_alter_field_pk_fk(self):\n  1917\t        \"\"\"\n  1918\t        Tests the AlterField operation on primary keys changes any FKs pointing to it.\n  1919\t        \"\"\"\n  1920\t        project_state = self.set_up_test_model(\"test_alflpkfk\", related_model=True)\n  1921\t        project_state = self.apply_operations(\n  1922\t            \"test_alflpkfk\",\n  1923\t            project_state,\n  1924\t            [\n  1925\t                migrations.CreateModel(\n  1926\t                    \"Stable\",\n  1927\t                    fields=[\n  1928\t                        (\"ponies\", models.ManyToManyField(\"Pony\")),\n  1929\t                    ],\n  1930\t                ),\n  1931\t                migrations.AddField(\n  1932\t                    \"Pony\",\n  1933\t                    \"stables\",\n  1934\t                    models.ManyToManyField(\"Stable\"),\n  1935\t                ),\n  1936\t            ],\n  1937\t        )\n  1938\t        # Test the state alteration\n  1939\t        operation = migrations.AlterField(\n  1940\t            \"Pony\", \"id\", models.FloatField(primary_key=True)\n  1941\t        )\n  1942\t        new_state = project_state.clone()\n  1943\t        operation.state_forwards(\"test_alflpkfk\", new_state)\n  1944\t        self.assertIsInstance(\n  1945\t            project_state.models[\"test_alflpkfk\", \"pony\"].fields[\"id\"],\n  1946\t            models.AutoField,\n  1947\t        )\n  1948\t        self.assertIsInstance(\n  1949\t            new_state.models[\"test_alflpkfk\", \"pony\"].fields[\"id\"],\n  1950\t            models.FloatField,\n  1951\t        )\n  1952\t\n  1953\t        def assertIdTypeEqualsFkType():\n  1954\t            with connection.cursor() as cursor:\n  1955\t                id_type, id_null = [\n  1956\t                    (c.type_code, c.null_ok)\n  1957\t                    for c in connection.introspection.get_table_description(\n  1958\t                        cursor, \"test_alflpkfk_pony\"\n  1959\t                    )\n  1960\t                    if c.name == \"id\"\n  1961\t                ][0]\n  1962\t                fk_type, fk_null = [\n  1963\t                    (c.type_code, c.null_ok)\n  1964\t                    for c in connection.introspection.get_table_description(\n  1965\t                        cursor, \"test_alflpkfk_rider\"\n  1966\t                    )\n  1967\t                    if c.name == \"pony_id\"\n  1968\t                ][0]\n  1969\t                m2m_fk_type, m2m_fk_null = [\n  1970\t                    (c.type_code, c.null_ok)\n  1971\t                    for c in connection.introspection.get_table_description(\n  1972\t                        cursor,\n  1973\t                        \"test_alflpkfk_pony_stables\",\n  1974\t                    )\n  1975\t                    if c.name == \"pony_id\"\n  1976\t                ][0]\n  1977\t                remote_m2m_fk_type, remote_m2m_fk_null = [\n  1978\t                    (c.type_code, c.null_ok)\n  1979\t                    for c in connection.introspection.get_table_description(\n  1980\t                        cursor,\n  1981\t                        \"test_alflpkfk_stable_ponies\",\n  1982\t                    )\n  1983\t                    if c.name == \"pony_id\"\n  1984\t                ][0]\n  1985\t            self.assertEqual(id_type, fk_type)\n  1986\t            self.assertEqual(id_type, m2m_fk_type)\n  1987\t            self.assertEqual(id_type, remote_m2m_fk_type)\n  1988\t            self.assertEqual(id_null, fk_null)\n  1989\t            self.assertEqual(id_null, m2m_fk_null)\n  1990\t            self.assertEqual(id_null, remote_m2m_fk_null)\n  1991\t\n  1992\t        assertIdTypeEqualsFkType()\n  1993\t        # Test the database alteration\n  1994\t        with connection.schema_editor() as editor:\n  1995\t            operation.database_forwards(\n  1996\t                \"test_alflpkfk\", editor, project_state, new_state\n  1997\t            )\n  1998\t        assertIdTypeEqualsFkType()\n  1999\t        if connection.features.supports_foreign_keys:\n  2000\t            self.assertFKExists(\n  2001\t                \"test_alflpkfk_pony_stables\",\n  2002\t                [\"pony_id\"],\n  2003\t                (\"test_alflpkfk_pony\", \"id\"),\n  2004\t            )\n  2005\t            self.assertFKExists(\n  2006\t                \"test_alflpkfk_stable_ponies\",\n  2007\t                [\"pony_id\"],\n  2008\t                (\"test_alflpkfk_pony\", \"id\"),\n  2009\t            )\n  2010\t        # And test reversal\n  2011\t        with connection.schema_editor() as editor:\n  2012\t            operation.database_backwards(\n  2013\t                \"test_alflpkfk\", editor, new_state, project_state\n  2014\t            )\n  2015\t        assertIdTypeEqualsFkType()\n  2016\t        if connection.features.supports_foreign_keys:\n  2017\t            self.assertFKExists(\n  2018\t                \"test_alflpkfk_pony_stables\",\n  2019\t                [\"pony_id\"],\n  2020\t                (\"test_alflpkfk_pony\", \"id\"),\n  2021\t            )\n  2022\t            self.assertFKExists(\n  2023\t                \"test_alflpkfk_stable_ponies\",\n  2024\t                [\"pony_id\"],\n  2025\t                (\"test_alflpkfk_pony\", \"id\"),\n  2026\t            )\n  2027\t\n  2028\t    @skipUnlessDBFeature(\"supports_collation_on_charfield\", \"supports_foreign_keys\")\n  2029\t    def test_alter_field_pk_fk_db_collation(self):\n  2030\t        \"\"\"\n  2031\t        AlterField operation of db_collation on primary keys changes any FKs\n  2032\t        pointing to it.\n  2033\t        \"\"\"\n  2034\t        collation = connection.features.test_collations.get(\"non_default\")\n  2035\t        if not collation:\n  2036\t            self.skipTest(\"Language collations are not supported.\")\n  2037\t\n  2038\t        app_label = \"test_alflpkfkdbc\"\n  2039\t        project_state = self.apply_operations(\n  2040\t            app_label,\n  2041\t            ProjectState(),\n  2042\t            [\n  2043\t                migrations.CreateModel(\n  2044\t                    \"Pony\",\n  2045\t                    [\n  2046\t                        (\"id\", models.CharField(primary_key=True, max_length=10)),\n  2047\t                    ],\n  2048\t                ),\n  2049\t                migrations.CreateModel(\n  2050\t                    \"Rider\",\n  2051\t                    [\n  2052\t                        (\"pony\", models.ForeignKey(\"Pony\", models.CASCADE)),\n  2053\t                    ],\n  2054\t                ),\n  2055\t                migrations.CreateModel(\n  2056\t                    \"Stable\",\n  2057\t                    [\n  2058\t                        (\"ponies\", models.ManyToManyField(\"Pony\")),\n  2059\t                    ],\n  2060\t                ),\n  2061\t            ],\n  2062\t        )\n  2063\t        # State alteration.\n  2064\t        operation = migrations.AlterField(\n  2065\t            \"Pony\",\n  2066\t            \"id\",\n  2067\t            models.CharField(\n  2068\t                primary_key=True,\n  2069\t                max_length=10,\n  2070\t                db_collation=collation,\n  2071\t            ),\n  2072\t        )\n  2073\t        new_state = project_state.clone()\n  2074\t        operation.state_forwards(app_label, new_state)\n  2075\t        # Database alteration.\n  2076\t        with connection.schema_editor() as editor:\n  2077\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2078\t        self.assertColumnCollation(f\"{app_label}_pony\", \"id\", collation)\n  2079\t        self.assertColumnCollation(f\"{app_label}_rider\", \"pony_id\", collation)\n  2080\t        self.assertColumnCollation(f\"{app_label}_stable_ponies\", \"pony_id\", collation)\n  2081\t        # Reversal.\n  2082\t        with connection.schema_editor() as editor:\n  2083\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2084\t\n  2085\t    def test_alter_field_pk_mti_fk(self):\n  2086\t        app_label = \"test_alflpkmtifk\"\n  2087\t        project_state = self.set_up_test_model(app_label, mti_model=True)\n  2088\t        project_state = self.apply_operations(\n  2089\t            app_label,\n  2090\t            project_state,\n  2091\t            [\n  2092\t                migrations.CreateModel(\n  2093\t                    \"ShetlandRider\",\n  2094\t                    fields=[\n  2095\t                        (\n  2096\t                            \"pony\",\n  2097\t                            models.ForeignKey(\n  2098\t                                f\"{app_label}.ShetlandPony\", models.CASCADE\n  2099\t                            ),\n  2100\t                        ),\n  2101\t                    ],\n  2102\t                ),\n  2103\t            ],\n  2104\t        )\n  2105\t        operation = migrations.AlterField(\n  2106\t            \"Pony\",\n  2107\t            \"id\",\n  2108\t            models.BigAutoField(primary_key=True),\n  2109\t        )\n  2110\t        new_state = project_state.clone()\n  2111\t        operation.state_forwards(app_label, new_state)\n  2112\t        self.assertIsInstance(\n  2113\t            new_state.models[app_label, \"pony\"].fields[\"id\"],\n  2114\t            models.BigAutoField,\n  2115\t        )\n  2116\t\n  2117\t        def _get_column_id_type(cursor, table, column):\n  2118\t            return [\n  2119\t                c.type_code\n  2120\t                for c in connection.introspection.get_table_description(\n  2121\t                    cursor,\n  2122\t                    f\"{app_label}_{table}\",\n  2123\t                )\n  2124\t                if c.name == column\n  2125\t            ][0]\n  2126\t\n  2127\t        def assertIdTypeEqualsMTIFkType():\n  2128\t            with connection.cursor() as cursor:\n  2129\t                parent_id_type = _get_column_id_type(cursor, \"pony\", \"id\")\n  2130\t                child_id_type = _get_column_id_type(\n  2131\t                    cursor, \"shetlandpony\", \"pony_ptr_id\"\n  2132\t                )\n  2133\t                mti_id_type = _get_column_id_type(cursor, \"shetlandrider\", \"pony_id\")\n  2134\t            self.assertEqual(parent_id_type, child_id_type)\n  2135\t            self.assertEqual(parent_id_type, mti_id_type)\n  2136\t\n  2137\t        assertIdTypeEqualsMTIFkType()\n  2138\t        # Alter primary key.\n  2139\t        with connection.schema_editor() as editor:\n  2140\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2141\t        assertIdTypeEqualsMTIFkType()\n  2142\t        if connection.features.supports_foreign_keys:\n  2143\t            self.assertFKExists(\n  2144\t                f\"{app_label}_shetlandpony\",\n  2145\t                [\"pony_ptr_id\"],\n  2146\t                (f\"{app_label}_pony\", \"id\"),\n  2147\t            )\n  2148\t            self.assertFKExists(\n  2149\t                f\"{app_label}_shetlandrider\",\n  2150\t                [\"pony_id\"],\n  2151\t                (f\"{app_label}_shetlandpony\", \"pony_ptr_id\"),\n  2152\t            )\n  2153\t        # Reversal.\n  2154\t        with connection.schema_editor() as editor:\n  2155\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2156\t        assertIdTypeEqualsMTIFkType()\n  2157\t        if connection.features.supports_foreign_keys:\n  2158\t            self.assertFKExists(\n  2159\t                f\"{app_label}_shetlandpony\",\n  2160\t                [\"pony_ptr_id\"],\n  2161\t                (f\"{app_label}_pony\", \"id\"),\n  2162\t            )\n  2163\t            self.assertFKExists(\n  2164\t                f\"{app_label}_shetlandrider\",\n  2165\t                [\"pony_id\"],\n  2166\t                (f\"{app_label}_shetlandpony\", \"pony_ptr_id\"),\n  2167\t            )\n  2168\t\n  2169\t    def test_alter_field_pk_mti_and_fk_to_base(self):\n  2170\t        app_label = \"test_alflpkmtiftb\"\n  2171\t        project_state = self.set_up_test_model(\n  2172\t            app_label,\n  2173\t            mti_model=True,\n  2174\t            related_model=True,\n  2175\t        )\n  2176\t        operation = migrations.AlterField(\n  2177\t            \"Pony\",\n  2178\t            \"id\",\n  2179\t            models.BigAutoField(primary_key=True),\n  2180\t        )\n  2181\t        new_state = project_state.clone()\n  2182\t        operation.state_forwards(app_label, new_state)\n  2183\t        self.assertIsInstance(\n  2184\t            new_state.models[app_label, \"pony\"].fields[\"id\"],\n  2185\t            models.BigAutoField,\n  2186\t        )\n  2187\t\n  2188\t        def _get_column_id_type(cursor, table, column):\n  2189\t            return [\n  2190\t                c.type_code\n  2191\t                for c in connection.introspection.get_table_description(\n  2192\t                    cursor,\n  2193\t                    f\"{app_label}_{table}\",\n  2194\t                )\n  2195\t                if c.name == column\n  2196\t            ][0]\n  2197\t\n  2198\t        def assertIdTypeEqualsMTIFkType():\n  2199\t            with connection.cursor() as cursor:\n  2200\t                parent_id_type = _get_column_id_type(cursor, \"pony\", \"id\")\n  2201\t                fk_id_type = _get_column_id_type(cursor, \"rider\", \"pony_id\")\n  2202\t                child_id_type = _get_column_id_type(\n  2203\t                    cursor, \"shetlandpony\", \"pony_ptr_id\"\n  2204\t                )\n  2205\t            self.assertEqual(parent_id_type, child_id_type)\n  2206\t            self.assertEqual(parent_id_type, fk_id_type)\n  2207\t\n  2208\t        assertIdTypeEqualsMTIFkType()\n  2209\t        # Alter primary key.\n  2210\t        with connection.schema_editor() as editor:\n  2211\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2212\t        assertIdTypeEqualsMTIFkType()\n  2213\t        if connection.features.supports_foreign_keys:\n  2214\t            self.assertFKExists(\n  2215\t                f\"{app_label}_shetlandpony\",\n  2216\t                [\"pony_ptr_id\"],\n  2217\t                (f\"{app_label}_pony\", \"id\"),\n  2218\t            )\n  2219\t            self.assertFKExists(\n  2220\t                f\"{app_label}_rider\",\n  2221\t                [\"pony_id\"],\n  2222\t                (f\"{app_label}_pony\", \"id\"),\n  2223\t            )\n  2224\t        # Reversal.\n  2225\t        with connection.schema_editor() as editor:\n  2226\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2227\t        assertIdTypeEqualsMTIFkType()\n  2228\t        if connection.features.supports_foreign_keys:\n  2229\t            self.assertFKExists(\n  2230\t                f\"{app_label}_shetlandpony\",\n  2231\t                [\"pony_ptr_id\"],\n  2232\t                (f\"{app_label}_pony\", \"id\"),\n  2233\t            )\n  2234\t            self.assertFKExists(\n  2235\t                f\"{app_label}_rider\",\n  2236\t                [\"pony_id\"],\n  2237\t                (f\"{app_label}_pony\", \"id\"),\n  2238\t            )\n  2239\t\n  2240\t    @skipUnlessDBFeature(\"supports_foreign_keys\")\n  2241\t    def test_alter_field_reloads_state_on_fk_with_to_field_target_type_change(self):\n  2242\t        app_label = \"test_alflrsfkwtflttc\"\n  2243\t        project_state = self.apply_operations(\n  2244\t            app_label,\n  2245\t            ProjectState(),\n  2246\t            operations=[\n  2247\t                migrations.CreateModel(\n  2248\t                    \"Rider\",\n  2249\t                    fields=[\n  2250\t                        (\"id\", models.AutoField(primary_key=True)),\n  2251\t                        (\"code\", models.IntegerField(unique=True)),\n  2252\t                    ],\n  2253\t                ),\n  2254\t                migrations.CreateModel(\n  2255\t                    \"Pony\",\n  2256\t                    fields=[\n  2257\t                        (\"id\", models.AutoField(primary_key=True)),\n  2258\t                        (\n  2259\t                            \"rider\",\n  2260\t                            models.ForeignKey(\n  2261\t                                \"%s.Rider\" % app_label, models.CASCADE, to_field=\"code\"\n  2262\t                            ),\n  2263\t                        ),\n  2264\t                    ],\n  2265\t                ),\n  2266\t            ],\n  2267\t        )\n  2268\t        operation = migrations.AlterField(\n  2269\t            \"Rider\",\n  2270\t            \"code\",\n  2271\t            models.CharField(max_length=100, unique=True),\n  2272\t        )\n  2273\t        self.apply_operations(app_label, project_state, operations=[operation])\n  2274\t        id_type, id_null = [\n  2275\t            (c.type_code, c.null_ok)\n  2276\t            for c in self.get_table_description(\"%s_rider\" % app_label)\n  2277\t            if c.name == \"code\"\n  2278\t        ][0]\n  2279\t        fk_type, fk_null = [\n  2280\t            (c.type_code, c.null_ok)\n  2281\t            for c in self.get_table_description(\"%s_pony\" % app_label)\n  2282\t            if c.name == \"rider_id\"\n  2283\t        ][0]\n  2284\t        self.assertEqual(id_type, fk_type)\n  2285\t        self.assertEqual(id_null, fk_null)\n  2286\t\n  2287\t    @skipUnlessDBFeature(\"supports_foreign_keys\")\n  2288\t    def test_alter_field_reloads_state_fk_with_to_field_related_name_target_type_change(\n  2289\t        self,\n  2290\t    ):\n  2291\t        app_label = \"test_alflrsfkwtflrnttc\"\n  2292\t        project_state = self.apply_operations(\n  2293\t            app_label,\n  2294\t            ProjectState(),\n  2295\t            operations=[\n  2296\t                migrations.CreateModel(\n  2297\t                    \"Rider\",\n  2298\t                    fields=[\n  2299\t                        (\"id\", models.AutoField(primary_key=True)),\n  2300\t                        (\"code\", models.PositiveIntegerField(unique=True)),\n  2301\t                    ],\n  2302\t                ),\n  2303\t                migrations.CreateModel(\n  2304\t                    \"Pony\",\n  2305\t                    fields=[\n  2306\t                        (\"id\", models.AutoField(primary_key=True)),\n  2307\t                        (\n  2308\t                            \"rider\",\n  2309\t                            models.ForeignKey(\n  2310\t                                \"%s.Rider\" % app_label,\n  2311\t                                models.CASCADE,\n  2312\t                                to_field=\"code\",\n  2313\t                                related_name=\"+\",\n  2314\t                            ),\n  2315\t                        ),\n  2316\t                    ],\n  2317\t                ),\n  2318\t            ],\n  2319\t        )\n  2320\t        operation = migrations.AlterField(\n  2321\t            \"Rider\",\n  2322\t            \"code\",\n  2323\t            models.CharField(max_length=100, unique=True),\n  2324\t        )\n  2325\t        self.apply_operations(app_label, project_state, operations=[operation])\n  2326\t\n  2327\t    def test_alter_field_reloads_state_on_fk_target_changes(self):\n  2328\t        \"\"\"\n  2329\t        If AlterField doesn't reload state appropriately, the second AlterField\n  2330\t        crashes on MySQL due to not dropping the PonyRider.pony foreign key\n  2331\t        constraint before modifying the column.\n  2332\t        \"\"\"\n  2333\t        app_label = \"alter_alter_field_reloads_state_on_fk_target_changes\"\n  2334\t        project_state = self.apply_operations(\n  2335\t            app_label,\n  2336\t            ProjectState(),\n  2337\t            operations=[\n  2338\t                migrations.CreateModel(\n  2339\t                    \"Rider\",\n  2340\t                    fields=[\n  2341\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2342\t                    ],\n  2343\t                ),\n  2344\t                migrations.CreateModel(\n  2345\t                    \"Pony\",\n  2346\t                    fields=[\n  2347\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2348\t                        (\n  2349\t                            \"rider\",\n  2350\t                            models.ForeignKey(\"%s.Rider\" % app_label, models.CASCADE),\n  2351\t                        ),\n  2352\t                    ],\n  2353\t                ),\n  2354\t                migrations.CreateModel(\n  2355\t                    \"PonyRider\",\n  2356\t                    fields=[\n  2357\t                        (\"id\", models.AutoField(primary_key=True)),\n  2358\t                        (\n  2359\t                            \"pony\",\n  2360\t                            models.ForeignKey(\"%s.Pony\" % app_label, models.CASCADE),\n  2361\t                        ),\n  2362\t                    ],\n  2363\t                ),\n  2364\t            ],\n  2365\t        )\n  2366\t        project_state = self.apply_operations(\n  2367\t            app_label,\n  2368\t            project_state,\n  2369\t            operations=[\n  2370\t                migrations.AlterField(\n  2371\t                    \"Rider\", \"id\", models.CharField(primary_key=True, max_length=99)\n  2372\t                ),\n  2373\t                migrations.AlterField(\n  2374\t                    \"Pony\", \"id\", models.CharField(primary_key=True, max_length=99)\n  2375\t                ),\n  2376\t            ],\n  2377\t        )\n  2378\t\n  2379\t    def test_alter_field_reloads_state_on_fk_with_to_field_target_changes(self):\n  2380\t        \"\"\"\n  2381\t        If AlterField doesn't reload state appropriately, the second AlterField\n  2382\t        crashes on MySQL due to not dropping the PonyRider.pony foreign key\n  2383\t        constraint before modifying the column.\n  2384\t        \"\"\"\n  2385\t        app_label = \"alter_alter_field_reloads_state_on_fk_with_to_field_target_changes\"\n  2386\t        project_state = self.apply_operations(\n  2387\t            app_label,\n  2388\t            ProjectState(),\n  2389\t            operations=[\n  2390\t                migrations.CreateModel(\n  2391\t                    \"Rider\",\n  2392\t                    fields=[\n  2393\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2394\t                        (\"slug\", models.CharField(unique=True, max_length=100)),\n  2395\t                    ],\n  2396\t                ),\n  2397\t                migrations.CreateModel(\n  2398\t                    \"Pony\",\n  2399\t                    fields=[\n  2400\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2401\t                        (\n  2402\t                            \"rider\",\n  2403\t                            models.ForeignKey(\n  2404\t                                \"%s.Rider\" % app_label, models.CASCADE, to_field=\"slug\"\n  2405\t                            ),\n  2406\t                        ),\n  2407\t                        (\"slug\", models.CharField(unique=True, max_length=100)),\n  2408\t                    ],\n  2409\t                ),\n  2410\t                migrations.CreateModel(\n  2411\t                    \"PonyRider\",\n  2412\t                    fields=[\n  2413\t                        (\"id\", models.AutoField(primary_key=True)),\n  2414\t                        (\n  2415\t                            \"pony\",\n  2416\t                            models.ForeignKey(\n  2417\t                                \"%s.Pony\" % app_label, models.CASCADE, to_field=\"slug\"\n  2418\t                            ),\n  2419\t                        ),\n  2420\t                    ],\n  2421\t                ),\n  2422\t            ],\n  2423\t        )\n  2424\t        project_state = self.apply_operations(\n  2425\t            app_label,\n  2426\t            project_state,\n  2427\t            operations=[\n  2428\t                migrations.AlterField(\n  2429\t                    \"Rider\", \"slug\", models.CharField(unique=True, max_length=99)\n  2430\t                ),\n  2431\t                migrations.AlterField(\n  2432\t                    \"Pony\", \"slug\", models.CharField(unique=True, max_length=99)\n  2433\t                ),\n  2434\t            ],\n  2435\t        )\n  2436\t\n  2437\t    def test_rename_field_reloads_state_on_fk_target_changes(self):\n  2438\t        \"\"\"\n  2439\t        If RenameField doesn't reload state appropriately, the AlterField\n  2440\t        crashes on MySQL due to not dropping the PonyRider.pony foreign key\n  2441\t        constraint before modifying the column.\n  2442\t        \"\"\"\n  2443\t        app_label = \"alter_rename_field_reloads_state_on_fk_target_changes\"\n  2444\t        project_state = self.apply_operations(\n  2445\t            app_label,\n  2446\t            ProjectState(),\n  2447\t            operations=[\n  2448\t                migrations.CreateModel(\n  2449\t                    \"Rider\",\n  2450\t                    fields=[\n  2451\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2452\t                    ],\n  2453\t                ),\n  2454\t                migrations.CreateModel(\n  2455\t                    \"Pony\",\n  2456\t                    fields=[\n  2457\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2458\t                        (\n  2459\t                            \"rider\",\n  2460\t                            models.ForeignKey(\"%s.Rider\" % app_label, models.CASCADE),\n  2461\t                        ),\n  2462\t                    ],\n  2463\t                ),\n  2464\t                migrations.CreateModel(\n  2465\t                    \"PonyRider\",\n  2466\t                    fields=[\n  2467\t                        (\"id\", models.AutoField(primary_key=True)),\n  2468\t                        (\n  2469\t                            \"pony\",\n  2470\t                            models.ForeignKey(\"%s.Pony\" % app_label, models.CASCADE),\n  2471\t                        ),\n  2472\t                    ],\n  2473\t                ),\n  2474\t            ],\n  2475\t        )\n  2476\t        project_state = self.apply_operations(\n  2477\t            app_label,\n  2478\t            project_state,\n  2479\t            operations=[\n  2480\t                migrations.RenameField(\"Rider\", \"id\", \"id2\"),\n  2481\t                migrations.AlterField(\n  2482\t                    \"Pony\", \"id\", models.CharField(primary_key=True, max_length=99)\n  2483\t                ),\n  2484\t            ],\n  2485\t            atomic=connection.features.supports_atomic_references_rename,\n  2486\t        )\n  2487\t\n  2488\t    def test_rename_field(self):\n  2489\t        \"\"\"\n  2490\t        Tests the RenameField operation.\n  2491\t        \"\"\"\n  2492\t        project_state = self.set_up_test_model(\n  2493\t            \"test_rnfl\", unique_together=True, index_together=True\n  2494\t        )\n  2495\t        # Test the state alteration\n  2496\t        operation = migrations.RenameField(\"Pony\", \"pink\", \"blue\")\n  2497\t        self.assertEqual(operation.describe(), \"Rename field pink on Pony to blue\")\n  2498\t        self.assertEqual(operation.migration_name_fragment, \"rename_pink_pony_blue\")\n  2499\t        new_state = project_state.clone()\n  2500\t        operation.state_forwards(\"test_rnfl\", new_state)\n  2501\t        self.assertIn(\"blue\", new_state.models[\"test_rnfl\", \"pony\"].fields)\n  2502\t        self.assertNotIn(\"pink\", new_state.models[\"test_rnfl\", \"pony\"].fields)\n  2503\t        # Make sure the unique_together has the renamed column too\n  2504\t        self.assertIn(\n  2505\t            \"blue\", new_state.models[\"test_rnfl\", \"pony\"].options[\"unique_together\"][0]\n  2506\t        )\n  2507\t        self.assertNotIn(\n  2508\t            \"pink\", new_state.models[\"test_rnfl\", \"pony\"].options[\"unique_together\"][0]\n  2509\t        )\n  2510\t        # Make sure the index_together has the renamed column too\n  2511\t        self.assertIn(\n  2512\t            \"blue\", new_state.models[\"test_rnfl\", \"pony\"].options[\"index_together\"][0]\n  2513\t        )\n  2514\t        self.assertNotIn(\n  2515\t            \"pink\", new_state.models[\"test_rnfl\", \"pony\"].options[\"index_together\"][0]\n  2516\t        )\n  2517\t        # Test the database alteration\n  2518\t        self.assertColumnExists(\"test_rnfl_pony\", \"pink\")\n  2519\t        self.assertColumnNotExists(\"test_rnfl_pony\", \"blue\")\n  2520\t        with connection.schema_editor() as editor:\n  2521\t            operation.database_forwards(\"test_rnfl\", editor, project_state, new_state)\n  2522\t        self.assertColumnExists(\"test_rnfl_pony\", \"blue\")\n  2523\t        self.assertColumnNotExists(\"test_rnfl_pony\", \"pink\")\n  2524\t        # Ensure the unique constraint has been ported over\n  2525\t        with connection.cursor() as cursor:\n  2526\t            cursor.execute(\"INSERT INTO test_rnfl_pony (blue, weight) VALUES (1, 1)\")\n  2527\t            with self.assertRaises(IntegrityError):\n  2528\t                with atomic():\n  2529\t                    cursor.execute(\n  2530\t                        \"INSERT INTO test_rnfl_pony (blue, weight) VALUES (1, 1)\"\n  2531\t                    )\n  2532\t            cursor.execute(\"DELETE FROM test_rnfl_pony\")\n  2533\t        # Ensure the index constraint has been ported over\n  2534\t        self.assertIndexExists(\"test_rnfl_pony\", [\"weight\", \"blue\"])\n  2535\t        # And test reversal\n  2536\t        with connection.schema_editor() as editor:\n  2537\t            operation.database_backwards(\"test_rnfl\", editor, new_state, project_state)\n  2538\t        self.assertColumnExists(\"test_rnfl_pony\", \"pink\")\n  2539\t        self.assertColumnNotExists(\"test_rnfl_pony\", \"blue\")\n  2540\t        # Ensure the index constraint has been reset\n  2541\t        self.assertIndexExists(\"test_rnfl_pony\", [\"weight\", \"pink\"])\n  2542\t        # And deconstruction\n  2543\t        definition = operation.deconstruct()\n  2544\t        self.assertEqual(definition[0], \"RenameField\")\n  2545\t        self.assertEqual(definition[1], [])\n  2546\t        self.assertEqual(\n  2547\t            definition[2],\n  2548\t            {\"model_name\": \"Pony\", \"old_name\": \"pink\", \"new_name\": \"blue\"},\n  2549\t        )\n  2550\t\n  2551\t    def test_rename_field_with_db_column(self):\n  2552\t        project_state = self.apply_operations(\n  2553\t            \"test_rfwdbc\",\n  2554\t            ProjectState(),\n  2555\t            operations=[\n  2556\t                migrations.CreateModel(\n  2557\t                    \"Pony\",\n  2558\t                    fields=[\n  2559\t                        (\"id\", models.AutoField(primary_key=True)),\n  2560\t                        (\"field\", models.IntegerField(db_column=\"db_field\")),\n  2561\t                        (\n  2562\t                            \"fk_field\",\n  2563\t                            models.ForeignKey(\n  2564\t                                \"Pony\",\n  2565\t                                models.CASCADE,\n  2566\t                                db_column=\"db_fk_field\",\n  2567\t                            ),\n  2568\t                        ),\n  2569\t                    ],\n  2570\t                ),\n  2571\t            ],\n  2572\t        )\n  2573\t        new_state = project_state.clone()\n  2574\t        operation = migrations.RenameField(\"Pony\", \"field\", \"renamed_field\")\n  2575\t        operation.state_forwards(\"test_rfwdbc\", new_state)\n  2576\t        self.assertIn(\"renamed_field\", new_state.models[\"test_rfwdbc\", \"pony\"].fields)\n  2577\t        self.assertNotIn(\"field\", new_state.models[\"test_rfwdbc\", \"pony\"].fields)\n  2578\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_field\")\n  2579\t        with connection.schema_editor() as editor:\n  2580\t            with self.assertNumQueries(0):\n  2581\t                operation.database_forwards(\n  2582\t                    \"test_rfwdbc\", editor, project_state, new_state\n  2583\t                )\n  2584\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_field\")\n  2585\t        with connection.schema_editor() as editor:\n  2586\t            with self.assertNumQueries(0):\n  2587\t                operation.database_backwards(\n  2588\t                    \"test_rfwdbc\", editor, new_state, project_state\n  2589\t                )\n  2590\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_field\")\n  2591\t\n  2592\t        new_state = project_state.clone()\n  2593\t        operation = migrations.RenameField(\"Pony\", \"fk_field\", \"renamed_fk_field\")\n  2594\t        operation.state_forwards(\"test_rfwdbc\", new_state)\n  2595\t        self.assertIn(\n  2596\t            \"renamed_fk_field\", new_state.models[\"test_rfwdbc\", \"pony\"].fields\n  2597\t        )\n  2598\t        self.assertNotIn(\"fk_field\", new_state.models[\"test_rfwdbc\", \"pony\"].fields)\n  2599\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_fk_field\")\n  2600\t        with connection.schema_editor() as editor:\n  2601\t            with self.assertNumQueries(0):\n  2602\t                operation.database_forwards(\n  2603\t                    \"test_rfwdbc\", editor, project_state, new_state\n  2604\t                )\n  2605\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_fk_field\")\n  2606\t        with connection.schema_editor() as editor:\n  2607\t            with self.assertNumQueries(0):\n  2608\t                operation.database_backwards(\n  2609\t                    \"test_rfwdbc\", editor, new_state, project_state\n  2610\t                )\n  2611\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_fk_field\")\n  2612\t\n  2613\t    def test_rename_field_case(self):\n  2614\t        project_state = self.apply_operations(\n  2615\t            \"test_rfmx\",\n  2616\t            ProjectState(),\n  2617\t            operations=[\n  2618\t                migrations.CreateModel(\n  2619\t                    \"Pony\",\n  2620\t                    fields=[\n  2621\t                        (\"id\", models.AutoField(primary_key=True)),\n  2622\t                        (\"field\", models.IntegerField()),\n  2623\t                    ],\n  2624\t                ),\n  2625\t            ],\n  2626\t        )\n  2627\t        new_state = project_state.clone()\n  2628\t        operation = migrations.RenameField(\"Pony\", \"field\", \"FiElD\")\n  2629\t        operation.state_forwards(\"test_rfmx\", new_state)\n  2630\t        self.assertIn(\"FiElD\", new_state.models[\"test_rfmx\", \"pony\"].fields)\n  2631\t        self.assertColumnExists(\"test_rfmx_pony\", \"field\")\n  2632\t        with connection.schema_editor() as editor:\n  2633\t            operation.database_forwards(\"test_rfmx\", editor, project_state, new_state)\n  2634\t        self.assertColumnExists(\n  2635\t            \"test_rfmx_pony\",\n  2636\t            connection.introspection.identifier_converter(\"FiElD\"),\n  2637\t        )\n  2638\t        with connection.schema_editor() as editor:\n  2639\t            operation.database_backwards(\"test_rfmx\", editor, new_state, project_state)\n  2640\t        self.assertColumnExists(\"test_rfmx_pony\", \"field\")\n  2641\t\n  2642\t    def test_rename_missing_field(self):\n  2643\t        state = ProjectState()\n  2644\t        state.add_model(ModelState(\"app\", \"model\", []))\n  2645\t        with self.assertRaisesMessage(\n  2646\t            FieldDoesNotExist, \"app.model has no field named 'field'\"\n  2647\t        ):\n  2648\t            migrations.RenameField(\"model\", \"field\", \"new_field\").state_forwards(\n  2649\t                \"app\", state\n  2650\t            )\n  2651\t\n  2652\t    def test_rename_referenced_field_state_forward(self):\n  2653\t        state = ProjectState()\n  2654\t        state.add_model(\n  2655\t            ModelState(\n  2656\t                \"app\",\n  2657\t                \"Model\",\n  2658\t                [\n  2659\t                    (\"id\", models.AutoField(primary_key=True)),\n  2660\t                    (\"field\", models.IntegerField(unique=True)),\n  2661\t                ],\n  2662\t            )\n  2663\t        )\n  2664\t        state.add_model(\n  2665\t            ModelState(\n  2666\t                \"app\",\n  2667\t                \"OtherModel\",\n  2668\t                [\n  2669\t                    (\"id\", models.AutoField(primary_key=True)),\n  2670\t                    (\n  2671\t                        \"fk\",\n  2672\t                        models.ForeignKey(\"Model\", models.CASCADE, to_field=\"field\"),\n  2673\t                    ),\n  2674\t                    (\n  2675\t                        \"fo\",\n  2676\t                        models.ForeignObject(\n  2677\t                            \"Model\",\n  2678\t                            models.CASCADE,\n  2679\t                            from_fields=(\"fk\",),\n  2680\t                            to_fields=(\"field\",),\n  2681\t                        ),\n  2682\t                    ),\n  2683\t                ],\n  2684\t            )\n  2685\t        )\n  2686\t        operation = migrations.RenameField(\"Model\", \"field\", \"renamed\")\n  2687\t        new_state = state.clone()\n  2688\t        operation.state_forwards(\"app\", new_state)\n  2689\t        self.assertEqual(\n  2690\t            new_state.models[\"app\", \"othermodel\"].fields[\"fk\"].remote_field.field_name,\n  2691\t            \"renamed\",\n  2692\t        )\n  2693\t        self.assertEqual(\n  2694\t            new_state.models[\"app\", \"othermodel\"].fields[\"fk\"].from_fields, [\"self\"]\n  2695\t        )\n  2696\t        self.assertEqual(\n  2697\t            new_state.models[\"app\", \"othermodel\"].fields[\"fk\"].to_fields, (\"renamed\",)\n  2698\t        )\n  2699\t        self.assertEqual(\n  2700\t            new_state.models[\"app\", \"othermodel\"].fields[\"fo\"].from_fields, (\"fk\",)\n  2701\t        )\n  2702\t        self.assertEqual(\n  2703\t            new_state.models[\"app\", \"othermodel\"].fields[\"fo\"].to_fields, (\"renamed\",)\n  2704\t        )\n  2705\t        operation = migrations.RenameField(\"OtherModel\", \"fk\", \"renamed_fk\")\n  2706\t        new_state = state.clone()\n  2707\t        operation.state_forwards(\"app\", new_state)\n  2708\t        self.assertEqual(\n  2709\t            new_state.models[\"app\", \"othermodel\"]\n  2710\t            .fields[\"renamed_fk\"]\n  2711\t            .remote_field.field_name,\n  2712\t            \"renamed\",\n  2713\t        )\n  2714\t        self.assertEqual(\n  2715\t            new_state.models[\"app\", \"othermodel\"].fields[\"renamed_fk\"].from_fields,\n  2716\t            (\"self\",),\n  2717\t        )\n  2718\t        self.assertEqual(\n  2719\t            new_state.models[\"app\", \"othermodel\"].fields[\"renamed_fk\"].to_fields,\n  2720\t            (\"renamed\",),\n  2721\t        )\n  2722\t        self.assertEqual(\n  2723\t            new_state.models[\"app\", \"othermodel\"].fields[\"fo\"].from_fields,\n  2724\t            (\"renamed_fk\",),\n  2725\t        )\n  2726\t        self.assertEqual(\n  2727\t            new_state.models[\"app\", \"othermodel\"].fields[\"fo\"].to_fields, (\"renamed\",)\n  2728\t        )\n  2729\t\n  2730\t    def test_alter_unique_together(self):\n  2731\t        \"\"\"\n  2732\t        Tests the AlterUniqueTogether operation.\n  2733\t        \"\"\"\n  2734\t        project_state = self.set_up_test_model(\"test_alunto\")\n  2735\t        # Test the state alteration\n  2736\t        operation = migrations.AlterUniqueTogether(\"Pony\", [(\"pink\", \"weight\")])\n  2737\t        self.assertEqual(\n  2738\t            operation.describe(), \"Alter unique_together for Pony (1 constraint(s))\"\n  2739\t        )\n  2740\t        self.assertEqual(\n  2741\t            operation.migration_name_fragment,\n  2742\t            \"alter_pony_unique_together\",\n  2743\t        )\n  2744\t        new_state = project_state.clone()\n  2745\t        operation.state_forwards(\"test_alunto\", new_state)\n  2746\t        self.assertEqual(\n  2747\t            len(\n  2748\t                project_state.models[\"test_alunto\", \"pony\"].options.get(\n  2749\t                    \"unique_together\", set()\n  2750\t                )\n  2751\t            ),\n  2752\t            0,\n  2753\t        )\n  2754\t        self.assertEqual(\n  2755\t            len(\n  2756\t                new_state.models[\"test_alunto\", \"pony\"].options.get(\n  2757\t                    \"unique_together\", set()\n  2758\t                )\n  2759\t            ),\n  2760\t            1,\n  2761\t        )\n  2762\t        # Make sure we can insert duplicate rows\n  2763\t        with connection.cursor() as cursor:\n  2764\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2765\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2766\t            cursor.execute(\"DELETE FROM test_alunto_pony\")\n  2767\t            # Test the database alteration\n  2768\t            with connection.schema_editor() as editor:\n  2769\t                operation.database_forwards(\n  2770\t                    \"test_alunto\", editor, project_state, new_state\n  2771\t                )\n  2772\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2773\t            with self.assertRaises(IntegrityError):\n  2774\t                with atomic():\n  2775\t                    cursor.execute(\n  2776\t                        \"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\"\n  2777\t                    )\n  2778\t            cursor.execute(\"DELETE FROM test_alunto_pony\")\n  2779\t            # And test reversal\n  2780\t            with connection.schema_editor() as editor:\n  2781\t                operation.database_backwards(\n  2782\t                    \"test_alunto\", editor, new_state, project_state\n  2783\t                )\n  2784\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2785\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2786\t            cursor.execute(\"DELETE FROM test_alunto_pony\")\n  2787\t        # Test flat unique_together\n  2788\t        operation = migrations.AlterUniqueTogether(\"Pony\", (\"pink\", \"weight\"))\n  2789\t        operation.state_forwards(\"test_alunto\", new_state)\n  2790\t        self.assertEqual(\n  2791\t            len(\n  2792\t                new_state.models[\"test_alunto\", \"pony\"].options.get(\n  2793\t                    \"unique_together\", set()\n  2794\t                )\n  2795\t            ),\n  2796\t            1,\n  2797\t        )\n  2798\t        # And deconstruction\n  2799\t        definition = operation.deconstruct()\n  2800\t        self.assertEqual(definition[0], \"AlterUniqueTogether\")\n  2801\t        self.assertEqual(definition[1], [])\n  2802\t        self.assertEqual(\n  2803\t            definition[2], {\"name\": \"Pony\", \"unique_together\": {(\"pink\", \"weight\")}}\n  2804\t        )\n  2805\t\n  2806\t    def test_alter_unique_together_remove(self):\n  2807\t        operation = migrations.AlterUniqueTogether(\"Pony\", None)\n  2808\t        self.assertEqual(\n  2809\t            operation.describe(), \"Alter unique_together for Pony (0 constraint(s))\"\n  2810\t        )\n  2811\t\n  2812\t    def test_add_index(self):\n  2813\t        \"\"\"\n  2814\t        Test the AddIndex operation.\n  2815\t        \"\"\"\n  2816\t        project_state = self.set_up_test_model(\"test_adin\")\n  2817\t        msg = (\n  2818\t            \"Indexes passed to AddIndex operations require a name argument. \"\n  2819\t            \"<Index: fields=['pink']> doesn't have one.\"\n  2820\t        )\n  2821\t        with self.assertRaisesMessage(ValueError, msg):\n  2822\t            migrations.AddIndex(\"Pony\", models.Index(fields=[\"pink\"]))\n  2823\t        index = models.Index(fields=[\"pink\"], name=\"test_adin_pony_pink_idx\")\n  2824\t        operation = migrations.AddIndex(\"Pony\", index)\n  2825\t        self.assertEqual(\n  2826\t            operation.describe(),\n  2827\t            \"Create index test_adin_pony_pink_idx on field(s) pink of model Pony\",\n  2828\t        )\n  2829\t        self.assertEqual(\n  2830\t            operation.migration_name_fragment,\n  2831\t            \"pony_test_adin_pony_pink_idx\",\n  2832\t        )\n  2833\t        new_state = project_state.clone()\n  2834\t        operation.state_forwards(\"test_adin\", new_state)\n  2835\t        # Test the database alteration\n  2836\t        self.assertEqual(\n  2837\t            len(new_state.models[\"test_adin\", \"pony\"].options[\"indexes\"]), 1\n  2838\t        )\n  2839\t        self.assertIndexNotExists(\"test_adin_pony\", [\"pink\"])\n  2840\t        with connection.schema_editor() as editor:\n  2841\t            operation.database_forwards(\"test_adin\", editor, project_state, new_state)\n  2842\t        self.assertIndexExists(\"test_adin_pony\", [\"pink\"])\n  2843\t        # And test reversal\n  2844\t        with connection.schema_editor() as editor:\n  2845\t            operation.database_backwards(\"test_adin\", editor, new_state, project_state)\n  2846\t        self.assertIndexNotExists(\"test_adin_pony\", [\"pink\"])\n  2847\t        # And deconstruction\n  2848\t        definition = operation.deconstruct()\n  2849\t        self.assertEqual(definition[0], \"AddIndex\")\n  2850\t        self.assertEqual(definition[1], [])\n  2851\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"index\": index})\n  2852\t\n  2853\t    def test_remove_index(self):\n  2854\t        \"\"\"\n  2855\t        Test the RemoveIndex operation.\n  2856\t        \"\"\"\n  2857\t        project_state = self.set_up_test_model(\"test_rmin\", multicol_index=True)\n  2858\t        self.assertTableExists(\"test_rmin_pony\")\n  2859\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2860\t        operation = migrations.RemoveIndex(\"Pony\", \"pony_test_idx\")\n  2861\t        self.assertEqual(operation.describe(), \"Remove index pony_test_idx from Pony\")\n  2862\t        self.assertEqual(\n  2863\t            operation.migration_name_fragment,\n  2864\t            \"remove_pony_pony_test_idx\",\n  2865\t        )\n  2866\t        new_state = project_state.clone()\n  2867\t        operation.state_forwards(\"test_rmin\", new_state)\n  2868\t        # Test the state alteration\n  2869\t        self.assertEqual(\n  2870\t            len(new_state.models[\"test_rmin\", \"pony\"].options[\"indexes\"]), 0\n  2871\t        )\n  2872\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2873\t        # Test the database alteration\n  2874\t        with connection.schema_editor() as editor:\n  2875\t            operation.database_forwards(\"test_rmin\", editor, project_state, new_state)\n  2876\t        self.assertIndexNotExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2877\t        # And test reversal\n  2878\t        with connection.schema_editor() as editor:\n  2879\t            operation.database_backwards(\"test_rmin\", editor, new_state, project_state)\n  2880\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2881\t        # And deconstruction\n  2882\t        definition = operation.deconstruct()\n  2883\t        self.assertEqual(definition[0], \"RemoveIndex\")\n  2884\t        self.assertEqual(definition[1], [])\n  2885\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"name\": \"pony_test_idx\"})\n  2886\t\n  2887\t        # Also test a field dropped with index - sqlite remake issue\n  2888\t        operations = [\n  2889\t            migrations.RemoveIndex(\"Pony\", \"pony_test_idx\"),\n  2890\t            migrations.RemoveField(\"Pony\", \"pink\"),\n  2891\t        ]\n  2892\t        self.assertColumnExists(\"test_rmin_pony\", \"pink\")\n  2893\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2894\t        # Test database alteration\n  2895\t        new_state = project_state.clone()\n  2896\t        self.apply_operations(\"test_rmin\", new_state, operations=operations)\n  2897\t        self.assertColumnNotExists(\"test_rmin_pony\", \"pink\")\n  2898\t        self.assertIndexNotExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2899\t        # And test reversal\n  2900\t        self.unapply_operations(\"test_rmin\", project_state, operations=operations)\n  2901\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2902\t\n  2903\t    def test_rename_index(self):\n  2904\t        app_label = \"test_rnin\"\n  2905\t        project_state = self.set_up_test_model(app_label, index=True)\n  2906\t        table_name = app_label + \"_pony\"\n  2907\t        self.assertIndexNameExists(table_name, \"pony_pink_idx\")\n  2908\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2909\t        operation = migrations.RenameIndex(\n  2910\t            \"Pony\", new_name=\"new_pony_test_idx\", old_name=\"pony_pink_idx\"\n  2911\t        )\n  2912\t        self.assertEqual(\n  2913\t            operation.describe(),\n  2914\t            \"Rename index pony_pink_idx on Pony to new_pony_test_idx\",\n  2915\t        )\n  2916\t        self.assertEqual(\n  2917\t            operation.migration_name_fragment,\n  2918\t            \"rename_pony_pink_idx_new_pony_test_idx\",\n  2919\t        )\n  2920\t\n  2921\t        new_state = project_state.clone()\n  2922\t        operation.state_forwards(app_label, new_state)\n  2923\t        # Rename index.\n  2924\t        expected_queries = 1 if connection.features.can_rename_index else 2\n  2925\t        with connection.schema_editor() as editor, self.assertNumQueries(\n  2926\t            expected_queries\n  2927\t        ):\n  2928\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2929\t        self.assertIndexNameNotExists(table_name, \"pony_pink_idx\")\n  2930\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2931\t        # Reversal.\n  2932\t        with connection.schema_editor() as editor, self.assertNumQueries(\n  2933\t            expected_queries\n  2934\t        ):\n  2935\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2936\t        self.assertIndexNameExists(table_name, \"pony_pink_idx\")\n  2937\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2938\t        # Deconstruction.\n  2939\t        definition = operation.deconstruct()\n  2940\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2941\t        self.assertEqual(definition[1], [])\n  2942\t        self.assertEqual(\n  2943\t            definition[2],\n  2944\t            {\n  2945\t                \"model_name\": \"Pony\",\n  2946\t                \"old_name\": \"pony_pink_idx\",\n  2947\t                \"new_name\": \"new_pony_test_idx\",\n  2948\t            },\n  2949\t        )\n  2950\t\n  2951\t    def test_rename_index_arguments(self):\n  2952\t        msg = \"RenameIndex.old_name and old_fields are mutually exclusive.\"\n  2953\t        with self.assertRaisesMessage(ValueError, msg):\n  2954\t            migrations.RenameIndex(\n  2955\t                \"Pony\",\n  2956\t                new_name=\"new_idx_name\",\n  2957\t                old_name=\"old_idx_name\",\n  2958\t                old_fields=(\"weight\", \"pink\"),\n  2959\t            )\n  2960\t        msg = \"RenameIndex requires one of old_name and old_fields arguments to be set.\"\n  2961\t        with self.assertRaisesMessage(ValueError, msg):\n  2962\t            migrations.RenameIndex(\"Pony\", new_name=\"new_idx_name\")\n  2963\t\n  2964\t    def test_rename_index_unnamed_index(self):\n  2965\t        app_label = \"test_rninui\"\n  2966\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  2967\t        table_name = app_label + \"_pony\"\n  2968\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2969\t        operation = migrations.RenameIndex(\n  2970\t            \"Pony\", new_name=\"new_pony_test_idx\", old_fields=(\"weight\", \"pink\")\n  2971\t        )\n  2972\t        self.assertEqual(\n  2973\t            operation.describe(),\n  2974\t            \"Rename unnamed index for ('weight', 'pink') on Pony to new_pony_test_idx\",\n  2975\t        )\n  2976\t        self.assertEqual(\n  2977\t            operation.migration_name_fragment,\n  2978\t            \"rename_pony_weight_pink_new_pony_test_idx\",\n  2979\t        )\n  2980\t\n  2981\t        new_state = project_state.clone()\n  2982\t        operation.state_forwards(app_label, new_state)\n  2983\t        # Rename index.\n  2984\t        with connection.schema_editor() as editor:\n  2985\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2986\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2987\t        # Reverse is a no-op.\n  2988\t        with connection.schema_editor() as editor, self.assertNumQueries(0):\n  2989\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2990\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2991\t        # Deconstruction.\n  2992\t        definition = operation.deconstruct()\n  2993\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2994\t        self.assertEqual(definition[1], [])\n  2995\t        self.assertEqual(\n  2996\t            definition[2],\n  2997\t            {\n  2998\t                \"model_name\": \"Pony\",\n  2999\t                \"new_name\": \"new_pony_test_idx\",\n  3000\t                \"old_fields\": (\"weight\", \"pink\"),\n  3001\t            },\n  3002\t        )\n  3003\t\n  3004\t    def test_rename_index_unknown_unnamed_index(self):\n  3005\t        app_label = \"test_rninuui\"\n  3006\t        project_state = self.set_up_test_model(app_label)\n  3007\t        operation = migrations.RenameIndex(\n  3008\t            \"Pony\", new_name=\"new_pony_test_idx\", old_fields=(\"weight\", \"pink\")\n  3009\t        )\n  3010\t        new_state = project_state.clone()\n  3011\t        operation.state_forwards(app_label, new_state)\n  3012\t        msg = \"Found wrong number (0) of indexes for test_rninuui_pony(weight, pink).\"\n  3013\t        with connection.schema_editor() as editor:\n  3014\t            with self.assertRaisesMessage(ValueError, msg):\n  3015\t                operation.database_forwards(app_label, editor, project_state, new_state)\n  3016\t\n  3017\t    def test_add_index_state_forwards(self):\n  3018\t        project_state = self.set_up_test_model(\"test_adinsf\")\n  3019\t        index = models.Index(fields=[\"pink\"], name=\"test_adinsf_pony_pink_idx\")\n  3020\t        old_model = project_state.apps.get_model(\"test_adinsf\", \"Pony\")\n  3021\t        new_state = project_state.clone()\n  3022\t\n  3023\t        operation = migrations.AddIndex(\"Pony\", index)\n  3024\t        operation.state_forwards(\"test_adinsf\", new_state)\n  3025\t        new_model = new_state.apps.get_model(\"test_adinsf\", \"Pony\")\n  3026\t        self.assertIsNot(old_model, new_model)\n  3027\t\n  3028\t    def test_remove_index_state_forwards(self):\n  3029\t        project_state = self.set_up_test_model(\"test_rminsf\")\n  3030\t        index = models.Index(fields=[\"pink\"], name=\"test_rminsf_pony_pink_idx\")\n  3031\t        migrations.AddIndex(\"Pony\", index).state_forwards(\"test_rminsf\", project_state)\n  3032\t        old_model = project_state.apps.get_model(\"test_rminsf\", \"Pony\")\n  3033\t        new_state = project_state.clone()\n  3034\t\n  3035\t        operation = migrations.RemoveIndex(\"Pony\", \"test_rminsf_pony_pink_idx\")\n  3036\t        operation.state_forwards(\"test_rminsf\", new_state)\n  3037\t        new_model = new_state.apps.get_model(\"test_rminsf\", \"Pony\")\n  3038\t        self.assertIsNot(old_model, new_model)\n  3039\t\n  3040\t    def test_rename_index_state_forwards(self):\n  3041\t        app_label = \"test_rnidsf\"\n  3042\t        project_state = self.set_up_test_model(app_label, index=True)\n  3043\t        old_model = project_state.apps.get_model(app_label, \"Pony\")\n  3044\t        new_state = project_state.clone()\n  3045\t\n  3046\t        operation = migrations.RenameIndex(\n  3047\t            \"Pony\", new_name=\"new_pony_pink_idx\", old_name=\"pony_pink_idx\"\n  3048\t        )\n  3049\t        operation.state_forwards(app_label, new_state)\n  3050\t        new_model = new_state.apps.get_model(app_label, \"Pony\")\n  3051\t        self.assertIsNot(old_model, new_model)\n  3052\t        self.assertEqual(new_model._meta.indexes[0].name, \"new_pony_pink_idx\")\n  3053\t\n  3054\t    def test_rename_index_state_forwards_unnamed_index(self):\n  3055\t        app_label = \"test_rnidsfui\"\n  3056\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  3057\t        old_model = project_state.apps.get_model(app_label, \"Pony\")\n  3058\t        new_state = project_state.clone()\n  3059\t\n  3060\t        operation = migrations.RenameIndex(\n  3061\t            \"Pony\", new_name=\"new_pony_pink_idx\", old_fields=(\"weight\", \"pink\")\n  3062\t        )\n  3063\t        operation.state_forwards(app_label, new_state)\n  3064\t        new_model = new_state.apps.get_model(app_label, \"Pony\")\n  3065\t        self.assertIsNot(old_model, new_model)\n  3066\t        self.assertEqual(new_model._meta.index_together, tuple())\n  3067\t        self.assertEqual(new_model._meta.indexes[0].name, \"new_pony_pink_idx\")\n  3068\t\n  3069\t    @skipUnlessDBFeature(\"supports_expression_indexes\")\n  3070\t    def test_add_func_index(self):\n  3071\t        app_label = \"test_addfuncin\"\n  3072\t        index_name = f\"{app_label}_pony_abs_idx\"\n  3073\t        table_name = f\"{app_label}_pony\"\n  3074\t        project_state = self.set_up_test_model(app_label)\n  3075\t        index = models.Index(Abs(\"weight\"), name=index_name)\n  3076\t        operation = migrations.AddIndex(\"Pony\", index)\n  3077\t        self.assertEqual(\n  3078\t            operation.describe(),\n  3079\t            \"Create index test_addfuncin_pony_abs_idx on Abs(F(weight)) on model Pony\",\n  3080\t        )\n  3081\t        self.assertEqual(\n  3082\t            operation.migration_name_fragment,\n  3083\t            \"pony_test_addfuncin_pony_abs_idx\",\n  3084\t        )\n  3085\t        new_state = project_state.clone()\n  3086\t        operation.state_forwards(app_label, new_state)\n  3087\t        self.assertEqual(len(new_state.models[app_label, \"pony\"].options[\"indexes\"]), 1)\n  3088\t        self.assertIndexNameNotExists(table_name, index_name)\n  3089\t        # Add index.\n  3090\t        with connection.schema_editor() as editor:\n  3091\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3092\t        self.assertIndexNameExists(table_name, index_name)\n  3093\t        # Reversal.\n  3094\t        with connection.schema_editor() as editor:\n  3095\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3096\t        self.assertIndexNameNotExists(table_name, index_name)\n  3097\t        # Deconstruction.\n  3098\t        definition = operation.deconstruct()\n  3099\t        self.assertEqual(definition[0], \"AddIndex\")\n  3100\t        self.assertEqual(definition[1], [])\n  3101\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"index\": index})\n  3102\t\n  3103\t    @skipUnlessDBFeature(\"supports_expression_indexes\")\n  3104\t    def test_remove_func_index(self):\n  3105\t        app_label = \"test_rmfuncin\"\n  3106\t        index_name = f\"{app_label}_pony_abs_idx\"\n  3107\t        table_name = f\"{app_label}_pony\"\n  3108\t        project_state = self.set_up_test_model(\n  3109\t            app_label,\n  3110\t            indexes=[\n  3111\t                models.Index(Abs(\"weight\"), name=index_name),\n  3112\t            ],\n  3113\t        )\n  3114\t        self.assertTableExists(table_name)\n  3115\t        self.assertIndexNameExists(table_name, index_name)\n  3116\t        operation = migrations.RemoveIndex(\"Pony\", index_name)\n  3117\t        self.assertEqual(\n  3118\t            operation.describe(),\n  3119\t            \"Remove index test_rmfuncin_pony_abs_idx from Pony\",\n  3120\t        )\n  3121\t        self.assertEqual(\n  3122\t            operation.migration_name_fragment,\n  3123\t            \"remove_pony_test_rmfuncin_pony_abs_idx\",\n  3124\t        )\n  3125\t        new_state = project_state.clone()\n  3126\t        operation.state_forwards(app_label, new_state)\n  3127\t        self.assertEqual(len(new_state.models[app_label, \"pony\"].options[\"indexes\"]), 0)\n  3128\t        # Remove index.\n  3129\t        with connection.schema_editor() as editor:\n  3130\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3131\t        self.assertIndexNameNotExists(table_name, index_name)\n  3132\t        # Reversal.\n  3133\t        with connection.schema_editor() as editor:\n  3134\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3135\t        self.assertIndexNameExists(table_name, index_name)\n  3136\t        # Deconstruction.\n  3137\t        definition = operation.deconstruct()\n  3138\t        self.assertEqual(definition[0], \"RemoveIndex\")\n  3139\t        self.assertEqual(definition[1], [])\n  3140\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"name\": index_name})\n  3141\t\n  3142\t    @skipUnlessDBFeature(\"supports_expression_indexes\")\n  3143\t    def test_alter_field_with_func_index(self):\n  3144\t        app_label = \"test_alfuncin\"\n  3145\t        index_name = f\"{app_label}_pony_idx\"\n  3146\t        table_name = f\"{app_label}_pony\"\n  3147\t        project_state = self.set_up_test_model(\n  3148\t            app_label,\n  3149\t            indexes=[models.Index(Abs(\"pink\"), name=index_name)],\n  3150\t        )\n  3151\t        operation = migrations.AlterField(\n  3152\t            \"Pony\", \"pink\", models.IntegerField(null=True)\n  3153\t        )\n  3154\t        new_state = project_state.clone()\n  3155\t        operation.state_forwards(app_label, new_state)\n  3156\t        with connection.schema_editor() as editor:\n  3157\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3158\t        self.assertIndexNameExists(table_name, index_name)\n  3159\t        with connection.schema_editor() as editor:\n  3160\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3161\t        self.assertIndexNameExists(table_name, index_name)\n  3162\t\n  3163\t    def test_alter_field_with_index(self):\n  3164\t        \"\"\"\n  3165\t        Test AlterField operation with an index to ensure indexes created via\n  3166\t        Meta.indexes don't get dropped with sqlite3 remake.\n  3167\t        \"\"\"\n  3168\t        project_state = self.set_up_test_model(\"test_alflin\", index=True)\n  3169\t        operation = migrations.AlterField(\n  3170\t            \"Pony\", \"pink\", models.IntegerField(null=True)\n  3171\t        )\n  3172\t        new_state = project_state.clone()\n  3173\t        operation.state_forwards(\"test_alflin\", new_state)\n  3174\t        # Test the database alteration\n  3175\t        self.assertColumnNotNull(\"test_alflin_pony\", \"pink\")\n  3176\t        with connection.schema_editor() as editor:\n  3177\t            operation.database_forwards(\"test_alflin\", editor, project_state, new_state)\n  3178\t        # Index hasn't been dropped\n  3179\t        self.assertIndexExists(\"test_alflin_pony\", [\"pink\"])\n  3180\t        # And test reversal\n  3181\t        with connection.schema_editor() as editor:\n  3182\t            operation.database_backwards(\n  3183\t                \"test_alflin\", editor, new_state, project_state\n  3184\t            )\n  3185\t        # Ensure the index is still there\n  3186\t        self.assertIndexExists(\"test_alflin_pony\", [\"pink\"])\n  3187\t\n  3188\t    def test_alter_index_together(self):\n  3189\t        \"\"\"\n  3190\t        Tests the AlterIndexTogether operation.\n  3191\t        \"\"\"\n  3192\t        project_state = self.set_up_test_model(\"test_alinto\")\n  3193\t        # Test the state alteration\n  3194\t        operation = migrations.AlterIndexTogether(\"Pony\", [(\"pink\", \"weight\")])\n  3195\t        self.assertEqual(\n  3196\t            operation.describe(), \"Alter index_together for Pony (1 constraint(s))\"\n  3197\t        )\n  3198\t        self.assertEqual(\n  3199\t            operation.migration_name_fragment,\n  3200\t            \"alter_pony_index_together\",\n  3201\t        )\n  3202\t        new_state = project_state.clone()\n  3203\t        operation.state_forwards(\"test_alinto\", new_state)\n  3204\t        self.assertEqual(\n  3205\t            len(\n  3206\t                project_state.models[\"test_alinto\", \"pony\"].options.get(\n  3207\t                    \"index_together\", set()\n  3208\t                )\n  3209\t            ),\n  3210\t            0,\n  3211\t        )\n  3212\t        self.assertEqual(\n  3213\t            len(\n  3214\t                new_state.models[\"test_alinto\", \"pony\"].options.get(\n  3215\t                    \"index_together\", set()\n  3216\t                )\n  3217\t            ),\n  3218\t            1,\n  3219\t        )\n  3220\t        # Make sure there's no matching index\n  3221\t        self.assertIndexNotExists(\"test_alinto_pony\", [\"pink\", \"weight\"])\n  3222\t        # Test the database alteration\n  3223\t        with connection.schema_editor() as editor:\n  3224\t            operation.database_forwards(\"test_alinto\", editor, project_state, new_state)\n  3225\t        self.assertIndexExists(\"test_alinto_pony\", [\"pink\", \"weight\"])\n  3226\t        # And test reversal\n  3227\t        with connection.schema_editor() as editor:\n  3228\t            operation.database_backwards(\n  3229\t                \"test_alinto\", editor, new_state, project_state\n  3230\t            )\n  3231\t        self.assertIndexNotExists(\"test_alinto_pony\", [\"pink\", \"weight\"])\n  3232\t        # And deconstruction\n  3233\t        definition = operation.deconstruct()\n  3234\t        self.assertEqual(definition[0], \"AlterIndexTogether\")\n  3235\t        self.assertEqual(definition[1], [])\n  3236\t        self.assertEqual(\n  3237\t            definition[2], {\"name\": \"Pony\", \"index_together\": {(\"pink\", \"weight\")}}\n  3238\t        )\n  3239\t\n  3240\t    def test_alter_index_together_remove(self):\n  3241\t        operation = migrations.AlterIndexTogether(\"Pony\", None)\n  3242\t        self.assertEqual(\n  3243\t            operation.describe(), \"Alter index_together for Pony (0 constraint(s))\"\n  3244\t        )\n  3245\t\n  3246\t    @skipUnlessDBFeature(\"allows_multiple_constraints_on_same_fields\")\n  3247\t    def test_alter_index_together_remove_with_unique_together(self):\n  3248\t        app_label = \"test_alintoremove_wunto\"\n  3249\t        table_name = \"%s_pony\" % app_label\n  3250\t        project_state = self.set_up_test_model(app_label, unique_together=True)\n  3251\t        self.assertUniqueConstraintExists(table_name, [\"pink\", \"weight\"])\n  3252\t        # Add index together.\n  3253\t        new_state = project_state.clone()\n  3254\t        operation = migrations.AlterIndexTogether(\"Pony\", [(\"pink\", \"weight\")])\n  3255\t        operation.state_forwards(app_label, new_state)\n  3256\t        with connection.schema_editor() as editor:\n  3257\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3258\t        self.assertIndexExists(table_name, [\"pink\", \"weight\"])\n  3259\t        # Remove index together.\n  3260\t        project_state = new_state\n  3261\t        new_state = project_state.clone()\n  3262\t        operation = migrations.AlterIndexTogether(\"Pony\", set())\n  3263\t        operation.state_forwards(app_label, new_state)\n  3264\t        with connection.schema_editor() as editor:\n  3265\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3266\t        self.assertIndexNotExists(table_name, [\"pink\", \"weight\"])\n  3267\t        self.assertUniqueConstraintExists(table_name, [\"pink\", \"weight\"])\n  3268\t\n  3269\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3270\t    def test_add_constraint(self):\n  3271\t        project_state = self.set_up_test_model(\"test_addconstraint\")\n  3272\t        gt_check = models.Q(pink__gt=2)\n  3273\t        gt_constraint = models.CheckConstraint(\n  3274\t            check=gt_check, name=\"test_add_constraint_pony_pink_gt_2\"\n  3275\t        )\n  3276\t        gt_operation = migrations.AddConstraint(\"Pony\", gt_constraint)\n  3277\t        self.assertEqual(\n  3278\t            gt_operation.describe(),\n  3279\t            \"Create constraint test_add_constraint_pony_pink_gt_2 on model Pony\",\n  3280\t        )\n  3281\t        self.assertEqual(\n  3282\t            gt_operation.migration_name_fragment,\n  3283\t            \"pony_test_add_constraint_pony_pink_gt_2\",\n  3284\t        )\n  3285\t        # Test the state alteration\n  3286\t        new_state = project_state.clone()\n  3287\t        gt_operation.state_forwards(\"test_addconstraint\", new_state)\n  3288\t        self.assertEqual(\n  3289\t            len(new_state.models[\"test_addconstraint\", \"pony\"].options[\"constraints\"]),\n  3290\t            1,\n  3291\t        )\n  3292\t        Pony = new_state.apps.get_model(\"test_addconstraint\", \"Pony\")\n  3293\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3294\t        # Test the database alteration\n  3295\t        with connection.schema_editor() as editor:\n  3296\t            gt_operation.database_forwards(\n  3297\t                \"test_addconstraint\", editor, project_state, new_state\n  3298\t            )\n  3299\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3300\t            Pony.objects.create(pink=1, weight=1.0)\n  3301\t        # Add another one.\n  3302\t        lt_check = models.Q(pink__lt=100)\n  3303\t        lt_constraint = models.CheckConstraint(\n  3304\t            check=lt_check, name=\"test_add_constraint_pony_pink_lt_100\"\n  3305\t        )\n  3306\t        lt_operation = migrations.AddConstraint(\"Pony\", lt_constraint)\n  3307\t        lt_operation.state_forwards(\"test_addconstraint\", new_state)\n  3308\t        self.assertEqual(\n  3309\t            len(new_state.models[\"test_addconstraint\", \"pony\"].options[\"constraints\"]),\n  3310\t            2,\n  3311\t        )\n  3312\t        Pony = new_state.apps.get_model(\"test_addconstraint\", \"Pony\")\n  3313\t        self.assertEqual(len(Pony._meta.constraints), 2)\n  3314\t        with connection.schema_editor() as editor:\n  3315\t            lt_operation.database_forwards(\n  3316\t                \"test_addconstraint\", editor, project_state, new_state\n  3317\t            )\n  3318\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3319\t            Pony.objects.create(pink=100, weight=1.0)\n  3320\t        # Test reversal\n  3321\t        with connection.schema_editor() as editor:\n  3322\t            gt_operation.database_backwards(\n  3323\t                \"test_addconstraint\", editor, new_state, project_state\n  3324\t            )\n  3325\t        Pony.objects.create(pink=1, weight=1.0)\n  3326\t        # Test deconstruction\n  3327\t        definition = gt_operation.deconstruct()\n  3328\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3329\t        self.assertEqual(definition[1], [])\n  3330\t        self.assertEqual(\n  3331\t            definition[2], {\"model_name\": \"Pony\", \"constraint\": gt_constraint}\n  3332\t        )\n  3333\t\n  3334\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3335\t    def test_add_constraint_percent_escaping(self):\n  3336\t        app_label = \"add_constraint_string_quoting\"\n  3337\t        operations = [\n  3338\t            migrations.CreateModel(\n  3339\t                \"Author\",\n  3340\t                fields=[\n  3341\t                    (\"id\", models.AutoField(primary_key=True)),\n  3342\t                    (\"name\", models.CharField(max_length=100)),\n  3343\t                    (\"surname\", models.CharField(max_length=100, default=\"\")),\n  3344\t                    (\"rebate\", models.CharField(max_length=100)),\n  3345\t                ],\n  3346\t            ),\n  3347\t        ]\n  3348\t        from_state = self.apply_operations(app_label, ProjectState(), operations)\n  3349\t        # \"%\" generated in startswith lookup should be escaped in a way that is\n  3350\t        # considered a leading wildcard.\n  3351\t        check = models.Q(name__startswith=\"Albert\")\n  3352\t        constraint = models.CheckConstraint(check=check, name=\"name_constraint\")\n  3353\t        operation = migrations.AddConstraint(\"Author\", constraint)\n  3354\t        to_state = from_state.clone()\n  3355\t        operation.state_forwards(app_label, to_state)\n  3356\t        with connection.schema_editor() as editor:\n  3357\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3358\t        Author = to_state.apps.get_model(app_label, \"Author\")\n  3359\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3360\t            Author.objects.create(name=\"Artur\")\n  3361\t        # Literal \"%\" should be escaped in a way that is not a considered a\n  3362\t        # wildcard.\n  3363\t        check = models.Q(rebate__endswith=\"%\")\n  3364\t        constraint = models.CheckConstraint(check=check, name=\"rebate_constraint\")\n  3365\t        operation = migrations.AddConstraint(\"Author\", constraint)\n  3366\t        from_state = to_state\n  3367\t        to_state = from_state.clone()\n  3368\t        operation.state_forwards(app_label, to_state)\n  3369\t        Author = to_state.apps.get_model(app_label, \"Author\")\n  3370\t        with connection.schema_editor() as editor:\n  3371\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3372\t        Author = to_state.apps.get_model(app_label, \"Author\")\n  3373\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3374\t            Author.objects.create(name=\"Albert\", rebate=\"10$\")\n  3375\t        author = Author.objects.create(name=\"Albert\", rebate=\"10%\")\n  3376\t        self.assertEqual(Author.objects.get(), author)\n  3377\t        # Right-hand-side baked \"%\" literals should not be used for parameters\n  3378\t        # interpolation.\n  3379\t        check = ~models.Q(surname__startswith=models.F(\"name\"))\n  3380\t        constraint = models.CheckConstraint(check=check, name=\"name_constraint_rhs\")\n  3381\t        operation = migrations.AddConstraint(\"Author\", constraint)\n  3382\t        from_state = to_state\n  3383\t        to_state = from_state.clone()\n  3384\t        operation.state_forwards(app_label, to_state)\n  3385\t        with connection.schema_editor() as editor:\n  3386\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3387\t        Author = to_state.apps.get_model(app_label, \"Author\")\n  3388\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3389\t            Author.objects.create(name=\"Albert\", surname=\"Alberto\")\n  3390\t\n  3391\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3392\t    def test_add_or_constraint(self):\n  3393\t        app_label = \"test_addorconstraint\"\n  3394\t        constraint_name = \"add_constraint_or\"\n  3395\t        from_state = self.set_up_test_model(app_label)\n  3396\t        check = models.Q(pink__gt=2, weight__gt=2) | models.Q(weight__lt=0)\n  3397\t        constraint = models.CheckConstraint(check=check, name=constraint_name)\n  3398\t        operation = migrations.AddConstraint(\"Pony\", constraint)\n  3399\t        to_state = from_state.clone()\n  3400\t        operation.state_forwards(app_label, to_state)\n  3401\t        with connection.schema_editor() as editor:\n  3402\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3403\t        Pony = to_state.apps.get_model(app_label, \"Pony\")\n  3404\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3405\t            Pony.objects.create(pink=2, weight=3.0)\n  3406\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3407\t            Pony.objects.create(pink=3, weight=1.0)\n  3408\t        Pony.objects.bulk_create(\n  3409\t            [\n  3410\t                Pony(pink=3, weight=-1.0),\n  3411\t                Pony(pink=1, weight=-1.0),\n  3412\t                Pony(pink=3, weight=3.0),\n  3413\t            ]\n  3414\t        )\n  3415\t\n  3416\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3417\t    def test_add_constraint_combinable(self):\n  3418\t        app_label = \"test_addconstraint_combinable\"\n  3419\t        operations = [\n  3420\t            migrations.CreateModel(\n  3421\t                \"Book\",\n  3422\t                fields=[\n  3423\t                    (\"id\", models.AutoField(primary_key=True)),\n  3424\t                    (\"read\", models.PositiveIntegerField()),\n  3425\t                    (\"unread\", models.PositiveIntegerField()),\n  3426\t                ],\n  3427\t            ),\n  3428\t        ]\n  3429\t        from_state = self.apply_operations(app_label, ProjectState(), operations)\n  3430\t        constraint = models.CheckConstraint(\n  3431\t            check=models.Q(read=(100 - models.F(\"unread\"))),\n  3432\t            name=\"test_addconstraint_combinable_sum_100\",\n  3433\t        )\n  3434\t        operation = migrations.AddConstraint(\"Book\", constraint)\n  3435\t        to_state = from_state.clone()\n  3436\t        operation.state_forwards(app_label, to_state)\n  3437\t        with connection.schema_editor() as editor:\n  3438\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3439\t        Book = to_state.apps.get_model(app_label, \"Book\")\n  3440\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3441\t            Book.objects.create(read=70, unread=10)\n  3442\t        Book.objects.create(read=70, unread=30)\n  3443\t\n  3444\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3445\t    def test_remove_constraint(self):\n  3446\t        project_state = self.set_up_test_model(\n  3447\t            \"test_removeconstraint\",\n  3448\t            constraints=[\n  3449\t                models.CheckConstraint(\n  3450\t                    check=models.Q(pink__gt=2),\n  3451\t                    name=\"test_remove_constraint_pony_pink_gt_2\",\n  3452\t                ),\n  3453\t                models.CheckConstraint(\n  3454\t                    check=models.Q(pink__lt=100),\n  3455\t                    name=\"test_remove_constraint_pony_pink_lt_100\",\n  3456\t                ),\n  3457\t            ],\n  3458\t        )\n  3459\t        gt_operation = migrations.RemoveConstraint(\n  3460\t            \"Pony\", \"test_remove_constraint_pony_pink_gt_2\"\n  3461\t        )\n  3462\t        self.assertEqual(\n  3463\t            gt_operation.describe(),\n  3464\t            \"Remove constraint test_remove_constraint_pony_pink_gt_2 from model Pony\",\n  3465\t        )\n  3466\t        self.assertEqual(\n  3467\t            gt_operation.migration_name_fragment,\n  3468\t            \"remove_pony_test_remove_constraint_pony_pink_gt_2\",\n  3469\t        )\n  3470\t        # Test state alteration\n  3471\t        new_state = project_state.clone()\n  3472\t        gt_operation.state_forwards(\"test_removeconstraint\", new_state)\n  3473\t        self.assertEqual(\n  3474\t            len(\n  3475\t                new_state.models[\"test_removeconstraint\", \"pony\"].options[\"constraints\"]\n  3476\t            ),\n  3477\t            1,\n  3478\t        )\n  3479\t        Pony = new_state.apps.get_model(\"test_removeconstraint\", \"Pony\")\n  3480\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3481\t        # Test database alteration\n  3482\t        with connection.schema_editor() as editor:\n  3483\t            gt_operation.database_forwards(\n  3484\t                \"test_removeconstraint\", editor, project_state, new_state\n  3485\t            )\n  3486\t        Pony.objects.create(pink=1, weight=1.0).delete()\n  3487\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3488\t            Pony.objects.create(pink=100, weight=1.0)\n  3489\t        # Remove the other one.\n  3490\t        lt_operation = migrations.RemoveConstraint(\n  3491\t            \"Pony\", \"test_remove_constraint_pony_pink_lt_100\"\n  3492\t        )\n  3493\t        lt_operation.state_forwards(\"test_removeconstraint\", new_state)\n  3494\t        self.assertEqual(\n  3495\t            len(\n  3496\t                new_state.models[\"test_removeconstraint\", \"pony\"].options[\"constraints\"]\n  3497\t            ),\n  3498\t            0,\n  3499\t        )\n  3500\t        Pony = new_state.apps.get_model(\"test_removeconstraint\", \"Pony\")\n  3501\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3502\t        with connection.schema_editor() as editor:\n  3503\t            lt_operation.database_forwards(\n  3504\t                \"test_removeconstraint\", editor, project_state, new_state\n  3505\t            )\n  3506\t        Pony.objects.create(pink=100, weight=1.0).delete()\n  3507\t        # Test reversal\n  3508\t        with connection.schema_editor() as editor:\n  3509\t            gt_operation.database_backwards(\n  3510\t                \"test_removeconstraint\", editor, new_state, project_state\n  3511\t            )\n  3512\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3513\t            Pony.objects.create(pink=1, weight=1.0)\n  3514\t        # Test deconstruction\n  3515\t        definition = gt_operation.deconstruct()\n  3516\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3517\t        self.assertEqual(definition[1], [])\n  3518\t        self.assertEqual(\n  3519\t            definition[2],\n  3520\t            {\"model_name\": \"Pony\", \"name\": \"test_remove_constraint_pony_pink_gt_2\"},\n  3521\t        )\n  3522\t\n  3523\t    def test_add_partial_unique_constraint(self):\n  3524\t        project_state = self.set_up_test_model(\"test_addpartialuniqueconstraint\")\n  3525\t        partial_unique_constraint = models.UniqueConstraint(\n  3526\t            fields=[\"pink\"],\n  3527\t            condition=models.Q(weight__gt=5),\n  3528\t            name=\"test_constraint_pony_pink_for_weight_gt_5_uniq\",\n  3529\t        )\n  3530\t        operation = migrations.AddConstraint(\"Pony\", partial_unique_constraint)\n  3531\t        self.assertEqual(\n  3532\t            operation.describe(),\n  3533\t            \"Create constraint test_constraint_pony_pink_for_weight_gt_5_uniq \"\n  3534\t            \"on model Pony\",\n  3535\t        )\n  3536\t        # Test the state alteration\n  3537\t        new_state = project_state.clone()\n  3538\t        operation.state_forwards(\"test_addpartialuniqueconstraint\", new_state)\n  3539\t        self.assertEqual(\n  3540\t            len(\n  3541\t                new_state.models[\"test_addpartialuniqueconstraint\", \"pony\"].options[\n  3542\t                    \"constraints\"\n  3543\t                ]\n  3544\t            ),\n  3545\t            1,\n  3546\t        )\n  3547\t        Pony = new_state.apps.get_model(\"test_addpartialuniqueconstraint\", \"Pony\")\n  3548\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3549\t        # Test the database alteration\n  3550\t        with connection.schema_editor() as editor:\n  3551\t            operation.database_forwards(\n  3552\t                \"test_addpartialuniqueconstraint\", editor, project_state, new_state\n  3553\t            )\n  3554\t        # Test constraint works\n  3555\t        Pony.objects.create(pink=1, weight=4.0)\n  3556\t        Pony.objects.create(pink=1, weight=4.0)\n  3557\t        Pony.objects.create(pink=1, weight=6.0)\n  3558\t        if connection.features.supports_partial_indexes:\n  3559\t            with self.assertRaises(IntegrityError), transaction.atomic():\n  3560\t                Pony.objects.create(pink=1, weight=7.0)\n  3561\t        else:\n  3562\t            Pony.objects.create(pink=1, weight=7.0)\n  3563\t        # Test reversal\n  3564\t        with connection.schema_editor() as editor:\n  3565\t            operation.database_backwards(\n  3566\t                \"test_addpartialuniqueconstraint\", editor, new_state, project_state\n  3567\t            )\n  3568\t        # Test constraint doesn't work\n  3569\t        Pony.objects.create(pink=1, weight=7.0)\n  3570\t        # Test deconstruction\n  3571\t        definition = operation.deconstruct()\n  3572\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3573\t        self.assertEqual(definition[1], [])\n  3574\t        self.assertEqual(\n  3575\t            definition[2],\n  3576\t            {\"model_name\": \"Pony\", \"constraint\": partial_unique_constraint},\n  3577\t        )\n  3578\t\n  3579\t    def test_remove_partial_unique_constraint(self):\n  3580\t        project_state = self.set_up_test_model(\n  3581\t            \"test_removepartialuniqueconstraint\",\n  3582\t            constraints=[\n  3583\t                models.UniqueConstraint(\n  3584\t                    fields=[\"pink\"],\n  3585\t                    condition=models.Q(weight__gt=5),\n  3586\t                    name=\"test_constraint_pony_pink_for_weight_gt_5_uniq\",\n  3587\t                ),\n  3588\t            ],\n  3589\t        )\n  3590\t        gt_operation = migrations.RemoveConstraint(\n  3591\t            \"Pony\", \"test_constraint_pony_pink_for_weight_gt_5_uniq\"\n  3592\t        )\n  3593\t        self.assertEqual(\n  3594\t            gt_operation.describe(),\n  3595\t            \"Remove constraint test_constraint_pony_pink_for_weight_gt_5_uniq from \"\n  3596\t            \"model Pony\",\n  3597\t        )\n  3598\t        # Test state alteration\n  3599\t        new_state = project_state.clone()\n  3600\t        gt_operation.state_forwards(\"test_removepartialuniqueconstraint\", new_state)\n  3601\t        self.assertEqual(\n  3602\t            len(\n  3603\t                new_state.models[\"test_removepartialuniqueconstraint\", \"pony\"].options[\n  3604\t                    \"constraints\"\n  3605\t                ]\n  3606\t            ),\n  3607\t            0,\n  3608\t        )\n  3609\t        Pony = new_state.apps.get_model(\"test_removepartialuniqueconstraint\", \"Pony\")\n  3610\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3611\t        # Test database alteration\n  3612\t        with connection.schema_editor() as editor:\n  3613\t            gt_operation.database_forwards(\n  3614\t                \"test_removepartialuniqueconstraint\", editor, project_state, new_state\n  3615\t            )\n  3616\t        # Test constraint doesn't work\n  3617\t        Pony.objects.create(pink=1, weight=4.0)\n  3618\t        Pony.objects.create(pink=1, weight=4.0)\n  3619\t        Pony.objects.create(pink=1, weight=6.0)\n  3620\t        Pony.objects.create(pink=1, weight=7.0).delete()\n  3621\t        # Test reversal\n  3622\t        with connection.schema_editor() as editor:\n  3623\t            gt_operation.database_backwards(\n  3624\t                \"test_removepartialuniqueconstraint\", editor, new_state, project_state\n  3625\t            )\n  3626\t        # Test constraint works\n  3627\t        if connection.features.supports_partial_indexes:\n  3628\t            with self.assertRaises(IntegrityError), transaction.atomic():\n  3629\t                Pony.objects.create(pink=1, weight=7.0)\n  3630\t        else:\n  3631\t            Pony.objects.create(pink=1, weight=7.0)\n  3632\t        # Test deconstruction\n  3633\t        definition = gt_operation.deconstruct()\n  3634\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3635\t        self.assertEqual(definition[1], [])\n  3636\t        self.assertEqual(\n  3637\t            definition[2],\n  3638\t            {\n  3639\t                \"model_name\": \"Pony\",\n  3640\t                \"name\": \"test_constraint_pony_pink_for_weight_gt_5_uniq\",\n  3641\t            },\n  3642\t        )\n  3643\t\n  3644\t    def test_add_deferred_unique_constraint(self):\n  3645\t        app_label = \"test_adddeferred_uc\"\n  3646\t        project_state = self.set_up_test_model(app_label)\n  3647\t        deferred_unique_constraint = models.UniqueConstraint(\n  3648\t            fields=[\"pink\"],\n  3649\t            name=\"deferred_pink_constraint_add\",\n  3650\t            deferrable=models.Deferrable.DEFERRED,\n  3651\t        )\n  3652\t        operation = migrations.AddConstraint(\"Pony\", deferred_unique_constraint)\n  3653\t        self.assertEqual(\n  3654\t            operation.describe(),\n  3655\t            \"Create constraint deferred_pink_constraint_add on model Pony\",\n  3656\t        )\n  3657\t        # Add constraint.\n  3658\t        new_state = project_state.clone()\n  3659\t        operation.state_forwards(app_label, new_state)\n  3660\t        self.assertEqual(\n  3661\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 1\n  3662\t        )\n  3663\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3664\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3665\t        with connection.schema_editor() as editor, CaptureQueriesContext(\n  3666\t            connection\n  3667\t        ) as ctx:\n  3668\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3669\t        Pony.objects.create(pink=1, weight=4.0)\n  3670\t        if connection.features.supports_deferrable_unique_constraints:\n  3671\t            # Unique constraint is deferred.\n  3672\t            with transaction.atomic():\n  3673\t                obj = Pony.objects.create(pink=1, weight=4.0)\n  3674\t                obj.pink = 2\n  3675\t                obj.save()\n  3676\t            # Constraint behavior can be changed with SET CONSTRAINTS.\n  3677\t            with self.assertRaises(IntegrityError):\n  3678\t                with transaction.atomic(), connection.cursor() as cursor:\n  3679\t                    quoted_name = connection.ops.quote_name(\n  3680\t                        deferred_unique_constraint.name\n  3681\t                    )\n  3682\t                    cursor.execute(\"SET CONSTRAINTS %s IMMEDIATE\" % quoted_name)\n  3683\t                    obj = Pony.objects.create(pink=1, weight=4.0)\n  3684\t                    obj.pink = 3\n  3685\t                    obj.save()\n  3686\t        else:\n  3687\t            self.assertEqual(len(ctx), 0)\n  3688\t            Pony.objects.create(pink=1, weight=4.0)\n  3689\t        # Reversal.\n  3690\t        with connection.schema_editor() as editor:\n  3691\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3692\t        # Constraint doesn't work.\n  3693\t        Pony.objects.create(pink=1, weight=4.0)\n  3694\t        # Deconstruction.\n  3695\t        definition = operation.deconstruct()\n  3696\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3697\t        self.assertEqual(definition[1], [])\n  3698\t        self.assertEqual(\n  3699\t            definition[2],\n  3700\t            {\"model_name\": \"Pony\", \"constraint\": deferred_unique_constraint},\n  3701\t        )\n  3702\t\n  3703\t    def test_remove_deferred_unique_constraint(self):\n  3704\t        app_label = \"test_removedeferred_uc\"\n  3705\t        deferred_unique_constraint = models.UniqueConstraint(\n  3706\t            fields=[\"pink\"],\n  3707\t            name=\"deferred_pink_constraint_rm\",\n  3708\t            deferrable=models.Deferrable.DEFERRED,\n  3709\t        )\n  3710\t        project_state = self.set_up_test_model(\n  3711\t            app_label, constraints=[deferred_unique_constraint]\n  3712\t        )\n  3713\t        operation = migrations.RemoveConstraint(\"Pony\", deferred_unique_constraint.name)\n  3714\t        self.assertEqual(\n  3715\t            operation.describe(),\n  3716\t            \"Remove constraint deferred_pink_constraint_rm from model Pony\",\n  3717\t        )\n  3718\t        # Remove constraint.\n  3719\t        new_state = project_state.clone()\n  3720\t        operation.state_forwards(app_label, new_state)\n  3721\t        self.assertEqual(\n  3722\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 0\n  3723\t        )\n  3724\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3725\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3726\t        with connection.schema_editor() as editor, CaptureQueriesContext(\n  3727\t            connection\n  3728\t        ) as ctx:\n  3729\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3730\t        # Constraint doesn't work.\n  3731\t        Pony.objects.create(pink=1, weight=4.0)\n  3732\t        Pony.objects.create(pink=1, weight=4.0).delete()\n  3733\t        if not connection.features.supports_deferrable_unique_constraints:\n  3734\t            self.assertEqual(len(ctx), 0)\n  3735\t        # Reversal.\n  3736\t        with connection.schema_editor() as editor:\n  3737\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3738\t        if connection.features.supports_deferrable_unique_constraints:\n  3739\t            # Unique constraint is deferred.\n  3740\t            with transaction.atomic():\n  3741\t                obj = Pony.objects.create(pink=1, weight=4.0)\n  3742\t                obj.pink = 2\n  3743\t                obj.save()\n  3744\t            # Constraint behavior can be changed with SET CONSTRAINTS.\n  3745\t            with self.assertRaises(IntegrityError):\n  3746\t                with transaction.atomic(), connection.cursor() as cursor:\n  3747\t                    quoted_name = connection.ops.quote_name(\n  3748\t                        deferred_unique_constraint.name\n  3749\t                    )\n  3750\t                    cursor.execute(\"SET CONSTRAINTS %s IMMEDIATE\" % quoted_name)\n  3751\t                    obj = Pony.objects.create(pink=1, weight=4.0)\n  3752\t                    obj.pink = 3\n  3753\t                    obj.save()\n  3754\t        else:\n  3755\t            Pony.objects.create(pink=1, weight=4.0)\n  3756\t        # Deconstruction.\n  3757\t        definition = operation.deconstruct()\n  3758\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3759\t        self.assertEqual(definition[1], [])\n  3760\t        self.assertEqual(\n  3761\t            definition[2],\n  3762\t            {\n  3763\t                \"model_name\": \"Pony\",\n  3764\t                \"name\": \"deferred_pink_constraint_rm\",\n  3765\t            },\n  3766\t        )\n  3767\t\n  3768\t    def test_add_covering_unique_constraint(self):\n  3769\t        app_label = \"test_addcovering_uc\"\n  3770\t        project_state = self.set_up_test_model(app_label)\n  3771\t        covering_unique_constraint = models.UniqueConstraint(\n  3772\t            fields=[\"pink\"],\n  3773\t            name=\"covering_pink_constraint_add\",\n  3774\t            include=[\"weight\"],\n  3775\t        )\n  3776\t        operation = migrations.AddConstraint(\"Pony\", covering_unique_constraint)\n  3777\t        self.assertEqual(\n  3778\t            operation.describe(),\n  3779\t            \"Create constraint covering_pink_constraint_add on model Pony\",\n  3780\t        )\n  3781\t        # Add constraint.\n  3782\t        new_state = project_state.clone()\n  3783\t        operation.state_forwards(app_label, new_state)\n  3784\t        self.assertEqual(\n  3785\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 1\n  3786\t        )\n  3787\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3788\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3789\t        with connection.schema_editor() as editor, CaptureQueriesContext(\n  3790\t            connection\n  3791\t        ) as ctx:\n  3792\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3793\t        Pony.objects.create(pink=1, weight=4.0)\n  3794\t        if connection.features.supports_covering_indexes:\n  3795\t            with self.assertRaises(IntegrityError):\n  3796\t                Pony.objects.create(pink=1, weight=4.0)\n  3797\t        else:\n  3798\t            self.assertEqual(len(ctx), 0)\n  3799\t            Pony.objects.create(pink=1, weight=4.0)\n  3800\t        # Reversal.\n  3801\t        with connection.schema_editor() as editor:\n  3802\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3803\t        # Constraint doesn't work.\n  3804\t        Pony.objects.create(pink=1, weight=4.0)\n  3805\t        # Deconstruction.\n  3806\t        definition = operation.deconstruct()\n  3807\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3808\t        self.assertEqual(definition[1], [])\n  3809\t        self.assertEqual(\n  3810\t            definition[2],\n  3811\t            {\"model_name\": \"Pony\", \"constraint\": covering_unique_constraint},\n  3812\t        )\n  3813\t\n  3814\t    def test_remove_covering_unique_constraint(self):\n  3815\t        app_label = \"test_removecovering_uc\"\n  3816\t        covering_unique_constraint = models.UniqueConstraint(\n  3817\t            fields=[\"pink\"],\n  3818\t            name=\"covering_pink_constraint_rm\",\n  3819\t            include=[\"weight\"],\n  3820\t        )\n  3821\t        project_state = self.set_up_test_model(\n  3822\t            app_label, constraints=[covering_unique_constraint]\n  3823\t        )\n  3824\t        operation = migrations.RemoveConstraint(\"Pony\", covering_unique_constraint.name)\n  3825\t        self.assertEqual(\n  3826\t            operation.describe(),\n  3827\t            \"Remove constraint covering_pink_constraint_rm from model Pony\",\n  3828\t        )\n  3829\t        # Remove constraint.\n  3830\t        new_state = project_state.clone()\n  3831\t        operation.state_forwards(app_label, new_state)\n  3832\t        self.assertEqual(\n  3833\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 0\n  3834\t        )\n  3835\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3836\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3837\t        with connection.schema_editor() as editor, CaptureQueriesContext(\n  3838\t            connection\n  3839\t        ) as ctx:\n  3840\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3841\t        # Constraint doesn't work.\n  3842\t        Pony.objects.create(pink=1, weight=4.0)\n  3843\t        Pony.objects.create(pink=1, weight=4.0).delete()\n  3844\t        if not connection.features.supports_covering_indexes:\n  3845\t            self.assertEqual(len(ctx), 0)\n  3846\t        # Reversal.\n  3847\t        with connection.schema_editor() as editor:\n  3848\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3849\t        if connection.features.supports_covering_indexes:\n  3850\t            with self.assertRaises(IntegrityError):\n  3851\t                Pony.objects.create(pink=1, weight=4.0)\n  3852\t        else:\n  3853\t            Pony.objects.create(pink=1, weight=4.0)\n  3854\t        # Deconstruction.\n  3855\t        definition = operation.deconstruct()\n  3856\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3857\t        self.assertEqual(definition[1], [])\n  3858\t        self.assertEqual(\n  3859\t            definition[2],\n  3860\t            {\n  3861\t                \"model_name\": \"Pony\",\n  3862\t                \"name\": \"covering_pink_constraint_rm\",\n  3863\t            },\n  3864\t        )\n  3865\t\n  3866\t    def test_alter_field_with_func_unique_constraint(self):\n  3867\t        app_label = \"test_alfuncuc\"\n  3868\t        constraint_name = f\"{app_label}_pony_uq\"\n  3869\t        table_name = f\"{app_label}_pony\"\n  3870\t        project_state = self.set_up_test_model(\n  3871\t            app_label,\n  3872\t            constraints=[\n  3873\t                models.UniqueConstraint(\"pink\", \"weight\", name=constraint_name)\n  3874\t            ],\n  3875\t        )\n  3876\t        operation = migrations.AlterField(\n  3877\t            \"Pony\", \"pink\", models.IntegerField(null=True)\n  3878\t        )\n  3879\t        new_state = project_state.clone()\n  3880\t        operation.state_forwards(app_label, new_state)\n  3881\t        with connection.schema_editor() as editor:\n  3882\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3883\t        if connection.features.supports_expression_indexes:\n  3884\t            self.assertIndexNameExists(table_name, constraint_name)\n  3885\t        with connection.schema_editor() as editor:\n  3886\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3887\t        if connection.features.supports_expression_indexes:\n  3888\t            self.assertIndexNameExists(table_name, constraint_name)\n  3889\t\n  3890\t    def test_add_func_unique_constraint(self):\n  3891\t        app_label = \"test_adfuncuc\"\n  3892\t        constraint_name = f\"{app_label}_pony_abs_uq\"\n  3893\t        table_name = f\"{app_label}_pony\"\n  3894\t        project_state = self.set_up_test_model(app_label)\n  3895\t        constraint = models.UniqueConstraint(Abs(\"weight\"), name=constraint_name)\n  3896\t        operation = migrations.AddConstraint(\"Pony\", constraint)\n  3897\t        self.assertEqual(\n  3898\t            operation.describe(),\n  3899\t            \"Create constraint test_adfuncuc_pony_abs_uq on model Pony\",\n  3900\t        )\n  3901\t        self.assertEqual(\n  3902\t            operation.migration_name_fragment,\n  3903\t            \"pony_test_adfuncuc_pony_abs_uq\",\n  3904\t        )\n  3905\t        new_state = project_state.clone()\n  3906\t        operation.state_forwards(app_label, new_state)\n  3907\t        self.assertEqual(\n  3908\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 1\n  3909\t        )\n  3910\t        self.assertIndexNameNotExists(table_name, constraint_name)\n  3911\t        # Add constraint.\n  3912\t        with connection.schema_editor() as editor:\n  3913\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3914\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3915\t        Pony.objects.create(weight=4.0)\n  3916\t        if connection.features.supports_expression_indexes:\n  3917\t            self.assertIndexNameExists(table_name, constraint_name)\n  3918\t            with self.assertRaises(IntegrityError):\n  3919\t                Pony.objects.create(weight=-4.0)\n  3920\t        else:\n  3921\t            self.assertIndexNameNotExists(table_name, constraint_name)\n  3922\t            Pony.objects.create(weight=-4.0)\n  3923\t        # Reversal.\n  3924\t        with connection.schema_editor() as editor:\n  3925\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3926\t        self.assertIndexNameNotExists(table_name, constraint_name)\n  3927\t        # Constraint doesn't work.\n  3928\t        Pony.objects.create(weight=-4.0)\n  3929\t        # Deconstruction.\n  3930\t        definition = operation.deconstruct()\n  3931\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3932\t        self.assertEqual(definition[1], [])\n  3933\t        self.assertEqual(\n  3934\t            definition[2],\n  3935\t            {\"model_name\": \"Pony\", \"constraint\": constraint},\n  3936\t        )\n  3937\t\n  3938\t    def test_remove_func_unique_constraint(self):\n  3939\t        app_label = \"test_rmfuncuc\"\n  3940\t        constraint_name = f\"{app_label}_pony_abs_uq\"\n  3941\t        table_name = f\"{app_label}_pony\"\n  3942\t        project_state = self.set_up_test_model(\n  3943\t            app_label,\n  3944\t            constraints=[\n  3945\t                models.UniqueConstraint(Abs(\"weight\"), name=constraint_name),\n  3946\t            ],\n  3947\t        )\n  3948\t        self.assertTableExists(table_name)\n  3949\t        if connection.features.supports_expression_indexes:\n  3950\t            self.assertIndexNameExists(table_name, constraint_name)\n  3951\t        operation = migrations.RemoveConstraint(\"Pony\", constraint_name)\n  3952\t        self.assertEqual(\n  3953\t            operation.describe(),\n  3954\t            \"Remove constraint test_rmfuncuc_pony_abs_uq from model Pony\",\n  3955\t        )\n  3956\t        self.assertEqual(\n  3957\t            operation.migration_name_fragment,\n  3958\t            \"remove_pony_test_rmfuncuc_pony_abs_uq\",\n  3959\t        )\n  3960\t        new_state = project_state.clone()\n  3961\t        operation.state_forwards(app_label, new_state)\n  3962\t        self.assertEqual(\n  3963\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 0\n  3964\t        )\n  3965\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3966\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3967\t        # Remove constraint.\n  3968\t        with connection.schema_editor() as editor:\n  3969\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3970\t        self.assertIndexNameNotExists(table_name, constraint_name)\n  3971\t        # Constraint doesn't work.\n  3972\t        Pony.objects.create(pink=1, weight=4.0)\n  3973\t        Pony.objects.create(pink=1, weight=-4.0).delete()\n  3974\t        # Reversal.\n  3975\t        with connection.schema_editor() as editor:\n  3976\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3977\t        if connection.features.supports_expression_indexes:\n  3978\t            self.assertIndexNameExists(table_name, constraint_name)\n  3979\t            with self.assertRaises(IntegrityError):\n  3980\t                Pony.objects.create(weight=-4.0)\n  3981\t        else:\n  3982\t            self.assertIndexNameNotExists(table_name, constraint_name)\n  3983\t            Pony.objects.create(weight=-4.0)\n  3984\t        # Deconstruction.\n  3985\t        definition = operation.deconstruct()\n  3986\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3987\t        self.assertEqual(definition[1], [])\n  3988\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"name\": constraint_name})\n  3989\t\n  3990\t    def test_alter_model_options(self):\n  3991\t        \"\"\"\n  3992\t        Tests the AlterModelOptions operation.\n  3993\t        \"\"\"\n  3994\t        project_state = self.set_up_test_model(\"test_almoop\")\n  3995\t        # Test the state alteration (no DB alteration to test)\n  3996\t        operation = migrations.AlterModelOptions(\n  3997\t            \"Pony\", {\"permissions\": [(\"can_groom\", \"Can groom\")]}\n  3998\t        )\n  3999\t        self.assertEqual(operation.describe(), \"Change Meta options on Pony\")\n  4000\t        self.assertEqual(operation.migration_name_fragment, \"alter_pony_options\")\n  4001\t        new_state = project_state.clone()\n  4002\t        operation.state_forwards(\"test_almoop\", new_state)\n  4003\t        self.assertEqual(\n  4004\t            len(\n  4005\t                project_state.models[\"test_almoop\", \"pony\"].options.get(\n  4006\t                    \"permissions\", []\n  4007\t                )\n  4008\t            ),\n  4009\t            0,\n  4010\t        )\n  4011\t        self.assertEqual(\n  4012\t            len(new_state.models[\"test_almoop\", \"pony\"].options.get(\"permissions\", [])),\n  4013\t            1,\n  4014\t        )\n  4015\t        self.assertEqual(\n  4016\t            new_state.models[\"test_almoop\", \"pony\"].options[\"permissions\"][0][0],\n  4017\t            \"can_groom\",\n  4018\t        )\n  4019\t        # And deconstruction\n  4020\t        definition = operation.deconstruct()\n  4021\t        self.assertEqual(definition[0], \"AlterModelOptions\")\n  4022\t        self.assertEqual(definition[1], [])\n  4023\t        self.assertEqual(\n  4024\t            definition[2],\n  4025\t            {\"name\": \"Pony\", \"options\": {\"permissions\": [(\"can_groom\", \"Can groom\")]}},\n  4026\t        )\n  4027\t\n  4028\t    def test_alter_model_options_emptying(self):\n  4029\t        \"\"\"\n  4030\t        The AlterModelOptions operation removes keys from the dict (#23121)\n  4031\t        \"\"\"\n  4032\t        project_state = self.set_up_test_model(\"test_almoop\", options=True)\n  4033\t        # Test the state alteration (no DB alteration to test)\n  4034\t        operation = migrations.AlterModelOptions(\"Pony\", {})\n  4035\t        self.assertEqual(operation.describe(), \"Change Meta options on Pony\")\n  4036\t        new_state = project_state.clone()\n  4037\t        operation.state_forwards(\"test_almoop\", new_state)\n  4038\t        self.assertEqual(\n  4039\t            len(\n  4040\t                project_state.models[\"test_almoop\", \"pony\"].options.get(\n  4041\t                    \"permissions\", []\n  4042\t                )\n  4043\t            ),\n  4044\t            1,\n  4045\t        )\n  4046\t        self.assertEqual(\n  4047\t            len(new_state.models[\"test_almoop\", \"pony\"].options.get(\"permissions\", [])),\n  4048\t            0,\n  4049\t        )\n  4050\t        # And deconstruction\n  4051\t        definition = operation.deconstruct()\n  4052\t        self.assertEqual(definition[0], \"AlterModelOptions\")\n  4053\t        self.assertEqual(definition[1], [])\n  4054\t        self.assertEqual(definition[2], {\"name\": \"Pony\", \"options\": {}})\n  4055\t\n  4056\t    def test_alter_order_with_respect_to(self):\n  4057\t        \"\"\"\n  4058\t        Tests the AlterOrderWithRespectTo operation.\n  4059\t        \"\"\"\n  4060\t        project_state = self.set_up_test_model(\"test_alorwrtto\", related_model=True)\n  4061\t        # Test the state alteration\n  4062\t        operation = migrations.AlterOrderWithRespectTo(\"Rider\", \"pony\")\n  4063\t        self.assertEqual(\n  4064\t            operation.describe(), \"Set order_with_respect_to on Rider to pony\"\n  4065\t        )\n  4066\t        self.assertEqual(\n  4067\t            operation.migration_name_fragment,\n  4068\t            \"alter_rider_order_with_respect_to\",\n  4069\t        )\n  4070\t        new_state = project_state.clone()\n  4071\t        operation.state_forwards(\"test_alorwrtto\", new_state)\n  4072\t        self.assertIsNone(\n  4073\t            project_state.models[\"test_alorwrtto\", \"rider\"].options.get(\n  4074\t                \"order_with_respect_to\", None\n  4075\t            )\n  4076\t        )\n  4077\t        self.assertEqual(\n  4078\t            new_state.models[\"test_alorwrtto\", \"rider\"].options.get(\n  4079\t                \"order_with_respect_to\", None\n  4080\t            ),\n  4081\t            \"pony\",\n  4082\t        )\n  4083\t        # Make sure there's no matching index\n  4084\t        self.assertColumnNotExists(\"test_alorwrtto_rider\", \"_order\")\n  4085\t        # Create some rows before alteration\n  4086\t        rendered_state = project_state.apps\n  4087\t        pony = rendered_state.get_model(\"test_alorwrtto\", \"Pony\").objects.create(\n  4088\t            weight=50\n  4089\t        )\n  4090\t        rider1 = rendered_state.get_model(\"test_alorwrtto\", \"Rider\").objects.create(\n  4091\t            pony=pony\n  4092\t        )\n  4093\t        rider1.friend = rider1\n  4094\t        rider1.save()\n  4095\t        rider2 = rendered_state.get_model(\"test_alorwrtto\", \"Rider\").objects.create(\n  4096\t            pony=pony\n  4097\t        )\n  4098\t        rider2.friend = rider2\n  4099\t        rider2.save()\n  4100\t        # Test the database alteration\n  4101\t        with connection.schema_editor() as editor:\n  4102\t            operation.database_forwards(\n  4103\t                \"test_alorwrtto\", editor, project_state, new_state\n  4104\t            )\n  4105\t        self.assertColumnExists(\"test_alorwrtto_rider\", \"_order\")\n  4106\t        # Check for correct value in rows\n  4107\t        updated_riders = new_state.apps.get_model(\n  4108\t            \"test_alorwrtto\", \"Rider\"\n  4109\t        ).objects.all()\n  4110\t        self.assertEqual(updated_riders[0]._order, 0)\n  4111\t        self.assertEqual(updated_riders[1]._order, 0)\n  4112\t        # And test reversal\n  4113\t        with connection.schema_editor() as editor:\n  4114\t            operation.database_backwards(\n  4115\t                \"test_alorwrtto\", editor, new_state, project_state\n  4116\t            )\n  4117\t        self.assertColumnNotExists(\"test_alorwrtto_rider\", \"_order\")\n  4118\t        # And deconstruction\n  4119\t        definition = operation.deconstruct()\n  4120\t        self.assertEqual(definition[0], \"AlterOrderWithRespectTo\")\n  4121\t        self.assertEqual(definition[1], [])\n  4122\t        self.assertEqual(\n  4123\t            definition[2], {\"name\": \"Rider\", \"order_with_respect_to\": \"pony\"}\n  4124\t        )\n  4125\t\n  4126\t    def test_alter_model_managers(self):\n  4127\t        \"\"\"\n  4128\t        The managers on a model are set.\n  4129\t        \"\"\"\n  4130\t        project_state = self.set_up_test_model(\"test_almoma\")\n  4131\t        # Test the state alteration\n  4132\t        operation = migrations.AlterModelManagers(\n  4133\t            \"Pony\",\n  4134\t            managers=[\n  4135\t                (\"food_qs\", FoodQuerySet.as_manager()),\n  4136\t                (\"food_mgr\", FoodManager(\"a\", \"b\")),\n  4137\t                (\"food_mgr_kwargs\", FoodManager(\"x\", \"y\", 3, 4)),\n  4138\t            ],\n  4139\t        )\n  4140\t        self.assertEqual(operation.describe(), \"Change managers on Pony\")\n  4141\t        self.assertEqual(operation.migration_name_fragment, \"alter_pony_managers\")\n  4142\t        managers = project_state.models[\"test_almoma\", \"pony\"].managers\n  4143\t        self.assertEqual(managers, [])\n  4144\t\n  4145\t        new_state = project_state.clone()\n  4146\t        operation.state_forwards(\"test_almoma\", new_state)\n  4147\t        self.assertIn((\"test_almoma\", \"pony\"), new_state.models)\n  4148\t        managers = new_state.models[\"test_almoma\", \"pony\"].managers\n  4149\t        self.assertEqual(managers[0][0], \"food_qs\")\n  4150\t        self.assertIsInstance(managers[0][1], models.Manager)\n  4151\t        self.assertEqual(managers[1][0], \"food_mgr\")\n  4152\t        self.assertIsInstance(managers[1][1], FoodManager)\n  4153\t        self.assertEqual(managers[1][1].args, (\"a\", \"b\", 1, 2))\n  4154\t        self.assertEqual(managers[2][0], \"food_mgr_kwargs\")\n  4155\t        self.assertIsInstance(managers[2][1], FoodManager)\n  4156\t        self.assertEqual(managers[2][1].args, (\"x\", \"y\", 3, 4))\n  4157\t        rendered_state = new_state.apps\n  4158\t        model = rendered_state.get_model(\"test_almoma\", \"pony\")\n  4159\t        self.assertIsInstance(model.food_qs, models.Manager)\n  4160\t        self.assertIsInstance(model.food_mgr, FoodManager)\n  4161\t        self.assertIsInstance(model.food_mgr_kwargs, FoodManager)\n  4162\t\n  4163\t    def test_alter_model_managers_emptying(self):\n  4164\t        \"\"\"\n  4165\t        The managers on a model are set.\n  4166\t        \"\"\"\n  4167\t        project_state = self.set_up_test_model(\"test_almomae\", manager_model=True)\n  4168\t        # Test the state alteration\n  4169\t        operation = migrations.AlterModelManagers(\"Food\", managers=[])\n  4170\t        self.assertEqual(operation.describe(), \"Change managers on Food\")\n  4171\t        self.assertIn((\"test_almomae\", \"food\"), project_state.models)\n  4172\t        managers = project_state.models[\"test_almomae\", \"food\"].managers\n  4173\t        self.assertEqual(managers[0][0], \"food_qs\")\n  4174\t        self.assertIsInstance(managers[0][1], models.Manager)\n  4175\t        self.assertEqual(managers[1][0], \"food_mgr\")\n  4176\t        self.assertIsInstance(managers[1][1], FoodManager)\n  4177\t        self.assertEqual(managers[1][1].args, (\"a\", \"b\", 1, 2))\n  4178\t        self.assertEqual(managers[2][0], \"food_mgr_kwargs\")\n  4179\t        self.assertIsInstance(managers[2][1], FoodManager)\n  4180\t        self.assertEqual(managers[2][1].args, (\"x\", \"y\", 3, 4))\n  4181\t\n  4182\t        new_state = project_state.clone()\n  4183\t        operation.state_forwards(\"test_almomae\", new_state)\n  4184\t        managers = new_state.models[\"test_almomae\", \"food\"].managers\n  4185\t        self.assertEqual(managers, [])\n  4186\t\n  4187\t    def test_alter_fk(self):\n  4188\t        \"\"\"\n  4189\t        Creating and then altering an FK works correctly\n  4190\t        and deals with the pending SQL (#23091)\n  4191\t        \"\"\"\n  4192\t        project_state = self.set_up_test_model(\"test_alfk\")\n  4193\t        # Test adding and then altering the FK in one go\n  4194\t        create_operation = migrations.CreateModel(\n  4195\t            name=\"Rider\",\n  4196\t            fields=[\n  4197\t                (\"id\", models.AutoField(primary_key=True)),\n  4198\t                (\"pony\", models.ForeignKey(\"Pony\", models.CASCADE)),\n  4199\t            ],\n  4200\t        )\n  4201\t        create_state = project_state.clone()\n  4202\t        create_operation.state_forwards(\"test_alfk\", create_state)\n  4203\t        alter_operation = migrations.AlterField(\n  4204\t            model_name=\"Rider\",\n  4205\t            name=\"pony\",\n  4206\t            field=models.ForeignKey(\"Pony\", models.CASCADE, editable=False),\n  4207\t        )\n  4208\t        alter_state = create_state.clone()\n  4209\t        alter_operation.state_forwards(\"test_alfk\", alter_state)\n  4210\t        with connection.schema_editor() as editor:\n  4211\t            create_operation.database_forwards(\n  4212\t                \"test_alfk\", editor, project_state, create_state\n  4213\t            )\n  4214\t            alter_operation.database_forwards(\n  4215\t                \"test_alfk\", editor, create_state, alter_state\n  4216\t            )\n  4217\t\n  4218\t    def test_alter_fk_non_fk(self):\n  4219\t        \"\"\"\n  4220\t        Altering an FK to a non-FK works (#23244)\n  4221\t        \"\"\"\n  4222\t        # Test the state alteration\n  4223\t        operation = migrations.AlterField(\n  4224\t            model_name=\"Rider\",\n  4225\t            name=\"pony\",\n  4226\t            field=models.FloatField(),\n  4227\t        )\n  4228\t        project_state, new_state = self.make_test_state(\n  4229\t            \"test_afknfk\", operation, related_model=True\n  4230\t        )\n  4231\t        # Test the database alteration\n  4232\t        self.assertColumnExists(\"test_afknfk_rider\", \"pony_id\")\n  4233\t        self.assertColumnNotExists(\"test_afknfk_rider\", \"pony\")\n  4234\t        with connection.schema_editor() as editor:\n  4235\t            operation.database_forwards(\"test_afknfk\", editor, project_state, new_state)\n  4236\t        self.assertColumnExists(\"test_afknfk_rider\", \"pony\")\n  4237\t        self.assertColumnNotExists(\"test_afknfk_rider\", \"pony_id\")\n  4238\t        # And test reversal\n  4239\t        with connection.schema_editor() as editor:\n  4240\t            operation.database_backwards(\n  4241\t                \"test_afknfk\", editor, new_state, project_state\n  4242\t            )\n  4243\t        self.assertColumnExists(\"test_afknfk_rider\", \"pony_id\")\n  4244\t        self.assertColumnNotExists(\"test_afknfk_rider\", \"pony\")\n  4245\t\n  4246\t    def test_run_sql(self):\n  4247\t        \"\"\"\n  4248\t        Tests the RunSQL operation.\n  4249\t        \"\"\"\n  4250\t        project_state = self.set_up_test_model(\"test_runsql\")\n  4251\t        # Create the operation\n  4252\t        operation = migrations.RunSQL(\n  4253\t            # Use a multi-line string with a comment to test splitting on\n  4254\t            # SQLite and MySQL respectively.\n  4255\t            \"CREATE TABLE i_love_ponies (id int, special_thing varchar(15));\\n\"\n  4256\t            \"INSERT INTO i_love_ponies (id, special_thing) \"\n  4257\t            \"VALUES (1, 'i love ponies'); -- this is magic!\\n\"\n  4258\t            \"INSERT INTO i_love_ponies (id, special_thing) \"\n  4259\t            \"VALUES (2, 'i love django');\\n\"\n  4260\t            \"UPDATE i_love_ponies SET special_thing = 'Ponies' \"\n  4261\t            \"WHERE special_thing LIKE '%%ponies';\"\n  4262\t            \"UPDATE i_love_ponies SET special_thing = 'Django' \"\n  4263\t            \"WHERE special_thing LIKE '%django';\",\n  4264\t            # Run delete queries to test for parameter substitution failure\n  4265\t            # reported in #23426\n  4266\t            \"DELETE FROM i_love_ponies WHERE special_thing LIKE '%Django%';\"\n  4267\t            \"DELETE FROM i_love_ponies WHERE special_thing LIKE '%%Ponies%%';\"\n  4268\t            \"DROP TABLE i_love_ponies\",\n  4269\t            state_operations=[\n  4270\t                migrations.CreateModel(\n  4271\t                    \"SomethingElse\", [(\"id\", models.AutoField(primary_key=True))]\n  4272\t                )\n  4273\t            ],\n  4274\t        )\n  4275\t        self.assertEqual(operation.describe(), \"Raw SQL operation\")\n  4276\t        # Test the state alteration\n  4277\t        new_state = project_state.clone()\n  4278\t        operation.state_forwards(\"test_runsql\", new_state)\n  4279\t        self.assertEqual(\n  4280\t            len(new_state.models[\"test_runsql\", \"somethingelse\"].fields), 1\n  4281\t        )\n  4282\t        # Make sure there's no table\n  4283\t        self.assertTableNotExists(\"i_love_ponies\")\n  4284\t        # Test SQL collection\n  4285\t        with connection.schema_editor(collect_sql=True) as editor:\n  4286\t            operation.database_forwards(\"test_runsql\", editor, project_state, new_state)\n  4287\t            self.assertIn(\"LIKE '%%ponies';\", \"\\n\".join(editor.collected_sql))\n  4288\t            operation.database_backwards(\n  4289\t                \"test_runsql\", editor, project_state, new_state\n  4290\t            )\n  4291\t            self.assertIn(\"LIKE '%%Ponies%%';\", \"\\n\".join(editor.collected_sql))\n  4292\t        # Test the database alteration\n  4293\t        with connection.schema_editor() as editor:\n  4294\t            operation.database_forwards(\"test_runsql\", editor, project_state, new_state)\n  4295\t        self.assertTableExists(\"i_love_ponies\")\n  4296\t        # Make sure all the SQL was processed\n  4297\t        with connection.cursor() as cursor:\n  4298\t            cursor.execute(\"SELECT COUNT(*) FROM i_love_ponies\")\n  4299\t            self.assertEqual(cursor.fetchall()[0][0], 2)\n  4300\t            cursor.execute(\n  4301\t                \"SELECT COUNT(*) FROM i_love_ponies WHERE special_thing = 'Django'\"\n  4302\t            )\n  4303\t            self.assertEqual(cursor.fetchall()[0][0], 1)\n  4304\t            cursor.execute(\n  4305\t                \"SELECT COUNT(*) FROM i_love_ponies WHERE special_thing = 'Ponies'\"\n  4306\t            )\n  4307\t            self.assertEqual(cursor.fetchall()[0][0], 1)\n  4308\t        # And test reversal\n  4309\t        self.assertTrue(operation.reversible)\n  4310\t        with connection.schema_editor() as editor:\n  4311\t            operation.database_backwards(\n  4312\t                \"test_runsql\", editor, new_state, project_state\n  4313\t            )\n  4314\t        self.assertTableNotExists(\"i_love_ponies\")\n  4315\t        # And deconstruction\n  4316\t        definition = operation.deconstruct()\n  4317\t        self.assertEqual(definition[0], \"RunSQL\")\n  4318\t        self.assertEqual(definition[1], [])\n  4319\t        self.assertEqual(\n  4320\t            sorted(definition[2]), [\"reverse_sql\", \"sql\", \"state_operations\"]\n  4321\t        )\n  4322\t        # And elidable reduction\n  4323\t        self.assertIs(False, operation.reduce(operation, []))\n  4324\t        elidable_operation = migrations.RunSQL(\"SELECT 1 FROM void;\", elidable=True)\n  4325\t        self.assertEqual(elidable_operation.reduce(operation, []), [operation])\n  4326\t\n  4327\t    def test_run_sql_params(self):\n  4328\t        \"\"\"\n  4329\t        #23426 - RunSQL should accept parameters.\n  4330\t        \"\"\"\n  4331\t        project_state = self.set_up_test_model(\"test_runsql\")\n  4332\t        # Create the operation\n  4333\t        operation = migrations.RunSQL(\n  4334\t            [\"CREATE TABLE i_love_ponies (id int, special_thing varchar(15));\"],\n  4335\t            [\"DROP TABLE i_love_ponies\"],\n  4336\t        )\n  4337\t        param_operation = migrations.RunSQL(\n  4338\t            # forwards\n  4339\t            (\n  4340\t                \"INSERT INTO i_love_ponies (id, special_thing) VALUES (1, 'Django');\",\n  4341\t                [\n  4342\t                    \"INSERT INTO i_love_ponies (id, special_thing) VALUES (2, %s);\",\n  4343\t                    [\"Ponies\"],\n  4344\t                ],\n  4345\t                (\n  4346\t                    \"INSERT INTO i_love_ponies (id, special_thing) VALUES (%s, %s);\",\n  4347\t                    (\n  4348\t                        3,\n  4349\t                        \"Python\",\n  4350\t                    ),\n  4351\t                ),\n  4352\t            ),\n  4353\t            # backwards\n  4354\t            [\n  4355\t                \"DELETE FROM i_love_ponies WHERE special_thing = 'Django';\",\n  4356\t                [\"DELETE FROM i_love_ponies WHERE special_thing = 'Ponies';\", None],\n  4357\t                (\n  4358\t                    \"DELETE FROM i_love_ponies WHERE id = %s OR special_thing = %s;\",\n  4359\t                    [3, \"Python\"],\n  4360\t                ),\n  4361\t            ],\n  4362\t        )\n  4363\t\n  4364\t        # Make sure there's no table\n  4365\t        self.assertTableNotExists(\"i_love_ponies\")\n  4366\t        new_state = project_state.clone()\n  4367\t        # Test the database alteration\n  4368\t        with connection.schema_editor() as editor:\n  4369\t            operation.database_forwards(\"test_runsql\", editor, project_state, new_state)\n  4370\t\n  4371\t        # Test parameter passing\n  4372\t        with connection.schema_editor() as editor:\n  4373\t            param_operation.database_forwards(\n  4374\t                \"test_runsql\", editor, project_state, new_state\n  4375\t            )\n  4376\t        # Make sure all the SQL was processed\n  4377\t        with connection.cursor() as cursor:\n  4378\t            cursor.execute(\"SELECT COUNT(*) FROM i_love_ponies\")\n  4379\t            self.assertEqual(cursor.fetchall()[0][0], 3)\n  4380\t\n  4381\t        with connection.schema_editor() as editor:\n  4382\t            param_operation.database_backwards(\n  4383\t                \"test_runsql\", editor, new_state, project_state\n  4384\t            )\n  4385\t        with connection.cursor() as cursor:\n  4386\t            cursor.execute(\"SELECT COUNT(*) FROM i_love_ponies\")\n  4387\t            self.assertEqual(cursor.fetchall()[0][0], 0)\n  4388\t\n  4389\t        # And test reversal\n  4390\t        with connection.schema_editor() as editor:\n  4391\t            operation.database_backwards(\n  4392\t                \"test_runsql\", editor, new_state, project_state\n  4393\t            )\n  4394\t        self.assertTableNotExists(\"i_love_ponies\")\n  4395\t\n  4396\t    def test_run_sql_params_invalid(self):\n  4397\t        \"\"\"\n  4398\t        #23426 - RunSQL should fail when a list of statements with an incorrect\n  4399\t        number of tuples is given.\n  4400\t        \"\"\"\n  4401\t        project_state = self.set_up_test_model(\"test_runsql\")\n  4402\t        new_state = project_state.clone()\n  4403\t        operation = migrations.RunSQL(\n  4404\t            # forwards\n  4405\t            [[\"INSERT INTO foo (bar) VALUES ('buz');\"]],\n  4406\t            # backwards\n  4407\t            ((\"DELETE FROM foo WHERE bar = 'buz';\", \"invalid\", \"parameter count\"),),\n  4408\t        )\n  4409\t\n  4410\t        with connection.schema_editor() as editor:\n  4411\t            with self.assertRaisesMessage(ValueError, \"Expected a 2-tuple but got 1\"):\n  4412\t                operation.database_forwards(\n  4413\t                    \"test_runsql\", editor, project_state, new_state\n  4414\t                )\n  4415\t\n  4416\t        with connection.schema_editor() as editor:\n  4417\t            with self.assertRaisesMessage(ValueError, \"Expected a 2-tuple but got 3\"):\n  4418\t                operation.database_backwards(\n  4419\t                    \"test_runsql\", editor, new_state, project_state\n  4420\t                )\n  4421\t\n  4422\t    def test_run_sql_noop(self):\n  4423\t        \"\"\"\n  4424\t        #24098 - Tests no-op RunSQL operations.\n  4425\t        \"\"\"\n  4426\t        operation = migrations.RunSQL(migrations.RunSQL.noop, migrations.RunSQL.noop)\n  4427\t        with connection.schema_editor() as editor:\n  4428\t            operation.database_forwards(\"test_runsql\", editor, None, None)\n  4429\t            operation.database_backwards(\"test_runsql\", editor, None, None)\n  4430\t\n  4431\t    def test_run_sql_add_missing_semicolon_on_collect_sql(self):\n  4432\t        project_state = self.set_up_test_model(\"test_runsql\")\n  4433\t        new_state = project_state.clone()\n  4434\t        tests = [\n  4435\t            \"INSERT INTO test_runsql_pony (pink, weight) VALUES (1, 1);\\n\",\n  4436\t            \"INSERT INTO test_runsql_pony (pink, weight) VALUES (1, 1)\\n\",\n  4437\t        ]\n  4438\t        for sql in tests:\n  4439\t            with self.subTest(sql=sql):\n  4440\t                operation = migrations.RunSQL(sql, migrations.RunPython.noop)\n  4441\t                with connection.schema_editor(collect_sql=True) as editor:\n  4442\t                    operation.database_forwards(\n  4443\t                        \"test_runsql\", editor, project_state, new_state\n  4444\t                    )\n  4445\t                    collected_sql = \"\\n\".join(editor.collected_sql)\n  4446\t                    self.assertEqual(collected_sql.count(\";\"), 1)\n  4447\t\n  4448\t    def test_run_python(self):\n  4449\t        \"\"\"\n  4450\t        Tests the RunPython operation\n  4451\t        \"\"\"\n  4452\t\n  4453\t        project_state = self.set_up_test_model(\"test_runpython\", mti_model=True)\n  4454\t\n  4455\t        # Create the operation\n  4456\t        def inner_method(models, schema_editor):\n  4457\t            Pony = models.get_model(\"test_runpython\", \"Pony\")\n  4458\t            Pony.objects.create(pink=1, weight=3.55)\n  4459\t            Pony.objects.create(weight=5)\n  4460\t\n  4461\t        def inner_method_reverse(models, schema_editor):\n  4462\t            Pony = models.get_model(\"test_runpython\", \"Pony\")\n  4463\t            Pony.objects.filter(pink=1, weight=3.55).delete()\n  4464\t            Pony.objects.filter(weight=5).delete()\n  4465\t\n  4466\t        operation = migrations.RunPython(\n  4467\t            inner_method, reverse_code=inner_method_reverse\n  4468\t        )\n  4469\t        self.assertEqual(operation.describe(), \"Raw Python operation\")\n  4470\t        # Test the state alteration does nothing\n  4471\t        new_state = project_state.clone()\n  4472\t        operation.state_forwards(\"test_runpython\", new_state)\n  4473\t        self.assertEqual(new_state, project_state)\n  4474\t        # Test the database alteration\n  4475\t        self.assertEqual(\n  4476\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 0\n  4477\t        )\n  4478\t        with connection.schema_editor() as editor:\n  4479\t            operation.database_forwards(\n  4480\t                \"test_runpython\", editor, project_state, new_state\n  4481\t            )\n  4482\t        self.assertEqual(\n  4483\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 2\n  4484\t        )\n  4485\t        # Now test reversal\n  4486\t        self.assertTrue(operation.reversible)\n  4487\t        with connection.schema_editor() as editor:\n  4488\t            operation.database_backwards(\n  4489\t                \"test_runpython\", editor, project_state, new_state\n  4490\t            )\n  4491\t        self.assertEqual(\n  4492\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 0\n  4493\t        )\n  4494\t        # Now test we can't use a string\n  4495\t        with self.assertRaisesMessage(\n  4496\t            ValueError, \"RunPython must be supplied with a callable\"\n  4497\t        ):\n  4498\t            migrations.RunPython(\"print 'ahahaha'\")\n  4499\t        # And deconstruction\n  4500\t        definition = operation.deconstruct()\n  4501\t        self.assertEqual(definition[0], \"RunPython\")\n  4502\t        self.assertEqual(definition[1], [])\n  4503\t        self.assertEqual(sorted(definition[2]), [\"code\", \"reverse_code\"])\n  4504\t\n  4505\t        # Also test reversal fails, with an operation identical to above but\n  4506\t        # without reverse_code set.\n  4507\t        no_reverse_operation = migrations.RunPython(inner_method)\n  4508\t        self.assertFalse(no_reverse_operation.reversible)\n  4509\t        with connection.schema_editor() as editor:\n  4510\t            no_reverse_operation.database_forwards(\n  4511\t                \"test_runpython\", editor, project_state, new_state\n  4512\t            )\n  4513\t            with self.assertRaises(NotImplementedError):\n  4514\t                no_reverse_operation.database_backwards(\n  4515\t                    \"test_runpython\", editor, new_state, project_state\n  4516\t                )\n  4517\t        self.assertEqual(\n  4518\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 2\n  4519\t        )\n  4520\t\n  4521\t        def create_ponies(models, schema_editor):\n  4522\t            Pony = models.get_model(\"test_runpython\", \"Pony\")\n  4523\t            pony1 = Pony.objects.create(pink=1, weight=3.55)\n  4524\t            self.assertIsNot(pony1.pk, None)\n  4525\t            pony2 = Pony.objects.create(weight=5)\n  4526\t            self.assertIsNot(pony2.pk, None)\n  4527\t            self.assertNotEqual(pony1.pk, pony2.pk)\n  4528\t\n  4529\t        operation = migrations.RunPython(create_ponies)\n  4530\t        with connection.schema_editor() as editor:\n  4531\t            operation.database_forwards(\n  4532\t                \"test_runpython\", editor, project_state, new_state\n  4533\t            )\n  4534\t        self.assertEqual(\n  4535\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 4\n  4536\t        )\n  4537\t        # And deconstruction\n  4538\t        definition = operation.deconstruct()\n  4539\t        self.assertEqual(definition[0], \"RunPython\")\n  4540\t        self.assertEqual(definition[1], [])\n  4541\t        self.assertEqual(sorted(definition[2]), [\"code\"])\n  4542\t\n  4543\t        def create_shetlandponies(models, schema_editor):\n  4544\t            ShetlandPony = models.get_model(\"test_runpython\", \"ShetlandPony\")\n  4545\t            pony1 = ShetlandPony.objects.create(weight=4.0)\n  4546\t            self.assertIsNot(pony1.pk, None)\n  4547\t            pony2 = ShetlandPony.objects.create(weight=5.0)\n  4548\t            self.assertIsNot(pony2.pk, None)\n  4549\t            self.assertNotEqual(pony1.pk, pony2.pk)\n  4550\t\n  4551\t        operation = migrations.RunPython(create_shetlandponies)\n  4552\t        with connection.schema_editor() as editor:\n  4553\t            operation.database_forwards(\n  4554\t                \"test_runpython\", editor, project_state, new_state\n  4555\t            )\n  4556\t        self.assertEqual(\n  4557\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 6\n  4558\t        )\n  4559\t        self.assertEqual(\n  4560\t            project_state.apps.get_model(\n  4561\t                \"test_runpython\", \"ShetlandPony\"\n  4562\t            ).objects.count(),\n  4563\t            2,\n  4564\t        )\n  4565\t        # And elidable reduction\n  4566\t        self.assertIs(False, operation.reduce(operation, []))\n  4567\t        elidable_operation = migrations.RunPython(inner_method, elidable=True)\n  4568\t        self.assertEqual(elidable_operation.reduce(operation, []), [operation])\n  4569\t\n  4570\t    def test_run_python_atomic(self):\n  4571\t        \"\"\"\n  4572\t        Tests the RunPython operation correctly handles the \"atomic\" keyword\n  4573\t        \"\"\"\n  4574\t        project_state = self.set_up_test_model(\"test_runpythonatomic\", mti_model=True)\n  4575\t\n  4576\t        def inner_method(models, schema_editor):\n  4577\t            Pony = models.get_model(\"test_runpythonatomic\", \"Pony\")\n  4578\t            Pony.objects.create(pink=1, weight=3.55)\n  4579\t            raise ValueError(\"Adrian hates ponies.\")\n  4580\t\n  4581\t        # Verify atomicity when applying.\n  4582\t        atomic_migration = Migration(\"test\", \"test_runpythonatomic\")\n  4583\t        atomic_migration.operations = [\n  4584\t            migrations.RunPython(inner_method, reverse_code=inner_method)\n  4585\t        ]\n  4586\t        non_atomic_migration = Migration(\"test\", \"test_runpythonatomic\")\n  4587\t        non_atomic_migration.operations = [\n  4588\t            migrations.RunPython(inner_method, reverse_code=inner_method, atomic=False)\n  4589\t        ]\n  4590\t        # If we're a fully-transactional database, both versions should rollback\n  4591\t        if connection.features.can_rollback_ddl:\n  4592\t            self.assertEqual(\n  4593\t                project_state.apps.get_model(\n  4594\t                    \"test_runpythonatomic\", \"Pony\"\n  4595\t                ).objects.count(),\n  4596\t                0,\n  4597\t            )\n  4598\t            with self.assertRaises(ValueError):\n  4599\t                with connection.schema_editor() as editor:\n  4600\t                    atomic_migration.apply(project_state, editor)\n  4601\t            self.assertEqual(\n  4602\t                project_state.apps.get_model(\n  4603\t                    \"test_runpythonatomic\", \"Pony\"\n  4604\t                ).objects.count(),\n  4605\t                0,\n  4606\t            )\n  4607\t            with self.assertRaises(ValueError):\n  4608\t                with connection.schema_editor() as editor:\n  4609\t                    non_atomic_migration.apply(project_state, editor)\n  4610\t            self.assertEqual(\n  4611\t                project_state.apps.get_model(\n  4612\t                    \"test_runpythonatomic\", \"Pony\"\n  4613\t                ).objects.count(),\n  4614\t                0,\n  4615\t            )\n  4616\t        # Otherwise, the non-atomic operation should leave a row there\n  4617\t        else:\n  4618\t            self.assertEqual(\n  4619\t                project_state.apps.get_model(\n  4620\t                    \"test_runpythonatomic\", \"Pony\"\n  4621\t                ).objects.count(),\n  4622\t                0,\n  4623\t            )\n  4624\t            with self.assertRaises(ValueError):\n  4625\t                with connection.schema_editor() as editor:\n  4626\t                    atomic_migration.apply(project_state, editor)\n  4627\t            self.assertEqual(\n  4628\t                project_state.apps.get_model(\n  4629\t                    \"test_runpythonatomic\", \"Pony\"\n  4630\t                ).objects.count(),\n  4631\t                0,\n  4632\t            )\n  4633\t            with self.assertRaises(ValueError):\n  4634\t                with connection.schema_editor() as editor:\n  4635\t                    non_atomic_migration.apply(project_state, editor)\n  4636\t            self.assertEqual(\n  4637\t                project_state.apps.get_model(\n  4638\t                    \"test_runpythonatomic\", \"Pony\"\n  4639\t                ).objects.count(),\n  4640\t                1,\n  4641\t            )\n  4642\t        # Reset object count to zero and verify atomicity when unapplying.\n  4643\t        project_state.apps.get_model(\n  4644\t            \"test_runpythonatomic\", \"Pony\"\n  4645\t        ).objects.all().delete()\n  4646\t        # On a fully-transactional database, both versions rollback.\n  4647\t        if connection.features.can_rollback_ddl:\n  4648\t            self.assertEqual(\n  4649\t                project_state.apps.get_model(\n  4650\t                    \"test_runpythonatomic\", \"Pony\"\n  4651\t                ).objects.count(),\n  4652\t                0,\n  4653\t            )\n  4654\t            with self.assertRaises(ValueError):\n  4655\t                with connection.schema_editor() as editor:\n  4656\t                    atomic_migration.unapply(project_state, editor)\n  4657\t            self.assertEqual(\n  4658\t                project_state.apps.get_model(\n  4659\t                    \"test_runpythonatomic\", \"Pony\"\n  4660\t                ).objects.count(),\n  4661\t                0,\n  4662\t            )\n  4663\t            with self.assertRaises(ValueError):\n  4664\t                with connection.schema_editor() as editor:\n  4665\t                    non_atomic_migration.unapply(project_state, editor)\n  4666\t            self.assertEqual(\n  4667\t                project_state.apps.get_model(\n  4668\t                    \"test_runpythonatomic\", \"Pony\"\n  4669\t                ).objects.count(),\n  4670\t                0,\n  4671\t            )\n  4672\t        # Otherwise, the non-atomic operation leaves a row there.\n  4673\t        else:\n  4674\t            self.assertEqual(\n  4675\t                project_state.apps.get_model(\n  4676\t                    \"test_runpythonatomic\", \"Pony\"\n  4677\t                ).objects.count(),\n  4678\t                0,\n  4679\t            )\n  4680\t            with self.assertRaises(ValueError):\n  4681\t                with connection.schema_editor() as editor:\n  4682\t                    atomic_migration.unapply(project_state, editor)\n  4683\t            self.assertEqual(\n  4684\t                project_state.apps.get_model(\n  4685\t                    \"test_runpythonatomic\", \"Pony\"\n  4686\t                ).objects.count(),\n  4687\t                0,\n  4688\t            )\n  4689\t            with self.assertRaises(ValueError):\n  4690\t                with connection.schema_editor() as editor:\n  4691\t                    non_atomic_migration.unapply(project_state, editor)\n  4692\t            self.assertEqual(\n  4693\t                project_state.apps.get_model(\n  4694\t                    \"test_runpythonatomic\", \"Pony\"\n  4695\t                ).objects.count(),\n  4696\t                1,\n  4697\t            )\n  4698\t        # Verify deconstruction.\n  4699\t        definition = non_atomic_migration.operations[0].deconstruct()\n  4700\t        self.assertEqual(definition[0], \"RunPython\")\n  4701\t        self.assertEqual(definition[1], [])\n  4702\t        self.assertEqual(sorted(definition[2]), [\"atomic\", \"code\", \"reverse_code\"])\n  4703\t\n  4704\t    def test_run_python_related_assignment(self):\n  4705\t        \"\"\"\n  4706\t        #24282 - Model changes to a FK reverse side update the model\n  4707\t        on the FK side as well.\n  4708\t        \"\"\"\n  4709\t\n  4710\t        def inner_method(models, schema_editor):\n  4711\t            Author = models.get_model(\"test_authors\", \"Author\")\n  4712\t            Book = models.get_model(\"test_books\", \"Book\")\n  4713\t            author = Author.objects.create(name=\"Hemingway\")\n  4714\t            Book.objects.create(title=\"Old Man and The Sea\", author=author)\n  4715\t\n  4716\t        create_author = migrations.CreateModel(\n  4717\t            \"Author\",\n  4718\t            [\n  4719\t                (\"id\", models.AutoField(primary_key=True)),\n  4720\t                (\"name\", models.CharField(max_length=100)),\n  4721\t            ],\n  4722\t            options={},\n  4723\t        )\n  4724\t        create_book = migrations.CreateModel(\n  4725\t            \"Book\",\n  4726\t            [\n  4727\t                (\"id\", models.AutoField(primary_key=True)),\n  4728\t                (\"title\", models.CharField(max_length=100)),\n  4729\t                (\"author\", models.ForeignKey(\"test_authors.Author\", models.CASCADE)),\n  4730\t            ],\n  4731\t            options={},\n  4732\t        )\n  4733\t        add_hometown = migrations.AddField(\n  4734\t            \"Author\",\n  4735\t            \"hometown\",\n  4736\t            models.CharField(max_length=100),\n  4737\t        )\n  4738\t        create_old_man = migrations.RunPython(inner_method, inner_method)\n  4739\t\n  4740\t        project_state = ProjectState()\n  4741\t        new_state = project_state.clone()\n  4742\t        with connection.schema_editor() as editor:\n  4743\t            create_author.state_forwards(\"test_authors\", new_state)\n  4744\t            create_author.database_forwards(\n  4745\t                \"test_authors\", editor, project_state, new_state\n  4746\t            )\n  4747\t        project_state = new_state\n  4748\t        new_state = new_state.clone()\n  4749\t        with connection.schema_editor() as editor:\n  4750\t            create_book.state_forwards(\"test_books\", new_state)\n  4751\t            create_book.database_forwards(\n  4752\t                \"test_books\", editor, project_state, new_state\n  4753\t            )\n  4754\t        project_state = new_state\n  4755\t        new_state = new_state.clone()\n  4756\t        with connection.schema_editor() as editor:\n  4757\t            add_hometown.state_forwards(\"test_authors\", new_state)\n  4758\t            add_hometown.database_forwards(\n  4759\t                \"test_authors\", editor, project_state, new_state\n  4760\t            )\n  4761\t        project_state = new_state\n  4762\t        new_state = new_state.clone()\n  4763\t        with connection.schema_editor() as editor:\n  4764\t            create_old_man.state_forwards(\"test_books\", new_state)\n  4765\t            create_old_man.database_forwards(\n  4766\t                \"test_books\", editor, project_state, new_state\n  4767\t            )\n  4768\t\n  4769\t    def test_model_with_bigautofield(self):\n  4770\t        \"\"\"\n  4771\t        A model with BigAutoField can be created.\n  4772\t        \"\"\"\n  4773\t\n  4774\t        def create_data(models, schema_editor):\n  4775\t            Author = models.get_model(\"test_author\", \"Author\")\n  4776\t            Book = models.get_model(\"test_book\", \"Book\")\n  4777\t            author1 = Author.objects.create(name=\"Hemingway\")\n  4778\t            Book.objects.create(title=\"Old Man and The Sea\", author=author1)\n  4779\t            Book.objects.create(id=2**33, title=\"A farewell to arms\", author=author1)\n  4780\t\n  4781\t            author2 = Author.objects.create(id=2**33, name=\"Remarque\")\n  4782\t            Book.objects.create(title=\"All quiet on the western front\", author=author2)\n  4783\t            Book.objects.create(title=\"Arc de Triomphe\", author=author2)\n  4784\t\n  4785\t        create_author = migrations.CreateModel(\n  4786\t            \"Author\",\n  4787\t            [\n  4788\t                (\"id\", models.BigAutoField(primary_key=True)),\n  4789\t                (\"name\", models.CharField(max_length=100)),\n  4790\t            ],\n  4791\t            options={},\n  4792\t        )\n  4793\t        create_book = migrations.CreateModel(\n  4794\t            \"Book\",\n  4795\t            [\n  4796\t                (\"id\", models.BigAutoField(primary_key=True)),\n  4797\t                (\"title\", models.CharField(max_length=100)),\n  4798\t                (\n  4799\t                    \"author\",\n  4800\t                    models.ForeignKey(\n  4801\t                        to=\"test_author.Author\", on_delete=models.CASCADE\n  4802\t                    ),\n  4803\t                ),\n  4804\t            ],\n  4805\t            options={},\n  4806\t        )\n  4807\t        fill_data = migrations.RunPython(create_data)\n  4808\t\n  4809\t        project_state = ProjectState()\n  4810\t        new_state = project_state.clone()\n  4811\t        with connection.schema_editor() as editor:\n  4812\t            create_author.state_forwards(\"test_author\", new_state)\n  4813\t            create_author.database_forwards(\n  4814\t                \"test_author\", editor, project_state, new_state\n  4815\t            )\n  4816\t\n  4817\t        project_state = new_state\n  4818\t        new_state = new_state.clone()\n  4819\t        with connection.schema_editor() as editor:\n  4820\t            create_book.state_forwards(\"test_book\", new_state)\n  4821\t            create_book.database_forwards(\"test_book\", editor, project_state, new_state)\n  4822\t\n  4823\t        project_state = new_state\n  4824\t        new_state = new_state.clone()\n  4825\t        with connection.schema_editor() as editor:\n  4826\t            fill_data.state_forwards(\"fill_data\", new_state)\n  4827\t            fill_data.database_forwards(\"fill_data\", editor, project_state, new_state)\n  4828\t\n  4829\t    def _test_autofield_foreignfield_growth(\n  4830\t        self, source_field, target_field, target_value\n  4831\t    ):\n  4832\t        \"\"\"\n  4833\t        A field may be migrated in the following ways:\n  4834\t\n  4835\t        - AutoField to BigAutoField\n  4836\t        - SmallAutoField to AutoField\n  4837\t        - SmallAutoField to BigAutoField\n  4838\t        \"\"\"\n  4839\t\n  4840\t        def create_initial_data(models, schema_editor):\n  4841\t            Article = models.get_model(\"test_article\", \"Article\")\n  4842\t            Blog = models.get_model(\"test_blog\", \"Blog\")\n  4843\t            blog = Blog.objects.create(name=\"web development done right\")\n  4844\t            Article.objects.create(name=\"Frameworks\", blog=blog)\n  4845\t            Article.objects.create(name=\"Programming Languages\", blog=blog)\n  4846\t\n  4847\t        def create_big_data(models, schema_editor):\n  4848\t            Article = models.get_model(\"test_article\", \"Article\")\n  4849\t            Blog = models.get_model(\"test_blog\", \"Blog\")\n  4850\t            blog2 = Blog.objects.create(name=\"Frameworks\", id=target_value)\n  4851\t            Article.objects.create(name=\"Django\", blog=blog2)\n  4852\t            Article.objects.create(id=target_value, name=\"Django2\", blog=blog2)\n  4853\t\n  4854\t        create_blog = migrations.CreateModel(\n  4855\t            \"Blog\",\n  4856\t            [\n  4857\t                (\"id\", source_field(primary_key=True)),\n  4858\t                (\"name\", models.CharField(max_length=100)),\n  4859\t            ],\n  4860\t            options={},\n  4861\t        )\n  4862\t        create_article = migrations.CreateModel(\n  4863\t            \"Article\",\n  4864\t            [\n  4865\t                (\"id\", source_field(primary_key=True)),\n  4866\t                (\n  4867\t                    \"blog\",\n  4868\t                    models.ForeignKey(to=\"test_blog.Blog\", on_delete=models.CASCADE),\n  4869\t                ),\n  4870\t                (\"name\", models.CharField(max_length=100)),\n  4871\t                (\"data\", models.TextField(default=\"\")),\n  4872\t            ],\n  4873\t            options={},\n  4874\t        )\n  4875\t        fill_initial_data = migrations.RunPython(\n  4876\t            create_initial_data, create_initial_data\n  4877\t        )\n  4878\t        fill_big_data = migrations.RunPython(create_big_data, create_big_data)\n  4879\t\n  4880\t        grow_article_id = migrations.AlterField(\n  4881\t            \"Article\", \"id\", target_field(primary_key=True)\n  4882\t        )\n  4883\t        grow_blog_id = migrations.AlterField(\n  4884\t            \"Blog\", \"id\", target_field(primary_key=True)\n  4885\t        )\n  4886\t\n  4887\t        project_state = ProjectState()\n  4888\t        new_state = project_state.clone()\n  4889\t        with connection.schema_editor() as editor:\n  4890\t            create_blog.state_forwards(\"test_blog\", new_state)\n  4891\t            create_blog.database_forwards(\"test_blog\", editor, project_state, new_state)\n  4892\t\n  4893\t        project_state = new_state\n  4894\t        new_state = new_state.clone()\n  4895\t        with connection.schema_editor() as editor:\n  4896\t            create_article.state_forwards(\"test_article\", new_state)\n  4897\t            create_article.database_forwards(\n  4898\t                \"test_article\", editor, project_state, new_state\n  4899\t            )\n  4900\t\n  4901\t        project_state = new_state\n  4902\t        new_state = new_state.clone()\n  4903\t        with connection.schema_editor() as editor:\n  4904\t            fill_initial_data.state_forwards(\"fill_initial_data\", new_state)\n  4905\t            fill_initial_data.database_forwards(\n  4906\t                \"fill_initial_data\", editor, project_state, new_state\n  4907\t            )\n  4908\t\n  4909\t        project_state = new_state\n  4910\t        new_state = new_state.clone()\n  4911\t        with connection.schema_editor() as editor:\n  4912\t            grow_article_id.state_forwards(\"test_article\", new_state)\n  4913\t            grow_article_id.database_forwards(\n  4914\t                \"test_article\", editor, project_state, new_state\n  4915\t            )\n  4916\t\n  4917\t        state = new_state.clone()\n  4918\t        article = state.apps.get_model(\"test_article.Article\")\n  4919\t        self.assertIsInstance(article._meta.pk, target_field)\n  4920\t\n  4921\t        project_state = new_state\n  4922\t        new_state = new_state.clone()\n  4923\t        with connection.schema_editor() as editor:\n  4924\t            grow_blog_id.state_forwards(\"test_blog\", new_state)\n  4925\t            grow_blog_id.database_forwards(\n  4926\t                \"test_blog\", editor, project_state, new_state\n  4927\t            )\n  4928\t\n  4929\t        state = new_state.clone()\n  4930\t        blog = state.apps.get_model(\"test_blog.Blog\")\n  4931\t        self.assertIsInstance(blog._meta.pk, target_field)\n  4932\t\n  4933\t        project_state = new_state\n  4934\t        new_state = new_state.clone()\n  4935\t        with connection.schema_editor() as editor:\n  4936\t            fill_big_data.state_forwards(\"fill_big_data\", new_state)\n  4937\t            fill_big_data.database_forwards(\n  4938\t                \"fill_big_data\", editor, project_state, new_state\n  4939\t            )\n  4940\t\n  4941\t    def test_autofield__bigautofield_foreignfield_growth(self):\n  4942\t        \"\"\"A field may be migrated from AutoField to BigAutoField.\"\"\"\n  4943\t        self._test_autofield_foreignfield_growth(\n  4944\t            models.AutoField,\n  4945\t            models.BigAutoField,\n  4946\t            2**33,\n  4947\t        )\n  4948\t\n  4949\t    def test_smallfield_autofield_foreignfield_growth(self):\n  4950\t        \"\"\"A field may be migrated from SmallAutoField to AutoField.\"\"\"\n  4951\t        self._test_autofield_foreignfield_growth(\n  4952\t            models.SmallAutoField,\n  4953\t            models.AutoField,\n  4954\t            2**22,\n  4955\t        )\n  4956\t\n  4957\t    def test_smallfield_bigautofield_foreignfield_growth(self):\n  4958\t        \"\"\"A field may be migrated from SmallAutoField to BigAutoField.\"\"\"\n  4959\t        self._test_autofield_foreignfield_growth(\n  4960\t            models.SmallAutoField,\n  4961\t            models.BigAutoField,\n  4962\t            2**33,\n  4963\t        )\n  4964\t\n  4965\t    def test_run_python_noop(self):\n  4966\t        \"\"\"\n  4967\t        #24098 - Tests no-op RunPython operations.\n  4968\t        \"\"\"\n  4969\t        project_state = ProjectState()\n  4970\t        new_state = project_state.clone()\n  4971\t        operation = migrations.RunPython(\n  4972\t            migrations.RunPython.noop, migrations.RunPython.noop\n  4973\t        )\n  4974\t        with connection.schema_editor() as editor:\n  4975\t            operation.database_forwards(\n  4976\t                \"test_runpython\", editor, project_state, new_state\n  4977\t            )\n  4978\t            operation.database_backwards(\n  4979\t                \"test_runpython\", editor, new_state, project_state\n  4980\t            )\n  4981\t\n  4982\t    def test_separate_database_and_state(self):\n  4983\t        \"\"\"\n  4984\t        Tests the SeparateDatabaseAndState operation.\n  4985\t        \"\"\"\n  4986\t        project_state = self.set_up_test_model(\"test_separatedatabaseandstate\")\n  4987\t        # Create the operation\n  4988\t        database_operation = migrations.RunSQL(\n  4989\t            \"CREATE TABLE i_love_ponies (id int, special_thing int);\",\n  4990\t            \"DROP TABLE i_love_ponies;\",\n  4991\t        )\n  4992\t        state_operation = migrations.CreateModel(\n  4993\t            \"SomethingElse\", [(\"id\", models.AutoField(primary_key=True))]\n  4994\t        )\n  4995\t        operation = migrations.SeparateDatabaseAndState(\n  4996\t            state_operations=[state_operation], database_operations=[database_operation]\n  4997\t        )\n  4998\t        self.assertEqual(\n  4999\t            operation.describe(), \"Custom state/database change combination\"\n  5000\t        )\n  5001\t        # Test the state alteration\n  5002\t        new_state = project_state.clone()\n  5003\t        operation.state_forwards(\"test_separatedatabaseandstate\", new_state)\n  5004\t        self.assertEqual(\n  5005\t            len(\n  5006\t                new_state.models[\n  5007\t                    \"test_separatedatabaseandstate\", \"somethingelse\"\n  5008\t                ].fields\n  5009\t            ),\n  5010\t            1,\n  5011\t        )\n  5012\t        # Make sure there's no table\n  5013\t        self.assertTableNotExists(\"i_love_ponies\")\n  5014\t        # Test the database alteration\n  5015\t        with connection.schema_editor() as editor:\n  5016\t            operation.database_forwards(\n  5017\t                \"test_separatedatabaseandstate\", editor, project_state, new_state\n  5018\t            )\n  5019\t        self.assertTableExists(\"i_love_ponies\")\n  5020\t        # And test reversal\n  5021\t        self.assertTrue(operation.reversible)\n  5022\t        with connection.schema_editor() as editor:\n  5023\t            operation.database_backwards(\n  5024\t                \"test_separatedatabaseandstate\", editor, new_state, project_state\n  5025\t            )\n  5026\t        self.assertTableNotExists(\"i_love_ponies\")\n  5027\t        # And deconstruction\n  5028\t        definition = operation.deconstruct()\n  5029\t        self.assertEqual(definition[0], \"SeparateDatabaseAndState\")\n  5030\t        self.assertEqual(definition[1], [])\n  5031\t        self.assertEqual(\n  5032\t            sorted(definition[2]), [\"database_operations\", \"state_operations\"]\n  5033\t        )\n  5034\t\n  5035\t    def test_separate_database_and_state2(self):\n  5036\t        \"\"\"\n  5037\t        A complex SeparateDatabaseAndState operation: Multiple operations both\n  5038\t        for state and database. Verify the state dependencies within each list\n  5039\t        and that state ops don't affect the database.\n  5040\t        \"\"\"\n  5041\t        app_label = \"test_separatedatabaseandstate2\"\n  5042\t        project_state = self.set_up_test_model(app_label)\n  5043\t        # Create the operation\n  5044\t        database_operations = [\n  5045\t            migrations.CreateModel(\n  5046\t                \"ILovePonies\",\n  5047\t                [(\"id\", models.AutoField(primary_key=True))],\n  5048\t                options={\"db_table\": \"iloveponies\"},\n  5049\t            ),\n  5050\t            migrations.CreateModel(\n  5051\t                \"ILoveMorePonies\",\n  5052\t                # We use IntegerField and not AutoField because\n  5053\t                # the model is going to be deleted immediately\n  5054\t                # and with an AutoField this fails on Oracle\n  5055\t                [(\"id\", models.IntegerField(primary_key=True))],\n  5056\t                options={\"db_table\": \"ilovemoreponies\"},\n  5057\t            ),\n  5058\t            migrations.DeleteModel(\"ILoveMorePonies\"),\n  5059\t            migrations.CreateModel(\n  5060\t                \"ILoveEvenMorePonies\",\n  5061\t                [(\"id\", models.AutoField(primary_key=True))],\n  5062\t                options={\"db_table\": \"iloveevenmoreponies\"},\n  5063\t            ),\n  5064\t        ]\n  5065\t        state_operations = [\n  5066\t            migrations.CreateModel(\n  5067\t                \"SomethingElse\",\n  5068\t                [(\"id\", models.AutoField(primary_key=True))],\n  5069\t                options={\"db_table\": \"somethingelse\"},\n  5070\t            ),\n  5071\t            migrations.DeleteModel(\"SomethingElse\"),\n  5072\t            migrations.CreateModel(\n  5073\t                \"SomethingCompletelyDifferent\",\n  5074\t                [(\"id\", models.AutoField(primary_key=True))],\n  5075\t                options={\"db_table\": \"somethingcompletelydifferent\"},\n  5076\t            ),\n  5077\t        ]\n  5078\t        operation = migrations.SeparateDatabaseAndState(\n  5079\t            state_operations=state_operations,\n  5080\t            database_operations=database_operations,\n  5081\t        )\n  5082\t        # Test the state alteration\n  5083\t        new_state = project_state.clone()\n  5084\t        operation.state_forwards(app_label, new_state)\n  5085\t\n  5086\t        def assertModelsAndTables(after_db):\n  5087\t            # Tables and models exist, or don't, as they should:\n  5088\t            self.assertNotIn((app_label, \"somethingelse\"), new_state.models)\n  5089\t            self.assertEqual(\n  5090\t                len(new_state.models[app_label, \"somethingcompletelydifferent\"].fields),\n  5091\t                1,\n  5092\t            )\n  5093\t            self.assertNotIn((app_label, \"iloveponiesonies\"), new_state.models)\n  5094\t            self.assertNotIn((app_label, \"ilovemoreponies\"), new_state.models)\n  5095\t            self.assertNotIn((app_label, \"iloveevenmoreponies\"), new_state.models)\n  5096\t            self.assertTableNotExists(\"somethingelse\")\n  5097\t            self.assertTableNotExists(\"somethingcompletelydifferent\")\n  5098\t            self.assertTableNotExists(\"ilovemoreponies\")\n  5099\t            if after_db:\n  5100\t                self.assertTableExists(\"iloveponies\")\n  5101\t                self.assertTableExists(\"iloveevenmoreponies\")\n  5102\t            else:\n  5103\t                self.assertTableNotExists(\"iloveponies\")\n  5104\t                self.assertTableNotExists(\"iloveevenmoreponies\")\n  5105\t\n  5106\t        assertModelsAndTables(after_db=False)\n  5107\t        # Test the database alteration\n  5108\t        with connection.schema_editor() as editor:\n  5109\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  5110\t        assertModelsAndTables(after_db=True)\n  5111\t        # And test reversal\n  5112\t        self.assertTrue(operation.reversible)\n  5113\t        with connection.schema_editor() as editor:\n  5114\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  5115\t        assertModelsAndTables(after_db=False)\n  5116\t\n  5117\t\n  5118\tclass SwappableOperationTests(OperationTestBase):\n  5119\t    \"\"\"\n  5120\t    Key operations ignore swappable models\n  5121\t    (we don't want to replicate all of them here, as the functionality\n  5122\t    is in a common base class anyway)\n  5123\t    \"\"\"\n  5124\t\n  5125\t    available_apps = [\"migrations\"]\n  5126\t\n  5127\t    @override_settings(TEST_SWAP_MODEL=\"migrations.SomeFakeModel\")\n  5128\t    def test_create_ignore_swapped(self):\n  5129\t        \"\"\"\n  5130\t        The CreateTable operation ignores swapped models.\n  5131\t        \"\"\"\n  5132\t        operation = migrations.CreateModel(\n  5133\t            \"Pony\",\n  5134\t            [\n  5135\t                (\"id\", models.AutoField(primary_key=True)),\n  5136\t                (\"pink\", models.IntegerField(default=1)),\n  5137\t            ],\n  5138\t            options={\n  5139\t                \"swappable\": \"TEST_SWAP_MODEL\",\n  5140\t            },\n  5141\t        )\n  5142\t        # Test the state alteration (it should still be there!)\n  5143\t        project_state = ProjectState()\n  5144\t        new_state = project_state.clone()\n  5145\t        operation.state_forwards(\"test_crigsw\", new_state)\n  5146\t        self.assertEqual(new_state.models[\"test_crigsw\", \"pony\"].name, \"Pony\")\n  5147\t        self.assertEqual(len(new_state.models[\"test_crigsw\", \"pony\"].fields), 2)\n  5148\t        # Test the database alteration\n  5149\t        self.assertTableNotExists(\"test_crigsw_pony\")\n  5150\t        with connection.schema_editor() as editor:\n  5151\t            operation.database_forwards(\"test_crigsw\", editor, project_state, new_state)\n  5152\t        self.assertTableNotExists(\"test_crigsw_pony\")\n  5153\t        # And test reversal\n  5154\t        with connection.schema_editor() as editor:\n  5155\t            operation.database_backwards(\n  5156\t                \"test_crigsw\", editor, new_state, project_state\n  5157\t            )\n  5158\t        self.assertTableNotExists(\"test_crigsw_pony\")\n  5159\t\n  5160\t    @override_settings(TEST_SWAP_MODEL=\"migrations.SomeFakeModel\")\n  5161\t    def test_delete_ignore_swapped(self):\n  5162\t        \"\"\"\n  5163\t        Tests the DeleteModel operation ignores swapped models.\n  5164\t        \"\"\"\n  5165\t        operation = migrations.DeleteModel(\"Pony\")\n  5166\t        project_state, new_state = self.make_test_state(\"test_dligsw\", operation)\n  5167\t        # Test the database alteration\n  5168\t        self.assertTableNotExists(\"test_dligsw_pony\")\n  5169\t        with connection.schema_editor() as editor:\n  5170\t            operation.database_forwards(\"test_dligsw\", editor, project_state, new_state)\n  5171\t        self.assertTableNotExists(\"test_dligsw_pony\")\n  5172\t        # And test reversal\n  5173\t        with connection.schema_editor() as editor:\n  5174\t            operation.database_backwards(\n  5175\t                \"test_dligsw\", editor, new_state, project_state\n  5176\t            )\n  5177\t        self.assertTableNotExists(\"test_dligsw_pony\")\n  5178\t\n  5179\t    @override_settings(TEST_SWAP_MODEL=\"migrations.SomeFakeModel\")\n  5180\t    def test_add_field_ignore_swapped(self):\n  5181\t        \"\"\"\n  5182\t        Tests the AddField operation.\n  5183\t        \"\"\"\n  5184\t        # Test the state alteration\n  5185\t        operation = migrations.AddField(\n  5186\t            \"Pony\",\n  5187\t            \"height\",\n  5188\t            models.FloatField(null=True, default=5),\n  5189\t        )\n  5190\t        project_state, new_state = self.make_test_state(\"test_adfligsw\", operation)\n  5191\t        # Test the database alteration\n  5192\t        self.assertTableNotExists(\"test_adfligsw_pony\")\n  5193\t        with connection.schema_editor() as editor:\n  5194\t            operation.database_forwards(\n  5195\t                \"test_adfligsw\", editor, project_state, new_state\n  5196\t            )\n  5197\t        self.assertTableNotExists(\"test_adfligsw_pony\")\n  5198\t        # And test reversal\n  5199\t        with connection.schema_editor() as editor:\n  5200\t            operation.database_backwards(\n  5201\t                \"test_adfligsw\", editor, new_state, project_state\n  5202\t            )\n  5203\t        self.assertTableNotExists(\"test_adfligsw_pony\")\n  5204\t\n  5205\t    @override_settings(TEST_SWAP_MODEL=\"migrations.SomeFakeModel\")\n  5206\t    def test_indexes_ignore_swapped(self):\n  5207\t        \"\"\"\n  5208\t        Add/RemoveIndex operations ignore swapped models.\n  5209\t        \"\"\"\n  5210\t        operation = migrations.AddIndex(\n  5211\t            \"Pony\", models.Index(fields=[\"pink\"], name=\"my_name_idx\")\n  5212\t        )\n  5213\t        project_state, new_state = self.make_test_state(\"test_adinigsw\", operation)\n  5214\t        with connection.schema_editor() as editor:\n  5215\t            # No database queries should be run for swapped models\n  5216\t            operation.database_forwards(\n  5217\t                \"test_adinigsw\", editor, project_state, new_state\n  5218\t            )\n  5219\t            operation.database_backwards(\n  5220\t                \"test_adinigsw\", editor, new_state, project_state\n  5221\t            )\n  5222\t\n  5223\t        operation = migrations.RemoveIndex(\n  5224\t            \"Pony\", models.Index(fields=[\"pink\"], name=\"my_name_idx\")\n  5225\t        )\n  5226\t        project_state, new_state = self.make_test_state(\"test_rminigsw\", operation)\n  5227\t        with connection.schema_editor() as editor:\n  5228\t            operation.database_forwards(\n  5229\t                \"test_rminigsw\", editor, project_state, new_state\n  5230\t            )\n  5231\t            operation.database_backwards(\n  5232\t                \"test_rminigsw\", editor, new_state, project_state\n  5233\t            )\n  5234\t\n  5235\t\n  5236\tclass TestCreateModel(SimpleTestCase):\n  5237\t    def test_references_model_mixin(self):\n  5238\t        migrations.CreateModel(\n  5239\t            \"name\",\n  5240\t            fields=[],\n  5241\t            bases=(Mixin, models.Model),\n  5242\t        ).references_model(\"other_model\", \"migrations\")\n  5243\t\n  5244\t\n  5245\tclass FieldOperationTests(SimpleTestCase):\n  5246\t    def test_references_model(self):\n  5247\t        operation = FieldOperation(\n  5248\t            \"MoDel\", \"field\", models.ForeignKey(\"Other\", models.CASCADE)\n  5249\t        )\n  5250\t        # Model name match.\n  5251\t        self.assertIs(operation.references_model(\"mOdEl\", \"migrations\"), True)\n  5252\t        # Referenced field.\n  5253\t        self.assertIs(operation.references_model(\"oTher\", \"migrations\"), True)\n  5254\t        # Doesn't reference.\n  5255\t        self.assertIs(operation.references_model(\"Whatever\", \"migrations\"), False)\n  5256\t\n  5257\t    def test_references_field_by_name(self):\n  5258\t        operation = FieldOperation(\"MoDel\", \"field\", models.BooleanField(default=False))\n  5259\t        self.assertIs(operation.references_field(\"model\", \"field\", \"migrations\"), True)\n  5260\t\n  5261\t    def test_references_field_by_remote_field_model(self):\n  5262\t        operation = FieldOperation(\n  5263\t            \"Model\", \"field\", models.ForeignKey(\"Other\", models.CASCADE)\n  5264\t        )\n  5265\t        self.assertIs(\n  5266\t            operation.references_field(\"Other\", \"whatever\", \"migrations\"), True\n  5267\t        )\n  5268\t        self.assertIs(\n  5269\t            operation.references_field(\"Missing\", \"whatever\", \"migrations\"), False\n  5270\t        )\n  5271\t\n  5272\t    def test_references_field_by_from_fields(self):\n  5273\t        operation = FieldOperation(\n  5274\t            \"Model\",\n  5275\t            \"field\",\n  5276\t            models.fields.related.ForeignObject(\n  5277\t                \"Other\", models.CASCADE, [\"from\"], [\"to\"]\n  5278\t            ),\n  5279\t        )\n  5280\t        self.assertIs(operation.references_field(\"Model\", \"from\", \"migrations\"), True)\n  5281\t        self.assertIs(operation.references_field(\"Model\", \"to\", \"migrations\"), False)\n  5282\t        self.assertIs(operation.references_field(\"Other\", \"from\", \"migrations\"), False)\n  5283\t        self.assertIs(operation.references_field(\"Model\", \"to\", \"migrations\"), False)\n  5284\t\n  5285\t    def test_references_field_by_to_fields(self):\n  5286\t        operation = FieldOperation(\n  5287\t            \"Model\",\n  5288\t            \"field\",\n  5289\t            models.ForeignKey(\"Other\", models.CASCADE, to_field=\"field\"),\n  5290\t        )\n  5291\t        self.assertIs(operation.references_field(\"Other\", \"field\", \"migrations\"), True)\n  5292\t        self.assertIs(\n  5293\t            operation.references_field(\"Other\", \"whatever\", \"migrations\"), False\n  5294\t        )\n  5295\t        self.assertIs(\n  5296\t            operation.references_field(\"Missing\", \"whatever\", \"migrations\"), False\n  5297\t        )\n  5298\t\n  5299\t    def test_references_field_by_through(self):\n  5300\t        operation = FieldOperation(\n  5301\t            \"Model\", \"field\", models.ManyToManyField(\"Other\", through=\"Through\")\n  5302\t        )\n  5303\t        self.assertIs(\n  5304\t            operation.references_field(\"Other\", \"whatever\", \"migrations\"), True\n  5305\t        )\n  5306\t        self.assertIs(\n  5307\t            operation.references_field(\"Through\", \"whatever\", \"migrations\"), True\n  5308\t        )\n  5309\t        self.assertIs(\n  5310\t            operation.references_field(\"Missing\", \"whatever\", \"migrations\"), False\n  5311\t        )\n  5312\t\n  5313\t    def test_reference_field_by_through_fields(self):\n  5314\t        operation = FieldOperation(\n  5315\t            \"Model\",\n  5316\t            \"field\",\n  5317\t            models.ManyToManyField(\n  5318\t                \"Other\", through=\"Through\", through_fields=(\"first\", \"second\")\n  5319\t            ),\n  5320\t        )\n  5321\t        self.assertIs(\n  5322\t            operation.references_field(\"Other\", \"whatever\", \"migrations\"), True\n  5323\t        )\n  5324\t        self.assertIs(\n  5325\t            operation.references_field(\"Through\", \"whatever\", \"migrations\"), False\n  5326\t        )\n  5327\t        self.assertIs(\n  5328\t            operation.references_field(\"Through\", \"first\", \"migrations\"), True\n  5329\t        )\n  5330\t        self.assertIs(\n  5331\t            operation.references_field(\"Through\", \"second\", \"migrations\"), True\n  5332\t        )\n  5333\t\n```\n\n</observation>",
                  "type": "tool_result",
                  "cache_control": {
                    "type": "ephemeral"
                  }
                }
              ]
            }
          ],
          "response": {
            "id": "msg_01ARWTdnHnQBentiRXeZnKNR",
            "content": [
              {
                "text": "<thoughts>\n1. From the test file, I can see this is related to the RenameIndex operation and how it handles unnamed indexes when moving backward and forward.\n\n2. Let me search for the RenameIndex operation implementation to understand how it currently works.\n</thoughts>",
                "type": "text"
              },
              {
                "id": "toolu_015kcDR9Z8gYwu4BmZvy4NYh",
                "input": {
                  "query": "RenameIndex operation implementation",
                  "category": "implementation"
                },
                "name": "SemanticSearch",
                "type": "tool_use"
              }
            ],
            "model": "claude-3-5-sonnet-20241022",
            "role": "assistant",
            "stop_reason": "tool_use",
            "stop_sequence": null,
            "type": "message",
            "usage": {
              "cache_creation_input_tokens": 83322,
              "cache_read_input_tokens": 3981,
              "input_tokens": 5,
              "output_tokens": 139
            }
          },
          "usage": {
            "completion_cost": 0.252066,
            "completion_tokens": 139,
            "prompt_tokens": 83327,
            "cached_tokens": 3981
          }
        },
        "execute_action": {
          "model": "claude-3-5-sonnet-20241022",
          "input": [
            {
              "role": "user",
              "content": "Search request:\nSearching for code using the query: RenameIndex operation implementation\n\nIdentify the relevant code sections in the search results to use them. \n\n<search_results>\ndjango/db/migrations/operations/models.py\n```\n\n\n\n<span id='imports'>\n     1\tfrom django.db import models\n     2\tfrom django.db.migrations.operations.base import Operation\n     3\tfrom django.db.migrations.state import ModelState\n     4\tfrom django.db.migrations.utils import field_references, resolve_relation\n     5\tfrom django.db.models.options import normalize_together\n     6\tfrom django.utils.functional import cached_property\n     7\t\n     8\tfrom .fields import AddField, AlterField, FieldOperation, RemoveField, RenameField\n      # ...\n\n\n<span id='RenameIndex'>\n   877\t\n   878\t\n   879\tclass RenameIndex(IndexOperation):\n   880\t    \"\"\"Rename an index.\"\"\"\n          # ...\n\n\n<span id='RenameIndex.old_name_lower'>\n   896\t\n   897\t    @cached_property\n   898\t    def old_name_lower(self):\n   899\t        return self.old_name.lower()\n\n\n<span id='RenameIndex.new_name_lower'>\n   900\t\n   901\t    @cached_property\n   902\t    def new_name_lower(self):\n   903\t        return self.new_name.lower()\n\n\n<span id='RenameIndex.deconstruct'>\n   904\t\n   905\t    def deconstruct(self):\n   906\t        kwargs = {\n   907\t            \"model_name\": self.model_name,\n   908\t            \"new_name\": self.new_name,\n   909\t        }\n   910\t        if self.old_name:\n   911\t            kwargs[\"old_name\"] = self.old_name\n   912\t        if self.old_fields:\n   913\t            kwargs[\"old_fields\"] = self.old_fields\n   914\t        return (self.__class__.__qualname__, [], kwargs)\n\n\n<span id='RenameIndex.state_forwards'>\n   915\t\n   916\t    def state_forwards(self, app_label, state):\n   917\t        if self.old_fields:\n   918\t            state.add_index(\n   919\t                app_label,\n   920\t                self.model_name_lower,\n   921\t                models.Index(fields=self.old_fields, name=self.new_name),\n   922\t            )\n   923\t            state.remove_model_options(\n   924\t                app_label,\n   925\t                self.model_name_lower,\n   926\t                AlterIndexTogether.option_name,\n   927\t                self.old_fields,\n   928\t            )\n   929\t        else:\n   930\t            state.rename_index(\n   931\t                app_label, self.model_name_lower, self.old_name, self.new_name\n   932\t            )\n\n\n<span id='RenameIndex.database_forwards'>\n   933\t\n   934\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n   935\t        model = to_state.apps.get_model(app_label, self.model_name)\n   936\t        if not self.allow_migrate_model(schema_editor.connection.alias, model):\n   937\t            return\n   938\t\n   939\t        if self.old_fields:\n   940\t            from_model = from_state.apps.get_model(app_label, self.model_name)\n   941\t            columns = [\n   942\t                from_model._meta.get_field(field).column for field in self.old_fields\n   943\t            ]\n   944\t            matching_index_name = schema_editor._constraint_names(\n   945\t                from_model, column_names=columns, index=True\n   946\t            )\n   947\t            if len(matching_index_name) != 1:\n   948\t                raise ValueError(\n   949\t                    \"Found wrong number (%s) of indexes for %s(%s).\"\n   950\t                    % (\n   951\t                        len(matching_index_name),\n   952\t                        from_model._meta.db_table,\n   953\t                        \", \".join(columns),\n   954\t                    )\n   955\t                )\n   956\t            old_index = models.Index(\n   957\t                fields=self.old_fields,\n   958\t                name=matching_index_name[0],\n   959\t            )\n   960\t        else:\n   961\t            from_model_state = from_state.models[app_label, self.model_name_lower]\n   962\t            old_index = from_model_state.get_index_by_name(self.old_name)\n   963\t\n   964\t        to_model_state = to_state.models[app_label, self.model_name_lower]\n   965\t        new_index = to_model_state.get_index_by_name(self.new_name)\n   966\t        schema_editor.rename_index(model, old_index, new_index)\n\n\n<span id='RenameIndex.database_backwards'>\n   967\t\n   968\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n   969\t        if self.old_fields:\n   970\t            # Backward operation with unnamed index is a no-op.\n   971\t            return\n   972\t\n   973\t        self.new_name_lower, self.old_name_lower = (\n   974\t            self.old_name_lower,\n   975\t            self.new_name_lower,\n   976\t        )\n   977\t        self.new_name, self.old_name = self.old_name, self.new_name\n   978\t\n   979\t        self.database_forwards(app_label, schema_editor, from_state, to_state)\n   980\t\n   981\t        self.new_name_lower, self.old_name_lower = (\n   982\t            self.old_name_lower,\n   983\t            self.new_name_lower,\n   984\t        )\n   985\t        self.new_name, self.old_name = self.old_name, self.new_name\n\n\n<span id='RenameIndex.describe'>\n   986\t\n   987\t    def describe(self):\n   988\t        if self.old_name:\n   989\t            return (\n   990\t                f\"Rename index {self.old_name} on {self.model_name} to {self.new_name}\"\n   991\t            )\n   992\t        return (\n   993\t            f\"Rename unnamed index for {self.old_fields} on {self.model_name} to \"\n   994\t            f\"{self.new_name}\"\n   995\t        )\n\n\n<span id='RenameIndex.migration_name_fragment'>\n   996\t\n   997\t    @property\n   998\t    def migration_name_fragment(self):\n   999\t        if self.old_name:\n  1000\t            return \"rename_%s_%s\" % (self.old_name_lower, self.new_name_lower)\n  1001\t        return \"rename_%s_%s_%s\" % (\n  1002\t            self.model_name_lower,\n  1003\t            \"_\".join(self.old_fields),\n  1004\t            self.new_name_lower,\n  1005\t        )\n\n\n<span id='RenameIndex.reduce'>\n  1006\t\n  1007\t    def reduce(self, operation, app_label):\n  1008\t        if (\n  1009\t            isinstance(operation, RenameIndex)\n  1010\t            and self.model_name_lower == operation.model_name_lower\n  1011\t            and operation.old_name\n  1012\t            and self.new_name_lower == operation.old_name_lower\n  1013\t        ):\n  1014\t            return [\n  1015\t                RenameIndex(\n  1016\t                    self.model_name,\n  1017\t                    new_name=operation.new_name,\n  1018\t                    old_name=self.old_name,\n  1019\t                    old_fields=self.old_fields,\n  1020\t                )\n  1021\t            ]\n  1022\t        return super().reduce(operation, app_label)\n      # ...\n```\n\n\ndjango/db/backends/base/schema.py\n```\n\n\n\n<span id='imports'>\n     1\timport logging\n     2\timport operator\n     3\tfrom datetime import datetime\n     4\t\n     5\tfrom django.db.backends.ddl_references import (\n     6\t    Columns,\n     7\t    Expressions,\n     8\t    ForeignKeyName,\n     9\t    IndexName,\n    10\t    Statement,\n    11\t    Table,\n    12\t)\n    13\tfrom django.db.backends.utils import names_digest, split_identifier\n    14\tfrom django.db.models import Deferrable, Index\n    15\tfrom django.db.models.sql import Query\n    16\tfrom django.db.transaction import TransactionManagementError, atomic\n    17\tfrom django.utils import timezone\n    18\t\n    19\tlogger = logging.getLogger(\"django.db.backends.schema\")\n      # ...\n\n\n<span id='BaseDatabaseSchemaEditor'>\n    72\t\n    73\t\n    74\tclass BaseDatabaseSchemaEditor:\n    75\t    \"\"\"\n    76\t    This class and its subclasses are responsible for emitting schema-changing\n    77\t    statements to the databases - model creation/removal/alteration, field\n    78\t    renaming, index fiddling, and so on.\n    79\t    \"\"\"\n    80\t\n    81\t    # Overrideable SQL templates\n    82\t    sql_create_table = \"CREATE TABLE %(table)s (%(definition)s)\"\n    83\t    sql_rename_table = \"ALTER TABLE %(old_table)s RENAME TO %(new_table)s\"\n    84\t    sql_retablespace_table = \"ALTER TABLE %(table)s SET TABLESPACE %(new_tablespace)s\"\n    85\t    sql_delete_table = \"DROP TABLE %(table)s CASCADE\"\n    86\t\n    87\t    sql_create_column = \"ALTER TABLE %(table)s ADD COLUMN %(column)s %(definition)s\"\n    88\t    sql_alter_column = \"ALTER TABLE %(table)s %(changes)s\"\n    89\t    sql_alter_column_type = \"ALTER COLUMN %(column)s TYPE %(type)s\"\n    90\t    sql_alter_column_null = \"ALTER COLUMN %(column)s DROP NOT NULL\"\n    91\t    sql_alter_column_not_null = \"ALTER COLUMN %(column)s SET NOT NULL\"\n    92\t    sql_alter_column_default = \"ALTER COLUMN %(column)s SET DEFAULT %(default)s\"\n    93\t    sql_alter_column_no_default = \"ALTER COLUMN %(column)s DROP DEFAULT\"\n    94\t    sql_alter_column_no_default_null = sql_alter_column_no_default\n    95\t    sql_alter_column_collate = \"ALTER COLUMN %(column)s TYPE %(type)s%(collation)s\"\n    96\t    sql_delete_column = \"ALTER TABLE %(table)s DROP COLUMN %(column)s CASCADE\"\n    97\t    sql_rename_column = (\n    98\t        \"ALTER TABLE %(table)s RENAME COLUMN %(old_column)s TO %(new_column)s\"\n    99\t    )\n   100\t    sql_update_with_default = (\n   101\t        \"UPDATE %(table)s SET %(column)s = %(default)s WHERE %(column)s IS NULL\"\n   102\t    )\n   103\t\n   104\t    sql_unique_constraint = \"UNIQUE (%(columns)s)%(deferrable)s\"\n   105\t    sql_check_constraint = \"CHECK (%(check)s)\"\n   106\t    sql_delete_constraint = \"ALTER TABLE %(table)s DROP CONSTRAINT %(name)s\"\n   107\t    sql_constraint = \"CONSTRAINT %(name)s %(constraint)s\"\n   108\t\n   109\t    sql_create_check = \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s CHECK (%(check)s)\"\n   110\t    sql_delete_check = sql_delete_constraint\n   111\t\n   112\t    sql_create_unique = (\n   113\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s \"\n   114\t        \"UNIQUE (%(columns)s)%(deferrable)s\"\n   115\t    )\n   116\t    sql_delete_unique = sql_delete_constraint\n   117\t\n   118\t    sql_create_fk = (\n   119\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s FOREIGN KEY (%(column)s) \"\n   120\t        \"REFERENCES %(to_table)s (%(to_column)s)%(deferrable)s\"\n   121\t    )\n   122\t    sql_create_inline_fk = None\n   123\t    sql_create_column_inline_fk = None\n   124\t    sql_delete_fk = sql_delete_constraint\n   125\t\n   126\t    sql_create_index = (\n   127\t        \"CREATE INDEX %(name)s ON %(table)s \"\n   128\t        \"(%(columns)s)%(include)s%(extra)s%(condition)s\"\n   129\t    )\n   130\t    sql_create_unique_index = (\n   131\t        \"CREATE UNIQUE INDEX %(name)s ON %(table)s \"\n   132\t        \"(%(columns)s)%(include)s%(condition)s\"\n   133\t    )\n   134\t    sql_rename_index = \"ALTER INDEX %(old_name)s RENAME TO %(new_name)s\"\n   135\t    sql_delete_index = \"DROP INDEX %(name)s\"\n   136\t\n   137\t    sql_create_pk = (\n   138\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s PRIMARY KEY (%(columns)s)\"\n   139\t    )\n   140\t    sql_delete_pk = sql_delete_constraint\n   141\t\n   142\t    sql_delete_procedure = \"DROP PROCEDURE %(procedure)s\"\n\n\n<span id='BaseDatabaseSchemaEditor.__init__'>\n   143\t\n   144\t    def __init__(self, connection, collect_sql=False, atomic=True):\n   145\t        self.connection = connection\n   146\t        self.collect_sql = collect_sql\n   147\t        if self.collect_sql:\n   148\t            self.collected_sql = []\n   149\t        self.atomic_migration = self.connection.features.can_rollback_ddl and atomic\n   150\t\n   151\t    # State-managing methods\n          # ...\n\n\n<span id='BaseDatabaseSchemaEditor._rename_index_sql'>\n  1374\t\n  1375\t    def _rename_index_sql(self, model, old_name, new_name):\n  1376\t        return Statement(\n  1377\t            self.sql_rename_index,\n  1378\t            table=Table(model._meta.db_table, self.quote_name),\n  1379\t            old_name=self.quote_name(old_name),\n  1380\t            new_name=self.quote_name(new_name),\n  1381\t        )\n          # ...\n```\n\n</search_result>\n"
            }
          ],
          "response": {
            "id": "msg_011MMxSWNenFY8oMfoYJMLhV",
            "content": [
              {
                "text": "I'll help identify the relevant code sections for the RenameIndex operation implementation. Let me analyze the search results and mark the relevant sections.",
                "type": "text"
              },
              {
                "id": "toolu_01XYLWrkinSybrWf6Ef9tXS9",
                "input": {
                  "scratch_pad": "The search results contain the complete implementation of the RenameIndex operation in Django's migration system. The relevant sections include:\n\n1. Main RenameIndex class definition and its methods (lines 879-1022 in migrations/operations/models.py):\n- Class definition and core functionality\n- Property methods for name handling\n- Key operation methods like state_forwards, database_forwards, database_backwards\n- Support methods like describe, deconstruct, reduce\n\n2. Supporting implementation in schema.py (lines 134, 1374-1381):\n- SQL template for rename index operation\n- Method to generate the SQL for renaming an index\n\nThese sections show the complete implementation of how Django handles index renaming operations in database migrations.",
                  "identified_spans": [
                    {
                      "file_path": "django/db/migrations/operations/models.py",
                      "start_line": 879,
                      "end_line": 1022
                    },
                    {
                      "file_path": "django/db/backends/base/schema.py",
                      "start_line": 134,
                      "end_line": 134
                    },
                    {
                      "file_path": "django/db/backends/base/schema.py",
                      "start_line": 1374,
                      "end_line": 1381
                    }
                  ]
                },
                "name": "Action",
                "type": "tool_use"
              }
            ],
            "model": "claude-3-5-sonnet-20241022",
            "role": "assistant",
            "stop_reason": "tool_use",
            "stop_sequence": null,
            "type": "message",
            "usage": {
              "cache_creation_input_tokens": 0,
              "cache_read_input_tokens": 0,
              "input_tokens": 4668,
              "output_tokens": 398
            }
          },
          "usage": {
            "completion_cost": 0.019974000000000002,
            "completion_tokens": 398,
            "prompt_tokens": 4668,
            "cached_tokens": 0
          }
        }
      },
      "possible_actions": [
        "SemanticSearch",
        "FindClass",
        "FindFunction",
        "FindCodeSnippet",
        "ViewCode",
        "ClaudeEditTool"
      ],
      "output": {
        "message": "Found 15 code sections.\n\nViewed relevant code:\ndjango/db/migrations/operations/models.py\n```\n     1\tfrom django.db import models\n     2\tfrom django.db.migrations.operations.base import Operation\n     3\tfrom django.db.migrations.state import ModelState\n     4\tfrom django.db.migrations.utils import field_references, resolve_relation\n     5\tfrom django.db.models.options import normalize_together\n     6\tfrom django.utils.functional import cached_property\n     7\t\n     8\tfrom .fields import AddField, AlterField, FieldOperation, RemoveField, RenameField\n      # ...\n   877\t\n   878\t\n   879\tclass RenameIndex(IndexOperation):\n   880\t    \"\"\"Rename an index.\"\"\"\n   881\t\n   882\t    def __init__(self, model_name, new_name, old_name=None, old_fields=None):\n   883\t        if not old_name and not old_fields:\n   884\t            raise ValueError(\n   885\t                \"RenameIndex requires one of old_name and old_fields arguments to be \"\n   886\t                \"set.\"\n   887\t            )\n   888\t        if old_name and old_fields:\n   889\t            raise ValueError(\n   890\t                \"RenameIndex.old_name and old_fields are mutually exclusive.\"\n   891\t            )\n   892\t        self.model_name = model_name\n   893\t        self.new_name = new_name\n   894\t        self.old_name = old_name\n   895\t        self.old_fields = old_fields\n   896\t\n   897\t    @cached_property\n   898\t    def old_name_lower(self):\n   899\t        return self.old_name.lower()\n   900\t\n   901\t    @cached_property\n   902\t    def new_name_lower(self):\n   903\t        return self.new_name.lower()\n   904\t\n   905\t    def deconstruct(self):\n   906\t        kwargs = {\n   907\t            \"model_name\": self.model_name,\n   908\t            \"new_name\": self.new_name,\n   909\t        }\n   910\t        if self.old_name:\n   911\t            kwargs[\"old_name\"] = self.old_name\n   912\t        if self.old_fields:\n   913\t            kwargs[\"old_fields\"] = self.old_fields\n   914\t        return (self.__class__.__qualname__, [], kwargs)\n   915\t\n   916\t    def state_forwards(self, app_label, state):\n   917\t        if self.old_fields:\n   918\t            state.add_index(\n   919\t                app_label,\n   920\t                self.model_name_lower,\n   921\t                models.Index(fields=self.old_fields, name=self.new_name),\n   922\t            )\n   923\t            state.remove_model_options(\n   924\t                app_label,\n   925\t                self.model_name_lower,\n   926\t                AlterIndexTogether.option_name,\n   927\t                self.old_fields,\n   928\t            )\n   929\t        else:\n   930\t            state.rename_index(\n   931\t                app_label, self.model_name_lower, self.old_name, self.new_name\n   932\t            )\n   933\t\n   934\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n   935\t        model = to_state.apps.get_model(app_label, self.model_name)\n   936\t        if not self.allow_migrate_model(schema_editor.connection.alias, model):\n   937\t            return\n   938\t\n   939\t        if self.old_fields:\n   940\t            from_model = from_state.apps.get_model(app_label, self.model_name)\n   941\t            columns = [\n   942\t                from_model._meta.get_field(field).column for field in self.old_fields\n   943\t            ]\n   944\t            matching_index_name = schema_editor._constraint_names(\n   945\t                from_model, column_names=columns, index=True\n   946\t            )\n   947\t            if len(matching_index_name) != 1:\n   948\t                raise ValueError(\n   949\t                    \"Found wrong number (%s) of indexes for %s(%s).\"\n   950\t                    % (\n   951\t                        len(matching_index_name),\n   952\t                        from_model._meta.db_table,\n   953\t                        \", \".join(columns),\n   954\t                    )\n   955\t                )\n   956\t            old_index = models.Index(\n   957\t                fields=self.old_fields,\n   958\t                name=matching_index_name[0],\n   959\t            )\n   960\t        else:\n   961\t            from_model_state = from_state.models[app_label, self.model_name_lower]\n   962\t            old_index = from_model_state.get_index_by_name(self.old_name)\n   963\t\n   964\t        to_model_state = to_state.models[app_label, self.model_name_lower]\n   965\t        new_index = to_model_state.get_index_by_name(self.new_name)\n   966\t        schema_editor.rename_index(model, old_index, new_index)\n   967\t\n   968\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n   969\t        if self.old_fields:\n   970\t            # Backward operation with unnamed index is a no-op.\n   971\t            return\n   972\t\n   973\t        self.new_name_lower, self.old_name_lower = (\n   974\t            self.old_name_lower,\n   975\t            self.new_name_lower,\n   976\t        )\n   977\t        self.new_name, self.old_name = self.old_name, self.new_name\n   978\t\n   979\t        self.database_forwards(app_label, schema_editor, from_state, to_state)\n   980\t\n   981\t        self.new_name_lower, self.old_name_lower = (\n   982\t            self.old_name_lower,\n   983\t            self.new_name_lower,\n   984\t        )\n   985\t        self.new_name, self.old_name = self.old_name, self.new_name\n   986\t\n   987\t    def describe(self):\n   988\t        if self.old_name:\n   989\t            return (\n   990\t                f\"Rename index {self.old_name} on {self.model_name} to {self.new_name}\"\n   991\t            )\n   992\t        return (\n   993\t            f\"Rename unnamed index for {self.old_fields} on {self.model_name} to \"\n   994\t            f\"{self.new_name}\"\n   995\t        )\n   996\t\n   997\t    @property\n   998\t    def migration_name_fragment(self):\n   999\t        if self.old_name:\n  1000\t            return \"rename_%s_%s\" % (self.old_name_lower, self.new_name_lower)\n  1001\t        return \"rename_%s_%s_%s\" % (\n  1002\t            self.model_name_lower,\n  1003\t            \"_\".join(self.old_fields),\n  1004\t            self.new_name_lower,\n  1005\t        )\n  1006\t\n  1007\t    def reduce(self, operation, app_label):\n  1008\t        if (\n  1009\t            isinstance(operation, RenameIndex)\n  1010\t            and self.model_name_lower == operation.model_name_lower\n  1011\t            and operation.old_name\n  1012\t            and self.new_name_lower == operation.old_name_lower\n  1013\t        ):\n  1014\t            return [\n  1015\t                RenameIndex(\n  1016\t                    self.model_name,\n  1017\t                    new_name=operation.new_name,\n  1018\t                    old_name=self.old_name,\n  1019\t                    old_fields=self.old_fields,\n  1020\t                )\n  1021\t            ]\n  1022\t        return super().reduce(operation, app_label)\n      # ...\n```\n\n\ndjango/db/backends/base/schema.py\n```\n     1\timport logging\n     2\timport operator\n     3\tfrom datetime import datetime\n     4\t\n     5\tfrom django.db.backends.ddl_references import (\n     6\t    Columns,\n     7\t    Expressions,\n     8\t    ForeignKeyName,\n     9\t    IndexName,\n    10\t    Statement,\n    11\t    Table,\n    12\t)\n    13\tfrom django.db.backends.utils import names_digest, split_identifier\n    14\tfrom django.db.models import Deferrable, Index\n    15\tfrom django.db.models.sql import Query\n    16\tfrom django.db.transaction import TransactionManagementError, atomic\n    17\tfrom django.utils import timezone\n    18\t\n    19\tlogger = logging.getLogger(\"django.db.backends.schema\")\n      # ...\n    72\t\n    73\t\n    74\tclass BaseDatabaseSchemaEditor:\n    75\t    \"\"\"\n    76\t    This class and its subclasses are responsible for emitting schema-changing\n    77\t    statements to the databases - model creation/removal/alteration, field\n    78\t    renaming, index fiddling, and so on.\n    79\t    \"\"\"\n    80\t\n    81\t    # Overrideable SQL templates\n    82\t    sql_create_table = \"CREATE TABLE %(table)s (%(definition)s)\"\n    83\t    sql_rename_table = \"ALTER TABLE %(old_table)s RENAME TO %(new_table)s\"\n    84\t    sql_retablespace_table = \"ALTER TABLE %(table)s SET TABLESPACE %(new_tablespace)s\"\n    85\t    sql_delete_table = \"DROP TABLE %(table)s CASCADE\"\n    86\t\n    87\t    sql_create_column = \"ALTER TABLE %(table)s ADD COLUMN %(column)s %(definition)s\"\n    88\t    sql_alter_column = \"ALTER TABLE %(table)s %(changes)s\"\n    89\t    sql_alter_column_type = \"ALTER COLUMN %(column)s TYPE %(type)s\"\n    90\t    sql_alter_column_null = \"ALTER COLUMN %(column)s DROP NOT NULL\"\n    91\t    sql_alter_column_not_null = \"ALTER COLUMN %(column)s SET NOT NULL\"\n    92\t    sql_alter_column_default = \"ALTER COLUMN %(column)s SET DEFAULT %(default)s\"\n    93\t    sql_alter_column_no_default = \"ALTER COLUMN %(column)s DROP DEFAULT\"\n    94\t    sql_alter_column_no_default_null = sql_alter_column_no_default\n    95\t    sql_alter_column_collate = \"ALTER COLUMN %(column)s TYPE %(type)s%(collation)s\"\n    96\t    sql_delete_column = \"ALTER TABLE %(table)s DROP COLUMN %(column)s CASCADE\"\n    97\t    sql_rename_column = (\n    98\t        \"ALTER TABLE %(table)s RENAME COLUMN %(old_column)s TO %(new_column)s\"\n    99\t    )\n   100\t    sql_update_with_default = (\n   101\t        \"UPDATE %(table)s SET %(column)s = %(default)s WHERE %(column)s IS NULL\"\n   102\t    )\n   103\t\n   104\t    sql_unique_constraint = \"UNIQUE (%(columns)s)%(deferrable)s\"\n   105\t    sql_check_constraint = \"CHECK (%(check)s)\"\n   106\t    sql_delete_constraint = \"ALTER TABLE %(table)s DROP CONSTRAINT %(name)s\"\n   107\t    sql_constraint = \"CONSTRAINT %(name)s %(constraint)s\"\n   108\t\n   109\t    sql_create_check = \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s CHECK (%(check)s)\"\n   110\t    sql_delete_check = sql_delete_constraint\n   111\t\n   112\t    sql_create_unique = (\n   113\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s \"\n   114\t        \"UNIQUE (%(columns)s)%(deferrable)s\"\n   115\t    )\n   116\t    sql_delete_unique = sql_delete_constraint\n   117\t\n   118\t    sql_create_fk = (\n   119\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s FOREIGN KEY (%(column)s) \"\n   120\t        \"REFERENCES %(to_table)s (%(to_column)s)%(deferrable)s\"\n   121\t    )\n   122\t    sql_create_inline_fk = None\n   123\t    sql_create_column_inline_fk = None\n   124\t    sql_delete_fk = sql_delete_constraint\n   125\t\n   126\t    sql_create_index = (\n   127\t        \"CREATE INDEX %(name)s ON %(table)s \"\n   128\t        \"(%(columns)s)%(include)s%(extra)s%(condition)s\"\n   129\t    )\n   130\t    sql_create_unique_index = (\n   131\t        \"CREATE UNIQUE INDEX %(name)s ON %(table)s \"\n   132\t        \"(%(columns)s)%(include)s%(condition)s\"\n   133\t    )\n   134\t    sql_rename_index = \"ALTER INDEX %(old_name)s RENAME TO %(new_name)s\"\n   135\t    sql_delete_index = \"DROP INDEX %(name)s\"\n   136\t\n   137\t    sql_create_pk = (\n   138\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s PRIMARY KEY (%(columns)s)\"\n   139\t    )\n   140\t    sql_delete_pk = sql_delete_constraint\n   141\t\n   142\t    sql_delete_procedure = \"DROP PROCEDURE %(procedure)s\"\n          # ...\n  1374\t\n  1375\t    def _rename_index_sql(self, model, old_name, new_name):\n  1376\t        return Statement(\n  1377\t            self.sql_rename_index,\n  1378\t            table=Table(model._meta.db_table, self.quote_name),\n  1379\t            old_name=self.quote_name(old_name),\n  1380\t            new_name=self.quote_name(new_name),\n  1381\t        )\n          # ...\n```\n",
        "summary": "Found relevant code sections in the search results.",
        "terminal": false,
        "expect_correction": false,
        "properties": {
          "search_hits": [],
          "search_tokens": 1804,
          "new_span_ids": [
            "RenameIndex",
            "RenameIndex.__init__",
            "RenameIndex.old_name_lower",
            "RenameIndex.new_name_lower",
            "RenameIndex.deconstruct",
            "RenameIndex.state_forwards",
            "RenameIndex.database_forwards",
            "RenameIndex.database_backwards",
            "RenameIndex.describe",
            "RenameIndex.migration_name_fragment",
            "RenameIndex.reduce",
            "BaseDatabaseSchemaEditor",
            "BaseDatabaseSchemaEditor._rename_index_sql"
          ]
        },
        "execution_completion": {
          "model": "claude-3-5-sonnet-20241022",
          "input": [
            {
              "role": "user",
              "content": "Search request:\nSearching for code using the query: RenameIndex operation implementation\n\nIdentify the relevant code sections in the search results to use them. \n\n<search_results>\ndjango/db/migrations/operations/models.py\n```\n\n\n\n<span id='imports'>\n     1\tfrom django.db import models\n     2\tfrom django.db.migrations.operations.base import Operation\n     3\tfrom django.db.migrations.state import ModelState\n     4\tfrom django.db.migrations.utils import field_references, resolve_relation\n     5\tfrom django.db.models.options import normalize_together\n     6\tfrom django.utils.functional import cached_property\n     7\t\n     8\tfrom .fields import AddField, AlterField, FieldOperation, RemoveField, RenameField\n      # ...\n\n\n<span id='RenameIndex'>\n   877\t\n   878\t\n   879\tclass RenameIndex(IndexOperation):\n   880\t    \"\"\"Rename an index.\"\"\"\n          # ...\n\n\n<span id='RenameIndex.old_name_lower'>\n   896\t\n   897\t    @cached_property\n   898\t    def old_name_lower(self):\n   899\t        return self.old_name.lower()\n\n\n<span id='RenameIndex.new_name_lower'>\n   900\t\n   901\t    @cached_property\n   902\t    def new_name_lower(self):\n   903\t        return self.new_name.lower()\n\n\n<span id='RenameIndex.deconstruct'>\n   904\t\n   905\t    def deconstruct(self):\n   906\t        kwargs = {\n   907\t            \"model_name\": self.model_name,\n   908\t            \"new_name\": self.new_name,\n   909\t        }\n   910\t        if self.old_name:\n   911\t            kwargs[\"old_name\"] = self.old_name\n   912\t        if self.old_fields:\n   913\t            kwargs[\"old_fields\"] = self.old_fields\n   914\t        return (self.__class__.__qualname__, [], kwargs)\n\n\n<span id='RenameIndex.state_forwards'>\n   915\t\n   916\t    def state_forwards(self, app_label, state):\n   917\t        if self.old_fields:\n   918\t            state.add_index(\n   919\t                app_label,\n   920\t                self.model_name_lower,\n   921\t                models.Index(fields=self.old_fields, name=self.new_name),\n   922\t            )\n   923\t            state.remove_model_options(\n   924\t                app_label,\n   925\t                self.model_name_lower,\n   926\t                AlterIndexTogether.option_name,\n   927\t                self.old_fields,\n   928\t            )\n   929\t        else:\n   930\t            state.rename_index(\n   931\t                app_label, self.model_name_lower, self.old_name, self.new_name\n   932\t            )\n\n\n<span id='RenameIndex.database_forwards'>\n   933\t\n   934\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n   935\t        model = to_state.apps.get_model(app_label, self.model_name)\n   936\t        if not self.allow_migrate_model(schema_editor.connection.alias, model):\n   937\t            return\n   938\t\n   939\t        if self.old_fields:\n   940\t            from_model = from_state.apps.get_model(app_label, self.model_name)\n   941\t            columns = [\n   942\t                from_model._meta.get_field(field).column for field in self.old_fields\n   943\t            ]\n   944\t            matching_index_name = schema_editor._constraint_names(\n   945\t                from_model, column_names=columns, index=True\n   946\t            )\n   947\t            if len(matching_index_name) != 1:\n   948\t                raise ValueError(\n   949\t                    \"Found wrong number (%s) of indexes for %s(%s).\"\n   950\t                    % (\n   951\t                        len(matching_index_name),\n   952\t                        from_model._meta.db_table,\n   953\t                        \", \".join(columns),\n   954\t                    )\n   955\t                )\n   956\t            old_index = models.Index(\n   957\t                fields=self.old_fields,\n   958\t                name=matching_index_name[0],\n   959\t            )\n   960\t        else:\n   961\t            from_model_state = from_state.models[app_label, self.model_name_lower]\n   962\t            old_index = from_model_state.get_index_by_name(self.old_name)\n   963\t\n   964\t        to_model_state = to_state.models[app_label, self.model_name_lower]\n   965\t        new_index = to_model_state.get_index_by_name(self.new_name)\n   966\t        schema_editor.rename_index(model, old_index, new_index)\n\n\n<span id='RenameIndex.database_backwards'>\n   967\t\n   968\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n   969\t        if self.old_fields:\n   970\t            # Backward operation with unnamed index is a no-op.\n   971\t            return\n   972\t\n   973\t        self.new_name_lower, self.old_name_lower = (\n   974\t            self.old_name_lower,\n   975\t            self.new_name_lower,\n   976\t        )\n   977\t        self.new_name, self.old_name = self.old_name, self.new_name\n   978\t\n   979\t        self.database_forwards(app_label, schema_editor, from_state, to_state)\n   980\t\n   981\t        self.new_name_lower, self.old_name_lower = (\n   982\t            self.old_name_lower,\n   983\t            self.new_name_lower,\n   984\t        )\n   985\t        self.new_name, self.old_name = self.old_name, self.new_name\n\n\n<span id='RenameIndex.describe'>\n   986\t\n   987\t    def describe(self):\n   988\t        if self.old_name:\n   989\t            return (\n   990\t                f\"Rename index {self.old_name} on {self.model_name} to {self.new_name}\"\n   991\t            )\n   992\t        return (\n   993\t            f\"Rename unnamed index for {self.old_fields} on {self.model_name} to \"\n   994\t            f\"{self.new_name}\"\n   995\t        )\n\n\n<span id='RenameIndex.migration_name_fragment'>\n   996\t\n   997\t    @property\n   998\t    def migration_name_fragment(self):\n   999\t        if self.old_name:\n  1000\t            return \"rename_%s_%s\" % (self.old_name_lower, self.new_name_lower)\n  1001\t        return \"rename_%s_%s_%s\" % (\n  1002\t            self.model_name_lower,\n  1003\t            \"_\".join(self.old_fields),\n  1004\t            self.new_name_lower,\n  1005\t        )\n\n\n<span id='RenameIndex.reduce'>\n  1006\t\n  1007\t    def reduce(self, operation, app_label):\n  1008\t        if (\n  1009\t            isinstance(operation, RenameIndex)\n  1010\t            and self.model_name_lower == operation.model_name_lower\n  1011\t            and operation.old_name\n  1012\t            and self.new_name_lower == operation.old_name_lower\n  1013\t        ):\n  1014\t            return [\n  1015\t                RenameIndex(\n  1016\t                    self.model_name,\n  1017\t                    new_name=operation.new_name,\n  1018\t                    old_name=self.old_name,\n  1019\t                    old_fields=self.old_fields,\n  1020\t                )\n  1021\t            ]\n  1022\t        return super().reduce(operation, app_label)\n      # ...\n```\n\n\ndjango/db/backends/base/schema.py\n```\n\n\n\n<span id='imports'>\n     1\timport logging\n     2\timport operator\n     3\tfrom datetime import datetime\n     4\t\n     5\tfrom django.db.backends.ddl_references import (\n     6\t    Columns,\n     7\t    Expressions,\n     8\t    ForeignKeyName,\n     9\t    IndexName,\n    10\t    Statement,\n    11\t    Table,\n    12\t)\n    13\tfrom django.db.backends.utils import names_digest, split_identifier\n    14\tfrom django.db.models import Deferrable, Index\n    15\tfrom django.db.models.sql import Query\n    16\tfrom django.db.transaction import TransactionManagementError, atomic\n    17\tfrom django.utils import timezone\n    18\t\n    19\tlogger = logging.getLogger(\"django.db.backends.schema\")\n      # ...\n\n\n<span id='BaseDatabaseSchemaEditor'>\n    72\t\n    73\t\n    74\tclass BaseDatabaseSchemaEditor:\n    75\t    \"\"\"\n    76\t    This class and its subclasses are responsible for emitting schema-changing\n    77\t    statements to the databases - model creation/removal/alteration, field\n    78\t    renaming, index fiddling, and so on.\n    79\t    \"\"\"\n    80\t\n    81\t    # Overrideable SQL templates\n    82\t    sql_create_table = \"CREATE TABLE %(table)s (%(definition)s)\"\n    83\t    sql_rename_table = \"ALTER TABLE %(old_table)s RENAME TO %(new_table)s\"\n    84\t    sql_retablespace_table = \"ALTER TABLE %(table)s SET TABLESPACE %(new_tablespace)s\"\n    85\t    sql_delete_table = \"DROP TABLE %(table)s CASCADE\"\n    86\t\n    87\t    sql_create_column = \"ALTER TABLE %(table)s ADD COLUMN %(column)s %(definition)s\"\n    88\t    sql_alter_column = \"ALTER TABLE %(table)s %(changes)s\"\n    89\t    sql_alter_column_type = \"ALTER COLUMN %(column)s TYPE %(type)s\"\n    90\t    sql_alter_column_null = \"ALTER COLUMN %(column)s DROP NOT NULL\"\n    91\t    sql_alter_column_not_null = \"ALTER COLUMN %(column)s SET NOT NULL\"\n    92\t    sql_alter_column_default = \"ALTER COLUMN %(column)s SET DEFAULT %(default)s\"\n    93\t    sql_alter_column_no_default = \"ALTER COLUMN %(column)s DROP DEFAULT\"\n    94\t    sql_alter_column_no_default_null = sql_alter_column_no_default\n    95\t    sql_alter_column_collate = \"ALTER COLUMN %(column)s TYPE %(type)s%(collation)s\"\n    96\t    sql_delete_column = \"ALTER TABLE %(table)s DROP COLUMN %(column)s CASCADE\"\n    97\t    sql_rename_column = (\n    98\t        \"ALTER TABLE %(table)s RENAME COLUMN %(old_column)s TO %(new_column)s\"\n    99\t    )\n   100\t    sql_update_with_default = (\n   101\t        \"UPDATE %(table)s SET %(column)s = %(default)s WHERE %(column)s IS NULL\"\n   102\t    )\n   103\t\n   104\t    sql_unique_constraint = \"UNIQUE (%(columns)s)%(deferrable)s\"\n   105\t    sql_check_constraint = \"CHECK (%(check)s)\"\n   106\t    sql_delete_constraint = \"ALTER TABLE %(table)s DROP CONSTRAINT %(name)s\"\n   107\t    sql_constraint = \"CONSTRAINT %(name)s %(constraint)s\"\n   108\t\n   109\t    sql_create_check = \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s CHECK (%(check)s)\"\n   110\t    sql_delete_check = sql_delete_constraint\n   111\t\n   112\t    sql_create_unique = (\n   113\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s \"\n   114\t        \"UNIQUE (%(columns)s)%(deferrable)s\"\n   115\t    )\n   116\t    sql_delete_unique = sql_delete_constraint\n   117\t\n   118\t    sql_create_fk = (\n   119\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s FOREIGN KEY (%(column)s) \"\n   120\t        \"REFERENCES %(to_table)s (%(to_column)s)%(deferrable)s\"\n   121\t    )\n   122\t    sql_create_inline_fk = None\n   123\t    sql_create_column_inline_fk = None\n   124\t    sql_delete_fk = sql_delete_constraint\n   125\t\n   126\t    sql_create_index = (\n   127\t        \"CREATE INDEX %(name)s ON %(table)s \"\n   128\t        \"(%(columns)s)%(include)s%(extra)s%(condition)s\"\n   129\t    )\n   130\t    sql_create_unique_index = (\n   131\t        \"CREATE UNIQUE INDEX %(name)s ON %(table)s \"\n   132\t        \"(%(columns)s)%(include)s%(condition)s\"\n   133\t    )\n   134\t    sql_rename_index = \"ALTER INDEX %(old_name)s RENAME TO %(new_name)s\"\n   135\t    sql_delete_index = \"DROP INDEX %(name)s\"\n   136\t\n   137\t    sql_create_pk = (\n   138\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s PRIMARY KEY (%(columns)s)\"\n   139\t    )\n   140\t    sql_delete_pk = sql_delete_constraint\n   141\t\n   142\t    sql_delete_procedure = \"DROP PROCEDURE %(procedure)s\"\n\n\n<span id='BaseDatabaseSchemaEditor.__init__'>\n   143\t\n   144\t    def __init__(self, connection, collect_sql=False, atomic=True):\n   145\t        self.connection = connection\n   146\t        self.collect_sql = collect_sql\n   147\t        if self.collect_sql:\n   148\t            self.collected_sql = []\n   149\t        self.atomic_migration = self.connection.features.can_rollback_ddl and atomic\n   150\t\n   151\t    # State-managing methods\n          # ...\n\n\n<span id='BaseDatabaseSchemaEditor._rename_index_sql'>\n  1374\t\n  1375\t    def _rename_index_sql(self, model, old_name, new_name):\n  1376\t        return Statement(\n  1377\t            self.sql_rename_index,\n  1378\t            table=Table(model._meta.db_table, self.quote_name),\n  1379\t            old_name=self.quote_name(old_name),\n  1380\t            new_name=self.quote_name(new_name),\n  1381\t        )\n          # ...\n```\n\n</search_result>\n"
            }
          ],
          "response": {
            "id": "msg_011MMxSWNenFY8oMfoYJMLhV",
            "content": [
              {
                "text": "I'll help identify the relevant code sections for the RenameIndex operation implementation. Let me analyze the search results and mark the relevant sections.",
                "type": "text"
              },
              {
                "id": "toolu_01XYLWrkinSybrWf6Ef9tXS9",
                "input": {
                  "scratch_pad": "The search results contain the complete implementation of the RenameIndex operation in Django's migration system. The relevant sections include:\n\n1. Main RenameIndex class definition and its methods (lines 879-1022 in migrations/operations/models.py):\n- Class definition and core functionality\n- Property methods for name handling\n- Key operation methods like state_forwards, database_forwards, database_backwards\n- Support methods like describe, deconstruct, reduce\n\n2. Supporting implementation in schema.py (lines 134, 1374-1381):\n- SQL template for rename index operation\n- Method to generate the SQL for renaming an index\n\nThese sections show the complete implementation of how Django handles index renaming operations in database migrations.",
                  "identified_spans": [
                    {
                      "file_path": "django/db/migrations/operations/models.py",
                      "start_line": 879,
                      "end_line": 1022
                    },
                    {
                      "file_path": "django/db/backends/base/schema.py",
                      "start_line": 134,
                      "end_line": 134
                    },
                    {
                      "file_path": "django/db/backends/base/schema.py",
                      "start_line": 1374,
                      "end_line": 1381
                    }
                  ]
                },
                "name": "Action",
                "type": "tool_use"
              }
            ],
            "model": "claude-3-5-sonnet-20241022",
            "role": "assistant",
            "stop_reason": "tool_use",
            "stop_sequence": null,
            "type": "message",
            "usage": {
              "cache_creation_input_tokens": 0,
              "cache_read_input_tokens": 0,
              "input_tokens": 4668,
              "output_tokens": 398
            }
          },
          "usage": {
            "completion_cost": 0.019974000000000002,
            "completion_tokens": 398,
            "prompt_tokens": 4668,
            "cached_tokens": 0
          }
        }
      },
      "parent_id": 1
    },
    {
      "node_id": 3,
      "action": {
        "scratch_pad": "1. Looking at the code, I can see that RenameIndex has two modes:\n   - Renaming an index by old_name \n   - Renaming an unnamed index by old_fields\n\n2. The issue appears to be in the database_backwards() method when dealing with unnamed indexes. The method has a comment \"Backward operation with unnamed index is a no-op\" and just returns without doing anything.\n\n3. This means that when trying to revert an unnamed index rename operation, it doesn't properly restore the old auto-generated name.\n\n4. The fix should be to:\n   - Remove the early return for unnamed indexes in database_backwards()\n   - Handle the reversal properly by swapping names and letting database_forwards() handle it\n\nLet me look at the test file again to understand the exact test case that's failing.",
        "files": [
          {
            "file_path": "tests/migrations/test_operations.py",
            "start_line": 2980,
            "end_line": 3000,
            "span_ids": []
          }
        ],
        "action_args_class": "moatless.actions.view_code.ViewCodeArgs"
      },
      "observation": {
        "message": "Here's the contents of the requested code spans:\ntests/migrations/test_operations.py\n```\n     1\tfrom django.core.exceptions import FieldDoesNotExist\n     2\tfrom django.db import IntegrityError, connection, migrations, models, transaction\n     3\tfrom django.db.migrations.migration import Migration\n     4\tfrom django.db.migrations.operations.fields import FieldOperation\n     5\tfrom django.db.migrations.state import ModelState, ProjectState\n     6\tfrom django.db.models.functions import Abs\n     7\tfrom django.db.transaction import atomic\n     8\tfrom django.test import SimpleTestCase, override_settings, skipUnlessDBFeature\n     9\tfrom django.test.utils import CaptureQueriesContext\n    10\t\n    11\tfrom .models import FoodManager, FoodQuerySet, UnicodeModel\n    12\tfrom .test_base import OperationTestBase\n      # ...\n    17\t\n    18\t\n    19\tclass OperationTests(OperationTestBase):\n    20\t    \"\"\"\n    21\t    Tests running the operations and making sure they do what they say they do.\n    22\t    Each test looks at their state changing, and then their database operation -\n    23\t    both forwards and backwards.\n    24\t    \"\"\"\n          # ...\n  2963\t\n  2964\t    def test_rename_index_unnamed_index(self):\n  2965\t        app_label = \"test_rninui\"\n  2966\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  2967\t        table_name = app_label + \"_pony\"\n  2968\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2969\t        operation = migrations.RenameIndex(\n  2970\t            \"Pony\", new_name=\"new_pony_test_idx\", old_fields=(\"weight\", \"pink\")\n  2971\t        )\n  2972\t        self.assertEqual(\n  2973\t            operation.describe(),\n  2974\t            \"Rename unnamed index for ('weight', 'pink') on Pony to new_pony_test_idx\",\n  2975\t        )\n  2976\t        self.assertEqual(\n  2977\t            operation.migration_name_fragment,\n  2978\t            \"rename_pony_weight_pink_new_pony_test_idx\",\n  2979\t        )\n  2980\t\n  2981\t        new_state = project_state.clone()\n  2982\t        operation.state_forwards(app_label, new_state)\n  2983\t        # Rename index.\n  2984\t        with connection.schema_editor() as editor:\n  2985\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2986\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2987\t        # Reverse is a no-op.\n  2988\t        with connection.schema_editor() as editor, self.assertNumQueries(0):\n  2989\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2990\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2991\t        # Deconstruction.\n  2992\t        definition = operation.deconstruct()\n  2993\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2994\t        self.assertEqual(definition[1], [])\n  2995\t        self.assertEqual(\n  2996\t            definition[2],\n  2997\t            {\n  2998\t                \"model_name\": \"Pony\",\n  2999\t                \"new_name\": \"new_pony_test_idx\",\n  3000\t                \"old_fields\": (\"weight\", \"pink\"),\n  3001\t            },\n  3002\t        )\n          # ...\n      # ...\n```\n",
        "summary": "Showed the following code spans:\n\nFile: tests/migrations/test_operations.py\n- Showing all code in file\n\nFile: django/db/migrations/operations/models.py\n- imports\n- RenameIndex\n- RenameIndex.__init__\n- RenameIndex.old_name_lower\n- RenameIndex.new_name_lower\n- RenameIndex.deconstruct\n- RenameIndex.state_forwards\n- RenameIndex.database_forwards\n- RenameIndex.database_backwards\n- RenameIndex.describe\n- RenameIndex.migration_name_fragment\n- RenameIndex.reduce\n\nFile: django/db/backends/base/schema.py\n- imports\n- BaseDatabaseSchemaEditor\n- BaseDatabaseSchemaEditor._rename_index_sql\n",
        "terminal": false,
        "expect_correction": false,
        "properties": {
          "files": {
            "tests/migrations/test_operations.py": {
              "new_span_ids": [
                "OperationTests",
                "OperationTests.test_rename_index_unnamed_index"
              ]
            }
          }
        }
      },
      "file_context": {
        "max_tokens": 8000,
        "files": [
          {
            "file_path": "tests/migrations/test_operations.py",
            "spans": [
              {
                "span_id": "imports",
                "pinned": false
              },
              {
                "span_id": "OperationTests",
                "pinned": false
              },
              {
                "span_id": "OperationTests.test_rename_index_unnamed_index",
                "pinned": false
              }
            ],
            "show_all_spans": true,
            "patch": null
          },
          {
            "file_path": "django/db/migrations/operations/models.py",
            "spans": [
              {
                "span_id": "imports",
                "pinned": false
              },
              {
                "span_id": "RenameIndex",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.__init__",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.old_name_lower",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.new_name_lower",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.deconstruct",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.state_forwards",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.database_forwards",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.database_backwards",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.describe",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.migration_name_fragment",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.reduce",
                "pinned": false
              }
            ],
            "show_all_spans": false,
            "patch": null
          },
          {
            "file_path": "django/db/backends/base/schema.py",
            "spans": [
              {
                "span_id": "imports",
                "pinned": false
              },
              {
                "span_id": "BaseDatabaseSchemaEditor",
                "pinned": false
              },
              {
                "span_id": "BaseDatabaseSchemaEditor._rename_index_sql",
                "pinned": false
              }
            ],
            "show_all_spans": false,
            "patch": null
          }
        ]
      },
      "completions": {
        "build_action": {
          "model": "claude-3-5-sonnet-20241022",
          "input": [
            {
              "role": "user",
              "content": "<task>\nRenameIndex() crashes when unnamed index is moving backward and forward.\nDescription\n\t\nRenameIndex() should restore the old auto-generated name when an unnamed index for unique_together is moving backward. Now re-applying RenameIndex() crashes. For example:\ntests/migrations/test_operations.py\ndiff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex cfd28b1b39..c0a55023bb 100644\n\t\t\t\t\t\n\t\t\t\t\t a\n\t\t\t\t \n\t\t\t\t\t\n\t\t\t\t\t b\n\t\t\t\t \n class OperationTests(OperationTestBase):\u00a0\n29882988\u00a0 \u00a0 \u00a0 \u00a0 with connection.schema_editor() as editor, self.assertNumQueries(0):\n29892989\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 operation.database_backwards(app_label, editor, new_state, project_state)\n29902990\u00a0 \u00a0 \u00a0 \u00a0 self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n\u00a02991\u00a0 \u00a0 \u00a0 \u00a0 # Re-apply renaming.\n\u00a02992\u00a0 \u00a0 \u00a0 \u00a0 with connection.schema_editor() as editor:\n\u00a02993\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 operation.database_forwards(app_label, editor, project_state, new_state)\n\u00a02994\u00a0 \u00a0 \u00a0 \u00a0 self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n29912995\u00a0 \u00a0 \u00a0 \u00a0 # Deconstruction.\n29922996\u00a0 \u00a0 \u00a0 \u00a0 definition = operation.deconstruct()\n29932997\u00a0 \u00a0 \u00a0 \u00a0 self.assertEqual(definition[0], \"RenameIndex\")\ncrashes on PostgreSQL:\ndjango.db.utils.ProgrammingError: relation \"new_pony_test_idx\" already exists\n\n</task>"
            },
            {
              "role": "assistant",
              "content": [
                {
                  "type": "text",
                  "text": "<thoughts>\n1. First, I need to understand the context better by:\n   - Looking at the test file to see the full test case\n   - Finding the RenameIndex operation implementation\n   - Understanding how index naming works in this context\n\n2. Let's start by viewing the test file to see the full test case context.\n</thoughts>"
                },
                {
                  "id": "call_8635dcc7",
                  "input": {
                    "files": [
                      {
                        "file_path": "tests/migrations/test_operations.py",
                        "start_line": null,
                        "end_line": null,
                        "span_ids": []
                      }
                    ]
                  },
                  "type": "tool_use",
                  "name": "ViewCode"
                }
              ]
            },
            {
              "role": "user",
              "content": [
                {
                  "tool_use_id": "call_8635dcc7",
                  "content": "<observation>\nHere's the contents of the requested code spans:\ntests/migrations/test_operations.py\n```\n     1\tfrom django.core.exceptions import FieldDoesNotExist\n     2\tfrom django.db import IntegrityError, connection, migrations, models, transaction\n     3\tfrom django.db.migrations.migration import Migration\n     4\tfrom django.db.migrations.operations.fields import FieldOperation\n     5\tfrom django.db.migrations.state import ModelState, ProjectState\n     6\tfrom django.db.models.functions import Abs\n     7\tfrom django.db.transaction import atomic\n     8\tfrom django.test import SimpleTestCase, override_settings, skipUnlessDBFeature\n     9\tfrom django.test.utils import CaptureQueriesContext\n    10\t\n    11\tfrom .models import FoodManager, FoodQuerySet, UnicodeModel\n    12\tfrom .test_base import OperationTestBase\n    13\t\n    14\t\n    15\tclass Mixin:\n    16\t    pass\n    17\t\n    18\t\n    19\tclass OperationTests(OperationTestBase):\n    20\t    \"\"\"\n    21\t    Tests running the operations and making sure they do what they say they do.\n    22\t    Each test looks at their state changing, and then their database operation -\n    23\t    both forwards and backwards.\n    24\t    \"\"\"\n    25\t\n    26\t    def test_create_model(self):\n    27\t        \"\"\"\n    28\t        Tests the CreateModel operation.\n    29\t        Most other tests use this operation as part of setup, so check failures\n    30\t        here first.\n    31\t        \"\"\"\n    32\t        operation = migrations.CreateModel(\n    33\t            \"Pony\",\n    34\t            [\n    35\t                (\"id\", models.AutoField(primary_key=True)),\n    36\t                (\"pink\", models.IntegerField(default=1)),\n    37\t            ],\n    38\t        )\n    39\t        self.assertEqual(operation.describe(), \"Create model Pony\")\n    40\t        self.assertEqual(operation.migration_name_fragment, \"pony\")\n    41\t        # Test the state alteration\n    42\t        project_state = ProjectState()\n    43\t        new_state = project_state.clone()\n    44\t        operation.state_forwards(\"test_crmo\", new_state)\n    45\t        self.assertEqual(new_state.models[\"test_crmo\", \"pony\"].name, \"Pony\")\n    46\t        self.assertEqual(len(new_state.models[\"test_crmo\", \"pony\"].fields), 2)\n    47\t        # Test the database alteration\n    48\t        self.assertTableNotExists(\"test_crmo_pony\")\n    49\t        with connection.schema_editor() as editor:\n    50\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n    51\t        self.assertTableExists(\"test_crmo_pony\")\n    52\t        # And test reversal\n    53\t        with connection.schema_editor() as editor:\n    54\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n    55\t        self.assertTableNotExists(\"test_crmo_pony\")\n    56\t        # And deconstruction\n    57\t        definition = operation.deconstruct()\n    58\t        self.assertEqual(definition[0], \"CreateModel\")\n    59\t        self.assertEqual(definition[1], [])\n    60\t        self.assertEqual(sorted(definition[2]), [\"fields\", \"name\"])\n    61\t        # And default manager not in set\n    62\t        operation = migrations.CreateModel(\n    63\t            \"Foo\", fields=[], managers=[(\"objects\", models.Manager())]\n    64\t        )\n    65\t        definition = operation.deconstruct()\n    66\t        self.assertNotIn(\"managers\", definition[2])\n    67\t\n    68\t    def test_create_model_with_duplicate_field_name(self):\n    69\t        with self.assertRaisesMessage(\n    70\t            ValueError, \"Found duplicate value pink in CreateModel fields argument.\"\n    71\t        ):\n    72\t            migrations.CreateModel(\n    73\t                \"Pony\",\n    74\t                [\n    75\t                    (\"id\", models.AutoField(primary_key=True)),\n    76\t                    (\"pink\", models.TextField()),\n    77\t                    (\"pink\", models.IntegerField(default=1)),\n    78\t                ],\n    79\t            )\n    80\t\n    81\t    def test_create_model_with_duplicate_base(self):\n    82\t        message = \"Found duplicate value test_crmo.pony in CreateModel bases argument.\"\n    83\t        with self.assertRaisesMessage(ValueError, message):\n    84\t            migrations.CreateModel(\n    85\t                \"Pony\",\n    86\t                fields=[],\n    87\t                bases=(\n    88\t                    \"test_crmo.Pony\",\n    89\t                    \"test_crmo.Pony\",\n    90\t                ),\n    91\t            )\n    92\t        with self.assertRaisesMessage(ValueError, message):\n    93\t            migrations.CreateModel(\n    94\t                \"Pony\",\n    95\t                fields=[],\n    96\t                bases=(\n    97\t                    \"test_crmo.Pony\",\n    98\t                    \"test_crmo.pony\",\n    99\t                ),\n   100\t            )\n   101\t        message = (\n   102\t            \"Found duplicate value migrations.unicodemodel in CreateModel bases \"\n   103\t            \"argument.\"\n   104\t        )\n   105\t        with self.assertRaisesMessage(ValueError, message):\n   106\t            migrations.CreateModel(\n   107\t                \"Pony\",\n   108\t                fields=[],\n   109\t                bases=(\n   110\t                    UnicodeModel,\n   111\t                    UnicodeModel,\n   112\t                ),\n   113\t            )\n   114\t        with self.assertRaisesMessage(ValueError, message):\n   115\t            migrations.CreateModel(\n   116\t                \"Pony\",\n   117\t                fields=[],\n   118\t                bases=(\n   119\t                    UnicodeModel,\n   120\t                    \"migrations.unicodemodel\",\n   121\t                ),\n   122\t            )\n   123\t        with self.assertRaisesMessage(ValueError, message):\n   124\t            migrations.CreateModel(\n   125\t                \"Pony\",\n   126\t                fields=[],\n   127\t                bases=(\n   128\t                    UnicodeModel,\n   129\t                    \"migrations.UnicodeModel\",\n   130\t                ),\n   131\t            )\n   132\t        message = (\n   133\t            \"Found duplicate value <class 'django.db.models.base.Model'> in \"\n   134\t            \"CreateModel bases argument.\"\n   135\t        )\n   136\t        with self.assertRaisesMessage(ValueError, message):\n   137\t            migrations.CreateModel(\n   138\t                \"Pony\",\n   139\t                fields=[],\n   140\t                bases=(\n   141\t                    models.Model,\n   142\t                    models.Model,\n   143\t                ),\n   144\t            )\n   145\t        message = (\n   146\t            \"Found duplicate value <class 'migrations.test_operations.Mixin'> in \"\n   147\t            \"CreateModel bases argument.\"\n   148\t        )\n   149\t        with self.assertRaisesMessage(ValueError, message):\n   150\t            migrations.CreateModel(\n   151\t                \"Pony\",\n   152\t                fields=[],\n   153\t                bases=(\n   154\t                    Mixin,\n   155\t                    Mixin,\n   156\t                ),\n   157\t            )\n   158\t\n   159\t    def test_create_model_with_duplicate_manager_name(self):\n   160\t        with self.assertRaisesMessage(\n   161\t            ValueError,\n   162\t            \"Found duplicate value objects in CreateModel managers argument.\",\n   163\t        ):\n   164\t            migrations.CreateModel(\n   165\t                \"Pony\",\n   166\t                fields=[],\n   167\t                managers=[\n   168\t                    (\"objects\", models.Manager()),\n   169\t                    (\"objects\", models.Manager()),\n   170\t                ],\n   171\t            )\n   172\t\n   173\t    def test_create_model_with_unique_after(self):\n   174\t        \"\"\"\n   175\t        Tests the CreateModel operation directly followed by an\n   176\t        AlterUniqueTogether (bug #22844 - sqlite remake issues)\n   177\t        \"\"\"\n   178\t        operation1 = migrations.CreateModel(\n   179\t            \"Pony\",\n   180\t            [\n   181\t                (\"id\", models.AutoField(primary_key=True)),\n   182\t                (\"pink\", models.IntegerField(default=1)),\n   183\t            ],\n   184\t        )\n   185\t        operation2 = migrations.CreateModel(\n   186\t            \"Rider\",\n   187\t            [\n   188\t                (\"id\", models.AutoField(primary_key=True)),\n   189\t                (\"number\", models.IntegerField(default=1)),\n   190\t                (\"pony\", models.ForeignKey(\"test_crmoua.Pony\", models.CASCADE)),\n   191\t            ],\n   192\t        )\n   193\t        operation3 = migrations.AlterUniqueTogether(\n   194\t            \"Rider\",\n   195\t            [\n   196\t                (\"number\", \"pony\"),\n   197\t            ],\n   198\t        )\n   199\t        # Test the database alteration\n   200\t        project_state = ProjectState()\n   201\t        self.assertTableNotExists(\"test_crmoua_pony\")\n   202\t        self.assertTableNotExists(\"test_crmoua_rider\")\n   203\t        with connection.schema_editor() as editor:\n   204\t            new_state = project_state.clone()\n   205\t            operation1.state_forwards(\"test_crmoua\", new_state)\n   206\t            operation1.database_forwards(\n   207\t                \"test_crmoua\", editor, project_state, new_state\n   208\t            )\n   209\t            project_state, new_state = new_state, new_state.clone()\n   210\t            operation2.state_forwards(\"test_crmoua\", new_state)\n   211\t            operation2.database_forwards(\n   212\t                \"test_crmoua\", editor, project_state, new_state\n   213\t            )\n   214\t            project_state, new_state = new_state, new_state.clone()\n   215\t            operation3.state_forwards(\"test_crmoua\", new_state)\n   216\t            operation3.database_forwards(\n   217\t                \"test_crmoua\", editor, project_state, new_state\n   218\t            )\n   219\t        self.assertTableExists(\"test_crmoua_pony\")\n   220\t        self.assertTableExists(\"test_crmoua_rider\")\n   221\t\n   222\t    def test_create_model_m2m(self):\n   223\t        \"\"\"\n   224\t        Test the creation of a model with a ManyToMany field and the\n   225\t        auto-created \"through\" model.\n   226\t        \"\"\"\n   227\t        project_state = self.set_up_test_model(\"test_crmomm\")\n   228\t        operation = migrations.CreateModel(\n   229\t            \"Stable\",\n   230\t            [\n   231\t                (\"id\", models.AutoField(primary_key=True)),\n   232\t                (\"ponies\", models.ManyToManyField(\"Pony\", related_name=\"stables\")),\n   233\t            ],\n   234\t        )\n   235\t        # Test the state alteration\n   236\t        new_state = project_state.clone()\n   237\t        operation.state_forwards(\"test_crmomm\", new_state)\n   238\t        # Test the database alteration\n   239\t        self.assertTableNotExists(\"test_crmomm_stable_ponies\")\n   240\t        with connection.schema_editor() as editor:\n   241\t            operation.database_forwards(\"test_crmomm\", editor, project_state, new_state)\n   242\t        self.assertTableExists(\"test_crmomm_stable\")\n   243\t        self.assertTableExists(\"test_crmomm_stable_ponies\")\n   244\t        self.assertColumnNotExists(\"test_crmomm_stable\", \"ponies\")\n   245\t        # Make sure the M2M field actually works\n   246\t        with atomic():\n   247\t            Pony = new_state.apps.get_model(\"test_crmomm\", \"Pony\")\n   248\t            Stable = new_state.apps.get_model(\"test_crmomm\", \"Stable\")\n   249\t            stable = Stable.objects.create()\n   250\t            p1 = Pony.objects.create(pink=False, weight=4.55)\n   251\t            p2 = Pony.objects.create(pink=True, weight=5.43)\n   252\t            stable.ponies.add(p1, p2)\n   253\t            self.assertEqual(stable.ponies.count(), 2)\n   254\t            stable.ponies.all().delete()\n   255\t        # And test reversal\n   256\t        with connection.schema_editor() as editor:\n   257\t            operation.database_backwards(\n   258\t                \"test_crmomm\", editor, new_state, project_state\n   259\t            )\n   260\t        self.assertTableNotExists(\"test_crmomm_stable\")\n   261\t        self.assertTableNotExists(\"test_crmomm_stable_ponies\")\n   262\t\n   263\t    @skipUnlessDBFeature(\"supports_collation_on_charfield\", \"supports_foreign_keys\")\n   264\t    def test_create_fk_models_to_pk_field_db_collation(self):\n   265\t        \"\"\"Creation of models with a FK to a PK with db_collation.\"\"\"\n   266\t        collation = connection.features.test_collations.get(\"non_default\")\n   267\t        if not collation:\n   268\t            self.skipTest(\"Language collations are not supported.\")\n   269\t\n   270\t        app_label = \"test_cfkmtopkfdbc\"\n   271\t        operations = [\n   272\t            migrations.CreateModel(\n   273\t                \"Pony\",\n   274\t                [\n   275\t                    (\n   276\t                        \"id\",\n   277\t                        models.CharField(\n   278\t                            primary_key=True,\n   279\t                            max_length=10,\n   280\t                            db_collation=collation,\n   281\t                        ),\n   282\t                    ),\n   283\t                ],\n   284\t            )\n   285\t        ]\n   286\t        project_state = self.apply_operations(app_label, ProjectState(), operations)\n   287\t        # ForeignKey.\n   288\t        new_state = project_state.clone()\n   289\t        operation = migrations.CreateModel(\n   290\t            \"Rider\",\n   291\t            [\n   292\t                (\"id\", models.AutoField(primary_key=True)),\n   293\t                (\"pony\", models.ForeignKey(\"Pony\", models.CASCADE)),\n   294\t            ],\n   295\t        )\n   296\t        operation.state_forwards(app_label, new_state)\n   297\t        with connection.schema_editor() as editor:\n   298\t            operation.database_forwards(app_label, editor, project_state, new_state)\n   299\t        self.assertColumnCollation(f\"{app_label}_rider\", \"pony_id\", collation)\n   300\t        # Reversal.\n   301\t        with connection.schema_editor() as editor:\n   302\t            operation.database_backwards(app_label, editor, new_state, project_state)\n   303\t        # OneToOneField.\n   304\t        new_state = project_state.clone()\n   305\t        operation = migrations.CreateModel(\n   306\t            \"ShetlandPony\",\n   307\t            [\n   308\t                (\n   309\t                    \"pony\",\n   310\t                    models.OneToOneField(\"Pony\", models.CASCADE, primary_key=True),\n   311\t                ),\n   312\t                (\"cuteness\", models.IntegerField(default=1)),\n   313\t            ],\n   314\t        )\n   315\t        operation.state_forwards(app_label, new_state)\n   316\t        with connection.schema_editor() as editor:\n   317\t            operation.database_forwards(app_label, editor, project_state, new_state)\n   318\t        self.assertColumnCollation(f\"{app_label}_shetlandpony\", \"pony_id\", collation)\n   319\t        # Reversal.\n   320\t        with connection.schema_editor() as editor:\n   321\t            operation.database_backwards(app_label, editor, new_state, project_state)\n   322\t\n   323\t    def test_create_model_inheritance(self):\n   324\t        \"\"\"\n   325\t        Tests the CreateModel operation on a multi-table inheritance setup.\n   326\t        \"\"\"\n   327\t        project_state = self.set_up_test_model(\"test_crmoih\")\n   328\t        # Test the state alteration\n   329\t        operation = migrations.CreateModel(\n   330\t            \"ShetlandPony\",\n   331\t            [\n   332\t                (\n   333\t                    \"pony_ptr\",\n   334\t                    models.OneToOneField(\n   335\t                        \"test_crmoih.Pony\",\n   336\t                        models.CASCADE,\n   337\t                        auto_created=True,\n   338\t                        primary_key=True,\n   339\t                        to_field=\"id\",\n   340\t                        serialize=False,\n   341\t                    ),\n   342\t                ),\n   343\t                (\"cuteness\", models.IntegerField(default=1)),\n   344\t            ],\n   345\t        )\n   346\t        new_state = project_state.clone()\n   347\t        operation.state_forwards(\"test_crmoih\", new_state)\n   348\t        self.assertIn((\"test_crmoih\", \"shetlandpony\"), new_state.models)\n   349\t        # Test the database alteration\n   350\t        self.assertTableNotExists(\"test_crmoih_shetlandpony\")\n   351\t        with connection.schema_editor() as editor:\n   352\t            operation.database_forwards(\"test_crmoih\", editor, project_state, new_state)\n   353\t        self.assertTableExists(\"test_crmoih_shetlandpony\")\n   354\t        # And test reversal\n   355\t        with connection.schema_editor() as editor:\n   356\t            operation.database_backwards(\n   357\t                \"test_crmoih\", editor, new_state, project_state\n   358\t            )\n   359\t        self.assertTableNotExists(\"test_crmoih_shetlandpony\")\n   360\t\n   361\t    def test_create_proxy_model(self):\n   362\t        \"\"\"\n   363\t        CreateModel ignores proxy models.\n   364\t        \"\"\"\n   365\t        project_state = self.set_up_test_model(\"test_crprmo\")\n   366\t        # Test the state alteration\n   367\t        operation = migrations.CreateModel(\n   368\t            \"ProxyPony\",\n   369\t            [],\n   370\t            options={\"proxy\": True},\n   371\t            bases=(\"test_crprmo.Pony\",),\n   372\t        )\n   373\t        self.assertEqual(operation.describe(), \"Create proxy model ProxyPony\")\n   374\t        new_state = project_state.clone()\n   375\t        operation.state_forwards(\"test_crprmo\", new_state)\n   376\t        self.assertIn((\"test_crprmo\", \"proxypony\"), new_state.models)\n   377\t        # Test the database alteration\n   378\t        self.assertTableNotExists(\"test_crprmo_proxypony\")\n   379\t        self.assertTableExists(\"test_crprmo_pony\")\n   380\t        with connection.schema_editor() as editor:\n   381\t            operation.database_forwards(\"test_crprmo\", editor, project_state, new_state)\n   382\t        self.assertTableNotExists(\"test_crprmo_proxypony\")\n   383\t        self.assertTableExists(\"test_crprmo_pony\")\n   384\t        # And test reversal\n   385\t        with connection.schema_editor() as editor:\n   386\t            operation.database_backwards(\n   387\t                \"test_crprmo\", editor, new_state, project_state\n   388\t            )\n   389\t        self.assertTableNotExists(\"test_crprmo_proxypony\")\n   390\t        self.assertTableExists(\"test_crprmo_pony\")\n   391\t        # And deconstruction\n   392\t        definition = operation.deconstruct()\n   393\t        self.assertEqual(definition[0], \"CreateModel\")\n   394\t        self.assertEqual(definition[1], [])\n   395\t        self.assertEqual(sorted(definition[2]), [\"bases\", \"fields\", \"name\", \"options\"])\n   396\t\n   397\t    def test_create_unmanaged_model(self):\n   398\t        \"\"\"\n   399\t        CreateModel ignores unmanaged models.\n   400\t        \"\"\"\n   401\t        project_state = self.set_up_test_model(\"test_crummo\")\n   402\t        # Test the state alteration\n   403\t        operation = migrations.CreateModel(\n   404\t            \"UnmanagedPony\",\n   405\t            [],\n   406\t            options={\"proxy\": True},\n   407\t            bases=(\"test_crummo.Pony\",),\n   408\t        )\n   409\t        self.assertEqual(operation.describe(), \"Create proxy model UnmanagedPony\")\n   410\t        new_state = project_state.clone()\n   411\t        operation.state_forwards(\"test_crummo\", new_state)\n   412\t        self.assertIn((\"test_crummo\", \"unmanagedpony\"), new_state.models)\n   413\t        # Test the database alteration\n   414\t        self.assertTableNotExists(\"test_crummo_unmanagedpony\")\n   415\t        self.assertTableExists(\"test_crummo_pony\")\n   416\t        with connection.schema_editor() as editor:\n   417\t            operation.database_forwards(\"test_crummo\", editor, project_state, new_state)\n   418\t        self.assertTableNotExists(\"test_crummo_unmanagedpony\")\n   419\t        self.assertTableExists(\"test_crummo_pony\")\n   420\t        # And test reversal\n   421\t        with connection.schema_editor() as editor:\n   422\t            operation.database_backwards(\n   423\t                \"test_crummo\", editor, new_state, project_state\n   424\t            )\n   425\t        self.assertTableNotExists(\"test_crummo_unmanagedpony\")\n   426\t        self.assertTableExists(\"test_crummo_pony\")\n   427\t\n   428\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n   429\t    def test_create_model_with_constraint(self):\n   430\t        where = models.Q(pink__gt=2)\n   431\t        check_constraint = models.CheckConstraint(\n   432\t            check=where, name=\"test_constraint_pony_pink_gt_2\"\n   433\t        )\n   434\t        operation = migrations.CreateModel(\n   435\t            \"Pony\",\n   436\t            [\n   437\t                (\"id\", models.AutoField(primary_key=True)),\n   438\t                (\"pink\", models.IntegerField(default=3)),\n   439\t            ],\n   440\t            options={\"constraints\": [check_constraint]},\n   441\t        )\n   442\t\n   443\t        # Test the state alteration\n   444\t        project_state = ProjectState()\n   445\t        new_state = project_state.clone()\n   446\t        operation.state_forwards(\"test_crmo\", new_state)\n   447\t        self.assertEqual(\n   448\t            len(new_state.models[\"test_crmo\", \"pony\"].options[\"constraints\"]), 1\n   449\t        )\n   450\t\n   451\t        # Test database alteration\n   452\t        self.assertTableNotExists(\"test_crmo_pony\")\n   453\t        with connection.schema_editor() as editor:\n   454\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n   455\t        self.assertTableExists(\"test_crmo_pony\")\n   456\t        with connection.cursor() as cursor:\n   457\t            with self.assertRaises(IntegrityError):\n   458\t                cursor.execute(\"INSERT INTO test_crmo_pony (id, pink) VALUES (1, 1)\")\n   459\t\n   460\t        # Test reversal\n   461\t        with connection.schema_editor() as editor:\n   462\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n   463\t        self.assertTableNotExists(\"test_crmo_pony\")\n   464\t\n   465\t        # Test deconstruction\n   466\t        definition = operation.deconstruct()\n   467\t        self.assertEqual(definition[0], \"CreateModel\")\n   468\t        self.assertEqual(definition[1], [])\n   469\t        self.assertEqual(definition[2][\"options\"][\"constraints\"], [check_constraint])\n   470\t\n   471\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n   472\t    def test_create_model_with_boolean_expression_in_check_constraint(self):\n   473\t        app_label = \"test_crmobechc\"\n   474\t        rawsql_constraint = models.CheckConstraint(\n   475\t            check=models.expressions.RawSQL(\n   476\t                \"price < %s\", (1000,), output_field=models.BooleanField()\n   477\t            ),\n   478\t            name=f\"{app_label}_price_lt_1000_raw\",\n   479\t        )\n   480\t        wrapper_constraint = models.CheckConstraint(\n   481\t            check=models.expressions.ExpressionWrapper(\n   482\t                models.Q(price__gt=500) | models.Q(price__lt=500),\n   483\t                output_field=models.BooleanField(),\n   484\t            ),\n   485\t            name=f\"{app_label}_price_neq_500_wrap\",\n   486\t        )\n   487\t        operation = migrations.CreateModel(\n   488\t            \"Product\",\n   489\t            [\n   490\t                (\"id\", models.AutoField(primary_key=True)),\n   491\t                (\"price\", models.IntegerField(null=True)),\n   492\t            ],\n   493\t            options={\"constraints\": [rawsql_constraint, wrapper_constraint]},\n   494\t        )\n   495\t\n   496\t        project_state = ProjectState()\n   497\t        new_state = project_state.clone()\n   498\t        operation.state_forwards(app_label, new_state)\n   499\t        # Add table.\n   500\t        self.assertTableNotExists(app_label)\n   501\t        with connection.schema_editor() as editor:\n   502\t            operation.database_forwards(app_label, editor, project_state, new_state)\n   503\t        self.assertTableExists(f\"{app_label}_product\")\n   504\t        insert_sql = f\"INSERT INTO {app_label}_product (id, price) VALUES (%d, %d)\"\n   505\t        with connection.cursor() as cursor:\n   506\t            with self.assertRaises(IntegrityError):\n   507\t                cursor.execute(insert_sql % (1, 1000))\n   508\t            cursor.execute(insert_sql % (1, 999))\n   509\t            with self.assertRaises(IntegrityError):\n   510\t                cursor.execute(insert_sql % (2, 500))\n   511\t            cursor.execute(insert_sql % (2, 499))\n   512\t\n   513\t    def test_create_model_with_partial_unique_constraint(self):\n   514\t        partial_unique_constraint = models.UniqueConstraint(\n   515\t            fields=[\"pink\"],\n   516\t            condition=models.Q(weight__gt=5),\n   517\t            name=\"test_constraint_pony_pink_for_weight_gt_5_uniq\",\n   518\t        )\n   519\t        operation = migrations.CreateModel(\n   520\t            \"Pony\",\n   521\t            [\n   522\t                (\"id\", models.AutoField(primary_key=True)),\n   523\t                (\"pink\", models.IntegerField(default=3)),\n   524\t                (\"weight\", models.FloatField()),\n   525\t            ],\n   526\t            options={\"constraints\": [partial_unique_constraint]},\n   527\t        )\n   528\t        # Test the state alteration\n   529\t        project_state = ProjectState()\n   530\t        new_state = project_state.clone()\n   531\t        operation.state_forwards(\"test_crmo\", new_state)\n   532\t        self.assertEqual(\n   533\t            len(new_state.models[\"test_crmo\", \"pony\"].options[\"constraints\"]), 1\n   534\t        )\n   535\t        # Test database alteration\n   536\t        self.assertTableNotExists(\"test_crmo_pony\")\n   537\t        with connection.schema_editor() as editor:\n   538\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n   539\t        self.assertTableExists(\"test_crmo_pony\")\n   540\t        # Test constraint works\n   541\t        Pony = new_state.apps.get_model(\"test_crmo\", \"Pony\")\n   542\t        Pony.objects.create(pink=1, weight=4.0)\n   543\t        Pony.objects.create(pink=1, weight=4.0)\n   544\t        Pony.objects.create(pink=1, weight=6.0)\n   545\t        if connection.features.supports_partial_indexes:\n   546\t            with self.assertRaises(IntegrityError):\n   547\t                Pony.objects.create(pink=1, weight=7.0)\n   548\t        else:\n   549\t            Pony.objects.create(pink=1, weight=7.0)\n   550\t        # Test reversal\n   551\t        with connection.schema_editor() as editor:\n   552\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n   553\t        self.assertTableNotExists(\"test_crmo_pony\")\n   554\t        # Test deconstruction\n   555\t        definition = operation.deconstruct()\n   556\t        self.assertEqual(definition[0], \"CreateModel\")\n   557\t        self.assertEqual(definition[1], [])\n   558\t        self.assertEqual(\n   559\t            definition[2][\"options\"][\"constraints\"], [partial_unique_constraint]\n   560\t        )\n   561\t\n   562\t    def test_create_model_with_deferred_unique_constraint(self):\n   563\t        deferred_unique_constraint = models.UniqueConstraint(\n   564\t            fields=[\"pink\"],\n   565\t            name=\"deferrable_pink_constraint\",\n   566\t            deferrable=models.Deferrable.DEFERRED,\n   567\t        )\n   568\t        operation = migrations.CreateModel(\n   569\t            \"Pony\",\n   570\t            [\n   571\t                (\"id\", models.AutoField(primary_key=True)),\n   572\t                (\"pink\", models.IntegerField(default=3)),\n   573\t            ],\n   574\t            options={\"constraints\": [deferred_unique_constraint]},\n   575\t        )\n   576\t        project_state = ProjectState()\n   577\t        new_state = project_state.clone()\n   578\t        operation.state_forwards(\"test_crmo\", new_state)\n   579\t        self.assertEqual(\n   580\t            len(new_state.models[\"test_crmo\", \"pony\"].options[\"constraints\"]), 1\n   581\t        )\n   582\t        self.assertTableNotExists(\"test_crmo_pony\")\n   583\t        # Create table.\n   584\t        with connection.schema_editor() as editor:\n   585\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n   586\t        self.assertTableExists(\"test_crmo_pony\")\n   587\t        Pony = new_state.apps.get_model(\"test_crmo\", \"Pony\")\n   588\t        Pony.objects.create(pink=1)\n   589\t        if connection.features.supports_deferrable_unique_constraints:\n   590\t            # Unique constraint is deferred.\n   591\t            with transaction.atomic():\n   592\t                obj = Pony.objects.create(pink=1)\n   593\t                obj.pink = 2\n   594\t                obj.save()\n   595\t            # Constraint behavior can be changed with SET CONSTRAINTS.\n   596\t            with self.assertRaises(IntegrityError):\n   597\t                with transaction.atomic(), connection.cursor() as cursor:\n   598\t                    quoted_name = connection.ops.quote_name(\n   599\t                        deferred_unique_constraint.name\n   600\t                    )\n   601\t                    cursor.execute(\"SET CONSTRAINTS %s IMMEDIATE\" % quoted_name)\n   602\t                    obj = Pony.objects.create(pink=1)\n   603\t                    obj.pink = 3\n   604\t                    obj.save()\n   605\t        else:\n   606\t            Pony.objects.create(pink=1)\n   607\t        # Reversal.\n   608\t        with connection.schema_editor() as editor:\n   609\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n   610\t        self.assertTableNotExists(\"test_crmo_pony\")\n   611\t        # Deconstruction.\n   612\t        definition = operation.deconstruct()\n   613\t        self.assertEqual(definition[0], \"CreateModel\")\n   614\t        self.assertEqual(definition[1], [])\n   615\t        self.assertEqual(\n   616\t            definition[2][\"options\"][\"constraints\"],\n   617\t            [deferred_unique_constraint],\n   618\t        )\n   619\t\n   620\t    @skipUnlessDBFeature(\"supports_covering_indexes\")\n   621\t    def test_create_model_with_covering_unique_constraint(self):\n   622\t        covering_unique_constraint = models.UniqueConstraint(\n   623\t            fields=[\"pink\"],\n   624\t            include=[\"weight\"],\n   625\t            name=\"test_constraint_pony_pink_covering_weight\",\n   626\t        )\n   627\t        operation = migrations.CreateModel(\n   628\t            \"Pony\",\n   629\t            [\n   630\t                (\"id\", models.AutoField(primary_key=True)),\n   631\t                (\"pink\", models.IntegerField(default=3)),\n   632\t                (\"weight\", models.FloatField()),\n   633\t            ],\n   634\t            options={\"constraints\": [covering_unique_constraint]},\n   635\t        )\n   636\t        project_state = ProjectState()\n   637\t        new_state = project_state.clone()\n   638\t        operation.state_forwards(\"test_crmo\", new_state)\n   639\t        self.assertEqual(\n   640\t            len(new_state.models[\"test_crmo\", \"pony\"].options[\"constraints\"]), 1\n   641\t        )\n   642\t        self.assertTableNotExists(\"test_crmo_pony\")\n   643\t        # Create table.\n   644\t        with connection.schema_editor() as editor:\n   645\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n   646\t        self.assertTableExists(\"test_crmo_pony\")\n   647\t        Pony = new_state.apps.get_model(\"test_crmo\", \"Pony\")\n   648\t        Pony.objects.create(pink=1, weight=4.0)\n   649\t        with self.assertRaises(IntegrityError):\n   650\t            Pony.objects.create(pink=1, weight=7.0)\n   651\t        # Reversal.\n   652\t        with connection.schema_editor() as editor:\n   653\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n   654\t        self.assertTableNotExists(\"test_crmo_pony\")\n   655\t        # Deconstruction.\n   656\t        definition = operation.deconstruct()\n   657\t        self.assertEqual(definition[0], \"CreateModel\")\n   658\t        self.assertEqual(definition[1], [])\n   659\t        self.assertEqual(\n   660\t            definition[2][\"options\"][\"constraints\"],\n   661\t            [covering_unique_constraint],\n   662\t        )\n   663\t\n   664\t    def test_create_model_managers(self):\n   665\t        \"\"\"\n   666\t        The managers on a model are set.\n   667\t        \"\"\"\n   668\t        project_state = self.set_up_test_model(\"test_cmoma\")\n   669\t        # Test the state alteration\n   670\t        operation = migrations.CreateModel(\n   671\t            \"Food\",\n   672\t            fields=[\n   673\t                (\"id\", models.AutoField(primary_key=True)),\n   674\t            ],\n   675\t            managers=[\n   676\t                (\"food_qs\", FoodQuerySet.as_manager()),\n   677\t                (\"food_mgr\", FoodManager(\"a\", \"b\")),\n   678\t                (\"food_mgr_kwargs\", FoodManager(\"x\", \"y\", 3, 4)),\n   679\t            ],\n   680\t        )\n   681\t        self.assertEqual(operation.describe(), \"Create model Food\")\n   682\t        new_state = project_state.clone()\n   683\t        operation.state_forwards(\"test_cmoma\", new_state)\n   684\t        self.assertIn((\"test_cmoma\", \"food\"), new_state.models)\n   685\t        managers = new_state.models[\"test_cmoma\", \"food\"].managers\n   686\t        self.assertEqual(managers[0][0], \"food_qs\")\n   687\t        self.assertIsInstance(managers[0][1], models.Manager)\n   688\t        self.assertEqual(managers[1][0], \"food_mgr\")\n   689\t        self.assertIsInstance(managers[1][1], FoodManager)\n   690\t        self.assertEqual(managers[1][1].args, (\"a\", \"b\", 1, 2))\n   691\t        self.assertEqual(managers[2][0], \"food_mgr_kwargs\")\n   692\t        self.assertIsInstance(managers[2][1], FoodManager)\n   693\t        self.assertEqual(managers[2][1].args, (\"x\", \"y\", 3, 4))\n   694\t\n   695\t    def test_delete_model(self):\n   696\t        \"\"\"\n   697\t        Tests the DeleteModel operation.\n   698\t        \"\"\"\n   699\t        project_state = self.set_up_test_model(\"test_dlmo\")\n   700\t        # Test the state alteration\n   701\t        operation = migrations.DeleteModel(\"Pony\")\n   702\t        self.assertEqual(operation.describe(), \"Delete model Pony\")\n   703\t        self.assertEqual(operation.migration_name_fragment, \"delete_pony\")\n   704\t        new_state = project_state.clone()\n   705\t        operation.state_forwards(\"test_dlmo\", new_state)\n   706\t        self.assertNotIn((\"test_dlmo\", \"pony\"), new_state.models)\n   707\t        # Test the database alteration\n   708\t        self.assertTableExists(\"test_dlmo_pony\")\n   709\t        with connection.schema_editor() as editor:\n   710\t            operation.database_forwards(\"test_dlmo\", editor, project_state, new_state)\n   711\t        self.assertTableNotExists(\"test_dlmo_pony\")\n   712\t        # And test reversal\n   713\t        with connection.schema_editor() as editor:\n   714\t            operation.database_backwards(\"test_dlmo\", editor, new_state, project_state)\n   715\t        self.assertTableExists(\"test_dlmo_pony\")\n   716\t        # And deconstruction\n   717\t        definition = operation.deconstruct()\n   718\t        self.assertEqual(definition[0], \"DeleteModel\")\n   719\t        self.assertEqual(definition[1], [])\n   720\t        self.assertEqual(list(definition[2]), [\"name\"])\n   721\t\n   722\t    def test_delete_proxy_model(self):\n   723\t        \"\"\"\n   724\t        Tests the DeleteModel operation ignores proxy models.\n   725\t        \"\"\"\n   726\t        project_state = self.set_up_test_model(\"test_dlprmo\", proxy_model=True)\n   727\t        # Test the state alteration\n   728\t        operation = migrations.DeleteModel(\"ProxyPony\")\n   729\t        new_state = project_state.clone()\n   730\t        operation.state_forwards(\"test_dlprmo\", new_state)\n   731\t        self.assertIn((\"test_dlprmo\", \"proxypony\"), project_state.models)\n   732\t        self.assertNotIn((\"test_dlprmo\", \"proxypony\"), new_state.models)\n   733\t        # Test the database alteration\n   734\t        self.assertTableExists(\"test_dlprmo_pony\")\n   735\t        self.assertTableNotExists(\"test_dlprmo_proxypony\")\n   736\t        with connection.schema_editor() as editor:\n   737\t            operation.database_forwards(\"test_dlprmo\", editor, project_state, new_state)\n   738\t        self.assertTableExists(\"test_dlprmo_pony\")\n   739\t        self.assertTableNotExists(\"test_dlprmo_proxypony\")\n   740\t        # And test reversal\n   741\t        with connection.schema_editor() as editor:\n   742\t            operation.database_backwards(\n   743\t                \"test_dlprmo\", editor, new_state, project_state\n   744\t            )\n   745\t        self.assertTableExists(\"test_dlprmo_pony\")\n   746\t        self.assertTableNotExists(\"test_dlprmo_proxypony\")\n   747\t\n   748\t    def test_delete_mti_model(self):\n   749\t        project_state = self.set_up_test_model(\"test_dlmtimo\", mti_model=True)\n   750\t        # Test the state alteration\n   751\t        operation = migrations.DeleteModel(\"ShetlandPony\")\n   752\t        new_state = project_state.clone()\n   753\t        operation.state_forwards(\"test_dlmtimo\", new_state)\n   754\t        self.assertIn((\"test_dlmtimo\", \"shetlandpony\"), project_state.models)\n   755\t        self.assertNotIn((\"test_dlmtimo\", \"shetlandpony\"), new_state.models)\n   756\t        # Test the database alteration\n   757\t        self.assertTableExists(\"test_dlmtimo_pony\")\n   758\t        self.assertTableExists(\"test_dlmtimo_shetlandpony\")\n   759\t        self.assertColumnExists(\"test_dlmtimo_shetlandpony\", \"pony_ptr_id\")\n   760\t        with connection.schema_editor() as editor:\n   761\t            operation.database_forwards(\n   762\t                \"test_dlmtimo\", editor, project_state, new_state\n   763\t            )\n   764\t        self.assertTableExists(\"test_dlmtimo_pony\")\n   765\t        self.assertTableNotExists(\"test_dlmtimo_shetlandpony\")\n   766\t        # And test reversal\n   767\t        with connection.schema_editor() as editor:\n   768\t            operation.database_backwards(\n   769\t                \"test_dlmtimo\", editor, new_state, project_state\n   770\t            )\n   771\t        self.assertTableExists(\"test_dlmtimo_pony\")\n   772\t        self.assertTableExists(\"test_dlmtimo_shetlandpony\")\n   773\t        self.assertColumnExists(\"test_dlmtimo_shetlandpony\", \"pony_ptr_id\")\n   774\t\n   775\t    def test_rename_model(self):\n   776\t        \"\"\"\n   777\t        Tests the RenameModel operation.\n   778\t        \"\"\"\n   779\t        project_state = self.set_up_test_model(\"test_rnmo\", related_model=True)\n   780\t        # Test the state alteration\n   781\t        operation = migrations.RenameModel(\"Pony\", \"Horse\")\n   782\t        self.assertEqual(operation.describe(), \"Rename model Pony to Horse\")\n   783\t        self.assertEqual(operation.migration_name_fragment, \"rename_pony_horse\")\n   784\t        # Test initial state and database\n   785\t        self.assertIn((\"test_rnmo\", \"pony\"), project_state.models)\n   786\t        self.assertNotIn((\"test_rnmo\", \"horse\"), project_state.models)\n   787\t        self.assertTableExists(\"test_rnmo_pony\")\n   788\t        self.assertTableNotExists(\"test_rnmo_horse\")\n   789\t        if connection.features.supports_foreign_keys:\n   790\t            self.assertFKExists(\n   791\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_pony\", \"id\")\n   792\t            )\n   793\t            self.assertFKNotExists(\n   794\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_horse\", \"id\")\n   795\t            )\n   796\t        # Migrate forwards\n   797\t        new_state = project_state.clone()\n   798\t        atomic_rename = connection.features.supports_atomic_references_rename\n   799\t        new_state = self.apply_operations(\n   800\t            \"test_rnmo\", new_state, [operation], atomic=atomic_rename\n   801\t        )\n   802\t        # Test new state and database\n   803\t        self.assertNotIn((\"test_rnmo\", \"pony\"), new_state.models)\n   804\t        self.assertIn((\"test_rnmo\", \"horse\"), new_state.models)\n   805\t        # RenameModel also repoints all incoming FKs and M2Ms\n   806\t        self.assertEqual(\n   807\t            new_state.models[\"test_rnmo\", \"rider\"].fields[\"pony\"].remote_field.model,\n   808\t            \"test_rnmo.Horse\",\n   809\t        )\n   810\t        self.assertTableNotExists(\"test_rnmo_pony\")\n   811\t        self.assertTableExists(\"test_rnmo_horse\")\n   812\t        if connection.features.supports_foreign_keys:\n   813\t            self.assertFKNotExists(\n   814\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_pony\", \"id\")\n   815\t            )\n   816\t            self.assertFKExists(\n   817\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_horse\", \"id\")\n   818\t            )\n   819\t        # Migrate backwards\n   820\t        original_state = self.unapply_operations(\n   821\t            \"test_rnmo\", project_state, [operation], atomic=atomic_rename\n   822\t        )\n   823\t        # Test original state and database\n   824\t        self.assertIn((\"test_rnmo\", \"pony\"), original_state.models)\n   825\t        self.assertNotIn((\"test_rnmo\", \"horse\"), original_state.models)\n   826\t        self.assertEqual(\n   827\t            original_state.models[\"test_rnmo\", \"rider\"]\n   828\t            .fields[\"pony\"]\n   829\t            .remote_field.model,\n   830\t            \"Pony\",\n   831\t        )\n   832\t        self.assertTableExists(\"test_rnmo_pony\")\n   833\t        self.assertTableNotExists(\"test_rnmo_horse\")\n   834\t        if connection.features.supports_foreign_keys:\n   835\t            self.assertFKExists(\n   836\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_pony\", \"id\")\n   837\t            )\n   838\t            self.assertFKNotExists(\n   839\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_horse\", \"id\")\n   840\t            )\n   841\t        # And deconstruction\n   842\t        definition = operation.deconstruct()\n   843\t        self.assertEqual(definition[0], \"RenameModel\")\n   844\t        self.assertEqual(definition[1], [])\n   845\t        self.assertEqual(definition[2], {\"old_name\": \"Pony\", \"new_name\": \"Horse\"})\n   846\t\n   847\t    def test_rename_model_state_forwards(self):\n   848\t        \"\"\"\n   849\t        RenameModel operations shouldn't trigger the caching of rendered apps\n   850\t        on state without prior apps.\n   851\t        \"\"\"\n   852\t        state = ProjectState()\n   853\t        state.add_model(ModelState(\"migrations\", \"Foo\", []))\n   854\t        operation = migrations.RenameModel(\"Foo\", \"Bar\")\n   855\t        operation.state_forwards(\"migrations\", state)\n   856\t        self.assertNotIn(\"apps\", state.__dict__)\n   857\t        self.assertNotIn((\"migrations\", \"foo\"), state.models)\n   858\t        self.assertIn((\"migrations\", \"bar\"), state.models)\n   859\t        # Now with apps cached.\n   860\t        apps = state.apps\n   861\t        operation = migrations.RenameModel(\"Bar\", \"Foo\")\n   862\t        operation.state_forwards(\"migrations\", state)\n   863\t        self.assertIs(state.apps, apps)\n   864\t        self.assertNotIn((\"migrations\", \"bar\"), state.models)\n   865\t        self.assertIn((\"migrations\", \"foo\"), state.models)\n   866\t\n   867\t    def test_rename_model_with_self_referential_fk(self):\n   868\t        \"\"\"\n   869\t        Tests the RenameModel operation on model with self referential FK.\n   870\t        \"\"\"\n   871\t        project_state = self.set_up_test_model(\"test_rmwsrf\", related_model=True)\n   872\t        # Test the state alteration\n   873\t        operation = migrations.RenameModel(\"Rider\", \"HorseRider\")\n   874\t        self.assertEqual(operation.describe(), \"Rename model Rider to HorseRider\")\n   875\t        new_state = project_state.clone()\n   876\t        operation.state_forwards(\"test_rmwsrf\", new_state)\n   877\t        self.assertNotIn((\"test_rmwsrf\", \"rider\"), new_state.models)\n   878\t        self.assertIn((\"test_rmwsrf\", \"horserider\"), new_state.models)\n   879\t        # Remember, RenameModel also repoints all incoming FKs and M2Ms\n   880\t        self.assertEqual(\n   881\t            \"self\",\n   882\t            new_state.models[\"test_rmwsrf\", \"horserider\"]\n   883\t            .fields[\"friend\"]\n   884\t            .remote_field.model,\n   885\t        )\n   886\t        HorseRider = new_state.apps.get_model(\"test_rmwsrf\", \"horserider\")\n   887\t        self.assertIs(\n   888\t            HorseRider._meta.get_field(\"horserider\").remote_field.model, HorseRider\n   889\t        )\n   890\t        # Test the database alteration\n   891\t        self.assertTableExists(\"test_rmwsrf_rider\")\n   892\t        self.assertTableNotExists(\"test_rmwsrf_horserider\")\n   893\t        if connection.features.supports_foreign_keys:\n   894\t            self.assertFKExists(\n   895\t                \"test_rmwsrf_rider\", [\"friend_id\"], (\"test_rmwsrf_rider\", \"id\")\n   896\t            )\n   897\t            self.assertFKNotExists(\n   898\t                \"test_rmwsrf_rider\", [\"friend_id\"], (\"test_rmwsrf_horserider\", \"id\")\n   899\t            )\n   900\t        atomic_rename = connection.features.supports_atomic_references_rename\n   901\t        with connection.schema_editor(atomic=atomic_rename) as editor:\n   902\t            operation.database_forwards(\"test_rmwsrf\", editor, project_state, new_state)\n   903\t        self.assertTableNotExists(\"test_rmwsrf_rider\")\n   904\t        self.assertTableExists(\"test_rmwsrf_horserider\")\n   905\t        if connection.features.supports_foreign_keys:\n   906\t            self.assertFKNotExists(\n   907\t                \"test_rmwsrf_horserider\", [\"friend_id\"], (\"test_rmwsrf_rider\", \"id\")\n   908\t            )\n   909\t            self.assertFKExists(\n   910\t                \"test_rmwsrf_horserider\",\n   911\t                [\"friend_id\"],\n   912\t                (\"test_rmwsrf_horserider\", \"id\"),\n   913\t            )\n   914\t        # And test reversal\n   915\t        with connection.schema_editor(atomic=atomic_rename) as editor:\n   916\t            operation.database_backwards(\n   917\t                \"test_rmwsrf\", editor, new_state, project_state\n   918\t            )\n   919\t        self.assertTableExists(\"test_rmwsrf_rider\")\n   920\t        self.assertTableNotExists(\"test_rmwsrf_horserider\")\n   921\t        if connection.features.supports_foreign_keys:\n   922\t            self.assertFKExists(\n   923\t                \"test_rmwsrf_rider\", [\"friend_id\"], (\"test_rmwsrf_rider\", \"id\")\n   924\t            )\n   925\t            self.assertFKNotExists(\n   926\t                \"test_rmwsrf_rider\", [\"friend_id\"], (\"test_rmwsrf_horserider\", \"id\")\n   927\t            )\n   928\t\n   929\t    def test_rename_model_with_superclass_fk(self):\n   930\t        \"\"\"\n   931\t        Tests the RenameModel operation on a model which has a superclass that\n   932\t        has a foreign key.\n   933\t        \"\"\"\n   934\t        project_state = self.set_up_test_model(\n   935\t            \"test_rmwsc\", related_model=True, mti_model=True\n   936\t        )\n   937\t        # Test the state alteration\n   938\t        operation = migrations.RenameModel(\"ShetlandPony\", \"LittleHorse\")\n   939\t        self.assertEqual(\n   940\t            operation.describe(), \"Rename model ShetlandPony to LittleHorse\"\n   941\t        )\n   942\t        new_state = project_state.clone()\n   943\t        operation.state_forwards(\"test_rmwsc\", new_state)\n   944\t        self.assertNotIn((\"test_rmwsc\", \"shetlandpony\"), new_state.models)\n   945\t        self.assertIn((\"test_rmwsc\", \"littlehorse\"), new_state.models)\n   946\t        # RenameModel shouldn't repoint the superclass's relations, only local ones\n   947\t        self.assertEqual(\n   948\t            project_state.models[\"test_rmwsc\", \"rider\"]\n   949\t            .fields[\"pony\"]\n   950\t            .remote_field.model,\n   951\t            new_state.models[\"test_rmwsc\", \"rider\"].fields[\"pony\"].remote_field.model,\n   952\t        )\n   953\t        # Before running the migration we have a table for Shetland Pony, not\n   954\t        # Little Horse.\n   955\t        self.assertTableExists(\"test_rmwsc_shetlandpony\")\n   956\t        self.assertTableNotExists(\"test_rmwsc_littlehorse\")\n   957\t        if connection.features.supports_foreign_keys:\n   958\t            # and the foreign key on rider points to pony, not shetland pony\n   959\t            self.assertFKExists(\n   960\t                \"test_rmwsc_rider\", [\"pony_id\"], (\"test_rmwsc_pony\", \"id\")\n   961\t            )\n   962\t            self.assertFKNotExists(\n   963\t                \"test_rmwsc_rider\", [\"pony_id\"], (\"test_rmwsc_shetlandpony\", \"id\")\n   964\t            )\n   965\t        with connection.schema_editor(\n   966\t            atomic=connection.features.supports_atomic_references_rename\n   967\t        ) as editor:\n   968\t            operation.database_forwards(\"test_rmwsc\", editor, project_state, new_state)\n   969\t        # Now we have a little horse table, not shetland pony\n   970\t        self.assertTableNotExists(\"test_rmwsc_shetlandpony\")\n   971\t        self.assertTableExists(\"test_rmwsc_littlehorse\")\n   972\t        if connection.features.supports_foreign_keys:\n   973\t            # but the Foreign keys still point at pony, not little horse\n   974\t            self.assertFKExists(\n   975\t                \"test_rmwsc_rider\", [\"pony_id\"], (\"test_rmwsc_pony\", \"id\")\n   976\t            )\n   977\t            self.assertFKNotExists(\n   978\t                \"test_rmwsc_rider\", [\"pony_id\"], (\"test_rmwsc_littlehorse\", \"id\")\n   979\t            )\n   980\t\n   981\t    def test_rename_model_with_self_referential_m2m(self):\n   982\t        app_label = \"test_rename_model_with_self_referential_m2m\"\n   983\t\n   984\t        project_state = self.apply_operations(\n   985\t            app_label,\n   986\t            ProjectState(),\n   987\t            operations=[\n   988\t                migrations.CreateModel(\n   989\t                    \"ReflexivePony\",\n   990\t                    fields=[\n   991\t                        (\"id\", models.AutoField(primary_key=True)),\n   992\t                        (\"ponies\", models.ManyToManyField(\"self\")),\n   993\t                    ],\n   994\t                ),\n   995\t            ],\n   996\t        )\n   997\t        project_state = self.apply_operations(\n   998\t            app_label,\n   999\t            project_state,\n  1000\t            operations=[\n  1001\t                migrations.RenameModel(\"ReflexivePony\", \"ReflexivePony2\"),\n  1002\t            ],\n  1003\t            atomic=connection.features.supports_atomic_references_rename,\n  1004\t        )\n  1005\t        Pony = project_state.apps.get_model(app_label, \"ReflexivePony2\")\n  1006\t        pony = Pony.objects.create()\n  1007\t        pony.ponies.add(pony)\n  1008\t\n  1009\t    def test_rename_model_with_m2m(self):\n  1010\t        app_label = \"test_rename_model_with_m2m\"\n  1011\t        project_state = self.apply_operations(\n  1012\t            app_label,\n  1013\t            ProjectState(),\n  1014\t            operations=[\n  1015\t                migrations.CreateModel(\n  1016\t                    \"Rider\",\n  1017\t                    fields=[\n  1018\t                        (\"id\", models.AutoField(primary_key=True)),\n  1019\t                    ],\n  1020\t                ),\n  1021\t                migrations.CreateModel(\n  1022\t                    \"Pony\",\n  1023\t                    fields=[\n  1024\t                        (\"id\", models.AutoField(primary_key=True)),\n  1025\t                        (\"riders\", models.ManyToManyField(\"Rider\")),\n  1026\t                    ],\n  1027\t                ),\n  1028\t            ],\n  1029\t        )\n  1030\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1031\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1032\t        pony = Pony.objects.create()\n  1033\t        rider = Rider.objects.create()\n  1034\t        pony.riders.add(rider)\n  1035\t\n  1036\t        project_state = self.apply_operations(\n  1037\t            app_label,\n  1038\t            project_state,\n  1039\t            operations=[\n  1040\t                migrations.RenameModel(\"Pony\", \"Pony2\"),\n  1041\t            ],\n  1042\t            atomic=connection.features.supports_atomic_references_rename,\n  1043\t        )\n  1044\t        Pony = project_state.apps.get_model(app_label, \"Pony2\")\n  1045\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1046\t        pony = Pony.objects.create()\n  1047\t        rider = Rider.objects.create()\n  1048\t        pony.riders.add(rider)\n  1049\t        self.assertEqual(Pony.objects.count(), 2)\n  1050\t        self.assertEqual(Rider.objects.count(), 2)\n  1051\t        self.assertEqual(\n  1052\t            Pony._meta.get_field(\"riders\").remote_field.through.objects.count(), 2\n  1053\t        )\n  1054\t\n  1055\t    def test_rename_model_with_db_table_noop(self):\n  1056\t        app_label = \"test_rmwdbtn\"\n  1057\t        project_state = self.apply_operations(\n  1058\t            app_label,\n  1059\t            ProjectState(),\n  1060\t            operations=[\n  1061\t                migrations.CreateModel(\n  1062\t                    \"Rider\",\n  1063\t                    fields=[\n  1064\t                        (\"id\", models.AutoField(primary_key=True)),\n  1065\t                    ],\n  1066\t                    options={\"db_table\": \"rider\"},\n  1067\t                ),\n  1068\t                migrations.CreateModel(\n  1069\t                    \"Pony\",\n  1070\t                    fields=[\n  1071\t                        (\"id\", models.AutoField(primary_key=True)),\n  1072\t                        (\n  1073\t                            \"rider\",\n  1074\t                            models.ForeignKey(\"%s.Rider\" % app_label, models.CASCADE),\n  1075\t                        ),\n  1076\t                    ],\n  1077\t                ),\n  1078\t            ],\n  1079\t        )\n  1080\t        new_state = project_state.clone()\n  1081\t        operation = migrations.RenameModel(\"Rider\", \"Runner\")\n  1082\t        operation.state_forwards(app_label, new_state)\n  1083\t\n  1084\t        with connection.schema_editor() as editor:\n  1085\t            with self.assertNumQueries(0):\n  1086\t                operation.database_forwards(app_label, editor, project_state, new_state)\n  1087\t        with connection.schema_editor() as editor:\n  1088\t            with self.assertNumQueries(0):\n  1089\t                operation.database_backwards(\n  1090\t                    app_label, editor, new_state, project_state\n  1091\t                )\n  1092\t\n  1093\t    def test_rename_m2m_target_model(self):\n  1094\t        app_label = \"test_rename_m2m_target_model\"\n  1095\t        project_state = self.apply_operations(\n  1096\t            app_label,\n  1097\t            ProjectState(),\n  1098\t            operations=[\n  1099\t                migrations.CreateModel(\n  1100\t                    \"Rider\",\n  1101\t                    fields=[\n  1102\t                        (\"id\", models.AutoField(primary_key=True)),\n  1103\t                    ],\n  1104\t                ),\n  1105\t                migrations.CreateModel(\n  1106\t                    \"Pony\",\n  1107\t                    fields=[\n  1108\t                        (\"id\", models.AutoField(primary_key=True)),\n  1109\t                        (\"riders\", models.ManyToManyField(\"Rider\")),\n  1110\t                    ],\n  1111\t                ),\n  1112\t            ],\n  1113\t        )\n  1114\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1115\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1116\t        pony = Pony.objects.create()\n  1117\t        rider = Rider.objects.create()\n  1118\t        pony.riders.add(rider)\n  1119\t\n  1120\t        project_state = self.apply_operations(\n  1121\t            app_label,\n  1122\t            project_state,\n  1123\t            operations=[\n  1124\t                migrations.RenameModel(\"Rider\", \"Rider2\"),\n  1125\t            ],\n  1126\t            atomic=connection.features.supports_atomic_references_rename,\n  1127\t        )\n  1128\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1129\t        Rider = project_state.apps.get_model(app_label, \"Rider2\")\n  1130\t        pony = Pony.objects.create()\n  1131\t        rider = Rider.objects.create()\n  1132\t        pony.riders.add(rider)\n  1133\t        self.assertEqual(Pony.objects.count(), 2)\n  1134\t        self.assertEqual(Rider.objects.count(), 2)\n  1135\t        self.assertEqual(\n  1136\t            Pony._meta.get_field(\"riders\").remote_field.through.objects.count(), 2\n  1137\t        )\n  1138\t\n  1139\t    def test_rename_m2m_through_model(self):\n  1140\t        app_label = \"test_rename_through\"\n  1141\t        project_state = self.apply_operations(\n  1142\t            app_label,\n  1143\t            ProjectState(),\n  1144\t            operations=[\n  1145\t                migrations.CreateModel(\n  1146\t                    \"Rider\",\n  1147\t                    fields=[\n  1148\t                        (\"id\", models.AutoField(primary_key=True)),\n  1149\t                    ],\n  1150\t                ),\n  1151\t                migrations.CreateModel(\n  1152\t                    \"Pony\",\n  1153\t                    fields=[\n  1154\t                        (\"id\", models.AutoField(primary_key=True)),\n  1155\t                    ],\n  1156\t                ),\n  1157\t                migrations.CreateModel(\n  1158\t                    \"PonyRider\",\n  1159\t                    fields=[\n  1160\t                        (\"id\", models.AutoField(primary_key=True)),\n  1161\t                        (\n  1162\t                            \"rider\",\n  1163\t                            models.ForeignKey(\n  1164\t                                \"test_rename_through.Rider\", models.CASCADE\n  1165\t                            ),\n  1166\t                        ),\n  1167\t                        (\n  1168\t                            \"pony\",\n  1169\t                            models.ForeignKey(\n  1170\t                                \"test_rename_through.Pony\", models.CASCADE\n  1171\t                            ),\n  1172\t                        ),\n  1173\t                    ],\n  1174\t                ),\n  1175\t                migrations.AddField(\n  1176\t                    \"Pony\",\n  1177\t                    \"riders\",\n  1178\t                    models.ManyToManyField(\n  1179\t                        \"test_rename_through.Rider\",\n  1180\t                        through=\"test_rename_through.PonyRider\",\n  1181\t                    ),\n  1182\t                ),\n  1183\t            ],\n  1184\t        )\n  1185\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1186\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1187\t        PonyRider = project_state.apps.get_model(app_label, \"PonyRider\")\n  1188\t        pony = Pony.objects.create()\n  1189\t        rider = Rider.objects.create()\n  1190\t        PonyRider.objects.create(pony=pony, rider=rider)\n  1191\t\n  1192\t        project_state = self.apply_operations(\n  1193\t            app_label,\n  1194\t            project_state,\n  1195\t            operations=[\n  1196\t                migrations.RenameModel(\"PonyRider\", \"PonyRider2\"),\n  1197\t            ],\n  1198\t        )\n  1199\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1200\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1201\t        PonyRider = project_state.apps.get_model(app_label, \"PonyRider2\")\n  1202\t        pony = Pony.objects.first()\n  1203\t        rider = Rider.objects.create()\n  1204\t        PonyRider.objects.create(pony=pony, rider=rider)\n  1205\t        self.assertEqual(Pony.objects.count(), 1)\n  1206\t        self.assertEqual(Rider.objects.count(), 2)\n  1207\t        self.assertEqual(PonyRider.objects.count(), 2)\n  1208\t        self.assertEqual(pony.riders.count(), 2)\n  1209\t\n  1210\t    def test_rename_m2m_model_after_rename_field(self):\n  1211\t        \"\"\"RenameModel renames a many-to-many column after a RenameField.\"\"\"\n  1212\t        app_label = \"test_rename_multiple\"\n  1213\t        project_state = self.apply_operations(\n  1214\t            app_label,\n  1215\t            ProjectState(),\n  1216\t            operations=[\n  1217\t                migrations.CreateModel(\n  1218\t                    \"Pony\",\n  1219\t                    fields=[\n  1220\t                        (\"id\", models.AutoField(primary_key=True)),\n  1221\t                        (\"name\", models.CharField(max_length=20)),\n  1222\t                    ],\n  1223\t                ),\n  1224\t                migrations.CreateModel(\n  1225\t                    \"Rider\",\n  1226\t                    fields=[\n  1227\t                        (\"id\", models.AutoField(primary_key=True)),\n  1228\t                        (\n  1229\t                            \"pony\",\n  1230\t                            models.ForeignKey(\n  1231\t                                \"test_rename_multiple.Pony\", models.CASCADE\n  1232\t                            ),\n  1233\t                        ),\n  1234\t                    ],\n  1235\t                ),\n  1236\t                migrations.CreateModel(\n  1237\t                    \"PonyRider\",\n  1238\t                    fields=[\n  1239\t                        (\"id\", models.AutoField(primary_key=True)),\n  1240\t                        (\"riders\", models.ManyToManyField(\"Rider\")),\n  1241\t                    ],\n  1242\t                ),\n  1243\t                migrations.RenameField(\n  1244\t                    model_name=\"pony\", old_name=\"name\", new_name=\"fancy_name\"\n  1245\t                ),\n  1246\t                migrations.RenameModel(old_name=\"Rider\", new_name=\"Jockey\"),\n  1247\t            ],\n  1248\t            atomic=connection.features.supports_atomic_references_rename,\n  1249\t        )\n  1250\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1251\t        Jockey = project_state.apps.get_model(app_label, \"Jockey\")\n  1252\t        PonyRider = project_state.apps.get_model(app_label, \"PonyRider\")\n  1253\t        # No \"no such column\" error means the column was renamed correctly.\n  1254\t        pony = Pony.objects.create(fancy_name=\"a good name\")\n  1255\t        jockey = Jockey.objects.create(pony=pony)\n  1256\t        ponyrider = PonyRider.objects.create()\n  1257\t        ponyrider.riders.add(jockey)\n  1258\t\n  1259\t    def test_add_field(self):\n  1260\t        \"\"\"\n  1261\t        Tests the AddField operation.\n  1262\t        \"\"\"\n  1263\t        # Test the state alteration\n  1264\t        operation = migrations.AddField(\n  1265\t            \"Pony\",\n  1266\t            \"height\",\n  1267\t            models.FloatField(null=True, default=5),\n  1268\t        )\n  1269\t        self.assertEqual(operation.describe(), \"Add field height to Pony\")\n  1270\t        self.assertEqual(operation.migration_name_fragment, \"pony_height\")\n  1271\t        project_state, new_state = self.make_test_state(\"test_adfl\", operation)\n  1272\t        self.assertEqual(len(new_state.models[\"test_adfl\", \"pony\"].fields), 4)\n  1273\t        field = new_state.models[\"test_adfl\", \"pony\"].fields[\"height\"]\n  1274\t        self.assertEqual(field.default, 5)\n  1275\t        # Test the database alteration\n  1276\t        self.assertColumnNotExists(\"test_adfl_pony\", \"height\")\n  1277\t        with connection.schema_editor() as editor:\n  1278\t            operation.database_forwards(\"test_adfl\", editor, project_state, new_state)\n  1279\t        self.assertColumnExists(\"test_adfl_pony\", \"height\")\n  1280\t        # And test reversal\n  1281\t        with connection.schema_editor() as editor:\n  1282\t            operation.database_backwards(\"test_adfl\", editor, new_state, project_state)\n  1283\t        self.assertColumnNotExists(\"test_adfl_pony\", \"height\")\n  1284\t        # And deconstruction\n  1285\t        definition = operation.deconstruct()\n  1286\t        self.assertEqual(definition[0], \"AddField\")\n  1287\t        self.assertEqual(definition[1], [])\n  1288\t        self.assertEqual(sorted(definition[2]), [\"field\", \"model_name\", \"name\"])\n  1289\t\n  1290\t    def test_add_charfield(self):\n  1291\t        \"\"\"\n  1292\t        Tests the AddField operation on TextField.\n  1293\t        \"\"\"\n  1294\t        project_state = self.set_up_test_model(\"test_adchfl\")\n  1295\t\n  1296\t        Pony = project_state.apps.get_model(\"test_adchfl\", \"Pony\")\n  1297\t        pony = Pony.objects.create(weight=42)\n  1298\t\n  1299\t        new_state = self.apply_operations(\n  1300\t            \"test_adchfl\",\n  1301\t            project_state,\n  1302\t            [\n  1303\t                migrations.AddField(\n  1304\t                    \"Pony\",\n  1305\t                    \"text\",\n  1306\t                    models.CharField(max_length=10, default=\"some text\"),\n  1307\t                ),\n  1308\t                migrations.AddField(\n  1309\t                    \"Pony\",\n  1310\t                    \"empty\",\n  1311\t                    models.CharField(max_length=10, default=\"\"),\n  1312\t                ),\n  1313\t                # If not properly quoted digits would be interpreted as an int.\n  1314\t                migrations.AddField(\n  1315\t                    \"Pony\",\n  1316\t                    \"digits\",\n  1317\t                    models.CharField(max_length=10, default=\"42\"),\n  1318\t                ),\n  1319\t                # Manual quoting is fragile and could trip on quotes. Refs #xyz.\n  1320\t                migrations.AddField(\n  1321\t                    \"Pony\",\n  1322\t                    \"quotes\",\n  1323\t                    models.CharField(max_length=10, default='\"\\'\"'),\n  1324\t                ),\n  1325\t            ],\n  1326\t        )\n  1327\t\n  1328\t        Pony = new_state.apps.get_model(\"test_adchfl\", \"Pony\")\n  1329\t        pony = Pony.objects.get(pk=pony.pk)\n  1330\t        self.assertEqual(pony.text, \"some text\")\n  1331\t        self.assertEqual(pony.empty, \"\")\n  1332\t        self.assertEqual(pony.digits, \"42\")\n  1333\t        self.assertEqual(pony.quotes, '\"\\'\"')\n  1334\t\n  1335\t    def test_add_textfield(self):\n  1336\t        \"\"\"\n  1337\t        Tests the AddField operation on TextField.\n  1338\t        \"\"\"\n  1339\t        project_state = self.set_up_test_model(\"test_adtxtfl\")\n  1340\t\n  1341\t        Pony = project_state.apps.get_model(\"test_adtxtfl\", \"Pony\")\n  1342\t        pony = Pony.objects.create(weight=42)\n  1343\t\n  1344\t        new_state = self.apply_operations(\n  1345\t            \"test_adtxtfl\",\n  1346\t            project_state,\n  1347\t            [\n  1348\t                migrations.AddField(\n  1349\t                    \"Pony\",\n  1350\t                    \"text\",\n  1351\t                    models.TextField(default=\"some text\"),\n  1352\t                ),\n  1353\t                migrations.AddField(\n  1354\t                    \"Pony\",\n  1355\t                    \"empty\",\n  1356\t                    models.TextField(default=\"\"),\n  1357\t                ),\n  1358\t                # If not properly quoted digits would be interpreted as an int.\n  1359\t                migrations.AddField(\n  1360\t                    \"Pony\",\n  1361\t                    \"digits\",\n  1362\t                    models.TextField(default=\"42\"),\n  1363\t                ),\n  1364\t                # Manual quoting is fragile and could trip on quotes. Refs #xyz.\n  1365\t                migrations.AddField(\n  1366\t                    \"Pony\",\n  1367\t                    \"quotes\",\n  1368\t                    models.TextField(default='\"\\'\"'),\n  1369\t                ),\n  1370\t            ],\n  1371\t        )\n  1372\t\n  1373\t        Pony = new_state.apps.get_model(\"test_adtxtfl\", \"Pony\")\n  1374\t        pony = Pony.objects.get(pk=pony.pk)\n  1375\t        self.assertEqual(pony.text, \"some text\")\n  1376\t        self.assertEqual(pony.empty, \"\")\n  1377\t        self.assertEqual(pony.digits, \"42\")\n  1378\t        self.assertEqual(pony.quotes, '\"\\'\"')\n  1379\t\n  1380\t    def test_add_binaryfield(self):\n  1381\t        \"\"\"\n  1382\t        Tests the AddField operation on TextField/BinaryField.\n  1383\t        \"\"\"\n  1384\t        project_state = self.set_up_test_model(\"test_adbinfl\")\n  1385\t\n  1386\t        Pony = project_state.apps.get_model(\"test_adbinfl\", \"Pony\")\n  1387\t        pony = Pony.objects.create(weight=42)\n  1388\t\n  1389\t        new_state = self.apply_operations(\n  1390\t            \"test_adbinfl\",\n  1391\t            project_state,\n  1392\t            [\n  1393\t                migrations.AddField(\n  1394\t                    \"Pony\",\n  1395\t                    \"blob\",\n  1396\t                    models.BinaryField(default=b\"some text\"),\n  1397\t                ),\n  1398\t                migrations.AddField(\n  1399\t                    \"Pony\",\n  1400\t                    \"empty\",\n  1401\t                    models.BinaryField(default=b\"\"),\n  1402\t                ),\n  1403\t                # If not properly quoted digits would be interpreted as an int.\n  1404\t                migrations.AddField(\n  1405\t                    \"Pony\",\n  1406\t                    \"digits\",\n  1407\t                    models.BinaryField(default=b\"42\"),\n  1408\t                ),\n  1409\t                # Manual quoting is fragile and could trip on quotes. Refs #xyz.\n  1410\t                migrations.AddField(\n  1411\t                    \"Pony\",\n  1412\t                    \"quotes\",\n  1413\t                    models.BinaryField(default=b'\"\\'\"'),\n  1414\t                ),\n  1415\t            ],\n  1416\t        )\n  1417\t\n  1418\t        Pony = new_state.apps.get_model(\"test_adbinfl\", \"Pony\")\n  1419\t        pony = Pony.objects.get(pk=pony.pk)\n  1420\t        # SQLite returns buffer/memoryview, cast to bytes for checking.\n  1421\t        self.assertEqual(bytes(pony.blob), b\"some text\")\n  1422\t        self.assertEqual(bytes(pony.empty), b\"\")\n  1423\t        self.assertEqual(bytes(pony.digits), b\"42\")\n  1424\t        self.assertEqual(bytes(pony.quotes), b'\"\\'\"')\n  1425\t\n  1426\t    def test_column_name_quoting(self):\n  1427\t        \"\"\"\n  1428\t        Column names that are SQL keywords shouldn't cause problems when used\n  1429\t        in migrations (#22168).\n  1430\t        \"\"\"\n  1431\t        project_state = self.set_up_test_model(\"test_regr22168\")\n  1432\t        operation = migrations.AddField(\n  1433\t            \"Pony\",\n  1434\t            \"order\",\n  1435\t            models.IntegerField(default=0),\n  1436\t        )\n  1437\t        new_state = project_state.clone()\n  1438\t        operation.state_forwards(\"test_regr22168\", new_state)\n  1439\t        with connection.schema_editor() as editor:\n  1440\t            operation.database_forwards(\n  1441\t                \"test_regr22168\", editor, project_state, new_state\n  1442\t            )\n  1443\t        self.assertColumnExists(\"test_regr22168_pony\", \"order\")\n  1444\t\n  1445\t    def test_add_field_preserve_default(self):\n  1446\t        \"\"\"\n  1447\t        Tests the AddField operation's state alteration\n  1448\t        when preserve_default = False.\n  1449\t        \"\"\"\n  1450\t        project_state = self.set_up_test_model(\"test_adflpd\")\n  1451\t        # Test the state alteration\n  1452\t        operation = migrations.AddField(\n  1453\t            \"Pony\",\n  1454\t            \"height\",\n  1455\t            models.FloatField(null=True, default=4),\n  1456\t            preserve_default=False,\n  1457\t        )\n  1458\t        new_state = project_state.clone()\n  1459\t        operation.state_forwards(\"test_adflpd\", new_state)\n  1460\t        self.assertEqual(len(new_state.models[\"test_adflpd\", \"pony\"].fields), 4)\n  1461\t        field = new_state.models[\"test_adflpd\", \"pony\"].fields[\"height\"]\n  1462\t        self.assertEqual(field.default, models.NOT_PROVIDED)\n  1463\t        # Test the database alteration\n  1464\t        project_state.apps.get_model(\"test_adflpd\", \"pony\").objects.create(\n  1465\t            weight=4,\n  1466\t        )\n  1467\t        self.assertColumnNotExists(\"test_adflpd_pony\", \"height\")\n  1468\t        with connection.schema_editor() as editor:\n  1469\t            operation.database_forwards(\"test_adflpd\", editor, project_state, new_state)\n  1470\t        self.assertColumnExists(\"test_adflpd_pony\", \"height\")\n  1471\t        # And deconstruction\n  1472\t        definition = operation.deconstruct()\n  1473\t        self.assertEqual(definition[0], \"AddField\")\n  1474\t        self.assertEqual(definition[1], [])\n  1475\t        self.assertEqual(\n  1476\t            sorted(definition[2]), [\"field\", \"model_name\", \"name\", \"preserve_default\"]\n  1477\t        )\n  1478\t\n  1479\t    def test_add_field_m2m(self):\n  1480\t        \"\"\"\n  1481\t        Tests the AddField operation with a ManyToManyField.\n  1482\t        \"\"\"\n  1483\t        project_state = self.set_up_test_model(\"test_adflmm\", second_model=True)\n  1484\t        # Test the state alteration\n  1485\t        operation = migrations.AddField(\n  1486\t            \"Pony\", \"stables\", models.ManyToManyField(\"Stable\", related_name=\"ponies\")\n  1487\t        )\n  1488\t        new_state = project_state.clone()\n  1489\t        operation.state_forwards(\"test_adflmm\", new_state)\n  1490\t        self.assertEqual(len(new_state.models[\"test_adflmm\", \"pony\"].fields), 4)\n  1491\t        # Test the database alteration\n  1492\t        self.assertTableNotExists(\"test_adflmm_pony_stables\")\n  1493\t        with connection.schema_editor() as editor:\n  1494\t            operation.database_forwards(\"test_adflmm\", editor, project_state, new_state)\n  1495\t        self.assertTableExists(\"test_adflmm_pony_stables\")\n  1496\t        self.assertColumnNotExists(\"test_adflmm_pony\", \"stables\")\n  1497\t        # Make sure the M2M field actually works\n  1498\t        with atomic():\n  1499\t            Pony = new_state.apps.get_model(\"test_adflmm\", \"Pony\")\n  1500\t            p = Pony.objects.create(pink=False, weight=4.55)\n  1501\t            p.stables.create()\n  1502\t            self.assertEqual(p.stables.count(), 1)\n  1503\t            p.stables.all().delete()\n  1504\t        # And test reversal\n  1505\t        with connection.schema_editor() as editor:\n  1506\t            operation.database_backwards(\n  1507\t                \"test_adflmm\", editor, new_state, project_state\n  1508\t            )\n  1509\t        self.assertTableNotExists(\"test_adflmm_pony_stables\")\n  1510\t\n  1511\t    def test_alter_field_m2m(self):\n  1512\t        project_state = self.set_up_test_model(\"test_alflmm\", second_model=True)\n  1513\t\n  1514\t        project_state = self.apply_operations(\n  1515\t            \"test_alflmm\",\n  1516\t            project_state,\n  1517\t            operations=[\n  1518\t                migrations.AddField(\n  1519\t                    \"Pony\",\n  1520\t                    \"stables\",\n  1521\t                    models.ManyToManyField(\"Stable\", related_name=\"ponies\"),\n  1522\t                )\n  1523\t            ],\n  1524\t        )\n  1525\t        Pony = project_state.apps.get_model(\"test_alflmm\", \"Pony\")\n  1526\t        self.assertFalse(Pony._meta.get_field(\"stables\").blank)\n  1527\t\n  1528\t        project_state = self.apply_operations(\n  1529\t            \"test_alflmm\",\n  1530\t            project_state,\n  1531\t            operations=[\n  1532\t                migrations.AlterField(\n  1533\t                    \"Pony\",\n  1534\t                    \"stables\",\n  1535\t                    models.ManyToManyField(\n  1536\t                        to=\"Stable\", related_name=\"ponies\", blank=True\n  1537\t                    ),\n  1538\t                )\n  1539\t            ],\n  1540\t        )\n  1541\t        Pony = project_state.apps.get_model(\"test_alflmm\", \"Pony\")\n  1542\t        self.assertTrue(Pony._meta.get_field(\"stables\").blank)\n  1543\t\n  1544\t    def test_repoint_field_m2m(self):\n  1545\t        project_state = self.set_up_test_model(\n  1546\t            \"test_alflmm\", second_model=True, third_model=True\n  1547\t        )\n  1548\t\n  1549\t        project_state = self.apply_operations(\n  1550\t            \"test_alflmm\",\n  1551\t            project_state,\n  1552\t            operations=[\n  1553\t                migrations.AddField(\n  1554\t                    \"Pony\",\n  1555\t                    \"places\",\n  1556\t                    models.ManyToManyField(\"Stable\", related_name=\"ponies\"),\n  1557\t                )\n  1558\t            ],\n  1559\t        )\n  1560\t        Pony = project_state.apps.get_model(\"test_alflmm\", \"Pony\")\n  1561\t\n  1562\t        project_state = self.apply_operations(\n  1563\t            \"test_alflmm\",\n  1564\t            project_state,\n  1565\t            operations=[\n  1566\t                migrations.AlterField(\n  1567\t                    \"Pony\",\n  1568\t                    \"places\",\n  1569\t                    models.ManyToManyField(to=\"Van\", related_name=\"ponies\"),\n  1570\t                )\n  1571\t            ],\n  1572\t        )\n  1573\t\n  1574\t        # Ensure the new field actually works\n  1575\t        Pony = project_state.apps.get_model(\"test_alflmm\", \"Pony\")\n  1576\t        p = Pony.objects.create(pink=False, weight=4.55)\n  1577\t        p.places.create()\n  1578\t        self.assertEqual(p.places.count(), 1)\n  1579\t        p.places.all().delete()\n  1580\t\n  1581\t    def test_remove_field_m2m(self):\n  1582\t        project_state = self.set_up_test_model(\"test_rmflmm\", second_model=True)\n  1583\t\n  1584\t        project_state = self.apply_operations(\n  1585\t            \"test_rmflmm\",\n  1586\t            project_state,\n  1587\t            operations=[\n  1588\t                migrations.AddField(\n  1589\t                    \"Pony\",\n  1590\t                    \"stables\",\n  1591\t                    models.ManyToManyField(\"Stable\", related_name=\"ponies\"),\n  1592\t                )\n  1593\t            ],\n  1594\t        )\n  1595\t        self.assertTableExists(\"test_rmflmm_pony_stables\")\n  1596\t\n  1597\t        with_field_state = project_state.clone()\n  1598\t        operations = [migrations.RemoveField(\"Pony\", \"stables\")]\n  1599\t        project_state = self.apply_operations(\n  1600\t            \"test_rmflmm\", project_state, operations=operations\n  1601\t        )\n  1602\t        self.assertTableNotExists(\"test_rmflmm_pony_stables\")\n  1603\t\n  1604\t        # And test reversal\n  1605\t        self.unapply_operations(\"test_rmflmm\", with_field_state, operations=operations)\n  1606\t        self.assertTableExists(\"test_rmflmm_pony_stables\")\n  1607\t\n  1608\t    def test_remove_field_m2m_with_through(self):\n  1609\t        project_state = self.set_up_test_model(\"test_rmflmmwt\", second_model=True)\n  1610\t\n  1611\t        self.assertTableNotExists(\"test_rmflmmwt_ponystables\")\n  1612\t        project_state = self.apply_operations(\n  1613\t            \"test_rmflmmwt\",\n  1614\t            project_state,\n  1615\t            operations=[\n  1616\t                migrations.CreateModel(\n  1617\t                    \"PonyStables\",\n  1618\t                    fields=[\n  1619\t                        (\n  1620\t                            \"pony\",\n  1621\t                            models.ForeignKey(\"test_rmflmmwt.Pony\", models.CASCADE),\n  1622\t                        ),\n  1623\t                        (\n  1624\t                            \"stable\",\n  1625\t                            models.ForeignKey(\"test_rmflmmwt.Stable\", models.CASCADE),\n  1626\t                        ),\n  1627\t                    ],\n  1628\t                ),\n  1629\t                migrations.AddField(\n  1630\t                    \"Pony\",\n  1631\t                    \"stables\",\n  1632\t                    models.ManyToManyField(\n  1633\t                        \"Stable\",\n  1634\t                        related_name=\"ponies\",\n  1635\t                        through=\"test_rmflmmwt.PonyStables\",\n  1636\t                    ),\n  1637\t                ),\n  1638\t            ],\n  1639\t        )\n  1640\t        self.assertTableExists(\"test_rmflmmwt_ponystables\")\n  1641\t\n  1642\t        operations = [\n  1643\t            migrations.RemoveField(\"Pony\", \"stables\"),\n  1644\t            migrations.DeleteModel(\"PonyStables\"),\n  1645\t        ]\n  1646\t        self.apply_operations(\"test_rmflmmwt\", project_state, operations=operations)\n  1647\t\n  1648\t    def test_remove_field(self):\n  1649\t        \"\"\"\n  1650\t        Tests the RemoveField operation.\n  1651\t        \"\"\"\n  1652\t        project_state = self.set_up_test_model(\"test_rmfl\")\n  1653\t        # Test the state alteration\n  1654\t        operation = migrations.RemoveField(\"Pony\", \"pink\")\n  1655\t        self.assertEqual(operation.describe(), \"Remove field pink from Pony\")\n  1656\t        self.assertEqual(operation.migration_name_fragment, \"remove_pony_pink\")\n  1657\t        new_state = project_state.clone()\n  1658\t        operation.state_forwards(\"test_rmfl\", new_state)\n  1659\t        self.assertEqual(len(new_state.models[\"test_rmfl\", \"pony\"].fields), 2)\n  1660\t        # Test the database alteration\n  1661\t        self.assertColumnExists(\"test_rmfl_pony\", \"pink\")\n  1662\t        with connection.schema_editor() as editor:\n  1663\t            operation.database_forwards(\"test_rmfl\", editor, project_state, new_state)\n  1664\t        self.assertColumnNotExists(\"test_rmfl_pony\", \"pink\")\n  1665\t        # And test reversal\n  1666\t        with connection.schema_editor() as editor:\n  1667\t            operation.database_backwards(\"test_rmfl\", editor, new_state, project_state)\n  1668\t        self.assertColumnExists(\"test_rmfl_pony\", \"pink\")\n  1669\t        # And deconstruction\n  1670\t        definition = operation.deconstruct()\n  1671\t        self.assertEqual(definition[0], \"RemoveField\")\n  1672\t        self.assertEqual(definition[1], [])\n  1673\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"name\": \"pink\"})\n  1674\t\n  1675\t    def test_remove_fk(self):\n  1676\t        \"\"\"\n  1677\t        Tests the RemoveField operation on a foreign key.\n  1678\t        \"\"\"\n  1679\t        project_state = self.set_up_test_model(\"test_rfk\", related_model=True)\n  1680\t        self.assertColumnExists(\"test_rfk_rider\", \"pony_id\")\n  1681\t        operation = migrations.RemoveField(\"Rider\", \"pony\")\n  1682\t\n  1683\t        new_state = project_state.clone()\n  1684\t        operation.state_forwards(\"test_rfk\", new_state)\n  1685\t        with connection.schema_editor() as editor:\n  1686\t            operation.database_forwards(\"test_rfk\", editor, project_state, new_state)\n  1687\t        self.assertColumnNotExists(\"test_rfk_rider\", \"pony_id\")\n  1688\t        with connection.schema_editor() as editor:\n  1689\t            operation.database_backwards(\"test_rfk\", editor, new_state, project_state)\n  1690\t        self.assertColumnExists(\"test_rfk_rider\", \"pony_id\")\n  1691\t\n  1692\t    def test_alter_model_table(self):\n  1693\t        \"\"\"\n  1694\t        Tests the AlterModelTable operation.\n  1695\t        \"\"\"\n  1696\t        project_state = self.set_up_test_model(\"test_almota\")\n  1697\t        # Test the state alteration\n  1698\t        operation = migrations.AlterModelTable(\"Pony\", \"test_almota_pony_2\")\n  1699\t        self.assertEqual(\n  1700\t            operation.describe(), \"Rename table for Pony to test_almota_pony_2\"\n  1701\t        )\n  1702\t        self.assertEqual(operation.migration_name_fragment, \"alter_pony_table\")\n  1703\t        new_state = project_state.clone()\n  1704\t        operation.state_forwards(\"test_almota\", new_state)\n  1705\t        self.assertEqual(\n  1706\t            new_state.models[\"test_almota\", \"pony\"].options[\"db_table\"],\n  1707\t            \"test_almota_pony_2\",\n  1708\t        )\n  1709\t        # Test the database alteration\n  1710\t        self.assertTableExists(\"test_almota_pony\")\n  1711\t        self.assertTableNotExists(\"test_almota_pony_2\")\n  1712\t        with connection.schema_editor() as editor:\n  1713\t            operation.database_forwards(\"test_almota\", editor, project_state, new_state)\n  1714\t        self.assertTableNotExists(\"test_almota_pony\")\n  1715\t        self.assertTableExists(\"test_almota_pony_2\")\n  1716\t        # And test reversal\n  1717\t        with connection.schema_editor() as editor:\n  1718\t            operation.database_backwards(\n  1719\t                \"test_almota\", editor, new_state, project_state\n  1720\t            )\n  1721\t        self.assertTableExists(\"test_almota_pony\")\n  1722\t        self.assertTableNotExists(\"test_almota_pony_2\")\n  1723\t        # And deconstruction\n  1724\t        definition = operation.deconstruct()\n  1725\t        self.assertEqual(definition[0], \"AlterModelTable\")\n  1726\t        self.assertEqual(definition[1], [])\n  1727\t        self.assertEqual(definition[2], {\"name\": \"Pony\", \"table\": \"test_almota_pony_2\"})\n  1728\t\n  1729\t    def test_alter_model_table_none(self):\n  1730\t        \"\"\"\n  1731\t        Tests the AlterModelTable operation if the table name is set to None.\n  1732\t        \"\"\"\n  1733\t        operation = migrations.AlterModelTable(\"Pony\", None)\n  1734\t        self.assertEqual(operation.describe(), \"Rename table for Pony to (default)\")\n  1735\t\n  1736\t    def test_alter_model_table_noop(self):\n  1737\t        \"\"\"\n  1738\t        Tests the AlterModelTable operation if the table name is not changed.\n  1739\t        \"\"\"\n  1740\t        project_state = self.set_up_test_model(\"test_almota\")\n  1741\t        # Test the state alteration\n  1742\t        operation = migrations.AlterModelTable(\"Pony\", \"test_almota_pony\")\n  1743\t        new_state = project_state.clone()\n  1744\t        operation.state_forwards(\"test_almota\", new_state)\n  1745\t        self.assertEqual(\n  1746\t            new_state.models[\"test_almota\", \"pony\"].options[\"db_table\"],\n  1747\t            \"test_almota_pony\",\n  1748\t        )\n  1749\t        # Test the database alteration\n  1750\t        self.assertTableExists(\"test_almota_pony\")\n  1751\t        with connection.schema_editor() as editor:\n  1752\t            operation.database_forwards(\"test_almota\", editor, project_state, new_state)\n  1753\t        self.assertTableExists(\"test_almota_pony\")\n  1754\t        # And test reversal\n  1755\t        with connection.schema_editor() as editor:\n  1756\t            operation.database_backwards(\n  1757\t                \"test_almota\", editor, new_state, project_state\n  1758\t            )\n  1759\t        self.assertTableExists(\"test_almota_pony\")\n  1760\t\n  1761\t    def test_alter_model_table_m2m(self):\n  1762\t        \"\"\"\n  1763\t        AlterModelTable should rename auto-generated M2M tables.\n  1764\t        \"\"\"\n  1765\t        app_label = \"test_talflmltlm2m\"\n  1766\t        pony_db_table = \"pony_foo\"\n  1767\t        project_state = self.set_up_test_model(\n  1768\t            app_label, second_model=True, db_table=pony_db_table\n  1769\t        )\n  1770\t        # Add the M2M field\n  1771\t        first_state = project_state.clone()\n  1772\t        operation = migrations.AddField(\n  1773\t            \"Pony\", \"stables\", models.ManyToManyField(\"Stable\")\n  1774\t        )\n  1775\t        operation.state_forwards(app_label, first_state)\n  1776\t        with connection.schema_editor() as editor:\n  1777\t            operation.database_forwards(app_label, editor, project_state, first_state)\n  1778\t        original_m2m_table = \"%s_%s\" % (pony_db_table, \"stables\")\n  1779\t        new_m2m_table = \"%s_%s\" % (app_label, \"pony_stables\")\n  1780\t        self.assertTableExists(original_m2m_table)\n  1781\t        self.assertTableNotExists(new_m2m_table)\n  1782\t        # Rename the Pony db_table which should also rename the m2m table.\n  1783\t        second_state = first_state.clone()\n  1784\t        operation = migrations.AlterModelTable(name=\"pony\", table=None)\n  1785\t        operation.state_forwards(app_label, second_state)\n  1786\t        atomic_rename = connection.features.supports_atomic_references_rename\n  1787\t        with connection.schema_editor(atomic=atomic_rename) as editor:\n  1788\t            operation.database_forwards(app_label, editor, first_state, second_state)\n  1789\t        self.assertTableExists(new_m2m_table)\n  1790\t        self.assertTableNotExists(original_m2m_table)\n  1791\t        # And test reversal\n  1792\t        with connection.schema_editor(atomic=atomic_rename) as editor:\n  1793\t            operation.database_backwards(app_label, editor, second_state, first_state)\n  1794\t        self.assertTableExists(original_m2m_table)\n  1795\t        self.assertTableNotExists(new_m2m_table)\n  1796\t\n  1797\t    def test_alter_field(self):\n  1798\t        \"\"\"\n  1799\t        Tests the AlterField operation.\n  1800\t        \"\"\"\n  1801\t        project_state = self.set_up_test_model(\"test_alfl\")\n  1802\t        # Test the state alteration\n  1803\t        operation = migrations.AlterField(\n  1804\t            \"Pony\", \"pink\", models.IntegerField(null=True)\n  1805\t        )\n  1806\t        self.assertEqual(operation.describe(), \"Alter field pink on Pony\")\n  1807\t        self.assertEqual(operation.migration_name_fragment, \"alter_pony_pink\")\n  1808\t        new_state = project_state.clone()\n  1809\t        operation.state_forwards(\"test_alfl\", new_state)\n  1810\t        self.assertIs(\n  1811\t            project_state.models[\"test_alfl\", \"pony\"].fields[\"pink\"].null, False\n  1812\t        )\n  1813\t        self.assertIs(new_state.models[\"test_alfl\", \"pony\"].fields[\"pink\"].null, True)\n  1814\t        # Test the database alteration\n  1815\t        self.assertColumnNotNull(\"test_alfl_pony\", \"pink\")\n  1816\t        with connection.schema_editor() as editor:\n  1817\t            operation.database_forwards(\"test_alfl\", editor, project_state, new_state)\n  1818\t        self.assertColumnNull(\"test_alfl_pony\", \"pink\")\n  1819\t        # And test reversal\n  1820\t        with connection.schema_editor() as editor:\n  1821\t            operation.database_backwards(\"test_alfl\", editor, new_state, project_state)\n  1822\t        self.assertColumnNotNull(\"test_alfl_pony\", \"pink\")\n  1823\t        # And deconstruction\n  1824\t        definition = operation.deconstruct()\n  1825\t        self.assertEqual(definition[0], \"AlterField\")\n  1826\t        self.assertEqual(definition[1], [])\n  1827\t        self.assertEqual(sorted(definition[2]), [\"field\", \"model_name\", \"name\"])\n  1828\t\n  1829\t    def test_alter_field_add_db_column_noop(self):\n  1830\t        \"\"\"\n  1831\t        AlterField operation is a noop when adding only a db_column and the\n  1832\t        column name is not changed.\n  1833\t        \"\"\"\n  1834\t        app_label = \"test_afadbn\"\n  1835\t        project_state = self.set_up_test_model(app_label, related_model=True)\n  1836\t        pony_table = \"%s_pony\" % app_label\n  1837\t        new_state = project_state.clone()\n  1838\t        operation = migrations.AlterField(\n  1839\t            \"Pony\", \"weight\", models.FloatField(db_column=\"weight\")\n  1840\t        )\n  1841\t        operation.state_forwards(app_label, new_state)\n  1842\t        self.assertIsNone(\n  1843\t            project_state.models[app_label, \"pony\"].fields[\"weight\"].db_column,\n  1844\t        )\n  1845\t        self.assertEqual(\n  1846\t            new_state.models[app_label, \"pony\"].fields[\"weight\"].db_column,\n  1847\t            \"weight\",\n  1848\t        )\n  1849\t        self.assertColumnExists(pony_table, \"weight\")\n  1850\t        with connection.schema_editor() as editor:\n  1851\t            with self.assertNumQueries(0):\n  1852\t                operation.database_forwards(app_label, editor, project_state, new_state)\n  1853\t        self.assertColumnExists(pony_table, \"weight\")\n  1854\t        with connection.schema_editor() as editor:\n  1855\t            with self.assertNumQueries(0):\n  1856\t                operation.database_backwards(\n  1857\t                    app_label, editor, new_state, project_state\n  1858\t                )\n  1859\t        self.assertColumnExists(pony_table, \"weight\")\n  1860\t\n  1861\t        rider_table = \"%s_rider\" % app_label\n  1862\t        new_state = project_state.clone()\n  1863\t        operation = migrations.AlterField(\n  1864\t            \"Rider\",\n  1865\t            \"pony\",\n  1866\t            models.ForeignKey(\"Pony\", models.CASCADE, db_column=\"pony_id\"),\n  1867\t        )\n  1868\t        operation.state_forwards(app_label, new_state)\n  1869\t        self.assertIsNone(\n  1870\t            project_state.models[app_label, \"rider\"].fields[\"pony\"].db_column,\n  1871\t        )\n  1872\t        self.assertIs(\n  1873\t            new_state.models[app_label, \"rider\"].fields[\"pony\"].db_column,\n  1874\t            \"pony_id\",\n  1875\t        )\n  1876\t        self.assertColumnExists(rider_table, \"pony_id\")\n  1877\t        with connection.schema_editor() as editor:\n  1878\t            with self.assertNumQueries(0):\n  1879\t                operation.database_forwards(app_label, editor, project_state, new_state)\n  1880\t        self.assertColumnExists(rider_table, \"pony_id\")\n  1881\t        with connection.schema_editor() as editor:\n  1882\t            with self.assertNumQueries(0):\n  1883\t                operation.database_forwards(app_label, editor, new_state, project_state)\n  1884\t        self.assertColumnExists(rider_table, \"pony_id\")\n  1885\t\n  1886\t    def test_alter_field_pk(self):\n  1887\t        \"\"\"\n  1888\t        The AlterField operation on primary keys (things like PostgreSQL's\n  1889\t        SERIAL weirdness).\n  1890\t        \"\"\"\n  1891\t        project_state = self.set_up_test_model(\"test_alflpk\")\n  1892\t        # Test the state alteration\n  1893\t        operation = migrations.AlterField(\n  1894\t            \"Pony\", \"id\", models.IntegerField(primary_key=True)\n  1895\t        )\n  1896\t        new_state = project_state.clone()\n  1897\t        operation.state_forwards(\"test_alflpk\", new_state)\n  1898\t        self.assertIsInstance(\n  1899\t            project_state.models[\"test_alflpk\", \"pony\"].fields[\"id\"],\n  1900\t            models.AutoField,\n  1901\t        )\n  1902\t        self.assertIsInstance(\n  1903\t            new_state.models[\"test_alflpk\", \"pony\"].fields[\"id\"],\n  1904\t            models.IntegerField,\n  1905\t        )\n  1906\t        # Test the database alteration\n  1907\t        with connection.schema_editor() as editor:\n  1908\t            operation.database_forwards(\"test_alflpk\", editor, project_state, new_state)\n  1909\t        # And test reversal\n  1910\t        with connection.schema_editor() as editor:\n  1911\t            operation.database_backwards(\n  1912\t                \"test_alflpk\", editor, new_state, project_state\n  1913\t            )\n  1914\t\n  1915\t    @skipUnlessDBFeature(\"supports_foreign_keys\")\n  1916\t    def test_alter_field_pk_fk(self):\n  1917\t        \"\"\"\n  1918\t        Tests the AlterField operation on primary keys changes any FKs pointing to it.\n  1919\t        \"\"\"\n  1920\t        project_state = self.set_up_test_model(\"test_alflpkfk\", related_model=True)\n  1921\t        project_state = self.apply_operations(\n  1922\t            \"test_alflpkfk\",\n  1923\t            project_state,\n  1924\t            [\n  1925\t                migrations.CreateModel(\n  1926\t                    \"Stable\",\n  1927\t                    fields=[\n  1928\t                        (\"ponies\", models.ManyToManyField(\"Pony\")),\n  1929\t                    ],\n  1930\t                ),\n  1931\t                migrations.AddField(\n  1932\t                    \"Pony\",\n  1933\t                    \"stables\",\n  1934\t                    models.ManyToManyField(\"Stable\"),\n  1935\t                ),\n  1936\t            ],\n  1937\t        )\n  1938\t        # Test the state alteration\n  1939\t        operation = migrations.AlterField(\n  1940\t            \"Pony\", \"id\", models.FloatField(primary_key=True)\n  1941\t        )\n  1942\t        new_state = project_state.clone()\n  1943\t        operation.state_forwards(\"test_alflpkfk\", new_state)\n  1944\t        self.assertIsInstance(\n  1945\t            project_state.models[\"test_alflpkfk\", \"pony\"].fields[\"id\"],\n  1946\t            models.AutoField,\n  1947\t        )\n  1948\t        self.assertIsInstance(\n  1949\t            new_state.models[\"test_alflpkfk\", \"pony\"].fields[\"id\"],\n  1950\t            models.FloatField,\n  1951\t        )\n  1952\t\n  1953\t        def assertIdTypeEqualsFkType():\n  1954\t            with connection.cursor() as cursor:\n  1955\t                id_type, id_null = [\n  1956\t                    (c.type_code, c.null_ok)\n  1957\t                    for c in connection.introspection.get_table_description(\n  1958\t                        cursor, \"test_alflpkfk_pony\"\n  1959\t                    )\n  1960\t                    if c.name == \"id\"\n  1961\t                ][0]\n  1962\t                fk_type, fk_null = [\n  1963\t                    (c.type_code, c.null_ok)\n  1964\t                    for c in connection.introspection.get_table_description(\n  1965\t                        cursor, \"test_alflpkfk_rider\"\n  1966\t                    )\n  1967\t                    if c.name == \"pony_id\"\n  1968\t                ][0]\n  1969\t                m2m_fk_type, m2m_fk_null = [\n  1970\t                    (c.type_code, c.null_ok)\n  1971\t                    for c in connection.introspection.get_table_description(\n  1972\t                        cursor,\n  1973\t                        \"test_alflpkfk_pony_stables\",\n  1974\t                    )\n  1975\t                    if c.name == \"pony_id\"\n  1976\t                ][0]\n  1977\t                remote_m2m_fk_type, remote_m2m_fk_null = [\n  1978\t                    (c.type_code, c.null_ok)\n  1979\t                    for c in connection.introspection.get_table_description(\n  1980\t                        cursor,\n  1981\t                        \"test_alflpkfk_stable_ponies\",\n  1982\t                    )\n  1983\t                    if c.name == \"pony_id\"\n  1984\t                ][0]\n  1985\t            self.assertEqual(id_type, fk_type)\n  1986\t            self.assertEqual(id_type, m2m_fk_type)\n  1987\t            self.assertEqual(id_type, remote_m2m_fk_type)\n  1988\t            self.assertEqual(id_null, fk_null)\n  1989\t            self.assertEqual(id_null, m2m_fk_null)\n  1990\t            self.assertEqual(id_null, remote_m2m_fk_null)\n  1991\t\n  1992\t        assertIdTypeEqualsFkType()\n  1993\t        # Test the database alteration\n  1994\t        with connection.schema_editor() as editor:\n  1995\t            operation.database_forwards(\n  1996\t                \"test_alflpkfk\", editor, project_state, new_state\n  1997\t            )\n  1998\t        assertIdTypeEqualsFkType()\n  1999\t        if connection.features.supports_foreign_keys:\n  2000\t            self.assertFKExists(\n  2001\t                \"test_alflpkfk_pony_stables\",\n  2002\t                [\"pony_id\"],\n  2003\t                (\"test_alflpkfk_pony\", \"id\"),\n  2004\t            )\n  2005\t            self.assertFKExists(\n  2006\t                \"test_alflpkfk_stable_ponies\",\n  2007\t                [\"pony_id\"],\n  2008\t                (\"test_alflpkfk_pony\", \"id\"),\n  2009\t            )\n  2010\t        # And test reversal\n  2011\t        with connection.schema_editor() as editor:\n  2012\t            operation.database_backwards(\n  2013\t                \"test_alflpkfk\", editor, new_state, project_state\n  2014\t            )\n  2015\t        assertIdTypeEqualsFkType()\n  2016\t        if connection.features.supports_foreign_keys:\n  2017\t            self.assertFKExists(\n  2018\t                \"test_alflpkfk_pony_stables\",\n  2019\t                [\"pony_id\"],\n  2020\t                (\"test_alflpkfk_pony\", \"id\"),\n  2021\t            )\n  2022\t            self.assertFKExists(\n  2023\t                \"test_alflpkfk_stable_ponies\",\n  2024\t                [\"pony_id\"],\n  2025\t                (\"test_alflpkfk_pony\", \"id\"),\n  2026\t            )\n  2027\t\n  2028\t    @skipUnlessDBFeature(\"supports_collation_on_charfield\", \"supports_foreign_keys\")\n  2029\t    def test_alter_field_pk_fk_db_collation(self):\n  2030\t        \"\"\"\n  2031\t        AlterField operation of db_collation on primary keys changes any FKs\n  2032\t        pointing to it.\n  2033\t        \"\"\"\n  2034\t        collation = connection.features.test_collations.get(\"non_default\")\n  2035\t        if not collation:\n  2036\t            self.skipTest(\"Language collations are not supported.\")\n  2037\t\n  2038\t        app_label = \"test_alflpkfkdbc\"\n  2039\t        project_state = self.apply_operations(\n  2040\t            app_label,\n  2041\t            ProjectState(),\n  2042\t            [\n  2043\t                migrations.CreateModel(\n  2044\t                    \"Pony\",\n  2045\t                    [\n  2046\t                        (\"id\", models.CharField(primary_key=True, max_length=10)),\n  2047\t                    ],\n  2048\t                ),\n  2049\t                migrations.CreateModel(\n  2050\t                    \"Rider\",\n  2051\t                    [\n  2052\t                        (\"pony\", models.ForeignKey(\"Pony\", models.CASCADE)),\n  2053\t                    ],\n  2054\t                ),\n  2055\t                migrations.CreateModel(\n  2056\t                    \"Stable\",\n  2057\t                    [\n  2058\t                        (\"ponies\", models.ManyToManyField(\"Pony\")),\n  2059\t                    ],\n  2060\t                ),\n  2061\t            ],\n  2062\t        )\n  2063\t        # State alteration.\n  2064\t        operation = migrations.AlterField(\n  2065\t            \"Pony\",\n  2066\t            \"id\",\n  2067\t            models.CharField(\n  2068\t                primary_key=True,\n  2069\t                max_length=10,\n  2070\t                db_collation=collation,\n  2071\t            ),\n  2072\t        )\n  2073\t        new_state = project_state.clone()\n  2074\t        operation.state_forwards(app_label, new_state)\n  2075\t        # Database alteration.\n  2076\t        with connection.schema_editor() as editor:\n  2077\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2078\t        self.assertColumnCollation(f\"{app_label}_pony\", \"id\", collation)\n  2079\t        self.assertColumnCollation(f\"{app_label}_rider\", \"pony_id\", collation)\n  2080\t        self.assertColumnCollation(f\"{app_label}_stable_ponies\", \"pony_id\", collation)\n  2081\t        # Reversal.\n  2082\t        with connection.schema_editor() as editor:\n  2083\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2084\t\n  2085\t    def test_alter_field_pk_mti_fk(self):\n  2086\t        app_label = \"test_alflpkmtifk\"\n  2087\t        project_state = self.set_up_test_model(app_label, mti_model=True)\n  2088\t        project_state = self.apply_operations(\n  2089\t            app_label,\n  2090\t            project_state,\n  2091\t            [\n  2092\t                migrations.CreateModel(\n  2093\t                    \"ShetlandRider\",\n  2094\t                    fields=[\n  2095\t                        (\n  2096\t                            \"pony\",\n  2097\t                            models.ForeignKey(\n  2098\t                                f\"{app_label}.ShetlandPony\", models.CASCADE\n  2099\t                            ),\n  2100\t                        ),\n  2101\t                    ],\n  2102\t                ),\n  2103\t            ],\n  2104\t        )\n  2105\t        operation = migrations.AlterField(\n  2106\t            \"Pony\",\n  2107\t            \"id\",\n  2108\t            models.BigAutoField(primary_key=True),\n  2109\t        )\n  2110\t        new_state = project_state.clone()\n  2111\t        operation.state_forwards(app_label, new_state)\n  2112\t        self.assertIsInstance(\n  2113\t            new_state.models[app_label, \"pony\"].fields[\"id\"],\n  2114\t            models.BigAutoField,\n  2115\t        )\n  2116\t\n  2117\t        def _get_column_id_type(cursor, table, column):\n  2118\t            return [\n  2119\t                c.type_code\n  2120\t                for c in connection.introspection.get_table_description(\n  2121\t                    cursor,\n  2122\t                    f\"{app_label}_{table}\",\n  2123\t                )\n  2124\t                if c.name == column\n  2125\t            ][0]\n  2126\t\n  2127\t        def assertIdTypeEqualsMTIFkType():\n  2128\t            with connection.cursor() as cursor:\n  2129\t                parent_id_type = _get_column_id_type(cursor, \"pony\", \"id\")\n  2130\t                child_id_type = _get_column_id_type(\n  2131\t                    cursor, \"shetlandpony\", \"pony_ptr_id\"\n  2132\t                )\n  2133\t                mti_id_type = _get_column_id_type(cursor, \"shetlandrider\", \"pony_id\")\n  2134\t            self.assertEqual(parent_id_type, child_id_type)\n  2135\t            self.assertEqual(parent_id_type, mti_id_type)\n  2136\t\n  2137\t        assertIdTypeEqualsMTIFkType()\n  2138\t        # Alter primary key.\n  2139\t        with connection.schema_editor() as editor:\n  2140\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2141\t        assertIdTypeEqualsMTIFkType()\n  2142\t        if connection.features.supports_foreign_keys:\n  2143\t            self.assertFKExists(\n  2144\t                f\"{app_label}_shetlandpony\",\n  2145\t                [\"pony_ptr_id\"],\n  2146\t                (f\"{app_label}_pony\", \"id\"),\n  2147\t            )\n  2148\t            self.assertFKExists(\n  2149\t                f\"{app_label}_shetlandrider\",\n  2150\t                [\"pony_id\"],\n  2151\t                (f\"{app_label}_shetlandpony\", \"pony_ptr_id\"),\n  2152\t            )\n  2153\t        # Reversal.\n  2154\t        with connection.schema_editor() as editor:\n  2155\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2156\t        assertIdTypeEqualsMTIFkType()\n  2157\t        if connection.features.supports_foreign_keys:\n  2158\t            self.assertFKExists(\n  2159\t                f\"{app_label}_shetlandpony\",\n  2160\t                [\"pony_ptr_id\"],\n  2161\t                (f\"{app_label}_pony\", \"id\"),\n  2162\t            )\n  2163\t            self.assertFKExists(\n  2164\t                f\"{app_label}_shetlandrider\",\n  2165\t                [\"pony_id\"],\n  2166\t                (f\"{app_label}_shetlandpony\", \"pony_ptr_id\"),\n  2167\t            )\n  2168\t\n  2169\t    def test_alter_field_pk_mti_and_fk_to_base(self):\n  2170\t        app_label = \"test_alflpkmtiftb\"\n  2171\t        project_state = self.set_up_test_model(\n  2172\t            app_label,\n  2173\t            mti_model=True,\n  2174\t            related_model=True,\n  2175\t        )\n  2176\t        operation = migrations.AlterField(\n  2177\t            \"Pony\",\n  2178\t            \"id\",\n  2179\t            models.BigAutoField(primary_key=True),\n  2180\t        )\n  2181\t        new_state = project_state.clone()\n  2182\t        operation.state_forwards(app_label, new_state)\n  2183\t        self.assertIsInstance(\n  2184\t            new_state.models[app_label, \"pony\"].fields[\"id\"],\n  2185\t            models.BigAutoField,\n  2186\t        )\n  2187\t\n  2188\t        def _get_column_id_type(cursor, table, column):\n  2189\t            return [\n  2190\t                c.type_code\n  2191\t                for c in connection.introspection.get_table_description(\n  2192\t                    cursor,\n  2193\t                    f\"{app_label}_{table}\",\n  2194\t                )\n  2195\t                if c.name == column\n  2196\t            ][0]\n  2197\t\n  2198\t        def assertIdTypeEqualsMTIFkType():\n  2199\t            with connection.cursor() as cursor:\n  2200\t                parent_id_type = _get_column_id_type(cursor, \"pony\", \"id\")\n  2201\t                fk_id_type = _get_column_id_type(cursor, \"rider\", \"pony_id\")\n  2202\t                child_id_type = _get_column_id_type(\n  2203\t                    cursor, \"shetlandpony\", \"pony_ptr_id\"\n  2204\t                )\n  2205\t            self.assertEqual(parent_id_type, child_id_type)\n  2206\t            self.assertEqual(parent_id_type, fk_id_type)\n  2207\t\n  2208\t        assertIdTypeEqualsMTIFkType()\n  2209\t        # Alter primary key.\n  2210\t        with connection.schema_editor() as editor:\n  2211\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2212\t        assertIdTypeEqualsMTIFkType()\n  2213\t        if connection.features.supports_foreign_keys:\n  2214\t            self.assertFKExists(\n  2215\t                f\"{app_label}_shetlandpony\",\n  2216\t                [\"pony_ptr_id\"],\n  2217\t                (f\"{app_label}_pony\", \"id\"),\n  2218\t            )\n  2219\t            self.assertFKExists(\n  2220\t                f\"{app_label}_rider\",\n  2221\t                [\"pony_id\"],\n  2222\t                (f\"{app_label}_pony\", \"id\"),\n  2223\t            )\n  2224\t        # Reversal.\n  2225\t        with connection.schema_editor() as editor:\n  2226\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2227\t        assertIdTypeEqualsMTIFkType()\n  2228\t        if connection.features.supports_foreign_keys:\n  2229\t            self.assertFKExists(\n  2230\t                f\"{app_label}_shetlandpony\",\n  2231\t                [\"pony_ptr_id\"],\n  2232\t                (f\"{app_label}_pony\", \"id\"),\n  2233\t            )\n  2234\t            self.assertFKExists(\n  2235\t                f\"{app_label}_rider\",\n  2236\t                [\"pony_id\"],\n  2237\t                (f\"{app_label}_pony\", \"id\"),\n  2238\t            )\n  2239\t\n  2240\t    @skipUnlessDBFeature(\"supports_foreign_keys\")\n  2241\t    def test_alter_field_reloads_state_on_fk_with_to_field_target_type_change(self):\n  2242\t        app_label = \"test_alflrsfkwtflttc\"\n  2243\t        project_state = self.apply_operations(\n  2244\t            app_label,\n  2245\t            ProjectState(),\n  2246\t            operations=[\n  2247\t                migrations.CreateModel(\n  2248\t                    \"Rider\",\n  2249\t                    fields=[\n  2250\t                        (\"id\", models.AutoField(primary_key=True)),\n  2251\t                        (\"code\", models.IntegerField(unique=True)),\n  2252\t                    ],\n  2253\t                ),\n  2254\t                migrations.CreateModel(\n  2255\t                    \"Pony\",\n  2256\t                    fields=[\n  2257\t                        (\"id\", models.AutoField(primary_key=True)),\n  2258\t                        (\n  2259\t                            \"rider\",\n  2260\t                            models.ForeignKey(\n  2261\t                                \"%s.Rider\" % app_label, models.CASCADE, to_field=\"code\"\n  2262\t                            ),\n  2263\t                        ),\n  2264\t                    ],\n  2265\t                ),\n  2266\t            ],\n  2267\t        )\n  2268\t        operation = migrations.AlterField(\n  2269\t            \"Rider\",\n  2270\t            \"code\",\n  2271\t            models.CharField(max_length=100, unique=True),\n  2272\t        )\n  2273\t        self.apply_operations(app_label, project_state, operations=[operation])\n  2274\t        id_type, id_null = [\n  2275\t            (c.type_code, c.null_ok)\n  2276\t            for c in self.get_table_description(\"%s_rider\" % app_label)\n  2277\t            if c.name == \"code\"\n  2278\t        ][0]\n  2279\t        fk_type, fk_null = [\n  2280\t            (c.type_code, c.null_ok)\n  2281\t            for c in self.get_table_description(\"%s_pony\" % app_label)\n  2282\t            if c.name == \"rider_id\"\n  2283\t        ][0]\n  2284\t        self.assertEqual(id_type, fk_type)\n  2285\t        self.assertEqual(id_null, fk_null)\n  2286\t\n  2287\t    @skipUnlessDBFeature(\"supports_foreign_keys\")\n  2288\t    def test_alter_field_reloads_state_fk_with_to_field_related_name_target_type_change(\n  2289\t        self,\n  2290\t    ):\n  2291\t        app_label = \"test_alflrsfkwtflrnttc\"\n  2292\t        project_state = self.apply_operations(\n  2293\t            app_label,\n  2294\t            ProjectState(),\n  2295\t            operations=[\n  2296\t                migrations.CreateModel(\n  2297\t                    \"Rider\",\n  2298\t                    fields=[\n  2299\t                        (\"id\", models.AutoField(primary_key=True)),\n  2300\t                        (\"code\", models.PositiveIntegerField(unique=True)),\n  2301\t                    ],\n  2302\t                ),\n  2303\t                migrations.CreateModel(\n  2304\t                    \"Pony\",\n  2305\t                    fields=[\n  2306\t                        (\"id\", models.AutoField(primary_key=True)),\n  2307\t                        (\n  2308\t                            \"rider\",\n  2309\t                            models.ForeignKey(\n  2310\t                                \"%s.Rider\" % app_label,\n  2311\t                                models.CASCADE,\n  2312\t                                to_field=\"code\",\n  2313\t                                related_name=\"+\",\n  2314\t                            ),\n  2315\t                        ),\n  2316\t                    ],\n  2317\t                ),\n  2318\t            ],\n  2319\t        )\n  2320\t        operation = migrations.AlterField(\n  2321\t            \"Rider\",\n  2322\t            \"code\",\n  2323\t            models.CharField(max_length=100, unique=True),\n  2324\t        )\n  2325\t        self.apply_operations(app_label, project_state, operations=[operation])\n  2326\t\n  2327\t    def test_alter_field_reloads_state_on_fk_target_changes(self):\n  2328\t        \"\"\"\n  2329\t        If AlterField doesn't reload state appropriately, the second AlterField\n  2330\t        crashes on MySQL due to not dropping the PonyRider.pony foreign key\n  2331\t        constraint before modifying the column.\n  2332\t        \"\"\"\n  2333\t        app_label = \"alter_alter_field_reloads_state_on_fk_target_changes\"\n  2334\t        project_state = self.apply_operations(\n  2335\t            app_label,\n  2336\t            ProjectState(),\n  2337\t            operations=[\n  2338\t                migrations.CreateModel(\n  2339\t                    \"Rider\",\n  2340\t                    fields=[\n  2341\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2342\t                    ],\n  2343\t                ),\n  2344\t                migrations.CreateModel(\n  2345\t                    \"Pony\",\n  2346\t                    fields=[\n  2347\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2348\t                        (\n  2349\t                            \"rider\",\n  2350\t                            models.ForeignKey(\"%s.Rider\" % app_label, models.CASCADE),\n  2351\t                        ),\n  2352\t                    ],\n  2353\t                ),\n  2354\t                migrations.CreateModel(\n  2355\t                    \"PonyRider\",\n  2356\t                    fields=[\n  2357\t                        (\"id\", models.AutoField(primary_key=True)),\n  2358\t                        (\n  2359\t                            \"pony\",\n  2360\t                            models.ForeignKey(\"%s.Pony\" % app_label, models.CASCADE),\n  2361\t                        ),\n  2362\t                    ],\n  2363\t                ),\n  2364\t            ],\n  2365\t        )\n  2366\t        project_state = self.apply_operations(\n  2367\t            app_label,\n  2368\t            project_state,\n  2369\t            operations=[\n  2370\t                migrations.AlterField(\n  2371\t                    \"Rider\", \"id\", models.CharField(primary_key=True, max_length=99)\n  2372\t                ),\n  2373\t                migrations.AlterField(\n  2374\t                    \"Pony\", \"id\", models.CharField(primary_key=True, max_length=99)\n  2375\t                ),\n  2376\t            ],\n  2377\t        )\n  2378\t\n  2379\t    def test_alter_field_reloads_state_on_fk_with_to_field_target_changes(self):\n  2380\t        \"\"\"\n  2381\t        If AlterField doesn't reload state appropriately, the second AlterField\n  2382\t        crashes on MySQL due to not dropping the PonyRider.pony foreign key\n  2383\t        constraint before modifying the column.\n  2384\t        \"\"\"\n  2385\t        app_label = \"alter_alter_field_reloads_state_on_fk_with_to_field_target_changes\"\n  2386\t        project_state = self.apply_operations(\n  2387\t            app_label,\n  2388\t            ProjectState(),\n  2389\t            operations=[\n  2390\t                migrations.CreateModel(\n  2391\t                    \"Rider\",\n  2392\t                    fields=[\n  2393\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2394\t                        (\"slug\", models.CharField(unique=True, max_length=100)),\n  2395\t                    ],\n  2396\t                ),\n  2397\t                migrations.CreateModel(\n  2398\t                    \"Pony\",\n  2399\t                    fields=[\n  2400\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2401\t                        (\n  2402\t                            \"rider\",\n  2403\t                            models.ForeignKey(\n  2404\t                                \"%s.Rider\" % app_label, models.CASCADE, to_field=\"slug\"\n  2405\t                            ),\n  2406\t                        ),\n  2407\t                        (\"slug\", models.CharField(unique=True, max_length=100)),\n  2408\t                    ],\n  2409\t                ),\n  2410\t                migrations.CreateModel(\n  2411\t                    \"PonyRider\",\n  2412\t                    fields=[\n  2413\t                        (\"id\", models.AutoField(primary_key=True)),\n  2414\t                        (\n  2415\t                            \"pony\",\n  2416\t                            models.ForeignKey(\n  2417\t                                \"%s.Pony\" % app_label, models.CASCADE, to_field=\"slug\"\n  2418\t                            ),\n  2419\t                        ),\n  2420\t                    ],\n  2421\t                ),\n  2422\t            ],\n  2423\t        )\n  2424\t        project_state = self.apply_operations(\n  2425\t            app_label,\n  2426\t            project_state,\n  2427\t            operations=[\n  2428\t                migrations.AlterField(\n  2429\t                    \"Rider\", \"slug\", models.CharField(unique=True, max_length=99)\n  2430\t                ),\n  2431\t                migrations.AlterField(\n  2432\t                    \"Pony\", \"slug\", models.CharField(unique=True, max_length=99)\n  2433\t                ),\n  2434\t            ],\n  2435\t        )\n  2436\t\n  2437\t    def test_rename_field_reloads_state_on_fk_target_changes(self):\n  2438\t        \"\"\"\n  2439\t        If RenameField doesn't reload state appropriately, the AlterField\n  2440\t        crashes on MySQL due to not dropping the PonyRider.pony foreign key\n  2441\t        constraint before modifying the column.\n  2442\t        \"\"\"\n  2443\t        app_label = \"alter_rename_field_reloads_state_on_fk_target_changes\"\n  2444\t        project_state = self.apply_operations(\n  2445\t            app_label,\n  2446\t            ProjectState(),\n  2447\t            operations=[\n  2448\t                migrations.CreateModel(\n  2449\t                    \"Rider\",\n  2450\t                    fields=[\n  2451\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2452\t                    ],\n  2453\t                ),\n  2454\t                migrations.CreateModel(\n  2455\t                    \"Pony\",\n  2456\t                    fields=[\n  2457\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2458\t                        (\n  2459\t                            \"rider\",\n  2460\t                            models.ForeignKey(\"%s.Rider\" % app_label, models.CASCADE),\n  2461\t                        ),\n  2462\t                    ],\n  2463\t                ),\n  2464\t                migrations.CreateModel(\n  2465\t                    \"PonyRider\",\n  2466\t                    fields=[\n  2467\t                        (\"id\", models.AutoField(primary_key=True)),\n  2468\t                        (\n  2469\t                            \"pony\",\n  2470\t                            models.ForeignKey(\"%s.Pony\" % app_label, models.CASCADE),\n  2471\t                        ),\n  2472\t                    ],\n  2473\t                ),\n  2474\t            ],\n  2475\t        )\n  2476\t        project_state = self.apply_operations(\n  2477\t            app_label,\n  2478\t            project_state,\n  2479\t            operations=[\n  2480\t                migrations.RenameField(\"Rider\", \"id\", \"id2\"),\n  2481\t                migrations.AlterField(\n  2482\t                    \"Pony\", \"id\", models.CharField(primary_key=True, max_length=99)\n  2483\t                ),\n  2484\t            ],\n  2485\t            atomic=connection.features.supports_atomic_references_rename,\n  2486\t        )\n  2487\t\n  2488\t    def test_rename_field(self):\n  2489\t        \"\"\"\n  2490\t        Tests the RenameField operation.\n  2491\t        \"\"\"\n  2492\t        project_state = self.set_up_test_model(\n  2493\t            \"test_rnfl\", unique_together=True, index_together=True\n  2494\t        )\n  2495\t        # Test the state alteration\n  2496\t        operation = migrations.RenameField(\"Pony\", \"pink\", \"blue\")\n  2497\t        self.assertEqual(operation.describe(), \"Rename field pink on Pony to blue\")\n  2498\t        self.assertEqual(operation.migration_name_fragment, \"rename_pink_pony_blue\")\n  2499\t        new_state = project_state.clone()\n  2500\t        operation.state_forwards(\"test_rnfl\", new_state)\n  2501\t        self.assertIn(\"blue\", new_state.models[\"test_rnfl\", \"pony\"].fields)\n  2502\t        self.assertNotIn(\"pink\", new_state.models[\"test_rnfl\", \"pony\"].fields)\n  2503\t        # Make sure the unique_together has the renamed column too\n  2504\t        self.assertIn(\n  2505\t            \"blue\", new_state.models[\"test_rnfl\", \"pony\"].options[\"unique_together\"][0]\n  2506\t        )\n  2507\t        self.assertNotIn(\n  2508\t            \"pink\", new_state.models[\"test_rnfl\", \"pony\"].options[\"unique_together\"][0]\n  2509\t        )\n  2510\t        # Make sure the index_together has the renamed column too\n  2511\t        self.assertIn(\n  2512\t            \"blue\", new_state.models[\"test_rnfl\", \"pony\"].options[\"index_together\"][0]\n  2513\t        )\n  2514\t        self.assertNotIn(\n  2515\t            \"pink\", new_state.models[\"test_rnfl\", \"pony\"].options[\"index_together\"][0]\n  2516\t        )\n  2517\t        # Test the database alteration\n  2518\t        self.assertColumnExists(\"test_rnfl_pony\", \"pink\")\n  2519\t        self.assertColumnNotExists(\"test_rnfl_pony\", \"blue\")\n  2520\t        with connection.schema_editor() as editor:\n  2521\t            operation.database_forwards(\"test_rnfl\", editor, project_state, new_state)\n  2522\t        self.assertColumnExists(\"test_rnfl_pony\", \"blue\")\n  2523\t        self.assertColumnNotExists(\"test_rnfl_pony\", \"pink\")\n  2524\t        # Ensure the unique constraint has been ported over\n  2525\t        with connection.cursor() as cursor:\n  2526\t            cursor.execute(\"INSERT INTO test_rnfl_pony (blue, weight) VALUES (1, 1)\")\n  2527\t            with self.assertRaises(IntegrityError):\n  2528\t                with atomic():\n  2529\t                    cursor.execute(\n  2530\t                        \"INSERT INTO test_rnfl_pony (blue, weight) VALUES (1, 1)\"\n  2531\t                    )\n  2532\t            cursor.execute(\"DELETE FROM test_rnfl_pony\")\n  2533\t        # Ensure the index constraint has been ported over\n  2534\t        self.assertIndexExists(\"test_rnfl_pony\", [\"weight\", \"blue\"])\n  2535\t        # And test reversal\n  2536\t        with connection.schema_editor() as editor:\n  2537\t            operation.database_backwards(\"test_rnfl\", editor, new_state, project_state)\n  2538\t        self.assertColumnExists(\"test_rnfl_pony\", \"pink\")\n  2539\t        self.assertColumnNotExists(\"test_rnfl_pony\", \"blue\")\n  2540\t        # Ensure the index constraint has been reset\n  2541\t        self.assertIndexExists(\"test_rnfl_pony\", [\"weight\", \"pink\"])\n  2542\t        # And deconstruction\n  2543\t        definition = operation.deconstruct()\n  2544\t        self.assertEqual(definition[0], \"RenameField\")\n  2545\t        self.assertEqual(definition[1], [])\n  2546\t        self.assertEqual(\n  2547\t            definition[2],\n  2548\t            {\"model_name\": \"Pony\", \"old_name\": \"pink\", \"new_name\": \"blue\"},\n  2549\t        )\n  2550\t\n  2551\t    def test_rename_field_with_db_column(self):\n  2552\t        project_state = self.apply_operations(\n  2553\t            \"test_rfwdbc\",\n  2554\t            ProjectState(),\n  2555\t            operations=[\n  2556\t                migrations.CreateModel(\n  2557\t                    \"Pony\",\n  2558\t                    fields=[\n  2559\t                        (\"id\", models.AutoField(primary_key=True)),\n  2560\t                        (\"field\", models.IntegerField(db_column=\"db_field\")),\n  2561\t                        (\n  2562\t                            \"fk_field\",\n  2563\t                            models.ForeignKey(\n  2564\t                                \"Pony\",\n  2565\t                                models.CASCADE,\n  2566\t                                db_column=\"db_fk_field\",\n  2567\t                            ),\n  2568\t                        ),\n  2569\t                    ],\n  2570\t                ),\n  2571\t            ],\n  2572\t        )\n  2573\t        new_state = project_state.clone()\n  2574\t        operation = migrations.RenameField(\"Pony\", \"field\", \"renamed_field\")\n  2575\t        operation.state_forwards(\"test_rfwdbc\", new_state)\n  2576\t        self.assertIn(\"renamed_field\", new_state.models[\"test_rfwdbc\", \"pony\"].fields)\n  2577\t        self.assertNotIn(\"field\", new_state.models[\"test_rfwdbc\", \"pony\"].fields)\n  2578\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_field\")\n  2579\t        with connection.schema_editor() as editor:\n  2580\t            with self.assertNumQueries(0):\n  2581\t                operation.database_forwards(\n  2582\t                    \"test_rfwdbc\", editor, project_state, new_state\n  2583\t                )\n  2584\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_field\")\n  2585\t        with connection.schema_editor() as editor:\n  2586\t            with self.assertNumQueries(0):\n  2587\t                operation.database_backwards(\n  2588\t                    \"test_rfwdbc\", editor, new_state, project_state\n  2589\t                )\n  2590\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_field\")\n  2591\t\n  2592\t        new_state = project_state.clone()\n  2593\t        operation = migrations.RenameField(\"Pony\", \"fk_field\", \"renamed_fk_field\")\n  2594\t        operation.state_forwards(\"test_rfwdbc\", new_state)\n  2595\t        self.assertIn(\n  2596\t            \"renamed_fk_field\", new_state.models[\"test_rfwdbc\", \"pony\"].fields\n  2597\t        )\n  2598\t        self.assertNotIn(\"fk_field\", new_state.models[\"test_rfwdbc\", \"pony\"].fields)\n  2599\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_fk_field\")\n  2600\t        with connection.schema_editor() as editor:\n  2601\t            with self.assertNumQueries(0):\n  2602\t                operation.database_forwards(\n  2603\t                    \"test_rfwdbc\", editor, project_state, new_state\n  2604\t                )\n  2605\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_fk_field\")\n  2606\t        with connection.schema_editor() as editor:\n  2607\t            with self.assertNumQueries(0):\n  2608\t                operation.database_backwards(\n  2609\t                    \"test_rfwdbc\", editor, new_state, project_state\n  2610\t                )\n  2611\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_fk_field\")\n  2612\t\n  2613\t    def test_rename_field_case(self):\n  2614\t        project_state = self.apply_operations(\n  2615\t            \"test_rfmx\",\n  2616\t            ProjectState(),\n  2617\t            operations=[\n  2618\t                migrations.CreateModel(\n  2619\t                    \"Pony\",\n  2620\t                    fields=[\n  2621\t                        (\"id\", models.AutoField(primary_key=True)),\n  2622\t                        (\"field\", models.IntegerField()),\n  2623\t                    ],\n  2624\t                ),\n  2625\t            ],\n  2626\t        )\n  2627\t        new_state = project_state.clone()\n  2628\t        operation = migrations.RenameField(\"Pony\", \"field\", \"FiElD\")\n  2629\t        operation.state_forwards(\"test_rfmx\", new_state)\n  2630\t        self.assertIn(\"FiElD\", new_state.models[\"test_rfmx\", \"pony\"].fields)\n  2631\t        self.assertColumnExists(\"test_rfmx_pony\", \"field\")\n  2632\t        with connection.schema_editor() as editor:\n  2633\t            operation.database_forwards(\"test_rfmx\", editor, project_state, new_state)\n  2634\t        self.assertColumnExists(\n  2635\t            \"test_rfmx_pony\",\n  2636\t            connection.introspection.identifier_converter(\"FiElD\"),\n  2637\t        )\n  2638\t        with connection.schema_editor() as editor:\n  2639\t            operation.database_backwards(\"test_rfmx\", editor, new_state, project_state)\n  2640\t        self.assertColumnExists(\"test_rfmx_pony\", \"field\")\n  2641\t\n  2642\t    def test_rename_missing_field(self):\n  2643\t        state = ProjectState()\n  2644\t        state.add_model(ModelState(\"app\", \"model\", []))\n  2645\t        with self.assertRaisesMessage(\n  2646\t            FieldDoesNotExist, \"app.model has no field named 'field'\"\n  2647\t        ):\n  2648\t            migrations.RenameField(\"model\", \"field\", \"new_field\").state_forwards(\n  2649\t                \"app\", state\n  2650\t            )\n  2651\t\n  2652\t    def test_rename_referenced_field_state_forward(self):\n  2653\t        state = ProjectState()\n  2654\t        state.add_model(\n  2655\t            ModelState(\n  2656\t                \"app\",\n  2657\t                \"Model\",\n  2658\t                [\n  2659\t                    (\"id\", models.AutoField(primary_key=True)),\n  2660\t                    (\"field\", models.IntegerField(unique=True)),\n  2661\t                ],\n  2662\t            )\n  2663\t        )\n  2664\t        state.add_model(\n  2665\t            ModelState(\n  2666\t                \"app\",\n  2667\t                \"OtherModel\",\n  2668\t                [\n  2669\t                    (\"id\", models.AutoField(primary_key=True)),\n  2670\t                    (\n  2671\t                        \"fk\",\n  2672\t                        models.ForeignKey(\"Model\", models.CASCADE, to_field=\"field\"),\n  2673\t                    ),\n  2674\t                    (\n  2675\t                        \"fo\",\n  2676\t                        models.ForeignObject(\n  2677\t                            \"Model\",\n  2678\t                            models.CASCADE,\n  2679\t                            from_fields=(\"fk\",),\n  2680\t                            to_fields=(\"field\",),\n  2681\t                        ),\n  2682\t                    ),\n  2683\t                ],\n  2684\t            )\n  2685\t        )\n  2686\t        operation = migrations.RenameField(\"Model\", \"field\", \"renamed\")\n  2687\t        new_state = state.clone()\n  2688\t        operation.state_forwards(\"app\", new_state)\n  2689\t        self.assertEqual(\n  2690\t            new_state.models[\"app\", \"othermodel\"].fields[\"fk\"].remote_field.field_name,\n  2691\t            \"renamed\",\n  2692\t        )\n  2693\t        self.assertEqual(\n  2694\t            new_state.models[\"app\", \"othermodel\"].fields[\"fk\"].from_fields, [\"self\"]\n  2695\t        )\n  2696\t        self.assertEqual(\n  2697\t            new_state.models[\"app\", \"othermodel\"].fields[\"fk\"].to_fields, (\"renamed\",)\n  2698\t        )\n  2699\t        self.assertEqual(\n  2700\t            new_state.models[\"app\", \"othermodel\"].fields[\"fo\"].from_fields, (\"fk\",)\n  2701\t        )\n  2702\t        self.assertEqual(\n  2703\t            new_state.models[\"app\", \"othermodel\"].fields[\"fo\"].to_fields, (\"renamed\",)\n  2704\t        )\n  2705\t        operation = migrations.RenameField(\"OtherModel\", \"fk\", \"renamed_fk\")\n  2706\t        new_state = state.clone()\n  2707\t        operation.state_forwards(\"app\", new_state)\n  2708\t        self.assertEqual(\n  2709\t            new_state.models[\"app\", \"othermodel\"]\n  2710\t            .fields[\"renamed_fk\"]\n  2711\t            .remote_field.field_name,\n  2712\t            \"renamed\",\n  2713\t        )\n  2714\t        self.assertEqual(\n  2715\t            new_state.models[\"app\", \"othermodel\"].fields[\"renamed_fk\"].from_fields,\n  2716\t            (\"self\",),\n  2717\t        )\n  2718\t        self.assertEqual(\n  2719\t            new_state.models[\"app\", \"othermodel\"].fields[\"renamed_fk\"].to_fields,\n  2720\t            (\"renamed\",),\n  2721\t        )\n  2722\t        self.assertEqual(\n  2723\t            new_state.models[\"app\", \"othermodel\"].fields[\"fo\"].from_fields,\n  2724\t            (\"renamed_fk\",),\n  2725\t        )\n  2726\t        self.assertEqual(\n  2727\t            new_state.models[\"app\", \"othermodel\"].fields[\"fo\"].to_fields, (\"renamed\",)\n  2728\t        )\n  2729\t\n  2730\t    def test_alter_unique_together(self):\n  2731\t        \"\"\"\n  2732\t        Tests the AlterUniqueTogether operation.\n  2733\t        \"\"\"\n  2734\t        project_state = self.set_up_test_model(\"test_alunto\")\n  2735\t        # Test the state alteration\n  2736\t        operation = migrations.AlterUniqueTogether(\"Pony\", [(\"pink\", \"weight\")])\n  2737\t        self.assertEqual(\n  2738\t            operation.describe(), \"Alter unique_together for Pony (1 constraint(s))\"\n  2739\t        )\n  2740\t        self.assertEqual(\n  2741\t            operation.migration_name_fragment,\n  2742\t            \"alter_pony_unique_together\",\n  2743\t        )\n  2744\t        new_state = project_state.clone()\n  2745\t        operation.state_forwards(\"test_alunto\", new_state)\n  2746\t        self.assertEqual(\n  2747\t            len(\n  2748\t                project_state.models[\"test_alunto\", \"pony\"].options.get(\n  2749\t                    \"unique_together\", set()\n  2750\t                )\n  2751\t            ),\n  2752\t            0,\n  2753\t        )\n  2754\t        self.assertEqual(\n  2755\t            len(\n  2756\t                new_state.models[\"test_alunto\", \"pony\"].options.get(\n  2757\t                    \"unique_together\", set()\n  2758\t                )\n  2759\t            ),\n  2760\t            1,\n  2761\t        )\n  2762\t        # Make sure we can insert duplicate rows\n  2763\t        with connection.cursor() as cursor:\n  2764\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2765\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2766\t            cursor.execute(\"DELETE FROM test_alunto_pony\")\n  2767\t            # Test the database alteration\n  2768\t            with connection.schema_editor() as editor:\n  2769\t                operation.database_forwards(\n  2770\t                    \"test_alunto\", editor, project_state, new_state\n  2771\t                )\n  2772\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2773\t            with self.assertRaises(IntegrityError):\n  2774\t                with atomic():\n  2775\t                    cursor.execute(\n  2776\t                        \"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\"\n  2777\t                    )\n  2778\t            cursor.execute(\"DELETE FROM test_alunto_pony\")\n  2779\t            # And test reversal\n  2780\t            with connection.schema_editor() as editor:\n  2781\t                operation.database_backwards(\n  2782\t                    \"test_alunto\", editor, new_state, project_state\n  2783\t                )\n  2784\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2785\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2786\t            cursor.execute(\"DELETE FROM test_alunto_pony\")\n  2787\t        # Test flat unique_together\n  2788\t        operation = migrations.AlterUniqueTogether(\"Pony\", (\"pink\", \"weight\"))\n  2789\t        operation.state_forwards(\"test_alunto\", new_state)\n  2790\t        self.assertEqual(\n  2791\t            len(\n  2792\t                new_state.models[\"test_alunto\", \"pony\"].options.get(\n  2793\t                    \"unique_together\", set()\n  2794\t                )\n  2795\t            ),\n  2796\t            1,\n  2797\t        )\n  2798\t        # And deconstruction\n  2799\t        definition = operation.deconstruct()\n  2800\t        self.assertEqual(definition[0], \"AlterUniqueTogether\")\n  2801\t        self.assertEqual(definition[1], [])\n  2802\t        self.assertEqual(\n  2803\t            definition[2], {\"name\": \"Pony\", \"unique_together\": {(\"pink\", \"weight\")}}\n  2804\t        )\n  2805\t\n  2806\t    def test_alter_unique_together_remove(self):\n  2807\t        operation = migrations.AlterUniqueTogether(\"Pony\", None)\n  2808\t        self.assertEqual(\n  2809\t            operation.describe(), \"Alter unique_together for Pony (0 constraint(s))\"\n  2810\t        )\n  2811\t\n  2812\t    def test_add_index(self):\n  2813\t        \"\"\"\n  2814\t        Test the AddIndex operation.\n  2815\t        \"\"\"\n  2816\t        project_state = self.set_up_test_model(\"test_adin\")\n  2817\t        msg = (\n  2818\t            \"Indexes passed to AddIndex operations require a name argument. \"\n  2819\t            \"<Index: fields=['pink']> doesn't have one.\"\n  2820\t        )\n  2821\t        with self.assertRaisesMessage(ValueError, msg):\n  2822\t            migrations.AddIndex(\"Pony\", models.Index(fields=[\"pink\"]))\n  2823\t        index = models.Index(fields=[\"pink\"], name=\"test_adin_pony_pink_idx\")\n  2824\t        operation = migrations.AddIndex(\"Pony\", index)\n  2825\t        self.assertEqual(\n  2826\t            operation.describe(),\n  2827\t            \"Create index test_adin_pony_pink_idx on field(s) pink of model Pony\",\n  2828\t        )\n  2829\t        self.assertEqual(\n  2830\t            operation.migration_name_fragment,\n  2831\t            \"pony_test_adin_pony_pink_idx\",\n  2832\t        )\n  2833\t        new_state = project_state.clone()\n  2834\t        operation.state_forwards(\"test_adin\", new_state)\n  2835\t        # Test the database alteration\n  2836\t        self.assertEqual(\n  2837\t            len(new_state.models[\"test_adin\", \"pony\"].options[\"indexes\"]), 1\n  2838\t        )\n  2839\t        self.assertIndexNotExists(\"test_adin_pony\", [\"pink\"])\n  2840\t        with connection.schema_editor() as editor:\n  2841\t            operation.database_forwards(\"test_adin\", editor, project_state, new_state)\n  2842\t        self.assertIndexExists(\"test_adin_pony\", [\"pink\"])\n  2843\t        # And test reversal\n  2844\t        with connection.schema_editor() as editor:\n  2845\t            operation.database_backwards(\"test_adin\", editor, new_state, project_state)\n  2846\t        self.assertIndexNotExists(\"test_adin_pony\", [\"pink\"])\n  2847\t        # And deconstruction\n  2848\t        definition = operation.deconstruct()\n  2849\t        self.assertEqual(definition[0], \"AddIndex\")\n  2850\t        self.assertEqual(definition[1], [])\n  2851\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"index\": index})\n  2852\t\n  2853\t    def test_remove_index(self):\n  2854\t        \"\"\"\n  2855\t        Test the RemoveIndex operation.\n  2856\t        \"\"\"\n  2857\t        project_state = self.set_up_test_model(\"test_rmin\", multicol_index=True)\n  2858\t        self.assertTableExists(\"test_rmin_pony\")\n  2859\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2860\t        operation = migrations.RemoveIndex(\"Pony\", \"pony_test_idx\")\n  2861\t        self.assertEqual(operation.describe(), \"Remove index pony_test_idx from Pony\")\n  2862\t        self.assertEqual(\n  2863\t            operation.migration_name_fragment,\n  2864\t            \"remove_pony_pony_test_idx\",\n  2865\t        )\n  2866\t        new_state = project_state.clone()\n  2867\t        operation.state_forwards(\"test_rmin\", new_state)\n  2868\t        # Test the state alteration\n  2869\t        self.assertEqual(\n  2870\t            len(new_state.models[\"test_rmin\", \"pony\"].options[\"indexes\"]), 0\n  2871\t        )\n  2872\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2873\t        # Test the database alteration\n  2874\t        with connection.schema_editor() as editor:\n  2875\t            operation.database_forwards(\"test_rmin\", editor, project_state, new_state)\n  2876\t        self.assertIndexNotExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2877\t        # And test reversal\n  2878\t        with connection.schema_editor() as editor:\n  2879\t            operation.database_backwards(\"test_rmin\", editor, new_state, project_state)\n  2880\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2881\t        # And deconstruction\n  2882\t        definition = operation.deconstruct()\n  2883\t        self.assertEqual(definition[0], \"RemoveIndex\")\n  2884\t        self.assertEqual(definition[1], [])\n  2885\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"name\": \"pony_test_idx\"})\n  2886\t\n  2887\t        # Also test a field dropped with index - sqlite remake issue\n  2888\t        operations = [\n  2889\t            migrations.RemoveIndex(\"Pony\", \"pony_test_idx\"),\n  2890\t            migrations.RemoveField(\"Pony\", \"pink\"),\n  2891\t        ]\n  2892\t        self.assertColumnExists(\"test_rmin_pony\", \"pink\")\n  2893\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2894\t        # Test database alteration\n  2895\t        new_state = project_state.clone()\n  2896\t        self.apply_operations(\"test_rmin\", new_state, operations=operations)\n  2897\t        self.assertColumnNotExists(\"test_rmin_pony\", \"pink\")\n  2898\t        self.assertIndexNotExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2899\t        # And test reversal\n  2900\t        self.unapply_operations(\"test_rmin\", project_state, operations=operations)\n  2901\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2902\t\n  2903\t    def test_rename_index(self):\n  2904\t        app_label = \"test_rnin\"\n  2905\t        project_state = self.set_up_test_model(app_label, index=True)\n  2906\t        table_name = app_label + \"_pony\"\n  2907\t        self.assertIndexNameExists(table_name, \"pony_pink_idx\")\n  2908\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2909\t        operation = migrations.RenameIndex(\n  2910\t            \"Pony\", new_name=\"new_pony_test_idx\", old_name=\"pony_pink_idx\"\n  2911\t        )\n  2912\t        self.assertEqual(\n  2913\t            operation.describe(),\n  2914\t            \"Rename index pony_pink_idx on Pony to new_pony_test_idx\",\n  2915\t        )\n  2916\t        self.assertEqual(\n  2917\t            operation.migration_name_fragment,\n  2918\t            \"rename_pony_pink_idx_new_pony_test_idx\",\n  2919\t        )\n  2920\t\n  2921\t        new_state = project_state.clone()\n  2922\t        operation.state_forwards(app_label, new_state)\n  2923\t        # Rename index.\n  2924\t        expected_queries = 1 if connection.features.can_rename_index else 2\n  2925\t        with connection.schema_editor() as editor, self.assertNumQueries(\n  2926\t            expected_queries\n  2927\t        ):\n  2928\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2929\t        self.assertIndexNameNotExists(table_name, \"pony_pink_idx\")\n  2930\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2931\t        # Reversal.\n  2932\t        with connection.schema_editor() as editor, self.assertNumQueries(\n  2933\t            expected_queries\n  2934\t        ):\n  2935\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2936\t        self.assertIndexNameExists(table_name, \"pony_pink_idx\")\n  2937\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2938\t        # Deconstruction.\n  2939\t        definition = operation.deconstruct()\n  2940\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2941\t        self.assertEqual(definition[1], [])\n  2942\t        self.assertEqual(\n  2943\t            definition[2],\n  2944\t            {\n  2945\t                \"model_name\": \"Pony\",\n  2946\t                \"old_name\": \"pony_pink_idx\",\n  2947\t                \"new_name\": \"new_pony_test_idx\",\n  2948\t            },\n  2949\t        )\n  2950\t\n  2951\t    def test_rename_index_arguments(self):\n  2952\t        msg = \"RenameIndex.old_name and old_fields are mutually exclusive.\"\n  2953\t        with self.assertRaisesMessage(ValueError, msg):\n  2954\t            migrations.RenameIndex(\n  2955\t                \"Pony\",\n  2956\t                new_name=\"new_idx_name\",\n  2957\t                old_name=\"old_idx_name\",\n  2958\t                old_fields=(\"weight\", \"pink\"),\n  2959\t            )\n  2960\t        msg = \"RenameIndex requires one of old_name and old_fields arguments to be set.\"\n  2961\t        with self.assertRaisesMessage(ValueError, msg):\n  2962\t            migrations.RenameIndex(\"Pony\", new_name=\"new_idx_name\")\n  2963\t\n  2964\t    def test_rename_index_unnamed_index(self):\n  2965\t        app_label = \"test_rninui\"\n  2966\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  2967\t        table_name = app_label + \"_pony\"\n  2968\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2969\t        operation = migrations.RenameIndex(\n  2970\t            \"Pony\", new_name=\"new_pony_test_idx\", old_fields=(\"weight\", \"pink\")\n  2971\t        )\n  2972\t        self.assertEqual(\n  2973\t            operation.describe(),\n  2974\t            \"Rename unnamed index for ('weight', 'pink') on Pony to new_pony_test_idx\",\n  2975\t        )\n  2976\t        self.assertEqual(\n  2977\t            operation.migration_name_fragment,\n  2978\t            \"rename_pony_weight_pink_new_pony_test_idx\",\n  2979\t        )\n  2980\t\n  2981\t        new_state = project_state.clone()\n  2982\t        operation.state_forwards(app_label, new_state)\n  2983\t        # Rename index.\n  2984\t        with connection.schema_editor() as editor:\n  2985\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2986\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2987\t        # Reverse is a no-op.\n  2988\t        with connection.schema_editor() as editor, self.assertNumQueries(0):\n  2989\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2990\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2991\t        # Deconstruction.\n  2992\t        definition = operation.deconstruct()\n  2993\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2994\t        self.assertEqual(definition[1], [])\n  2995\t        self.assertEqual(\n  2996\t            definition[2],\n  2997\t            {\n  2998\t                \"model_name\": \"Pony\",\n  2999\t                \"new_name\": \"new_pony_test_idx\",\n  3000\t                \"old_fields\": (\"weight\", \"pink\"),\n  3001\t            },\n  3002\t        )\n  3003\t\n  3004\t    def test_rename_index_unknown_unnamed_index(self):\n  3005\t        app_label = \"test_rninuui\"\n  3006\t        project_state = self.set_up_test_model(app_label)\n  3007\t        operation = migrations.RenameIndex(\n  3008\t            \"Pony\", new_name=\"new_pony_test_idx\", old_fields=(\"weight\", \"pink\")\n  3009\t        )\n  3010\t        new_state = project_state.clone()\n  3011\t        operation.state_forwards(app_label, new_state)\n  3012\t        msg = \"Found wrong number (0) of indexes for test_rninuui_pony(weight, pink).\"\n  3013\t        with connection.schema_editor() as editor:\n  3014\t            with self.assertRaisesMessage(ValueError, msg):\n  3015\t                operation.database_forwards(app_label, editor, project_state, new_state)\n  3016\t\n  3017\t    def test_add_index_state_forwards(self):\n  3018\t        project_state = self.set_up_test_model(\"test_adinsf\")\n  3019\t        index = models.Index(fields=[\"pink\"], name=\"test_adinsf_pony_pink_idx\")\n  3020\t        old_model = project_state.apps.get_model(\"test_adinsf\", \"Pony\")\n  3021\t        new_state = project_state.clone()\n  3022\t\n  3023\t        operation = migrations.AddIndex(\"Pony\", index)\n  3024\t        operation.state_forwards(\"test_adinsf\", new_state)\n  3025\t        new_model = new_state.apps.get_model(\"test_adinsf\", \"Pony\")\n  3026\t        self.assertIsNot(old_model, new_model)\n  3027\t\n  3028\t    def test_remove_index_state_forwards(self):\n  3029\t        project_state = self.set_up_test_model(\"test_rminsf\")\n  3030\t        index = models.Index(fields=[\"pink\"], name=\"test_rminsf_pony_pink_idx\")\n  3031\t        migrations.AddIndex(\"Pony\", index).state_forwards(\"test_rminsf\", project_state)\n  3032\t        old_model = project_state.apps.get_model(\"test_rminsf\", \"Pony\")\n  3033\t        new_state = project_state.clone()\n  3034\t\n  3035\t        operation = migrations.RemoveIndex(\"Pony\", \"test_rminsf_pony_pink_idx\")\n  3036\t        operation.state_forwards(\"test_rminsf\", new_state)\n  3037\t        new_model = new_state.apps.get_model(\"test_rminsf\", \"Pony\")\n  3038\t        self.assertIsNot(old_model, new_model)\n  3039\t\n  3040\t    def test_rename_index_state_forwards(self):\n  3041\t        app_label = \"test_rnidsf\"\n  3042\t        project_state = self.set_up_test_model(app_label, index=True)\n  3043\t        old_model = project_state.apps.get_model(app_label, \"Pony\")\n  3044\t        new_state = project_state.clone()\n  3045\t\n  3046\t        operation = migrations.RenameIndex(\n  3047\t            \"Pony\", new_name=\"new_pony_pink_idx\", old_name=\"pony_pink_idx\"\n  3048\t        )\n  3049\t        operation.state_forwards(app_label, new_state)\n  3050\t        new_model = new_state.apps.get_model(app_label, \"Pony\")\n  3051\t        self.assertIsNot(old_model, new_model)\n  3052\t        self.assertEqual(new_model._meta.indexes[0].name, \"new_pony_pink_idx\")\n  3053\t\n  3054\t    def test_rename_index_state_forwards_unnamed_index(self):\n  3055\t        app_label = \"test_rnidsfui\"\n  3056\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  3057\t        old_model = project_state.apps.get_model(app_label, \"Pony\")\n  3058\t        new_state = project_state.clone()\n  3059\t\n  3060\t        operation = migrations.RenameIndex(\n  3061\t            \"Pony\", new_name=\"new_pony_pink_idx\", old_fields=(\"weight\", \"pink\")\n  3062\t        )\n  3063\t        operation.state_forwards(app_label, new_state)\n  3064\t        new_model = new_state.apps.get_model(app_label, \"Pony\")\n  3065\t        self.assertIsNot(old_model, new_model)\n  3066\t        self.assertEqual(new_model._meta.index_together, tuple())\n  3067\t        self.assertEqual(new_model._meta.indexes[0].name, \"new_pony_pink_idx\")\n  3068\t\n  3069\t    @skipUnlessDBFeature(\"supports_expression_indexes\")\n  3070\t    def test_add_func_index(self):\n  3071\t        app_label = \"test_addfuncin\"\n  3072\t        index_name = f\"{app_label}_pony_abs_idx\"\n  3073\t        table_name = f\"{app_label}_pony\"\n  3074\t        project_state = self.set_up_test_model(app_label)\n  3075\t        index = models.Index(Abs(\"weight\"), name=index_name)\n  3076\t        operation = migrations.AddIndex(\"Pony\", index)\n  3077\t        self.assertEqual(\n  3078\t            operation.describe(),\n  3079\t            \"Create index test_addfuncin_pony_abs_idx on Abs(F(weight)) on model Pony\",\n  3080\t        )\n  3081\t        self.assertEqual(\n  3082\t            operation.migration_name_fragment,\n  3083\t            \"pony_test_addfuncin_pony_abs_idx\",\n  3084\t        )\n  3085\t        new_state = project_state.clone()\n  3086\t        operation.state_forwards(app_label, new_state)\n  3087\t        self.assertEqual(len(new_state.models[app_label, \"pony\"].options[\"indexes\"]), 1)\n  3088\t        self.assertIndexNameNotExists(table_name, index_name)\n  3089\t        # Add index.\n  3090\t        with connection.schema_editor() as editor:\n  3091\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3092\t        self.assertIndexNameExists(table_name, index_name)\n  3093\t        # Reversal.\n  3094\t        with connection.schema_editor() as editor:\n  3095\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3096\t        self.assertIndexNameNotExists(table_name, index_name)\n  3097\t        # Deconstruction.\n  3098\t        definition = operation.deconstruct()\n  3099\t        self.assertEqual(definition[0], \"AddIndex\")\n  3100\t        self.assertEqual(definition[1], [])\n  3101\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"index\": index})\n  3102\t\n  3103\t    @skipUnlessDBFeature(\"supports_expression_indexes\")\n  3104\t    def test_remove_func_index(self):\n  3105\t        app_label = \"test_rmfuncin\"\n  3106\t        index_name = f\"{app_label}_pony_abs_idx\"\n  3107\t        table_name = f\"{app_label}_pony\"\n  3108\t        project_state = self.set_up_test_model(\n  3109\t            app_label,\n  3110\t            indexes=[\n  3111\t                models.Index(Abs(\"weight\"), name=index_name),\n  3112\t            ],\n  3113\t        )\n  3114\t        self.assertTableExists(table_name)\n  3115\t        self.assertIndexNameExists(table_name, index_name)\n  3116\t        operation = migrations.RemoveIndex(\"Pony\", index_name)\n  3117\t        self.assertEqual(\n  3118\t            operation.describe(),\n  3119\t            \"Remove index test_rmfuncin_pony_abs_idx from Pony\",\n  3120\t        )\n  3121\t        self.assertEqual(\n  3122\t            operation.migration_name_fragment,\n  3123\t            \"remove_pony_test_rmfuncin_pony_abs_idx\",\n  3124\t        )\n  3125\t        new_state = project_state.clone()\n  3126\t        operation.state_forwards(app_label, new_state)\n  3127\t        self.assertEqual(len(new_state.models[app_label, \"pony\"].options[\"indexes\"]), 0)\n  3128\t        # Remove index.\n  3129\t        with connection.schema_editor() as editor:\n  3130\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3131\t        self.assertIndexNameNotExists(table_name, index_name)\n  3132\t        # Reversal.\n  3133\t        with connection.schema_editor() as editor:\n  3134\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3135\t        self.assertIndexNameExists(table_name, index_name)\n  3136\t        # Deconstruction.\n  3137\t        definition = operation.deconstruct()\n  3138\t        self.assertEqual(definition[0], \"RemoveIndex\")\n  3139\t        self.assertEqual(definition[1], [])\n  3140\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"name\": index_name})\n  3141\t\n  3142\t    @skipUnlessDBFeature(\"supports_expression_indexes\")\n  3143\t    def test_alter_field_with_func_index(self):\n  3144\t        app_label = \"test_alfuncin\"\n  3145\t        index_name = f\"{app_label}_pony_idx\"\n  3146\t        table_name = f\"{app_label}_pony\"\n  3147\t        project_state = self.set_up_test_model(\n  3148\t            app_label,\n  3149\t            indexes=[models.Index(Abs(\"pink\"), name=index_name)],\n  3150\t        )\n  3151\t        operation = migrations.AlterField(\n  3152\t            \"Pony\", \"pink\", models.IntegerField(null=True)\n  3153\t        )\n  3154\t        new_state = project_state.clone()\n  3155\t        operation.state_forwards(app_label, new_state)\n  3156\t        with connection.schema_editor() as editor:\n  3157\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3158\t        self.assertIndexNameExists(table_name, index_name)\n  3159\t        with connection.schema_editor() as editor:\n  3160\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3161\t        self.assertIndexNameExists(table_name, index_name)\n  3162\t\n  3163\t    def test_alter_field_with_index(self):\n  3164\t        \"\"\"\n  3165\t        Test AlterField operation with an index to ensure indexes created via\n  3166\t        Meta.indexes don't get dropped with sqlite3 remake.\n  3167\t        \"\"\"\n  3168\t        project_state = self.set_up_test_model(\"test_alflin\", index=True)\n  3169\t        operation = migrations.AlterField(\n  3170\t            \"Pony\", \"pink\", models.IntegerField(null=True)\n  3171\t        )\n  3172\t        new_state = project_state.clone()\n  3173\t        operation.state_forwards(\"test_alflin\", new_state)\n  3174\t        # Test the database alteration\n  3175\t        self.assertColumnNotNull(\"test_alflin_pony\", \"pink\")\n  3176\t        with connection.schema_editor() as editor:\n  3177\t            operation.database_forwards(\"test_alflin\", editor, project_state, new_state)\n  3178\t        # Index hasn't been dropped\n  3179\t        self.assertIndexExists(\"test_alflin_pony\", [\"pink\"])\n  3180\t        # And test reversal\n  3181\t        with connection.schema_editor() as editor:\n  3182\t            operation.database_backwards(\n  3183\t                \"test_alflin\", editor, new_state, project_state\n  3184\t            )\n  3185\t        # Ensure the index is still there\n  3186\t        self.assertIndexExists(\"test_alflin_pony\", [\"pink\"])\n  3187\t\n  3188\t    def test_alter_index_together(self):\n  3189\t        \"\"\"\n  3190\t        Tests the AlterIndexTogether operation.\n  3191\t        \"\"\"\n  3192\t        project_state = self.set_up_test_model(\"test_alinto\")\n  3193\t        # Test the state alteration\n  3194\t        operation = migrations.AlterIndexTogether(\"Pony\", [(\"pink\", \"weight\")])\n  3195\t        self.assertEqual(\n  3196\t            operation.describe(), \"Alter index_together for Pony (1 constraint(s))\"\n  3197\t        )\n  3198\t        self.assertEqual(\n  3199\t            operation.migration_name_fragment,\n  3200\t            \"alter_pony_index_together\",\n  3201\t        )\n  3202\t        new_state = project_state.clone()\n  3203\t        operation.state_forwards(\"test_alinto\", new_state)\n  3204\t        self.assertEqual(\n  3205\t            len(\n  3206\t                project_state.models[\"test_alinto\", \"pony\"].options.get(\n  3207\t                    \"index_together\", set()\n  3208\t                )\n  3209\t            ),\n  3210\t            0,\n  3211\t        )\n  3212\t        self.assertEqual(\n  3213\t            len(\n  3214\t                new_state.models[\"test_alinto\", \"pony\"].options.get(\n  3215\t                    \"index_together\", set()\n  3216\t                )\n  3217\t            ),\n  3218\t            1,\n  3219\t        )\n  3220\t        # Make sure there's no matching index\n  3221\t        self.assertIndexNotExists(\"test_alinto_pony\", [\"pink\", \"weight\"])\n  3222\t        # Test the database alteration\n  3223\t        with connection.schema_editor() as editor:\n  3224\t            operation.database_forwards(\"test_alinto\", editor, project_state, new_state)\n  3225\t        self.assertIndexExists(\"test_alinto_pony\", [\"pink\", \"weight\"])\n  3226\t        # And test reversal\n  3227\t        with connection.schema_editor() as editor:\n  3228\t            operation.database_backwards(\n  3229\t                \"test_alinto\", editor, new_state, project_state\n  3230\t            )\n  3231\t        self.assertIndexNotExists(\"test_alinto_pony\", [\"pink\", \"weight\"])\n  3232\t        # And deconstruction\n  3233\t        definition = operation.deconstruct()\n  3234\t        self.assertEqual(definition[0], \"AlterIndexTogether\")\n  3235\t        self.assertEqual(definition[1], [])\n  3236\t        self.assertEqual(\n  3237\t            definition[2], {\"name\": \"Pony\", \"index_together\": {(\"pink\", \"weight\")}}\n  3238\t        )\n  3239\t\n  3240\t    def test_alter_index_together_remove(self):\n  3241\t        operation = migrations.AlterIndexTogether(\"Pony\", None)\n  3242\t        self.assertEqual(\n  3243\t            operation.describe(), \"Alter index_together for Pony (0 constraint(s))\"\n  3244\t        )\n  3245\t\n  3246\t    @skipUnlessDBFeature(\"allows_multiple_constraints_on_same_fields\")\n  3247\t    def test_alter_index_together_remove_with_unique_together(self):\n  3248\t        app_label = \"test_alintoremove_wunto\"\n  3249\t        table_name = \"%s_pony\" % app_label\n  3250\t        project_state = self.set_up_test_model(app_label, unique_together=True)\n  3251\t        self.assertUniqueConstraintExists(table_name, [\"pink\", \"weight\"])\n  3252\t        # Add index together.\n  3253\t        new_state = project_state.clone()\n  3254\t        operation = migrations.AlterIndexTogether(\"Pony\", [(\"pink\", \"weight\")])\n  3255\t        operation.state_forwards(app_label, new_state)\n  3256\t        with connection.schema_editor() as editor:\n  3257\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3258\t        self.assertIndexExists(table_name, [\"pink\", \"weight\"])\n  3259\t        # Remove index together.\n  3260\t        project_state = new_state\n  3261\t        new_state = project_state.clone()\n  3262\t        operation = migrations.AlterIndexTogether(\"Pony\", set())\n  3263\t        operation.state_forwards(app_label, new_state)\n  3264\t        with connection.schema_editor() as editor:\n  3265\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3266\t        self.assertIndexNotExists(table_name, [\"pink\", \"weight\"])\n  3267\t        self.assertUniqueConstraintExists(table_name, [\"pink\", \"weight\"])\n  3268\t\n  3269\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3270\t    def test_add_constraint(self):\n  3271\t        project_state = self.set_up_test_model(\"test_addconstraint\")\n  3272\t        gt_check = models.Q(pink__gt=2)\n  3273\t        gt_constraint = models.CheckConstraint(\n  3274\t            check=gt_check, name=\"test_add_constraint_pony_pink_gt_2\"\n  3275\t        )\n  3276\t        gt_operation = migrations.AddConstraint(\"Pony\", gt_constraint)\n  3277\t        self.assertEqual(\n  3278\t            gt_operation.describe(),\n  3279\t            \"Create constraint test_add_constraint_pony_pink_gt_2 on model Pony\",\n  3280\t        )\n  3281\t        self.assertEqual(\n  3282\t            gt_operation.migration_name_fragment,\n  3283\t            \"pony_test_add_constraint_pony_pink_gt_2\",\n  3284\t        )\n  3285\t        # Test the state alteration\n  3286\t        new_state = project_state.clone()\n  3287\t        gt_operation.state_forwards(\"test_addconstraint\", new_state)\n  3288\t        self.assertEqual(\n  3289\t            len(new_state.models[\"test_addconstraint\", \"pony\"].options[\"constraints\"]),\n  3290\t            1,\n  3291\t        )\n  3292\t        Pony = new_state.apps.get_model(\"test_addconstraint\", \"Pony\")\n  3293\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3294\t        # Test the database alteration\n  3295\t        with connection.schema_editor() as editor:\n  3296\t            gt_operation.database_forwards(\n  3297\t                \"test_addconstraint\", editor, project_state, new_state\n  3298\t            )\n  3299\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3300\t            Pony.objects.create(pink=1, weight=1.0)\n  3301\t        # Add another one.\n  3302\t        lt_check = models.Q(pink__lt=100)\n  3303\t        lt_constraint = models.CheckConstraint(\n  3304\t            check=lt_check, name=\"test_add_constraint_pony_pink_lt_100\"\n  3305\t        )\n  3306\t        lt_operation = migrations.AddConstraint(\"Pony\", lt_constraint)\n  3307\t        lt_operation.state_forwards(\"test_addconstraint\", new_state)\n  3308\t        self.assertEqual(\n  3309\t            len(new_state.models[\"test_addconstraint\", \"pony\"].options[\"constraints\"]),\n  3310\t            2,\n  3311\t        )\n  3312\t        Pony = new_state.apps.get_model(\"test_addconstraint\", \"Pony\")\n  3313\t        self.assertEqual(len(Pony._meta.constraints), 2)\n  3314\t        with connection.schema_editor() as editor:\n  3315\t            lt_operation.database_forwards(\n  3316\t                \"test_addconstraint\", editor, project_state, new_state\n  3317\t            )\n  3318\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3319\t            Pony.objects.create(pink=100, weight=1.0)\n  3320\t        # Test reversal\n  3321\t        with connection.schema_editor() as editor:\n  3322\t            gt_operation.database_backwards(\n  3323\t                \"test_addconstraint\", editor, new_state, project_state\n  3324\t            )\n  3325\t        Pony.objects.create(pink=1, weight=1.0)\n  3326\t        # Test deconstruction\n  3327\t        definition = gt_operation.deconstruct()\n  3328\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3329\t        self.assertEqual(definition[1], [])\n  3330\t        self.assertEqual(\n  3331\t            definition[2], {\"model_name\": \"Pony\", \"constraint\": gt_constraint}\n  3332\t        )\n  3333\t\n  3334\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3335\t    def test_add_constraint_percent_escaping(self):\n  3336\t        app_label = \"add_constraint_string_quoting\"\n  3337\t        operations = [\n  3338\t            migrations.CreateModel(\n  3339\t                \"Author\",\n  3340\t                fields=[\n  3341\t                    (\"id\", models.AutoField(primary_key=True)),\n  3342\t                    (\"name\", models.CharField(max_length=100)),\n  3343\t                    (\"surname\", models.CharField(max_length=100, default=\"\")),\n  3344\t                    (\"rebate\", models.CharField(max_length=100)),\n  3345\t                ],\n  3346\t            ),\n  3347\t        ]\n  3348\t        from_state = self.apply_operations(app_label, ProjectState(), operations)\n  3349\t        # \"%\" generated in startswith lookup should be escaped in a way that is\n  3350\t        # considered a leading wildcard.\n  3351\t        check = models.Q(name__startswith=\"Albert\")\n  3352\t        constraint = models.CheckConstraint(check=check, name=\"name_constraint\")\n  3353\t        operation = migrations.AddConstraint(\"Author\", constraint)\n  3354\t        to_state = from_state.clone()\n  3355\t        operation.state_forwards(app_label, to_state)\n  3356\t        with connection.schema_editor() as editor:\n  3357\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3358\t        Author = to_state.apps.get_model(app_label, \"Author\")\n  3359\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3360\t            Author.objects.create(name=\"Artur\")\n  3361\t        # Literal \"%\" should be escaped in a way that is not a considered a\n  3362\t        # wildcard.\n  3363\t        check = models.Q(rebate__endswith=\"%\")\n  3364\t        constraint = models.CheckConstraint(check=check, name=\"rebate_constraint\")\n  3365\t        operation = migrations.AddConstraint(\"Author\", constraint)\n  3366\t        from_state = to_state\n  3367\t        to_state = from_state.clone()\n  3368\t        operation.state_forwards(app_label, to_state)\n  3369\t        Author = to_state.apps.get_model(app_label, \"Author\")\n  3370\t        with connection.schema_editor() as editor:\n  3371\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3372\t        Author = to_state.apps.get_model(app_label, \"Author\")\n  3373\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3374\t            Author.objects.create(name=\"Albert\", rebate=\"10$\")\n  3375\t        author = Author.objects.create(name=\"Albert\", rebate=\"10%\")\n  3376\t        self.assertEqual(Author.objects.get(), author)\n  3377\t        # Right-hand-side baked \"%\" literals should not be used for parameters\n  3378\t        # interpolation.\n  3379\t        check = ~models.Q(surname__startswith=models.F(\"name\"))\n  3380\t        constraint = models.CheckConstraint(check=check, name=\"name_constraint_rhs\")\n  3381\t        operation = migrations.AddConstraint(\"Author\", constraint)\n  3382\t        from_state = to_state\n  3383\t        to_state = from_state.clone()\n  3384\t        operation.state_forwards(app_label, to_state)\n  3385\t        with connection.schema_editor() as editor:\n  3386\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3387\t        Author = to_state.apps.get_model(app_label, \"Author\")\n  3388\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3389\t            Author.objects.create(name=\"Albert\", surname=\"Alberto\")\n  3390\t\n  3391\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3392\t    def test_add_or_constraint(self):\n  3393\t        app_label = \"test_addorconstraint\"\n  3394\t        constraint_name = \"add_constraint_or\"\n  3395\t        from_state = self.set_up_test_model(app_label)\n  3396\t        check = models.Q(pink__gt=2, weight__gt=2) | models.Q(weight__lt=0)\n  3397\t        constraint = models.CheckConstraint(check=check, name=constraint_name)\n  3398\t        operation = migrations.AddConstraint(\"Pony\", constraint)\n  3399\t        to_state = from_state.clone()\n  3400\t        operation.state_forwards(app_label, to_state)\n  3401\t        with connection.schema_editor() as editor:\n  3402\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3403\t        Pony = to_state.apps.get_model(app_label, \"Pony\")\n  3404\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3405\t            Pony.objects.create(pink=2, weight=3.0)\n  3406\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3407\t            Pony.objects.create(pink=3, weight=1.0)\n  3408\t        Pony.objects.bulk_create(\n  3409\t            [\n  3410\t                Pony(pink=3, weight=-1.0),\n  3411\t                Pony(pink=1, weight=-1.0),\n  3412\t                Pony(pink=3, weight=3.0),\n  3413\t            ]\n  3414\t        )\n  3415\t\n  3416\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3417\t    def test_add_constraint_combinable(self):\n  3418\t        app_label = \"test_addconstraint_combinable\"\n  3419\t        operations = [\n  3420\t            migrations.CreateModel(\n  3421\t                \"Book\",\n  3422\t                fields=[\n  3423\t                    (\"id\", models.AutoField(primary_key=True)),\n  3424\t                    (\"read\", models.PositiveIntegerField()),\n  3425\t                    (\"unread\", models.PositiveIntegerField()),\n  3426\t                ],\n  3427\t            ),\n  3428\t        ]\n  3429\t        from_state = self.apply_operations(app_label, ProjectState(), operations)\n  3430\t        constraint = models.CheckConstraint(\n  3431\t            check=models.Q(read=(100 - models.F(\"unread\"))),\n  3432\t            name=\"test_addconstraint_combinable_sum_100\",\n  3433\t        )\n  3434\t        operation = migrations.AddConstraint(\"Book\", constraint)\n  3435\t        to_state = from_state.clone()\n  3436\t        operation.state_forwards(app_label, to_state)\n  3437\t        with connection.schema_editor() as editor:\n  3438\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3439\t        Book = to_state.apps.get_model(app_label, \"Book\")\n  3440\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3441\t            Book.objects.create(read=70, unread=10)\n  3442\t        Book.objects.create(read=70, unread=30)\n  3443\t\n  3444\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3445\t    def test_remove_constraint(self):\n  3446\t        project_state = self.set_up_test_model(\n  3447\t            \"test_removeconstraint\",\n  3448\t            constraints=[\n  3449\t                models.CheckConstraint(\n  3450\t                    check=models.Q(pink__gt=2),\n  3451\t                    name=\"test_remove_constraint_pony_pink_gt_2\",\n  3452\t                ),\n  3453\t                models.CheckConstraint(\n  3454\t                    check=models.Q(pink__lt=100),\n  3455\t                    name=\"test_remove_constraint_pony_pink_lt_100\",\n  3456\t                ),\n  3457\t            ],\n  3458\t        )\n  3459\t        gt_operation = migrations.RemoveConstraint(\n  3460\t            \"Pony\", \"test_remove_constraint_pony_pink_gt_2\"\n  3461\t        )\n  3462\t        self.assertEqual(\n  3463\t            gt_operation.describe(),\n  3464\t            \"Remove constraint test_remove_constraint_pony_pink_gt_2 from model Pony\",\n  3465\t        )\n  3466\t        self.assertEqual(\n  3467\t            gt_operation.migration_name_fragment,\n  3468\t            \"remove_pony_test_remove_constraint_pony_pink_gt_2\",\n  3469\t        )\n  3470\t        # Test state alteration\n  3471\t        new_state = project_state.clone()\n  3472\t        gt_operation.state_forwards(\"test_removeconstraint\", new_state)\n  3473\t        self.assertEqual(\n  3474\t            len(\n  3475\t                new_state.models[\"test_removeconstraint\", \"pony\"].options[\"constraints\"]\n  3476\t            ),\n  3477\t            1,\n  3478\t        )\n  3479\t        Pony = new_state.apps.get_model(\"test_removeconstraint\", \"Pony\")\n  3480\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3481\t        # Test database alteration\n  3482\t        with connection.schema_editor() as editor:\n  3483\t            gt_operation.database_forwards(\n  3484\t                \"test_removeconstraint\", editor, project_state, new_state\n  3485\t            )\n  3486\t        Pony.objects.create(pink=1, weight=1.0).delete()\n  3487\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3488\t            Pony.objects.create(pink=100, weight=1.0)\n  3489\t        # Remove the other one.\n  3490\t        lt_operation = migrations.RemoveConstraint(\n  3491\t            \"Pony\", \"test_remove_constraint_pony_pink_lt_100\"\n  3492\t        )\n  3493\t        lt_operation.state_forwards(\"test_removeconstraint\", new_state)\n  3494\t        self.assertEqual(\n  3495\t            len(\n  3496\t                new_state.models[\"test_removeconstraint\", \"pony\"].options[\"constraints\"]\n  3497\t            ),\n  3498\t            0,\n  3499\t        )\n  3500\t        Pony = new_state.apps.get_model(\"test_removeconstraint\", \"Pony\")\n  3501\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3502\t        with connection.schema_editor() as editor:\n  3503\t            lt_operation.database_forwards(\n  3504\t                \"test_removeconstraint\", editor, project_state, new_state\n  3505\t            )\n  3506\t        Pony.objects.create(pink=100, weight=1.0).delete()\n  3507\t        # Test reversal\n  3508\t        with connection.schema_editor() as editor:\n  3509\t            gt_operation.database_backwards(\n  3510\t                \"test_removeconstraint\", editor, new_state, project_state\n  3511\t            )\n  3512\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3513\t            Pony.objects.create(pink=1, weight=1.0)\n  3514\t        # Test deconstruction\n  3515\t        definition = gt_operation.deconstruct()\n  3516\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3517\t        self.assertEqual(definition[1], [])\n  3518\t        self.assertEqual(\n  3519\t            definition[2],\n  3520\t            {\"model_name\": \"Pony\", \"name\": \"test_remove_constraint_pony_pink_gt_2\"},\n  3521\t        )\n  3522\t\n  3523\t    def test_add_partial_unique_constraint(self):\n  3524\t        project_state = self.set_up_test_model(\"test_addpartialuniqueconstraint\")\n  3525\t        partial_unique_constraint = models.UniqueConstraint(\n  3526\t            fields=[\"pink\"],\n  3527\t            condition=models.Q(weight__gt=5),\n  3528\t            name=\"test_constraint_pony_pink_for_weight_gt_5_uniq\",\n  3529\t        )\n  3530\t        operation = migrations.AddConstraint(\"Pony\", partial_unique_constraint)\n  3531\t        self.assertEqual(\n  3532\t            operation.describe(),\n  3533\t            \"Create constraint test_constraint_pony_pink_for_weight_gt_5_uniq \"\n  3534\t            \"on model Pony\",\n  3535\t        )\n  3536\t        # Test the state alteration\n  3537\t        new_state = project_state.clone()\n  3538\t        operation.state_forwards(\"test_addpartialuniqueconstraint\", new_state)\n  3539\t        self.assertEqual(\n  3540\t            len(\n  3541\t                new_state.models[\"test_addpartialuniqueconstraint\", \"pony\"].options[\n  3542\t                    \"constraints\"\n  3543\t                ]\n  3544\t            ),\n  3545\t            1,\n  3546\t        )\n  3547\t        Pony = new_state.apps.get_model(\"test_addpartialuniqueconstraint\", \"Pony\")\n  3548\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3549\t        # Test the database alteration\n  3550\t        with connection.schema_editor() as editor:\n  3551\t            operation.database_forwards(\n  3552\t                \"test_addpartialuniqueconstraint\", editor, project_state, new_state\n  3553\t            )\n  3554\t        # Test constraint works\n  3555\t        Pony.objects.create(pink=1, weight=4.0)\n  3556\t        Pony.objects.create(pink=1, weight=4.0)\n  3557\t        Pony.objects.create(pink=1, weight=6.0)\n  3558\t        if connection.features.supports_partial_indexes:\n  3559\t            with self.assertRaises(IntegrityError), transaction.atomic():\n  3560\t                Pony.objects.create(pink=1, weight=7.0)\n  3561\t        else:\n  3562\t            Pony.objects.create(pink=1, weight=7.0)\n  3563\t        # Test reversal\n  3564\t        with connection.schema_editor() as editor:\n  3565\t            operation.database_backwards(\n  3566\t                \"test_addpartialuniqueconstraint\", editor, new_state, project_state\n  3567\t            )\n  3568\t        # Test constraint doesn't work\n  3569\t        Pony.objects.create(pink=1, weight=7.0)\n  3570\t        # Test deconstruction\n  3571\t        definition = operation.deconstruct()\n  3572\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3573\t        self.assertEqual(definition[1], [])\n  3574\t        self.assertEqual(\n  3575\t            definition[2],\n  3576\t            {\"model_name\": \"Pony\", \"constraint\": partial_unique_constraint},\n  3577\t        )\n  3578\t\n  3579\t    def test_remove_partial_unique_constraint(self):\n  3580\t        project_state = self.set_up_test_model(\n  3581\t            \"test_removepartialuniqueconstraint\",\n  3582\t            constraints=[\n  3583\t                models.UniqueConstraint(\n  3584\t                    fields=[\"pink\"],\n  3585\t                    condition=models.Q(weight__gt=5),\n  3586\t                    name=\"test_constraint_pony_pink_for_weight_gt_5_uniq\",\n  3587\t                ),\n  3588\t            ],\n  3589\t        )\n  3590\t        gt_operation = migrations.RemoveConstraint(\n  3591\t            \"Pony\", \"test_constraint_pony_pink_for_weight_gt_5_uniq\"\n  3592\t        )\n  3593\t        self.assertEqual(\n  3594\t            gt_operation.describe(),\n  3595\t            \"Remove constraint test_constraint_pony_pink_for_weight_gt_5_uniq from \"\n  3596\t            \"model Pony\",\n  3597\t        )\n  3598\t        # Test state alteration\n  3599\t        new_state = project_state.clone()\n  3600\t        gt_operation.state_forwards(\"test_removepartialuniqueconstraint\", new_state)\n  3601\t        self.assertEqual(\n  3602\t            len(\n  3603\t                new_state.models[\"test_removepartialuniqueconstraint\", \"pony\"].options[\n  3604\t                    \"constraints\"\n  3605\t                ]\n  3606\t            ),\n  3607\t            0,\n  3608\t        )\n  3609\t        Pony = new_state.apps.get_model(\"test_removepartialuniqueconstraint\", \"Pony\")\n  3610\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3611\t        # Test database alteration\n  3612\t        with connection.schema_editor() as editor:\n  3613\t            gt_operation.database_forwards(\n  3614\t                \"test_removepartialuniqueconstraint\", editor, project_state, new_state\n  3615\t            )\n  3616\t        # Test constraint doesn't work\n  3617\t        Pony.objects.create(pink=1, weight=4.0)\n  3618\t        Pony.objects.create(pink=1, weight=4.0)\n  3619\t        Pony.objects.create(pink=1, weight=6.0)\n  3620\t        Pony.objects.create(pink=1, weight=7.0).delete()\n  3621\t        # Test reversal\n  3622\t        with connection.schema_editor() as editor:\n  3623\t            gt_operation.database_backwards(\n  3624\t                \"test_removepartialuniqueconstraint\", editor, new_state, project_state\n  3625\t            )\n  3626\t        # Test constraint works\n  3627\t        if connection.features.supports_partial_indexes:\n  3628\t            with self.assertRaises(IntegrityError), transaction.atomic():\n  3629\t                Pony.objects.create(pink=1, weight=7.0)\n  3630\t        else:\n  3631\t            Pony.objects.create(pink=1, weight=7.0)\n  3632\t        # Test deconstruction\n  3633\t        definition = gt_operation.deconstruct()\n  3634\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3635\t        self.assertEqual(definition[1], [])\n  3636\t        self.assertEqual(\n  3637\t            definition[2],\n  3638\t            {\n  3639\t                \"model_name\": \"Pony\",\n  3640\t                \"name\": \"test_constraint_pony_pink_for_weight_gt_5_uniq\",\n  3641\t            },\n  3642\t        )\n  3643\t\n  3644\t    def test_add_deferred_unique_constraint(self):\n  3645\t        app_label = \"test_adddeferred_uc\"\n  3646\t        project_state = self.set_up_test_model(app_label)\n  3647\t        deferred_unique_constraint = models.UniqueConstraint(\n  3648\t            fields=[\"pink\"],\n  3649\t            name=\"deferred_pink_constraint_add\",\n  3650\t            deferrable=models.Deferrable.DEFERRED,\n  3651\t        )\n  3652\t        operation = migrations.AddConstraint(\"Pony\", deferred_unique_constraint)\n  3653\t        self.assertEqual(\n  3654\t            operation.describe(),\n  3655\t            \"Create constraint deferred_pink_constraint_add on model Pony\",\n  3656\t        )\n  3657\t        # Add constraint.\n  3658\t        new_state = project_state.clone()\n  3659\t        operation.state_forwards(app_label, new_state)\n  3660\t        self.assertEqual(\n  3661\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 1\n  3662\t        )\n  3663\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3664\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3665\t        with connection.schema_editor() as editor, CaptureQueriesContext(\n  3666\t            connection\n  3667\t        ) as ctx:\n  3668\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3669\t        Pony.objects.create(pink=1, weight=4.0)\n  3670\t        if connection.features.supports_deferrable_unique_constraints:\n  3671\t            # Unique constraint is deferred.\n  3672\t            with transaction.atomic():\n  3673\t                obj = Pony.objects.create(pink=1, weight=4.0)\n  3674\t                obj.pink = 2\n  3675\t                obj.save()\n  3676\t            # Constraint behavior can be changed with SET CONSTRAINTS.\n  3677\t            with self.assertRaises(IntegrityError):\n  3678\t                with transaction.atomic(), connection.cursor() as cursor:\n  3679\t                    quoted_name = connection.ops.quote_name(\n  3680\t                        deferred_unique_constraint.name\n  3681\t                    )\n  3682\t                    cursor.execute(\"SET CONSTRAINTS %s IMMEDIATE\" % quoted_name)\n  3683\t                    obj = Pony.objects.create(pink=1, weight=4.0)\n  3684\t                    obj.pink = 3\n  3685\t                    obj.save()\n  3686\t        else:\n  3687\t            self.assertEqual(len(ctx), 0)\n  3688\t            Pony.objects.create(pink=1, weight=4.0)\n  3689\t        # Reversal.\n  3690\t        with connection.schema_editor() as editor:\n  3691\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3692\t        # Constraint doesn't work.\n  3693\t        Pony.objects.create(pink=1, weight=4.0)\n  3694\t        # Deconstruction.\n  3695\t        definition = operation.deconstruct()\n  3696\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3697\t        self.assertEqual(definition[1], [])\n  3698\t        self.assertEqual(\n  3699\t            definition[2],\n  3700\t            {\"model_name\": \"Pony\", \"constraint\": deferred_unique_constraint},\n  3701\t        )\n  3702\t\n  3703\t    def test_remove_deferred_unique_constraint(self):\n  3704\t        app_label = \"test_removedeferred_uc\"\n  3705\t        deferred_unique_constraint = models.UniqueConstraint(\n  3706\t            fields=[\"pink\"],\n  3707\t            name=\"deferred_pink_constraint_rm\",\n  3708\t            deferrable=models.Deferrable.DEFERRED,\n  3709\t        )\n  3710\t        project_state = self.set_up_test_model(\n  3711\t            app_label, constraints=[deferred_unique_constraint]\n  3712\t        )\n  3713\t        operation = migrations.RemoveConstraint(\"Pony\", deferred_unique_constraint.name)\n  3714\t        self.assertEqual(\n  3715\t            operation.describe(),\n  3716\t            \"Remove constraint deferred_pink_constraint_rm from model Pony\",\n  3717\t        )\n  3718\t        # Remove constraint.\n  3719\t        new_state = project_state.clone()\n  3720\t        operation.state_forwards(app_label, new_state)\n  3721\t        self.assertEqual(\n  3722\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 0\n  3723\t        )\n  3724\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3725\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3726\t        with connection.schema_editor() as editor, CaptureQueriesContext(\n  3727\t            connection\n  3728\t        ) as ctx:\n  3729\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3730\t        # Constraint doesn't work.\n  3731\t        Pony.objects.create(pink=1, weight=4.0)\n  3732\t        Pony.objects.create(pink=1, weight=4.0).delete()\n  3733\t        if not connection.features.supports_deferrable_unique_constraints:\n  3734\t            self.assertEqual(len(ctx), 0)\n  3735\t        # Reversal.\n  3736\t        with connection.schema_editor() as editor:\n  3737\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3738\t        if connection.features.supports_deferrable_unique_constraints:\n  3739\t            # Unique constraint is deferred.\n  3740\t            with transaction.atomic():\n  3741\t                obj = Pony.objects.create(pink=1, weight=4.0)\n  3742\t                obj.pink = 2\n  3743\t                obj.save()\n  3744\t            # Constraint behavior can be changed with SET CONSTRAINTS.\n  3745\t            with self.assertRaises(IntegrityError):\n  3746\t                with transaction.atomic(), connection.cursor() as cursor:\n  3747\t                    quoted_name = connection.ops.quote_name(\n  3748\t                        deferred_unique_constraint.name\n  3749\t                    )\n  3750\t                    cursor.execute(\"SET CONSTRAINTS %s IMMEDIATE\" % quoted_name)\n  3751\t                    obj = Pony.objects.create(pink=1, weight=4.0)\n  3752\t                    obj.pink = 3\n  3753\t                    obj.save()\n  3754\t        else:\n  3755\t            Pony.objects.create(pink=1, weight=4.0)\n  3756\t        # Deconstruction.\n  3757\t        definition = operation.deconstruct()\n  3758\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3759\t        self.assertEqual(definition[1], [])\n  3760\t        self.assertEqual(\n  3761\t            definition[2],\n  3762\t            {\n  3763\t                \"model_name\": \"Pony\",\n  3764\t                \"name\": \"deferred_pink_constraint_rm\",\n  3765\t            },\n  3766\t        )\n  3767\t\n  3768\t    def test_add_covering_unique_constraint(self):\n  3769\t        app_label = \"test_addcovering_uc\"\n  3770\t        project_state = self.set_up_test_model(app_label)\n  3771\t        covering_unique_constraint = models.UniqueConstraint(\n  3772\t            fields=[\"pink\"],\n  3773\t            name=\"covering_pink_constraint_add\",\n  3774\t            include=[\"weight\"],\n  3775\t        )\n  3776\t        operation = migrations.AddConstraint(\"Pony\", covering_unique_constraint)\n  3777\t        self.assertEqual(\n  3778\t            operation.describe(),\n  3779\t            \"Create constraint covering_pink_constraint_add on model Pony\",\n  3780\t        )\n  3781\t        # Add constraint.\n  3782\t        new_state = project_state.clone()\n  3783\t        operation.state_forwards(app_label, new_state)\n  3784\t        self.assertEqual(\n  3785\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 1\n  3786\t        )\n  3787\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3788\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3789\t        with connection.schema_editor() as editor, CaptureQueriesContext(\n  3790\t            connection\n  3791\t        ) as ctx:\n  3792\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3793\t        Pony.objects.create(pink=1, weight=4.0)\n  3794\t        if connection.features.supports_covering_indexes:\n  3795\t            with self.assertRaises(IntegrityError):\n  3796\t                Pony.objects.create(pink=1, weight=4.0)\n  3797\t        else:\n  3798\t            self.assertEqual(len(ctx), 0)\n  3799\t            Pony.objects.create(pink=1, weight=4.0)\n  3800\t        # Reversal.\n  3801\t        with connection.schema_editor() as editor:\n  3802\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3803\t        # Constraint doesn't work.\n  3804\t        Pony.objects.create(pink=1, weight=4.0)\n  3805\t        # Deconstruction.\n  3806\t        definition = operation.deconstruct()\n  3807\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3808\t        self.assertEqual(definition[1], [])\n  3809\t        self.assertEqual(\n  3810\t            definition[2],\n  3811\t            {\"model_name\": \"Pony\", \"constraint\": covering_unique_constraint},\n  3812\t        )\n  3813\t\n  3814\t    def test_remove_covering_unique_constraint(self):\n  3815\t        app_label = \"test_removecovering_uc\"\n  3816\t        covering_unique_constraint = models.UniqueConstraint(\n  3817\t            fields=[\"pink\"],\n  3818\t            name=\"covering_pink_constraint_rm\",\n  3819\t            include=[\"weight\"],\n  3820\t        )\n  3821\t        project_state = self.set_up_test_model(\n  3822\t            app_label, constraints=[covering_unique_constraint]\n  3823\t        )\n  3824\t        operation = migrations.RemoveConstraint(\"Pony\", covering_unique_constraint.name)\n  3825\t        self.assertEqual(\n  3826\t            operation.describe(),\n  3827\t            \"Remove constraint covering_pink_constraint_rm from model Pony\",\n  3828\t        )\n  3829\t        # Remove constraint.\n  3830\t        new_state = project_state.clone()\n  3831\t        operation.state_forwards(app_label, new_state)\n  3832\t        self.assertEqual(\n  3833\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 0\n  3834\t        )\n  3835\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3836\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3837\t        with connection.schema_editor() as editor, CaptureQueriesContext(\n  3838\t            connection\n  3839\t        ) as ctx:\n  3840\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3841\t        # Constraint doesn't work.\n  3842\t        Pony.objects.create(pink=1, weight=4.0)\n  3843\t        Pony.objects.create(pink=1, weight=4.0).delete()\n  3844\t        if not connection.features.supports_covering_indexes:\n  3845\t            self.assertEqual(len(ctx), 0)\n  3846\t        # Reversal.\n  3847\t        with connection.schema_editor() as editor:\n  3848\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3849\t        if connection.features.supports_covering_indexes:\n  3850\t            with self.assertRaises(IntegrityError):\n  3851\t                Pony.objects.create(pink=1, weight=4.0)\n  3852\t        else:\n  3853\t            Pony.objects.create(pink=1, weight=4.0)\n  3854\t        # Deconstruction.\n  3855\t        definition = operation.deconstruct()\n  3856\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3857\t        self.assertEqual(definition[1], [])\n  3858\t        self.assertEqual(\n  3859\t            definition[2],\n  3860\t            {\n  3861\t                \"model_name\": \"Pony\",\n  3862\t                \"name\": \"covering_pink_constraint_rm\",\n  3863\t            },\n  3864\t        )\n  3865\t\n  3866\t    def test_alter_field_with_func_unique_constraint(self):\n  3867\t        app_label = \"test_alfuncuc\"\n  3868\t        constraint_name = f\"{app_label}_pony_uq\"\n  3869\t        table_name = f\"{app_label}_pony\"\n  3870\t        project_state = self.set_up_test_model(\n  3871\t            app_label,\n  3872\t            constraints=[\n  3873\t                models.UniqueConstraint(\"pink\", \"weight\", name=constraint_name)\n  3874\t            ],\n  3875\t        )\n  3876\t        operation = migrations.AlterField(\n  3877\t            \"Pony\", \"pink\", models.IntegerField(null=True)\n  3878\t        )\n  3879\t        new_state = project_state.clone()\n  3880\t        operation.state_forwards(app_label, new_state)\n  3881\t        with connection.schema_editor() as editor:\n  3882\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3883\t        if connection.features.supports_expression_indexes:\n  3884\t            self.assertIndexNameExists(table_name, constraint_name)\n  3885\t        with connection.schema_editor() as editor:\n  3886\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3887\t        if connection.features.supports_expression_indexes:\n  3888\t            self.assertIndexNameExists(table_name, constraint_name)\n  3889\t\n  3890\t    def test_add_func_unique_constraint(self):\n  3891\t        app_label = \"test_adfuncuc\"\n  3892\t        constraint_name = f\"{app_label}_pony_abs_uq\"\n  3893\t        table_name = f\"{app_label}_pony\"\n  3894\t        project_state = self.set_up_test_model(app_label)\n  3895\t        constraint = models.UniqueConstraint(Abs(\"weight\"), name=constraint_name)\n  3896\t        operation = migrations.AddConstraint(\"Pony\", constraint)\n  3897\t        self.assertEqual(\n  3898\t            operation.describe(),\n  3899\t            \"Create constraint test_adfuncuc_pony_abs_uq on model Pony\",\n  3900\t        )\n  3901\t        self.assertEqual(\n  3902\t            operation.migration_name_fragment,\n  3903\t            \"pony_test_adfuncuc_pony_abs_uq\",\n  3904\t        )\n  3905\t        new_state = project_state.clone()\n  3906\t        operation.state_forwards(app_label, new_state)\n  3907\t        self.assertEqual(\n  3908\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 1\n  3909\t        )\n  3910\t        self.assertIndexNameNotExists(table_name, constraint_name)\n  3911\t        # Add constraint.\n  3912\t        with connection.schema_editor() as editor:\n  3913\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3914\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3915\t        Pony.objects.create(weight=4.0)\n  3916\t        if connection.features.supports_expression_indexes:\n  3917\t            self.assertIndexNameExists(table_name, constraint_name)\n  3918\t            with self.assertRaises(IntegrityError):\n  3919\t                Pony.objects.create(weight=-4.0)\n  3920\t        else:\n  3921\t            self.assertIndexNameNotExists(table_name, constraint_name)\n  3922\t            Pony.objects.create(weight=-4.0)\n  3923\t        # Reversal.\n  3924\t        with connection.schema_editor() as editor:\n  3925\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3926\t        self.assertIndexNameNotExists(table_name, constraint_name)\n  3927\t        # Constraint doesn't work.\n  3928\t        Pony.objects.create(weight=-4.0)\n  3929\t        # Deconstruction.\n  3930\t        definition = operation.deconstruct()\n  3931\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3932\t        self.assertEqual(definition[1], [])\n  3933\t        self.assertEqual(\n  3934\t            definition[2],\n  3935\t            {\"model_name\": \"Pony\", \"constraint\": constraint},\n  3936\t        )\n  3937\t\n  3938\t    def test_remove_func_unique_constraint(self):\n  3939\t        app_label = \"test_rmfuncuc\"\n  3940\t        constraint_name = f\"{app_label}_pony_abs_uq\"\n  3941\t        table_name = f\"{app_label}_pony\"\n  3942\t        project_state = self.set_up_test_model(\n  3943\t            app_label,\n  3944\t            constraints=[\n  3945\t                models.UniqueConstraint(Abs(\"weight\"), name=constraint_name),\n  3946\t            ],\n  3947\t        )\n  3948\t        self.assertTableExists(table_name)\n  3949\t        if connection.features.supports_expression_indexes:\n  3950\t            self.assertIndexNameExists(table_name, constraint_name)\n  3951\t        operation = migrations.RemoveConstraint(\"Pony\", constraint_name)\n  3952\t        self.assertEqual(\n  3953\t            operation.describe(),\n  3954\t            \"Remove constraint test_rmfuncuc_pony_abs_uq from model Pony\",\n  3955\t        )\n  3956\t        self.assertEqual(\n  3957\t            operation.migration_name_fragment,\n  3958\t            \"remove_pony_test_rmfuncuc_pony_abs_uq\",\n  3959\t        )\n  3960\t        new_state = project_state.clone()\n  3961\t        operation.state_forwards(app_label, new_state)\n  3962\t        self.assertEqual(\n  3963\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 0\n  3964\t        )\n  3965\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3966\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3967\t        # Remove constraint.\n  3968\t        with connection.schema_editor() as editor:\n  3969\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3970\t        self.assertIndexNameNotExists(table_name, constraint_name)\n  3971\t        # Constraint doesn't work.\n  3972\t        Pony.objects.create(pink=1, weight=4.0)\n  3973\t        Pony.objects.create(pink=1, weight=-4.0).delete()\n  3974\t        # Reversal.\n  3975\t        with connection.schema_editor() as editor:\n  3976\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3977\t        if connection.features.supports_expression_indexes:\n  3978\t            self.assertIndexNameExists(table_name, constraint_name)\n  3979\t            with self.assertRaises(IntegrityError):\n  3980\t                Pony.objects.create(weight=-4.0)\n  3981\t        else:\n  3982\t            self.assertIndexNameNotExists(table_name, constraint_name)\n  3983\t            Pony.objects.create(weight=-4.0)\n  3984\t        # Deconstruction.\n  3985\t        definition = operation.deconstruct()\n  3986\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3987\t        self.assertEqual(definition[1], [])\n  3988\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"name\": constraint_name})\n  3989\t\n  3990\t    def test_alter_model_options(self):\n  3991\t        \"\"\"\n  3992\t        Tests the AlterModelOptions operation.\n  3993\t        \"\"\"\n  3994\t        project_state = self.set_up_test_model(\"test_almoop\")\n  3995\t        # Test the state alteration (no DB alteration to test)\n  3996\t        operation = migrations.AlterModelOptions(\n  3997\t            \"Pony\", {\"permissions\": [(\"can_groom\", \"Can groom\")]}\n  3998\t        )\n  3999\t        self.assertEqual(operation.describe(), \"Change Meta options on Pony\")\n  4000\t        self.assertEqual(operation.migration_name_fragment, \"alter_pony_options\")\n  4001\t        new_state = project_state.clone()\n  4002\t        operation.state_forwards(\"test_almoop\", new_state)\n  4003\t        self.assertEqual(\n  4004\t            len(\n  4005\t                project_state.models[\"test_almoop\", \"pony\"].options.get(\n  4006\t                    \"permissions\", []\n  4007\t                )\n  4008\t            ),\n  4009\t            0,\n  4010\t        )\n  4011\t        self.assertEqual(\n  4012\t            len(new_state.models[\"test_almoop\", \"pony\"].options.get(\"permissions\", [])),\n  4013\t            1,\n  4014\t        )\n  4015\t        self.assertEqual(\n  4016\t            new_state.models[\"test_almoop\", \"pony\"].options[\"permissions\"][0][0],\n  4017\t            \"can_groom\",\n  4018\t        )\n  4019\t        # And deconstruction\n  4020\t        definition = operation.deconstruct()\n  4021\t        self.assertEqual(definition[0], \"AlterModelOptions\")\n  4022\t        self.assertEqual(definition[1], [])\n  4023\t        self.assertEqual(\n  4024\t            definition[2],\n  4025\t            {\"name\": \"Pony\", \"options\": {\"permissions\": [(\"can_groom\", \"Can groom\")]}},\n  4026\t        )\n  4027\t\n  4028\t    def test_alter_model_options_emptying(self):\n  4029\t        \"\"\"\n  4030\t        The AlterModelOptions operation removes keys from the dict (#23121)\n  4031\t        \"\"\"\n  4032\t        project_state = self.set_up_test_model(\"test_almoop\", options=True)\n  4033\t        # Test the state alteration (no DB alteration to test)\n  4034\t        operation = migrations.AlterModelOptions(\"Pony\", {})\n  4035\t        self.assertEqual(operation.describe(), \"Change Meta options on Pony\")\n  4036\t        new_state = project_state.clone()\n  4037\t        operation.state_forwards(\"test_almoop\", new_state)\n  4038\t        self.assertEqual(\n  4039\t            len(\n  4040\t                project_state.models[\"test_almoop\", \"pony\"].options.get(\n  4041\t                    \"permissions\", []\n  4042\t                )\n  4043\t            ),\n  4044\t            1,\n  4045\t        )\n  4046\t        self.assertEqual(\n  4047\t            len(new_state.models[\"test_almoop\", \"pony\"].options.get(\"permissions\", [])),\n  4048\t            0,\n  4049\t        )\n  4050\t        # And deconstruction\n  4051\t        definition = operation.deconstruct()\n  4052\t        self.assertEqual(definition[0], \"AlterModelOptions\")\n  4053\t        self.assertEqual(definition[1], [])\n  4054\t        self.assertEqual(definition[2], {\"name\": \"Pony\", \"options\": {}})\n  4055\t\n  4056\t    def test_alter_order_with_respect_to(self):\n  4057\t        \"\"\"\n  4058\t        Tests the AlterOrderWithRespectTo operation.\n  4059\t        \"\"\"\n  4060\t        project_state = self.set_up_test_model(\"test_alorwrtto\", related_model=True)\n  4061\t        # Test the state alteration\n  4062\t        operation = migrations.AlterOrderWithRespectTo(\"Rider\", \"pony\")\n  4063\t        self.assertEqual(\n  4064\t            operation.describe(), \"Set order_with_respect_to on Rider to pony\"\n  4065\t        )\n  4066\t        self.assertEqual(\n  4067\t            operation.migration_name_fragment,\n  4068\t            \"alter_rider_order_with_respect_to\",\n  4069\t        )\n  4070\t        new_state = project_state.clone()\n  4071\t        operation.state_forwards(\"test_alorwrtto\", new_state)\n  4072\t        self.assertIsNone(\n  4073\t            project_state.models[\"test_alorwrtto\", \"rider\"].options.get(\n  4074\t                \"order_with_respect_to\", None\n  4075\t            )\n  4076\t        )\n  4077\t        self.assertEqual(\n  4078\t            new_state.models[\"test_alorwrtto\", \"rider\"].options.get(\n  4079\t                \"order_with_respect_to\", None\n  4080\t            ),\n  4081\t            \"pony\",\n  4082\t        )\n  4083\t        # Make sure there's no matching index\n  4084\t        self.assertColumnNotExists(\"test_alorwrtto_rider\", \"_order\")\n  4085\t        # Create some rows before alteration\n  4086\t        rendered_state = project_state.apps\n  4087\t        pony = rendered_state.get_model(\"test_alorwrtto\", \"Pony\").objects.create(\n  4088\t            weight=50\n  4089\t        )\n  4090\t        rider1 = rendered_state.get_model(\"test_alorwrtto\", \"Rider\").objects.create(\n  4091\t            pony=pony\n  4092\t        )\n  4093\t        rider1.friend = rider1\n  4094\t        rider1.save()\n  4095\t        rider2 = rendered_state.get_model(\"test_alorwrtto\", \"Rider\").objects.create(\n  4096\t            pony=pony\n  4097\t        )\n  4098\t        rider2.friend = rider2\n  4099\t        rider2.save()\n  4100\t        # Test the database alteration\n  4101\t        with connection.schema_editor() as editor:\n  4102\t            operation.database_forwards(\n  4103\t                \"test_alorwrtto\", editor, project_state, new_state\n  4104\t            )\n  4105\t        self.assertColumnExists(\"test_alorwrtto_rider\", \"_order\")\n  4106\t        # Check for correct value in rows\n  4107\t        updated_riders = new_state.apps.get_model(\n  4108\t            \"test_alorwrtto\", \"Rider\"\n  4109\t        ).objects.all()\n  4110\t        self.assertEqual(updated_riders[0]._order, 0)\n  4111\t        self.assertEqual(updated_riders[1]._order, 0)\n  4112\t        # And test reversal\n  4113\t        with connection.schema_editor() as editor:\n  4114\t            operation.database_backwards(\n  4115\t                \"test_alorwrtto\", editor, new_state, project_state\n  4116\t            )\n  4117\t        self.assertColumnNotExists(\"test_alorwrtto_rider\", \"_order\")\n  4118\t        # And deconstruction\n  4119\t        definition = operation.deconstruct()\n  4120\t        self.assertEqual(definition[0], \"AlterOrderWithRespectTo\")\n  4121\t        self.assertEqual(definition[1], [])\n  4122\t        self.assertEqual(\n  4123\t            definition[2], {\"name\": \"Rider\", \"order_with_respect_to\": \"pony\"}\n  4124\t        )\n  4125\t\n  4126\t    def test_alter_model_managers(self):\n  4127\t        \"\"\"\n  4128\t        The managers on a model are set.\n  4129\t        \"\"\"\n  4130\t        project_state = self.set_up_test_model(\"test_almoma\")\n  4131\t        # Test the state alteration\n  4132\t        operation = migrations.AlterModelManagers(\n  4133\t            \"Pony\",\n  4134\t            managers=[\n  4135\t                (\"food_qs\", FoodQuerySet.as_manager()),\n  4136\t                (\"food_mgr\", FoodManager(\"a\", \"b\")),\n  4137\t                (\"food_mgr_kwargs\", FoodManager(\"x\", \"y\", 3, 4)),\n  4138\t            ],\n  4139\t        )\n  4140\t        self.assertEqual(operation.describe(), \"Change managers on Pony\")\n  4141\t        self.assertEqual(operation.migration_name_fragment, \"alter_pony_managers\")\n  4142\t        managers = project_state.models[\"test_almoma\", \"pony\"].managers\n  4143\t        self.assertEqual(managers, [])\n  4144\t\n  4145\t        new_state = project_state.clone()\n  4146\t        operation.state_forwards(\"test_almoma\", new_state)\n  4147\t        self.assertIn((\"test_almoma\", \"pony\"), new_state.models)\n  4148\t        managers = new_state.models[\"test_almoma\", \"pony\"].managers\n  4149\t        self.assertEqual(managers[0][0], \"food_qs\")\n  4150\t        self.assertIsInstance(managers[0][1], models.Manager)\n  4151\t        self.assertEqual(managers[1][0], \"food_mgr\")\n  4152\t        self.assertIsInstance(managers[1][1], FoodManager)\n  4153\t        self.assertEqual(managers[1][1].args, (\"a\", \"b\", 1, 2))\n  4154\t        self.assertEqual(managers[2][0], \"food_mgr_kwargs\")\n  4155\t        self.assertIsInstance(managers[2][1], FoodManager)\n  4156\t        self.assertEqual(managers[2][1].args, (\"x\", \"y\", 3, 4))\n  4157\t        rendered_state = new_state.apps\n  4158\t        model = rendered_state.get_model(\"test_almoma\", \"pony\")\n  4159\t        self.assertIsInstance(model.food_qs, models.Manager)\n  4160\t        self.assertIsInstance(model.food_mgr, FoodManager)\n  4161\t        self.assertIsInstance(model.food_mgr_kwargs, FoodManager)\n  4162\t\n  4163\t    def test_alter_model_managers_emptying(self):\n  4164\t        \"\"\"\n  4165\t        The managers on a model are set.\n  4166\t        \"\"\"\n  4167\t        project_state = self.set_up_test_model(\"test_almomae\", manager_model=True)\n  4168\t        # Test the state alteration\n  4169\t        operation = migrations.AlterModelManagers(\"Food\", managers=[])\n  4170\t        self.assertEqual(operation.describe(), \"Change managers on Food\")\n  4171\t        self.assertIn((\"test_almomae\", \"food\"), project_state.models)\n  4172\t        managers = project_state.models[\"test_almomae\", \"food\"].managers\n  4173\t        self.assertEqual(managers[0][0], \"food_qs\")\n  4174\t        self.assertIsInstance(managers[0][1], models.Manager)\n  4175\t        self.assertEqual(managers[1][0], \"food_mgr\")\n  4176\t        self.assertIsInstance(managers[1][1], FoodManager)\n  4177\t        self.assertEqual(managers[1][1].args, (\"a\", \"b\", 1, 2))\n  4178\t        self.assertEqual(managers[2][0], \"food_mgr_kwargs\")\n  4179\t        self.assertIsInstance(managers[2][1], FoodManager)\n  4180\t        self.assertEqual(managers[2][1].args, (\"x\", \"y\", 3, 4))\n  4181\t\n  4182\t        new_state = project_state.clone()\n  4183\t        operation.state_forwards(\"test_almomae\", new_state)\n  4184\t        managers = new_state.models[\"test_almomae\", \"food\"].managers\n  4185\t        self.assertEqual(managers, [])\n  4186\t\n  4187\t    def test_alter_fk(self):\n  4188\t        \"\"\"\n  4189\t        Creating and then altering an FK works correctly\n  4190\t        and deals with the pending SQL (#23091)\n  4191\t        \"\"\"\n  4192\t        project_state = self.set_up_test_model(\"test_alfk\")\n  4193\t        # Test adding and then altering the FK in one go\n  4194\t        create_operation = migrations.CreateModel(\n  4195\t            name=\"Rider\",\n  4196\t            fields=[\n  4197\t                (\"id\", models.AutoField(primary_key=True)),\n  4198\t                (\"pony\", models.ForeignKey(\"Pony\", models.CASCADE)),\n  4199\t            ],\n  4200\t        )\n  4201\t        create_state = project_state.clone()\n  4202\t        create_operation.state_forwards(\"test_alfk\", create_state)\n  4203\t        alter_operation = migrations.AlterField(\n  4204\t            model_name=\"Rider\",\n  4205\t            name=\"pony\",\n  4206\t            field=models.ForeignKey(\"Pony\", models.CASCADE, editable=False),\n  4207\t        )\n  4208\t        alter_state = create_state.clone()\n  4209\t        alter_operation.state_forwards(\"test_alfk\", alter_state)\n  4210\t        with connection.schema_editor() as editor:\n  4211\t            create_operation.database_forwards(\n  4212\t                \"test_alfk\", editor, project_state, create_state\n  4213\t            )\n  4214\t            alter_operation.database_forwards(\n  4215\t                \"test_alfk\", editor, create_state, alter_state\n  4216\t            )\n  4217\t\n  4218\t    def test_alter_fk_non_fk(self):\n  4219\t        \"\"\"\n  4220\t        Altering an FK to a non-FK works (#23244)\n  4221\t        \"\"\"\n  4222\t        # Test the state alteration\n  4223\t        operation = migrations.AlterField(\n  4224\t            model_name=\"Rider\",\n  4225\t            name=\"pony\",\n  4226\t            field=models.FloatField(),\n  4227\t        )\n  4228\t        project_state, new_state = self.make_test_state(\n  4229\t            \"test_afknfk\", operation, related_model=True\n  4230\t        )\n  4231\t        # Test the database alteration\n  4232\t        self.assertColumnExists(\"test_afknfk_rider\", \"pony_id\")\n  4233\t        self.assertColumnNotExists(\"test_afknfk_rider\", \"pony\")\n  4234\t        with connection.schema_editor() as editor:\n  4235\t            operation.database_forwards(\"test_afknfk\", editor, project_state, new_state)\n  4236\t        self.assertColumnExists(\"test_afknfk_rider\", \"pony\")\n  4237\t        self.assertColumnNotExists(\"test_afknfk_rider\", \"pony_id\")\n  4238\t        # And test reversal\n  4239\t        with connection.schema_editor() as editor:\n  4240\t            operation.database_backwards(\n  4241\t                \"test_afknfk\", editor, new_state, project_state\n  4242\t            )\n  4243\t        self.assertColumnExists(\"test_afknfk_rider\", \"pony_id\")\n  4244\t        self.assertColumnNotExists(\"test_afknfk_rider\", \"pony\")\n  4245\t\n  4246\t    def test_run_sql(self):\n  4247\t        \"\"\"\n  4248\t        Tests the RunSQL operation.\n  4249\t        \"\"\"\n  4250\t        project_state = self.set_up_test_model(\"test_runsql\")\n  4251\t        # Create the operation\n  4252\t        operation = migrations.RunSQL(\n  4253\t            # Use a multi-line string with a comment to test splitting on\n  4254\t            # SQLite and MySQL respectively.\n  4255\t            \"CREATE TABLE i_love_ponies (id int, special_thing varchar(15));\\n\"\n  4256\t            \"INSERT INTO i_love_ponies (id, special_thing) \"\n  4257\t            \"VALUES (1, 'i love ponies'); -- this is magic!\\n\"\n  4258\t            \"INSERT INTO i_love_ponies (id, special_thing) \"\n  4259\t            \"VALUES (2, 'i love django');\\n\"\n  4260\t            \"UPDATE i_love_ponies SET special_thing = 'Ponies' \"\n  4261\t            \"WHERE special_thing LIKE '%%ponies';\"\n  4262\t            \"UPDATE i_love_ponies SET special_thing = 'Django' \"\n  4263\t            \"WHERE special_thing LIKE '%django';\",\n  4264\t            # Run delete queries to test for parameter substitution failure\n  4265\t            # reported in #23426\n  4266\t            \"DELETE FROM i_love_ponies WHERE special_thing LIKE '%Django%';\"\n  4267\t            \"DELETE FROM i_love_ponies WHERE special_thing LIKE '%%Ponies%%';\"\n  4268\t            \"DROP TABLE i_love_ponies\",\n  4269\t            state_operations=[\n  4270\t                migrations.CreateModel(\n  4271\t                    \"SomethingElse\", [(\"id\", models.AutoField(primary_key=True))]\n  4272\t                )\n  4273\t            ],\n  4274\t        )\n  4275\t        self.assertEqual(operation.describe(), \"Raw SQL operation\")\n  4276\t        # Test the state alteration\n  4277\t        new_state = project_state.clone()\n  4278\t        operation.state_forwards(\"test_runsql\", new_state)\n  4279\t        self.assertEqual(\n  4280\t            len(new_state.models[\"test_runsql\", \"somethingelse\"].fields), 1\n  4281\t        )\n  4282\t        # Make sure there's no table\n  4283\t        self.assertTableNotExists(\"i_love_ponies\")\n  4284\t        # Test SQL collection\n  4285\t        with connection.schema_editor(collect_sql=True) as editor:\n  4286\t            operation.database_forwards(\"test_runsql\", editor, project_state, new_state)\n  4287\t            self.assertIn(\"LIKE '%%ponies';\", \"\\n\".join(editor.collected_sql))\n  4288\t            operation.database_backwards(\n  4289\t                \"test_runsql\", editor, project_state, new_state\n  4290\t            )\n  4291\t            self.assertIn(\"LIKE '%%Ponies%%';\", \"\\n\".join(editor.collected_sql))\n  4292\t        # Test the database alteration\n  4293\t        with connection.schema_editor() as editor:\n  4294\t            operation.database_forwards(\"test_runsql\", editor, project_state, new_state)\n  4295\t        self.assertTableExists(\"i_love_ponies\")\n  4296\t        # Make sure all the SQL was processed\n  4297\t        with connection.cursor() as cursor:\n  4298\t            cursor.execute(\"SELECT COUNT(*) FROM i_love_ponies\")\n  4299\t            self.assertEqual(cursor.fetchall()[0][0], 2)\n  4300\t            cursor.execute(\n  4301\t                \"SELECT COUNT(*) FROM i_love_ponies WHERE special_thing = 'Django'\"\n  4302\t            )\n  4303\t            self.assertEqual(cursor.fetchall()[0][0], 1)\n  4304\t            cursor.execute(\n  4305\t                \"SELECT COUNT(*) FROM i_love_ponies WHERE special_thing = 'Ponies'\"\n  4306\t            )\n  4307\t            self.assertEqual(cursor.fetchall()[0][0], 1)\n  4308\t        # And test reversal\n  4309\t        self.assertTrue(operation.reversible)\n  4310\t        with connection.schema_editor() as editor:\n  4311\t            operation.database_backwards(\n  4312\t                \"test_runsql\", editor, new_state, project_state\n  4313\t            )\n  4314\t        self.assertTableNotExists(\"i_love_ponies\")\n  4315\t        # And deconstruction\n  4316\t        definition = operation.deconstruct()\n  4317\t        self.assertEqual(definition[0], \"RunSQL\")\n  4318\t        self.assertEqual(definition[1], [])\n  4319\t        self.assertEqual(\n  4320\t            sorted(definition[2]), [\"reverse_sql\", \"sql\", \"state_operations\"]\n  4321\t        )\n  4322\t        # And elidable reduction\n  4323\t        self.assertIs(False, operation.reduce(operation, []))\n  4324\t        elidable_operation = migrations.RunSQL(\"SELECT 1 FROM void;\", elidable=True)\n  4325\t        self.assertEqual(elidable_operation.reduce(operation, []), [operation])\n  4326\t\n  4327\t    def test_run_sql_params(self):\n  4328\t        \"\"\"\n  4329\t        #23426 - RunSQL should accept parameters.\n  4330\t        \"\"\"\n  4331\t        project_state = self.set_up_test_model(\"test_runsql\")\n  4332\t        # Create the operation\n  4333\t        operation = migrations.RunSQL(\n  4334\t            [\"CREATE TABLE i_love_ponies (id int, special_thing varchar(15));\"],\n  4335\t            [\"DROP TABLE i_love_ponies\"],\n  4336\t        )\n  4337\t        param_operation = migrations.RunSQL(\n  4338\t            # forwards\n  4339\t            (\n  4340\t                \"INSERT INTO i_love_ponies (id, special_thing) VALUES (1, 'Django');\",\n  4341\t                [\n  4342\t                    \"INSERT INTO i_love_ponies (id, special_thing) VALUES (2, %s);\",\n  4343\t                    [\"Ponies\"],\n  4344\t                ],\n  4345\t                (\n  4346\t                    \"INSERT INTO i_love_ponies (id, special_thing) VALUES (%s, %s);\",\n  4347\t                    (\n  4348\t                        3,\n  4349\t                        \"Python\",\n  4350\t                    ),\n  4351\t                ),\n  4352\t            ),\n  4353\t            # backwards\n  4354\t            [\n  4355\t                \"DELETE FROM i_love_ponies WHERE special_thing = 'Django';\",\n  4356\t                [\"DELETE FROM i_love_ponies WHERE special_thing = 'Ponies';\", None],\n  4357\t                (\n  4358\t                    \"DELETE FROM i_love_ponies WHERE id = %s OR special_thing = %s;\",\n  4359\t                    [3, \"Python\"],\n  4360\t                ),\n  4361\t            ],\n  4362\t        )\n  4363\t\n  4364\t        # Make sure there's no table\n  4365\t        self.assertTableNotExists(\"i_love_ponies\")\n  4366\t        new_state = project_state.clone()\n  4367\t        # Test the database alteration\n  4368\t        with connection.schema_editor() as editor:\n  4369\t            operation.database_forwards(\"test_runsql\", editor, project_state, new_state)\n  4370\t\n  4371\t        # Test parameter passing\n  4372\t        with connection.schema_editor() as editor:\n  4373\t            param_operation.database_forwards(\n  4374\t                \"test_runsql\", editor, project_state, new_state\n  4375\t            )\n  4376\t        # Make sure all the SQL was processed\n  4377\t        with connection.cursor() as cursor:\n  4378\t            cursor.execute(\"SELECT COUNT(*) FROM i_love_ponies\")\n  4379\t            self.assertEqual(cursor.fetchall()[0][0], 3)\n  4380\t\n  4381\t        with connection.schema_editor() as editor:\n  4382\t            param_operation.database_backwards(\n  4383\t                \"test_runsql\", editor, new_state, project_state\n  4384\t            )\n  4385\t        with connection.cursor() as cursor:\n  4386\t            cursor.execute(\"SELECT COUNT(*) FROM i_love_ponies\")\n  4387\t            self.assertEqual(cursor.fetchall()[0][0], 0)\n  4388\t\n  4389\t        # And test reversal\n  4390\t        with connection.schema_editor() as editor:\n  4391\t            operation.database_backwards(\n  4392\t                \"test_runsql\", editor, new_state, project_state\n  4393\t            )\n  4394\t        self.assertTableNotExists(\"i_love_ponies\")\n  4395\t\n  4396\t    def test_run_sql_params_invalid(self):\n  4397\t        \"\"\"\n  4398\t        #23426 - RunSQL should fail when a list of statements with an incorrect\n  4399\t        number of tuples is given.\n  4400\t        \"\"\"\n  4401\t        project_state = self.set_up_test_model(\"test_runsql\")\n  4402\t        new_state = project_state.clone()\n  4403\t        operation = migrations.RunSQL(\n  4404\t            # forwards\n  4405\t            [[\"INSERT INTO foo (bar) VALUES ('buz');\"]],\n  4406\t            # backwards\n  4407\t            ((\"DELETE FROM foo WHERE bar = 'buz';\", \"invalid\", \"parameter count\"),),\n  4408\t        )\n  4409\t\n  4410\t        with connection.schema_editor() as editor:\n  4411\t            with self.assertRaisesMessage(ValueError, \"Expected a 2-tuple but got 1\"):\n  4412\t                operation.database_forwards(\n  4413\t                    \"test_runsql\", editor, project_state, new_state\n  4414\t                )\n  4415\t\n  4416\t        with connection.schema_editor() as editor:\n  4417\t            with self.assertRaisesMessage(ValueError, \"Expected a 2-tuple but got 3\"):\n  4418\t                operation.database_backwards(\n  4419\t                    \"test_runsql\", editor, new_state, project_state\n  4420\t                )\n  4421\t\n  4422\t    def test_run_sql_noop(self):\n  4423\t        \"\"\"\n  4424\t        #24098 - Tests no-op RunSQL operations.\n  4425\t        \"\"\"\n  4426\t        operation = migrations.RunSQL(migrations.RunSQL.noop, migrations.RunSQL.noop)\n  4427\t        with connection.schema_editor() as editor:\n  4428\t            operation.database_forwards(\"test_runsql\", editor, None, None)\n  4429\t            operation.database_backwards(\"test_runsql\", editor, None, None)\n  4430\t\n  4431\t    def test_run_sql_add_missing_semicolon_on_collect_sql(self):\n  4432\t        project_state = self.set_up_test_model(\"test_runsql\")\n  4433\t        new_state = project_state.clone()\n  4434\t        tests = [\n  4435\t            \"INSERT INTO test_runsql_pony (pink, weight) VALUES (1, 1);\\n\",\n  4436\t            \"INSERT INTO test_runsql_pony (pink, weight) VALUES (1, 1)\\n\",\n  4437\t        ]\n  4438\t        for sql in tests:\n  4439\t            with self.subTest(sql=sql):\n  4440\t                operation = migrations.RunSQL(sql, migrations.RunPython.noop)\n  4441\t                with connection.schema_editor(collect_sql=True) as editor:\n  4442\t                    operation.database_forwards(\n  4443\t                        \"test_runsql\", editor, project_state, new_state\n  4444\t                    )\n  4445\t                    collected_sql = \"\\n\".join(editor.collected_sql)\n  4446\t                    self.assertEqual(collected_sql.count(\";\"), 1)\n  4447\t\n  4448\t    def test_run_python(self):\n  4449\t        \"\"\"\n  4450\t        Tests the RunPython operation\n  4451\t        \"\"\"\n  4452\t\n  4453\t        project_state = self.set_up_test_model(\"test_runpython\", mti_model=True)\n  4454\t\n  4455\t        # Create the operation\n  4456\t        def inner_method(models, schema_editor):\n  4457\t            Pony = models.get_model(\"test_runpython\", \"Pony\")\n  4458\t            Pony.objects.create(pink=1, weight=3.55)\n  4459\t            Pony.objects.create(weight=5)\n  4460\t\n  4461\t        def inner_method_reverse(models, schema_editor):\n  4462\t            Pony = models.get_model(\"test_runpython\", \"Pony\")\n  4463\t            Pony.objects.filter(pink=1, weight=3.55).delete()\n  4464\t            Pony.objects.filter(weight=5).delete()\n  4465\t\n  4466\t        operation = migrations.RunPython(\n  4467\t            inner_method, reverse_code=inner_method_reverse\n  4468\t        )\n  4469\t        self.assertEqual(operation.describe(), \"Raw Python operation\")\n  4470\t        # Test the state alteration does nothing\n  4471\t        new_state = project_state.clone()\n  4472\t        operation.state_forwards(\"test_runpython\", new_state)\n  4473\t        self.assertEqual(new_state, project_state)\n  4474\t        # Test the database alteration\n  4475\t        self.assertEqual(\n  4476\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 0\n  4477\t        )\n  4478\t        with connection.schema_editor() as editor:\n  4479\t            operation.database_forwards(\n  4480\t                \"test_runpython\", editor, project_state, new_state\n  4481\t            )\n  4482\t        self.assertEqual(\n  4483\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 2\n  4484\t        )\n  4485\t        # Now test reversal\n  4486\t        self.assertTrue(operation.reversible)\n  4487\t        with connection.schema_editor() as editor:\n  4488\t            operation.database_backwards(\n  4489\t                \"test_runpython\", editor, project_state, new_state\n  4490\t            )\n  4491\t        self.assertEqual(\n  4492\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 0\n  4493\t        )\n  4494\t        # Now test we can't use a string\n  4495\t        with self.assertRaisesMessage(\n  4496\t            ValueError, \"RunPython must be supplied with a callable\"\n  4497\t        ):\n  4498\t            migrations.RunPython(\"print 'ahahaha'\")\n  4499\t        # And deconstruction\n  4500\t        definition = operation.deconstruct()\n  4501\t        self.assertEqual(definition[0], \"RunPython\")\n  4502\t        self.assertEqual(definition[1], [])\n  4503\t        self.assertEqual(sorted(definition[2]), [\"code\", \"reverse_code\"])\n  4504\t\n  4505\t        # Also test reversal fails, with an operation identical to above but\n  4506\t        # without reverse_code set.\n  4507\t        no_reverse_operation = migrations.RunPython(inner_method)\n  4508\t        self.assertFalse(no_reverse_operation.reversible)\n  4509\t        with connection.schema_editor() as editor:\n  4510\t            no_reverse_operation.database_forwards(\n  4511\t                \"test_runpython\", editor, project_state, new_state\n  4512\t            )\n  4513\t            with self.assertRaises(NotImplementedError):\n  4514\t                no_reverse_operation.database_backwards(\n  4515\t                    \"test_runpython\", editor, new_state, project_state\n  4516\t                )\n  4517\t        self.assertEqual(\n  4518\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 2\n  4519\t        )\n  4520\t\n  4521\t        def create_ponies(models, schema_editor):\n  4522\t            Pony = models.get_model(\"test_runpython\", \"Pony\")\n  4523\t            pony1 = Pony.objects.create(pink=1, weight=3.55)\n  4524\t            self.assertIsNot(pony1.pk, None)\n  4525\t            pony2 = Pony.objects.create(weight=5)\n  4526\t            self.assertIsNot(pony2.pk, None)\n  4527\t            self.assertNotEqual(pony1.pk, pony2.pk)\n  4528\t\n  4529\t        operation = migrations.RunPython(create_ponies)\n  4530\t        with connection.schema_editor() as editor:\n  4531\t            operation.database_forwards(\n  4532\t                \"test_runpython\", editor, project_state, new_state\n  4533\t            )\n  4534\t        self.assertEqual(\n  4535\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 4\n  4536\t        )\n  4537\t        # And deconstruction\n  4538\t        definition = operation.deconstruct()\n  4539\t        self.assertEqual(definition[0], \"RunPython\")\n  4540\t        self.assertEqual(definition[1], [])\n  4541\t        self.assertEqual(sorted(definition[2]), [\"code\"])\n  4542\t\n  4543\t        def create_shetlandponies(models, schema_editor):\n  4544\t            ShetlandPony = models.get_model(\"test_runpython\", \"ShetlandPony\")\n  4545\t            pony1 = ShetlandPony.objects.create(weight=4.0)\n  4546\t            self.assertIsNot(pony1.pk, None)\n  4547\t            pony2 = ShetlandPony.objects.create(weight=5.0)\n  4548\t            self.assertIsNot(pony2.pk, None)\n  4549\t            self.assertNotEqual(pony1.pk, pony2.pk)\n  4550\t\n  4551\t        operation = migrations.RunPython(create_shetlandponies)\n  4552\t        with connection.schema_editor() as editor:\n  4553\t            operation.database_forwards(\n  4554\t                \"test_runpython\", editor, project_state, new_state\n  4555\t            )\n  4556\t        self.assertEqual(\n  4557\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 6\n  4558\t        )\n  4559\t        self.assertEqual(\n  4560\t            project_state.apps.get_model(\n  4561\t                \"test_runpython\", \"ShetlandPony\"\n  4562\t            ).objects.count(),\n  4563\t            2,\n  4564\t        )\n  4565\t        # And elidable reduction\n  4566\t        self.assertIs(False, operation.reduce(operation, []))\n  4567\t        elidable_operation = migrations.RunPython(inner_method, elidable=True)\n  4568\t        self.assertEqual(elidable_operation.reduce(operation, []), [operation])\n  4569\t\n  4570\t    def test_run_python_atomic(self):\n  4571\t        \"\"\"\n  4572\t        Tests the RunPython operation correctly handles the \"atomic\" keyword\n  4573\t        \"\"\"\n  4574\t        project_state = self.set_up_test_model(\"test_runpythonatomic\", mti_model=True)\n  4575\t\n  4576\t        def inner_method(models, schema_editor):\n  4577\t            Pony = models.get_model(\"test_runpythonatomic\", \"Pony\")\n  4578\t            Pony.objects.create(pink=1, weight=3.55)\n  4579\t            raise ValueError(\"Adrian hates ponies.\")\n  4580\t\n  4581\t        # Verify atomicity when applying.\n  4582\t        atomic_migration = Migration(\"test\", \"test_runpythonatomic\")\n  4583\t        atomic_migration.operations = [\n  4584\t            migrations.RunPython(inner_method, reverse_code=inner_method)\n  4585\t        ]\n  4586\t        non_atomic_migration = Migration(\"test\", \"test_runpythonatomic\")\n  4587\t        non_atomic_migration.operations = [\n  4588\t            migrations.RunPython(inner_method, reverse_code=inner_method, atomic=False)\n  4589\t        ]\n  4590\t        # If we're a fully-transactional database, both versions should rollback\n  4591\t        if connection.features.can_rollback_ddl:\n  4592\t            self.assertEqual(\n  4593\t                project_state.apps.get_model(\n  4594\t                    \"test_runpythonatomic\", \"Pony\"\n  4595\t                ).objects.count(),\n  4596\t                0,\n  4597\t            )\n  4598\t            with self.assertRaises(ValueError):\n  4599\t                with connection.schema_editor() as editor:\n  4600\t                    atomic_migration.apply(project_state, editor)\n  4601\t            self.assertEqual(\n  4602\t                project_state.apps.get_model(\n  4603\t                    \"test_runpythonatomic\", \"Pony\"\n  4604\t                ).objects.count(),\n  4605\t                0,\n  4606\t            )\n  4607\t            with self.assertRaises(ValueError):\n  4608\t                with connection.schema_editor() as editor:\n  4609\t                    non_atomic_migration.apply(project_state, editor)\n  4610\t            self.assertEqual(\n  4611\t                project_state.apps.get_model(\n  4612\t                    \"test_runpythonatomic\", \"Pony\"\n  4613\t                ).objects.count(),\n  4614\t                0,\n  4615\t            )\n  4616\t        # Otherwise, the non-atomic operation should leave a row there\n  4617\t        else:\n  4618\t            self.assertEqual(\n  4619\t                project_state.apps.get_model(\n  4620\t                    \"test_runpythonatomic\", \"Pony\"\n  4621\t                ).objects.count(),\n  4622\t                0,\n  4623\t            )\n  4624\t            with self.assertRaises(ValueError):\n  4625\t                with connection.schema_editor() as editor:\n  4626\t                    atomic_migration.apply(project_state, editor)\n  4627\t            self.assertEqual(\n  4628\t                project_state.apps.get_model(\n  4629\t                    \"test_runpythonatomic\", \"Pony\"\n  4630\t                ).objects.count(),\n  4631\t                0,\n  4632\t            )\n  4633\t            with self.assertRaises(ValueError):\n  4634\t                with connection.schema_editor() as editor:\n  4635\t                    non_atomic_migration.apply(project_state, editor)\n  4636\t            self.assertEqual(\n  4637\t                project_state.apps.get_model(\n  4638\t                    \"test_runpythonatomic\", \"Pony\"\n  4639\t                ).objects.count(),\n  4640\t                1,\n  4641\t            )\n  4642\t        # Reset object count to zero and verify atomicity when unapplying.\n  4643\t        project_state.apps.get_model(\n  4644\t            \"test_runpythonatomic\", \"Pony\"\n  4645\t        ).objects.all().delete()\n  4646\t        # On a fully-transactional database, both versions rollback.\n  4647\t        if connection.features.can_rollback_ddl:\n  4648\t            self.assertEqual(\n  4649\t                project_state.apps.get_model(\n  4650\t                    \"test_runpythonatomic\", \"Pony\"\n  4651\t                ).objects.count(),\n  4652\t                0,\n  4653\t            )\n  4654\t            with self.assertRaises(ValueError):\n  4655\t                with connection.schema_editor() as editor:\n  4656\t                    atomic_migration.unapply(project_state, editor)\n  4657\t            self.assertEqual(\n  4658\t                project_state.apps.get_model(\n  4659\t                    \"test_runpythonatomic\", \"Pony\"\n  4660\t                ).objects.count(),\n  4661\t                0,\n  4662\t            )\n  4663\t            with self.assertRaises(ValueError):\n  4664\t                with connection.schema_editor() as editor:\n  4665\t                    non_atomic_migration.unapply(project_state, editor)\n  4666\t            self.assertEqual(\n  4667\t                project_state.apps.get_model(\n  4668\t                    \"test_runpythonatomic\", \"Pony\"\n  4669\t                ).objects.count(),\n  4670\t                0,\n  4671\t            )\n  4672\t        # Otherwise, the non-atomic operation leaves a row there.\n  4673\t        else:\n  4674\t            self.assertEqual(\n  4675\t                project_state.apps.get_model(\n  4676\t                    \"test_runpythonatomic\", \"Pony\"\n  4677\t                ).objects.count(),\n  4678\t                0,\n  4679\t            )\n  4680\t            with self.assertRaises(ValueError):\n  4681\t                with connection.schema_editor() as editor:\n  4682\t                    atomic_migration.unapply(project_state, editor)\n  4683\t            self.assertEqual(\n  4684\t                project_state.apps.get_model(\n  4685\t                    \"test_runpythonatomic\", \"Pony\"\n  4686\t                ).objects.count(),\n  4687\t                0,\n  4688\t            )\n  4689\t            with self.assertRaises(ValueError):\n  4690\t                with connection.schema_editor() as editor:\n  4691\t                    non_atomic_migration.unapply(project_state, editor)\n  4692\t            self.assertEqual(\n  4693\t                project_state.apps.get_model(\n  4694\t                    \"test_runpythonatomic\", \"Pony\"\n  4695\t                ).objects.count(),\n  4696\t                1,\n  4697\t            )\n  4698\t        # Verify deconstruction.\n  4699\t        definition = non_atomic_migration.operations[0].deconstruct()\n  4700\t        self.assertEqual(definition[0], \"RunPython\")\n  4701\t        self.assertEqual(definition[1], [])\n  4702\t        self.assertEqual(sorted(definition[2]), [\"atomic\", \"code\", \"reverse_code\"])\n  4703\t\n  4704\t    def test_run_python_related_assignment(self):\n  4705\t        \"\"\"\n  4706\t        #24282 - Model changes to a FK reverse side update the model\n  4707\t        on the FK side as well.\n  4708\t        \"\"\"\n  4709\t\n  4710\t        def inner_method(models, schema_editor):\n  4711\t            Author = models.get_model(\"test_authors\", \"Author\")\n  4712\t            Book = models.get_model(\"test_books\", \"Book\")\n  4713\t            author = Author.objects.create(name=\"Hemingway\")\n  4714\t            Book.objects.create(title=\"Old Man and The Sea\", author=author)\n  4715\t\n  4716\t        create_author = migrations.CreateModel(\n  4717\t            \"Author\",\n  4718\t            [\n  4719\t                (\"id\", models.AutoField(primary_key=True)),\n  4720\t                (\"name\", models.CharField(max_length=100)),\n  4721\t            ],\n  4722\t            options={},\n  4723\t        )\n  4724\t        create_book = migrations.CreateModel(\n  4725\t            \"Book\",\n  4726\t            [\n  4727\t                (\"id\", models.AutoField(primary_key=True)),\n  4728\t                (\"title\", models.CharField(max_length=100)),\n  4729\t                (\"author\", models.ForeignKey(\"test_authors.Author\", models.CASCADE)),\n  4730\t            ],\n  4731\t            options={},\n  4732\t        )\n  4733\t        add_hometown = migrations.AddField(\n  4734\t            \"Author\",\n  4735\t            \"hometown\",\n  4736\t            models.CharField(max_length=100),\n  4737\t        )\n  4738\t        create_old_man = migrations.RunPython(inner_method, inner_method)\n  4739\t\n  4740\t        project_state = ProjectState()\n  4741\t        new_state = project_state.clone()\n  4742\t        with connection.schema_editor() as editor:\n  4743\t            create_author.state_forwards(\"test_authors\", new_state)\n  4744\t            create_author.database_forwards(\n  4745\t                \"test_authors\", editor, project_state, new_state\n  4746\t            )\n  4747\t        project_state = new_state\n  4748\t        new_state = new_state.clone()\n  4749\t        with connection.schema_editor() as editor:\n  4750\t            create_book.state_forwards(\"test_books\", new_state)\n  4751\t            create_book.database_forwards(\n  4752\t                \"test_books\", editor, project_state, new_state\n  4753\t            )\n  4754\t        project_state = new_state\n  4755\t        new_state = new_state.clone()\n  4756\t        with connection.schema_editor() as editor:\n  4757\t            add_hometown.state_forwards(\"test_authors\", new_state)\n  4758\t            add_hometown.database_forwards(\n  4759\t                \"test_authors\", editor, project_state, new_state\n  4760\t            )\n  4761\t        project_state = new_state\n  4762\t        new_state = new_state.clone()\n  4763\t        with connection.schema_editor() as editor:\n  4764\t            create_old_man.state_forwards(\"test_books\", new_state)\n  4765\t            create_old_man.database_forwards(\n  4766\t                \"test_books\", editor, project_state, new_state\n  4767\t            )\n  4768\t\n  4769\t    def test_model_with_bigautofield(self):\n  4770\t        \"\"\"\n  4771\t        A model with BigAutoField can be created.\n  4772\t        \"\"\"\n  4773\t\n  4774\t        def create_data(models, schema_editor):\n  4775\t            Author = models.get_model(\"test_author\", \"Author\")\n  4776\t            Book = models.get_model(\"test_book\", \"Book\")\n  4777\t            author1 = Author.objects.create(name=\"Hemingway\")\n  4778\t            Book.objects.create(title=\"Old Man and The Sea\", author=author1)\n  4779\t            Book.objects.create(id=2**33, title=\"A farewell to arms\", author=author1)\n  4780\t\n  4781\t            author2 = Author.objects.create(id=2**33, name=\"Remarque\")\n  4782\t            Book.objects.create(title=\"All quiet on the western front\", author=author2)\n  4783\t            Book.objects.create(title=\"Arc de Triomphe\", author=author2)\n  4784\t\n  4785\t        create_author = migrations.CreateModel(\n  4786\t            \"Author\",\n  4787\t            [\n  4788\t                (\"id\", models.BigAutoField(primary_key=True)),\n  4789\t                (\"name\", models.CharField(max_length=100)),\n  4790\t            ],\n  4791\t            options={},\n  4792\t        )\n  4793\t        create_book = migrations.CreateModel(\n  4794\t            \"Book\",\n  4795\t            [\n  4796\t                (\"id\", models.BigAutoField(primary_key=True)),\n  4797\t                (\"title\", models.CharField(max_length=100)),\n  4798\t                (\n  4799\t                    \"author\",\n  4800\t                    models.ForeignKey(\n  4801\t                        to=\"test_author.Author\", on_delete=models.CASCADE\n  4802\t                    ),\n  4803\t                ),\n  4804\t            ],\n  4805\t            options={},\n  4806\t        )\n  4807\t        fill_data = migrations.RunPython(create_data)\n  4808\t\n  4809\t        project_state = ProjectState()\n  4810\t        new_state = project_state.clone()\n  4811\t        with connection.schema_editor() as editor:\n  4812\t            create_author.state_forwards(\"test_author\", new_state)\n  4813\t            create_author.database_forwards(\n  4814\t                \"test_author\", editor, project_state, new_state\n  4815\t            )\n  4816\t\n  4817\t        project_state = new_state\n  4818\t        new_state = new_state.clone()\n  4819\t        with connection.schema_editor() as editor:\n  4820\t            create_book.state_forwards(\"test_book\", new_state)\n  4821\t            create_book.database_forwards(\"test_book\", editor, project_state, new_state)\n  4822\t\n  4823\t        project_state = new_state\n  4824\t        new_state = new_state.clone()\n  4825\t        with connection.schema_editor() as editor:\n  4826\t            fill_data.state_forwards(\"fill_data\", new_state)\n  4827\t            fill_data.database_forwards(\"fill_data\", editor, project_state, new_state)\n  4828\t\n  4829\t    def _test_autofield_foreignfield_growth(\n  4830\t        self, source_field, target_field, target_value\n  4831\t    ):\n  4832\t        \"\"\"\n  4833\t        A field may be migrated in the following ways:\n  4834\t\n  4835\t        - AutoField to BigAutoField\n  4836\t        - SmallAutoField to AutoField\n  4837\t        - SmallAutoField to BigAutoField\n  4838\t        \"\"\"\n  4839\t\n  4840\t        def create_initial_data(models, schema_editor):\n  4841\t            Article = models.get_model(\"test_article\", \"Article\")\n  4842\t            Blog = models.get_model(\"test_blog\", \"Blog\")\n  4843\t            blog = Blog.objects.create(name=\"web development done right\")\n  4844\t            Article.objects.create(name=\"Frameworks\", blog=blog)\n  4845\t            Article.objects.create(name=\"Programming Languages\", blog=blog)\n  4846\t\n  4847\t        def create_big_data(models, schema_editor):\n  4848\t            Article = models.get_model(\"test_article\", \"Article\")\n  4849\t            Blog = models.get_model(\"test_blog\", \"Blog\")\n  4850\t            blog2 = Blog.objects.create(name=\"Frameworks\", id=target_value)\n  4851\t            Article.objects.create(name=\"Django\", blog=blog2)\n  4852\t            Article.objects.create(id=target_value, name=\"Django2\", blog=blog2)\n  4853\t\n  4854\t        create_blog = migrations.CreateModel(\n  4855\t            \"Blog\",\n  4856\t            [\n  4857\t                (\"id\", source_field(primary_key=True)),\n  4858\t                (\"name\", models.CharField(max_length=100)),\n  4859\t            ],\n  4860\t            options={},\n  4861\t        )\n  4862\t        create_article = migrations.CreateModel(\n  4863\t            \"Article\",\n  4864\t            [\n  4865\t                (\"id\", source_field(primary_key=True)),\n  4866\t                (\n  4867\t                    \"blog\",\n  4868\t                    models.ForeignKey(to=\"test_blog.Blog\", on_delete=models.CASCADE),\n  4869\t                ),\n  4870\t                (\"name\", models.CharField(max_length=100)),\n  4871\t                (\"data\", models.TextField(default=\"\")),\n  4872\t            ],\n  4873\t            options={},\n  4874\t        )\n  4875\t        fill_initial_data = migrations.RunPython(\n  4876\t            create_initial_data, create_initial_data\n  4877\t        )\n  4878\t        fill_big_data = migrations.RunPython(create_big_data, create_big_data)\n  4879\t\n  4880\t        grow_article_id = migrations.AlterField(\n  4881\t            \"Article\", \"id\", target_field(primary_key=True)\n  4882\t        )\n  4883\t        grow_blog_id = migrations.AlterField(\n  4884\t            \"Blog\", \"id\", target_field(primary_key=True)\n  4885\t        )\n  4886\t\n  4887\t        project_state = ProjectState()\n  4888\t        new_state = project_state.clone()\n  4889\t        with connection.schema_editor() as editor:\n  4890\t            create_blog.state_forwards(\"test_blog\", new_state)\n  4891\t            create_blog.database_forwards(\"test_blog\", editor, project_state, new_state)\n  4892\t\n  4893\t        project_state = new_state\n  4894\t        new_state = new_state.clone()\n  4895\t        with connection.schema_editor() as editor:\n  4896\t            create_article.state_forwards(\"test_article\", new_state)\n  4897\t            create_article.database_forwards(\n  4898\t                \"test_article\", editor, project_state, new_state\n  4899\t            )\n  4900\t\n  4901\t        project_state = new_state\n  4902\t        new_state = new_state.clone()\n  4903\t        with connection.schema_editor() as editor:\n  4904\t            fill_initial_data.state_forwards(\"fill_initial_data\", new_state)\n  4905\t            fill_initial_data.database_forwards(\n  4906\t                \"fill_initial_data\", editor, project_state, new_state\n  4907\t            )\n  4908\t\n  4909\t        project_state = new_state\n  4910\t        new_state = new_state.clone()\n  4911\t        with connection.schema_editor() as editor:\n  4912\t            grow_article_id.state_forwards(\"test_article\", new_state)\n  4913\t            grow_article_id.database_forwards(\n  4914\t                \"test_article\", editor, project_state, new_state\n  4915\t            )\n  4916\t\n  4917\t        state = new_state.clone()\n  4918\t        article = state.apps.get_model(\"test_article.Article\")\n  4919\t        self.assertIsInstance(article._meta.pk, target_field)\n  4920\t\n  4921\t        project_state = new_state\n  4922\t        new_state = new_state.clone()\n  4923\t        with connection.schema_editor() as editor:\n  4924\t            grow_blog_id.state_forwards(\"test_blog\", new_state)\n  4925\t            grow_blog_id.database_forwards(\n  4926\t                \"test_blog\", editor, project_state, new_state\n  4927\t            )\n  4928\t\n  4929\t        state = new_state.clone()\n  4930\t        blog = state.apps.get_model(\"test_blog.Blog\")\n  4931\t        self.assertIsInstance(blog._meta.pk, target_field)\n  4932\t\n  4933\t        project_state = new_state\n  4934\t        new_state = new_state.clone()\n  4935\t        with connection.schema_editor() as editor:\n  4936\t            fill_big_data.state_forwards(\"fill_big_data\", new_state)\n  4937\t            fill_big_data.database_forwards(\n  4938\t                \"fill_big_data\", editor, project_state, new_state\n  4939\t            )\n  4940\t\n  4941\t    def test_autofield__bigautofield_foreignfield_growth(self):\n  4942\t        \"\"\"A field may be migrated from AutoField to BigAutoField.\"\"\"\n  4943\t        self._test_autofield_foreignfield_growth(\n  4944\t            models.AutoField,\n  4945\t            models.BigAutoField,\n  4946\t            2**33,\n  4947\t        )\n  4948\t\n  4949\t    def test_smallfield_autofield_foreignfield_growth(self):\n  4950\t        \"\"\"A field may be migrated from SmallAutoField to AutoField.\"\"\"\n  4951\t        self._test_autofield_foreignfield_growth(\n  4952\t            models.SmallAutoField,\n  4953\t            models.AutoField,\n  4954\t            2**22,\n  4955\t        )\n  4956\t\n  4957\t    def test_smallfield_bigautofield_foreignfield_growth(self):\n  4958\t        \"\"\"A field may be migrated from SmallAutoField to BigAutoField.\"\"\"\n  4959\t        self._test_autofield_foreignfield_growth(\n  4960\t            models.SmallAutoField,\n  4961\t            models.BigAutoField,\n  4962\t            2**33,\n  4963\t        )\n  4964\t\n  4965\t    def test_run_python_noop(self):\n  4966\t        \"\"\"\n  4967\t        #24098 - Tests no-op RunPython operations.\n  4968\t        \"\"\"\n  4969\t        project_state = ProjectState()\n  4970\t        new_state = project_state.clone()\n  4971\t        operation = migrations.RunPython(\n  4972\t            migrations.RunPython.noop, migrations.RunPython.noop\n  4973\t        )\n  4974\t        with connection.schema_editor() as editor:\n  4975\t            operation.database_forwards(\n  4976\t                \"test_runpython\", editor, project_state, new_state\n  4977\t            )\n  4978\t            operation.database_backwards(\n  4979\t                \"test_runpython\", editor, new_state, project_state\n  4980\t            )\n  4981\t\n  4982\t    def test_separate_database_and_state(self):\n  4983\t        \"\"\"\n  4984\t        Tests the SeparateDatabaseAndState operation.\n  4985\t        \"\"\"\n  4986\t        project_state = self.set_up_test_model(\"test_separatedatabaseandstate\")\n  4987\t        # Create the operation\n  4988\t        database_operation = migrations.RunSQL(\n  4989\t            \"CREATE TABLE i_love_ponies (id int, special_thing int);\",\n  4990\t            \"DROP TABLE i_love_ponies;\",\n  4991\t        )\n  4992\t        state_operation = migrations.CreateModel(\n  4993\t            \"SomethingElse\", [(\"id\", models.AutoField(primary_key=True))]\n  4994\t        )\n  4995\t        operation = migrations.SeparateDatabaseAndState(\n  4996\t            state_operations=[state_operation], database_operations=[database_operation]\n  4997\t        )\n  4998\t        self.assertEqual(\n  4999\t            operation.describe(), \"Custom state/database change combination\"\n  5000\t        )\n  5001\t        # Test the state alteration\n  5002\t        new_state = project_state.clone()\n  5003\t        operation.state_forwards(\"test_separatedatabaseandstate\", new_state)\n  5004\t        self.assertEqual(\n  5005\t            len(\n  5006\t                new_state.models[\n  5007\t                    \"test_separatedatabaseandstate\", \"somethingelse\"\n  5008\t                ].fields\n  5009\t            ),\n  5010\t            1,\n  5011\t        )\n  5012\t        # Make sure there's no table\n  5013\t        self.assertTableNotExists(\"i_love_ponies\")\n  5014\t        # Test the database alteration\n  5015\t        with connection.schema_editor() as editor:\n  5016\t            operation.database_forwards(\n  5017\t                \"test_separatedatabaseandstate\", editor, project_state, new_state\n  5018\t            )\n  5019\t        self.assertTableExists(\"i_love_ponies\")\n  5020\t        # And test reversal\n  5021\t        self.assertTrue(operation.reversible)\n  5022\t        with connection.schema_editor() as editor:\n  5023\t            operation.database_backwards(\n  5024\t                \"test_separatedatabaseandstate\", editor, new_state, project_state\n  5025\t            )\n  5026\t        self.assertTableNotExists(\"i_love_ponies\")\n  5027\t        # And deconstruction\n  5028\t        definition = operation.deconstruct()\n  5029\t        self.assertEqual(definition[0], \"SeparateDatabaseAndState\")\n  5030\t        self.assertEqual(definition[1], [])\n  5031\t        self.assertEqual(\n  5032\t            sorted(definition[2]), [\"database_operations\", \"state_operations\"]\n  5033\t        )\n  5034\t\n  5035\t    def test_separate_database_and_state2(self):\n  5036\t        \"\"\"\n  5037\t        A complex SeparateDatabaseAndState operation: Multiple operations both\n  5038\t        for state and database. Verify the state dependencies within each list\n  5039\t        and that state ops don't affect the database.\n  5040\t        \"\"\"\n  5041\t        app_label = \"test_separatedatabaseandstate2\"\n  5042\t        project_state = self.set_up_test_model(app_label)\n  5043\t        # Create the operation\n  5044\t        database_operations = [\n  5045\t            migrations.CreateModel(\n  5046\t                \"ILovePonies\",\n  5047\t                [(\"id\", models.AutoField(primary_key=True))],\n  5048\t                options={\"db_table\": \"iloveponies\"},\n  5049\t            ),\n  5050\t            migrations.CreateModel(\n  5051\t                \"ILoveMorePonies\",\n  5052\t                # We use IntegerField and not AutoField because\n  5053\t                # the model is going to be deleted immediately\n  5054\t                # and with an AutoField this fails on Oracle\n  5055\t                [(\"id\", models.IntegerField(primary_key=True))],\n  5056\t                options={\"db_table\": \"ilovemoreponies\"},\n  5057\t            ),\n  5058\t            migrations.DeleteModel(\"ILoveMorePonies\"),\n  5059\t            migrations.CreateModel(\n  5060\t                \"ILoveEvenMorePonies\",\n  5061\t                [(\"id\", models.AutoField(primary_key=True))],\n  5062\t                options={\"db_table\": \"iloveevenmoreponies\"},\n  5063\t            ),\n  5064\t        ]\n  5065\t        state_operations = [\n  5066\t            migrations.CreateModel(\n  5067\t                \"SomethingElse\",\n  5068\t                [(\"id\", models.AutoField(primary_key=True))],\n  5069\t                options={\"db_table\": \"somethingelse\"},\n  5070\t            ),\n  5071\t            migrations.DeleteModel(\"SomethingElse\"),\n  5072\t            migrations.CreateModel(\n  5073\t                \"SomethingCompletelyDifferent\",\n  5074\t                [(\"id\", models.AutoField(primary_key=True))],\n  5075\t                options={\"db_table\": \"somethingcompletelydifferent\"},\n  5076\t            ),\n  5077\t        ]\n  5078\t        operation = migrations.SeparateDatabaseAndState(\n  5079\t            state_operations=state_operations,\n  5080\t            database_operations=database_operations,\n  5081\t        )\n  5082\t        # Test the state alteration\n  5083\t        new_state = project_state.clone()\n  5084\t        operation.state_forwards(app_label, new_state)\n  5085\t\n  5086\t        def assertModelsAndTables(after_db):\n  5087\t            # Tables and models exist, or don't, as they should:\n  5088\t            self.assertNotIn((app_label, \"somethingelse\"), new_state.models)\n  5089\t            self.assertEqual(\n  5090\t                len(new_state.models[app_label, \"somethingcompletelydifferent\"].fields),\n  5091\t                1,\n  5092\t            )\n  5093\t            self.assertNotIn((app_label, \"iloveponiesonies\"), new_state.models)\n  5094\t            self.assertNotIn((app_label, \"ilovemoreponies\"), new_state.models)\n  5095\t            self.assertNotIn((app_label, \"iloveevenmoreponies\"), new_state.models)\n  5096\t            self.assertTableNotExists(\"somethingelse\")\n  5097\t            self.assertTableNotExists(\"somethingcompletelydifferent\")\n  5098\t            self.assertTableNotExists(\"ilovemoreponies\")\n  5099\t            if after_db:\n  5100\t                self.assertTableExists(\"iloveponies\")\n  5101\t                self.assertTableExists(\"iloveevenmoreponies\")\n  5102\t            else:\n  5103\t                self.assertTableNotExists(\"iloveponies\")\n  5104\t                self.assertTableNotExists(\"iloveevenmoreponies\")\n  5105\t\n  5106\t        assertModelsAndTables(after_db=False)\n  5107\t        # Test the database alteration\n  5108\t        with connection.schema_editor() as editor:\n  5109\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  5110\t        assertModelsAndTables(after_db=True)\n  5111\t        # And test reversal\n  5112\t        self.assertTrue(operation.reversible)\n  5113\t        with connection.schema_editor() as editor:\n  5114\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  5115\t        assertModelsAndTables(after_db=False)\n  5116\t\n  5117\t\n  5118\tclass SwappableOperationTests(OperationTestBase):\n  5119\t    \"\"\"\n  5120\t    Key operations ignore swappable models\n  5121\t    (we don't want to replicate all of them here, as the functionality\n  5122\t    is in a common base class anyway)\n  5123\t    \"\"\"\n  5124\t\n  5125\t    available_apps = [\"migrations\"]\n  5126\t\n  5127\t    @override_settings(TEST_SWAP_MODEL=\"migrations.SomeFakeModel\")\n  5128\t    def test_create_ignore_swapped(self):\n  5129\t        \"\"\"\n  5130\t        The CreateTable operation ignores swapped models.\n  5131\t        \"\"\"\n  5132\t        operation = migrations.CreateModel(\n  5133\t            \"Pony\",\n  5134\t            [\n  5135\t                (\"id\", models.AutoField(primary_key=True)),\n  5136\t                (\"pink\", models.IntegerField(default=1)),\n  5137\t            ],\n  5138\t            options={\n  5139\t                \"swappable\": \"TEST_SWAP_MODEL\",\n  5140\t            },\n  5141\t        )\n  5142\t        # Test the state alteration (it should still be there!)\n  5143\t        project_state = ProjectState()\n  5144\t        new_state = project_state.clone()\n  5145\t        operation.state_forwards(\"test_crigsw\", new_state)\n  5146\t        self.assertEqual(new_state.models[\"test_crigsw\", \"pony\"].name, \"Pony\")\n  5147\t        self.assertEqual(len(new_state.models[\"test_crigsw\", \"pony\"].fields), 2)\n  5148\t        # Test the database alteration\n  5149\t        self.assertTableNotExists(\"test_crigsw_pony\")\n  5150\t        with connection.schema_editor() as editor:\n  5151\t            operation.database_forwards(\"test_crigsw\", editor, project_state, new_state)\n  5152\t        self.assertTableNotExists(\"test_crigsw_pony\")\n  5153\t        # And test reversal\n  5154\t        with connection.schema_editor() as editor:\n  5155\t            operation.database_backwards(\n  5156\t                \"test_crigsw\", editor, new_state, project_state\n  5157\t            )\n  5158\t        self.assertTableNotExists(\"test_crigsw_pony\")\n  5159\t\n  5160\t    @override_settings(TEST_SWAP_MODEL=\"migrations.SomeFakeModel\")\n  5161\t    def test_delete_ignore_swapped(self):\n  5162\t        \"\"\"\n  5163\t        Tests the DeleteModel operation ignores swapped models.\n  5164\t        \"\"\"\n  5165\t        operation = migrations.DeleteModel(\"Pony\")\n  5166\t        project_state, new_state = self.make_test_state(\"test_dligsw\", operation)\n  5167\t        # Test the database alteration\n  5168\t        self.assertTableNotExists(\"test_dligsw_pony\")\n  5169\t        with connection.schema_editor() as editor:\n  5170\t            operation.database_forwards(\"test_dligsw\", editor, project_state, new_state)\n  5171\t        self.assertTableNotExists(\"test_dligsw_pony\")\n  5172\t        # And test reversal\n  5173\t        with connection.schema_editor() as editor:\n  5174\t            operation.database_backwards(\n  5175\t                \"test_dligsw\", editor, new_state, project_state\n  5176\t            )\n  5177\t        self.assertTableNotExists(\"test_dligsw_pony\")\n  5178\t\n  5179\t    @override_settings(TEST_SWAP_MODEL=\"migrations.SomeFakeModel\")\n  5180\t    def test_add_field_ignore_swapped(self):\n  5181\t        \"\"\"\n  5182\t        Tests the AddField operation.\n  5183\t        \"\"\"\n  5184\t        # Test the state alteration\n  5185\t        operation = migrations.AddField(\n  5186\t            \"Pony\",\n  5187\t            \"height\",\n  5188\t            models.FloatField(null=True, default=5),\n  5189\t        )\n  5190\t        project_state, new_state = self.make_test_state(\"test_adfligsw\", operation)\n  5191\t        # Test the database alteration\n  5192\t        self.assertTableNotExists(\"test_adfligsw_pony\")\n  5193\t        with connection.schema_editor() as editor:\n  5194\t            operation.database_forwards(\n  5195\t                \"test_adfligsw\", editor, project_state, new_state\n  5196\t            )\n  5197\t        self.assertTableNotExists(\"test_adfligsw_pony\")\n  5198\t        # And test reversal\n  5199\t        with connection.schema_editor() as editor:\n  5200\t            operation.database_backwards(\n  5201\t                \"test_adfligsw\", editor, new_state, project_state\n  5202\t            )\n  5203\t        self.assertTableNotExists(\"test_adfligsw_pony\")\n  5204\t\n  5205\t    @override_settings(TEST_SWAP_MODEL=\"migrations.SomeFakeModel\")\n  5206\t    def test_indexes_ignore_swapped(self):\n  5207\t        \"\"\"\n  5208\t        Add/RemoveIndex operations ignore swapped models.\n  5209\t        \"\"\"\n  5210\t        operation = migrations.AddIndex(\n  5211\t            \"Pony\", models.Index(fields=[\"pink\"], name=\"my_name_idx\")\n  5212\t        )\n  5213\t        project_state, new_state = self.make_test_state(\"test_adinigsw\", operation)\n  5214\t        with connection.schema_editor() as editor:\n  5215\t            # No database queries should be run for swapped models\n  5216\t            operation.database_forwards(\n  5217\t                \"test_adinigsw\", editor, project_state, new_state\n  5218\t            )\n  5219\t            operation.database_backwards(\n  5220\t                \"test_adinigsw\", editor, new_state, project_state\n  5221\t            )\n  5222\t\n  5223\t        operation = migrations.RemoveIndex(\n  5224\t            \"Pony\", models.Index(fields=[\"pink\"], name=\"my_name_idx\")\n  5225\t        )\n  5226\t        project_state, new_state = self.make_test_state(\"test_rminigsw\", operation)\n  5227\t        with connection.schema_editor() as editor:\n  5228\t            operation.database_forwards(\n  5229\t                \"test_rminigsw\", editor, project_state, new_state\n  5230\t            )\n  5231\t            operation.database_backwards(\n  5232\t                \"test_rminigsw\", editor, new_state, project_state\n  5233\t            )\n  5234\t\n  5235\t\n  5236\tclass TestCreateModel(SimpleTestCase):\n  5237\t    def test_references_model_mixin(self):\n  5238\t        migrations.CreateModel(\n  5239\t            \"name\",\n  5240\t            fields=[],\n  5241\t            bases=(Mixin, models.Model),\n  5242\t        ).references_model(\"other_model\", \"migrations\")\n  5243\t\n  5244\t\n  5245\tclass FieldOperationTests(SimpleTestCase):\n  5246\t    def test_references_model(self):\n  5247\t        operation = FieldOperation(\n  5248\t            \"MoDel\", \"field\", models.ForeignKey(\"Other\", models.CASCADE)\n  5249\t        )\n  5250\t        # Model name match.\n  5251\t        self.assertIs(operation.references_model(\"mOdEl\", \"migrations\"), True)\n  5252\t        # Referenced field.\n  5253\t        self.assertIs(operation.references_model(\"oTher\", \"migrations\"), True)\n  5254\t        # Doesn't reference.\n  5255\t        self.assertIs(operation.references_model(\"Whatever\", \"migrations\"), False)\n  5256\t\n  5257\t    def test_references_field_by_name(self):\n  5258\t        operation = FieldOperation(\"MoDel\", \"field\", models.BooleanField(default=False))\n  5259\t        self.assertIs(operation.references_field(\"model\", \"field\", \"migrations\"), True)\n  5260\t\n  5261\t    def test_references_field_by_remote_field_model(self):\n  5262\t        operation = FieldOperation(\n  5263\t            \"Model\", \"field\", models.ForeignKey(\"Other\", models.CASCADE)\n  5264\t        )\n  5265\t        self.assertIs(\n  5266\t            operation.references_field(\"Other\", \"whatever\", \"migrations\"), True\n  5267\t        )\n  5268\t        self.assertIs(\n  5269\t            operation.references_field(\"Missing\", \"whatever\", \"migrations\"), False\n  5270\t        )\n  5271\t\n  5272\t    def test_references_field_by_from_fields(self):\n  5273\t        operation = FieldOperation(\n  5274\t            \"Model\",\n  5275\t            \"field\",\n  5276\t            models.fields.related.ForeignObject(\n  5277\t                \"Other\", models.CASCADE, [\"from\"], [\"to\"]\n  5278\t            ),\n  5279\t        )\n  5280\t        self.assertIs(operation.references_field(\"Model\", \"from\", \"migrations\"), True)\n  5281\t        self.assertIs(operation.references_field(\"Model\", \"to\", \"migrations\"), False)\n  5282\t        self.assertIs(operation.references_field(\"Other\", \"from\", \"migrations\"), False)\n  5283\t        self.assertIs(operation.references_field(\"Model\", \"to\", \"migrations\"), False)\n  5284\t\n  5285\t    def test_references_field_by_to_fields(self):\n  5286\t        operation = FieldOperation(\n  5287\t            \"Model\",\n  5288\t            \"field\",\n  5289\t            models.ForeignKey(\"Other\", models.CASCADE, to_field=\"field\"),\n  5290\t        )\n  5291\t        self.assertIs(operation.references_field(\"Other\", \"field\", \"migrations\"), True)\n  5292\t        self.assertIs(\n  5293\t            operation.references_field(\"Other\", \"whatever\", \"migrations\"), False\n  5294\t        )\n  5295\t        self.assertIs(\n  5296\t            operation.references_field(\"Missing\", \"whatever\", \"migrations\"), False\n  5297\t        )\n  5298\t\n  5299\t    def test_references_field_by_through(self):\n  5300\t        operation = FieldOperation(\n  5301\t            \"Model\", \"field\", models.ManyToManyField(\"Other\", through=\"Through\")\n  5302\t        )\n  5303\t        self.assertIs(\n  5304\t            operation.references_field(\"Other\", \"whatever\", \"migrations\"), True\n  5305\t        )\n  5306\t        self.assertIs(\n  5307\t            operation.references_field(\"Through\", \"whatever\", \"migrations\"), True\n  5308\t        )\n  5309\t        self.assertIs(\n  5310\t            operation.references_field(\"Missing\", \"whatever\", \"migrations\"), False\n  5311\t        )\n  5312\t\n  5313\t    def test_reference_field_by_through_fields(self):\n  5314\t        operation = FieldOperation(\n  5315\t            \"Model\",\n  5316\t            \"field\",\n  5317\t            models.ManyToManyField(\n  5318\t                \"Other\", through=\"Through\", through_fields=(\"first\", \"second\")\n  5319\t            ),\n  5320\t        )\n  5321\t        self.assertIs(\n  5322\t            operation.references_field(\"Other\", \"whatever\", \"migrations\"), True\n  5323\t        )\n  5324\t        self.assertIs(\n  5325\t            operation.references_field(\"Through\", \"whatever\", \"migrations\"), False\n  5326\t        )\n  5327\t        self.assertIs(\n  5328\t            operation.references_field(\"Through\", \"first\", \"migrations\"), True\n  5329\t        )\n  5330\t        self.assertIs(\n  5331\t            operation.references_field(\"Through\", \"second\", \"migrations\"), True\n  5332\t        )\n  5333\t\n```\n\n</observation>",
                  "type": "tool_result",
                  "cache_control": {
                    "type": "ephemeral"
                  }
                }
              ]
            },
            {
              "role": "assistant",
              "content": [
                {
                  "type": "text",
                  "text": "<thoughts>\n1. From the test file, I can see this is related to the RenameIndex operation and how it handles unnamed indexes when moving backward and forward.\n\n2. Let me search for the RenameIndex operation implementation to understand how it currently works.\n</thoughts>"
                },
                {
                  "id": "call_459acff2",
                  "input": {
                    "file_pattern": null,
                    "query": "RenameIndex operation implementation",
                    "category": "implementation"
                  },
                  "type": "tool_use",
                  "name": "SemanticSearch",
                  "cache_control": {
                    "type": "ephemeral"
                  }
                }
              ]
            },
            {
              "role": "user",
              "content": [
                {
                  "tool_use_id": "call_459acff2",
                  "content": "<observation>\nFound 15 code sections.\n\nViewed relevant code:\ndjango/db/migrations/operations/models.py\n```\n     1\tfrom django.db import models\n     2\tfrom django.db.migrations.operations.base import Operation\n     3\tfrom django.db.migrations.state import ModelState\n     4\tfrom django.db.migrations.utils import field_references, resolve_relation\n     5\tfrom django.db.models.options import normalize_together\n     6\tfrom django.utils.functional import cached_property\n     7\t\n     8\tfrom .fields import AddField, AlterField, FieldOperation, RemoveField, RenameField\n      # ...\n   877\t\n   878\t\n   879\tclass RenameIndex(IndexOperation):\n   880\t    \"\"\"Rename an index.\"\"\"\n   881\t\n   882\t    def __init__(self, model_name, new_name, old_name=None, old_fields=None):\n   883\t        if not old_name and not old_fields:\n   884\t            raise ValueError(\n   885\t                \"RenameIndex requires one of old_name and old_fields arguments to be \"\n   886\t                \"set.\"\n   887\t            )\n   888\t        if old_name and old_fields:\n   889\t            raise ValueError(\n   890\t                \"RenameIndex.old_name and old_fields are mutually exclusive.\"\n   891\t            )\n   892\t        self.model_name = model_name\n   893\t        self.new_name = new_name\n   894\t        self.old_name = old_name\n   895\t        self.old_fields = old_fields\n   896\t\n   897\t    @cached_property\n   898\t    def old_name_lower(self):\n   899\t        return self.old_name.lower()\n   900\t\n   901\t    @cached_property\n   902\t    def new_name_lower(self):\n   903\t        return self.new_name.lower()\n   904\t\n   905\t    def deconstruct(self):\n   906\t        kwargs = {\n   907\t            \"model_name\": self.model_name,\n   908\t            \"new_name\": self.new_name,\n   909\t        }\n   910\t        if self.old_name:\n   911\t            kwargs[\"old_name\"] = self.old_name\n   912\t        if self.old_fields:\n   913\t            kwargs[\"old_fields\"] = self.old_fields\n   914\t        return (self.__class__.__qualname__, [], kwargs)\n   915\t\n   916\t    def state_forwards(self, app_label, state):\n   917\t        if self.old_fields:\n   918\t            state.add_index(\n   919\t                app_label,\n   920\t                self.model_name_lower,\n   921\t                models.Index(fields=self.old_fields, name=self.new_name),\n   922\t            )\n   923\t            state.remove_model_options(\n   924\t                app_label,\n   925\t                self.model_name_lower,\n   926\t                AlterIndexTogether.option_name,\n   927\t                self.old_fields,\n   928\t            )\n   929\t        else:\n   930\t            state.rename_index(\n   931\t                app_label, self.model_name_lower, self.old_name, self.new_name\n   932\t            )\n   933\t\n   934\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n   935\t        model = to_state.apps.get_model(app_label, self.model_name)\n   936\t        if not self.allow_migrate_model(schema_editor.connection.alias, model):\n   937\t            return\n   938\t\n   939\t        if self.old_fields:\n   940\t            from_model = from_state.apps.get_model(app_label, self.model_name)\n   941\t            columns = [\n   942\t                from_model._meta.get_field(field).column for field in self.old_fields\n   943\t            ]\n   944\t            matching_index_name = schema_editor._constraint_names(\n   945\t                from_model, column_names=columns, index=True\n   946\t            )\n   947\t            if len(matching_index_name) != 1:\n   948\t                raise ValueError(\n   949\t                    \"Found wrong number (%s) of indexes for %s(%s).\"\n   950\t                    % (\n   951\t                        len(matching_index_name),\n   952\t                        from_model._meta.db_table,\n   953\t                        \", \".join(columns),\n   954\t                    )\n   955\t                )\n   956\t            old_index = models.Index(\n   957\t                fields=self.old_fields,\n   958\t                name=matching_index_name[0],\n   959\t            )\n   960\t        else:\n   961\t            from_model_state = from_state.models[app_label, self.model_name_lower]\n   962\t            old_index = from_model_state.get_index_by_name(self.old_name)\n   963\t\n   964\t        to_model_state = to_state.models[app_label, self.model_name_lower]\n   965\t        new_index = to_model_state.get_index_by_name(self.new_name)\n   966\t        schema_editor.rename_index(model, old_index, new_index)\n   967\t\n   968\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n   969\t        if self.old_fields:\n   970\t            # Backward operation with unnamed index is a no-op.\n   971\t            return\n   972\t\n   973\t        self.new_name_lower, self.old_name_lower = (\n   974\t            self.old_name_lower,\n   975\t            self.new_name_lower,\n   976\t        )\n   977\t        self.new_name, self.old_name = self.old_name, self.new_name\n   978\t\n   979\t        self.database_forwards(app_label, schema_editor, from_state, to_state)\n   980\t\n   981\t        self.new_name_lower, self.old_name_lower = (\n   982\t            self.old_name_lower,\n   983\t            self.new_name_lower,\n   984\t        )\n   985\t        self.new_name, self.old_name = self.old_name, self.new_name\n   986\t\n   987\t    def describe(self):\n   988\t        if self.old_name:\n   989\t            return (\n   990\t                f\"Rename index {self.old_name} on {self.model_name} to {self.new_name}\"\n   991\t            )\n   992\t        return (\n   993\t            f\"Rename unnamed index for {self.old_fields} on {self.model_name} to \"\n   994\t            f\"{self.new_name}\"\n   995\t        )\n   996\t\n   997\t    @property\n   998\t    def migration_name_fragment(self):\n   999\t        if self.old_name:\n  1000\t            return \"rename_%s_%s\" % (self.old_name_lower, self.new_name_lower)\n  1001\t        return \"rename_%s_%s_%s\" % (\n  1002\t            self.model_name_lower,\n  1003\t            \"_\".join(self.old_fields),\n  1004\t            self.new_name_lower,\n  1005\t        )\n  1006\t\n  1007\t    def reduce(self, operation, app_label):\n  1008\t        if (\n  1009\t            isinstance(operation, RenameIndex)\n  1010\t            and self.model_name_lower == operation.model_name_lower\n  1011\t            and operation.old_name\n  1012\t            and self.new_name_lower == operation.old_name_lower\n  1013\t        ):\n  1014\t            return [\n  1015\t                RenameIndex(\n  1016\t                    self.model_name,\n  1017\t                    new_name=operation.new_name,\n  1018\t                    old_name=self.old_name,\n  1019\t                    old_fields=self.old_fields,\n  1020\t                )\n  1021\t            ]\n  1022\t        return super().reduce(operation, app_label)\n      # ...\n```\n\n\ndjango/db/backends/base/schema.py\n```\n     1\timport logging\n     2\timport operator\n     3\tfrom datetime import datetime\n     4\t\n     5\tfrom django.db.backends.ddl_references import (\n     6\t    Columns,\n     7\t    Expressions,\n     8\t    ForeignKeyName,\n     9\t    IndexName,\n    10\t    Statement,\n    11\t    Table,\n    12\t)\n    13\tfrom django.db.backends.utils import names_digest, split_identifier\n    14\tfrom django.db.models import Deferrable, Index\n    15\tfrom django.db.models.sql import Query\n    16\tfrom django.db.transaction import TransactionManagementError, atomic\n    17\tfrom django.utils import timezone\n    18\t\n    19\tlogger = logging.getLogger(\"django.db.backends.schema\")\n      # ...\n    72\t\n    73\t\n    74\tclass BaseDatabaseSchemaEditor:\n    75\t    \"\"\"\n    76\t    This class and its subclasses are responsible for emitting schema-changing\n    77\t    statements to the databases - model creation/removal/alteration, field\n    78\t    renaming, index fiddling, and so on.\n    79\t    \"\"\"\n    80\t\n    81\t    # Overrideable SQL templates\n    82\t    sql_create_table = \"CREATE TABLE %(table)s (%(definition)s)\"\n    83\t    sql_rename_table = \"ALTER TABLE %(old_table)s RENAME TO %(new_table)s\"\n    84\t    sql_retablespace_table = \"ALTER TABLE %(table)s SET TABLESPACE %(new_tablespace)s\"\n    85\t    sql_delete_table = \"DROP TABLE %(table)s CASCADE\"\n    86\t\n    87\t    sql_create_column = \"ALTER TABLE %(table)s ADD COLUMN %(column)s %(definition)s\"\n    88\t    sql_alter_column = \"ALTER TABLE %(table)s %(changes)s\"\n    89\t    sql_alter_column_type = \"ALTER COLUMN %(column)s TYPE %(type)s\"\n    90\t    sql_alter_column_null = \"ALTER COLUMN %(column)s DROP NOT NULL\"\n    91\t    sql_alter_column_not_null = \"ALTER COLUMN %(column)s SET NOT NULL\"\n    92\t    sql_alter_column_default = \"ALTER COLUMN %(column)s SET DEFAULT %(default)s\"\n    93\t    sql_alter_column_no_default = \"ALTER COLUMN %(column)s DROP DEFAULT\"\n    94\t    sql_alter_column_no_default_null = sql_alter_column_no_default\n    95\t    sql_alter_column_collate = \"ALTER COLUMN %(column)s TYPE %(type)s%(collation)s\"\n    96\t    sql_delete_column = \"ALTER TABLE %(table)s DROP COLUMN %(column)s CASCADE\"\n    97\t    sql_rename_column = (\n    98\t        \"ALTER TABLE %(table)s RENAME COLUMN %(old_column)s TO %(new_column)s\"\n    99\t    )\n   100\t    sql_update_with_default = (\n   101\t        \"UPDATE %(table)s SET %(column)s = %(default)s WHERE %(column)s IS NULL\"\n   102\t    )\n   103\t\n   104\t    sql_unique_constraint = \"UNIQUE (%(columns)s)%(deferrable)s\"\n   105\t    sql_check_constraint = \"CHECK (%(check)s)\"\n   106\t    sql_delete_constraint = \"ALTER TABLE %(table)s DROP CONSTRAINT %(name)s\"\n   107\t    sql_constraint = \"CONSTRAINT %(name)s %(constraint)s\"\n   108\t\n   109\t    sql_create_check = \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s CHECK (%(check)s)\"\n   110\t    sql_delete_check = sql_delete_constraint\n   111\t\n   112\t    sql_create_unique = (\n   113\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s \"\n   114\t        \"UNIQUE (%(columns)s)%(deferrable)s\"\n   115\t    )\n   116\t    sql_delete_unique = sql_delete_constraint\n   117\t\n   118\t    sql_create_fk = (\n   119\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s FOREIGN KEY (%(column)s) \"\n   120\t        \"REFERENCES %(to_table)s (%(to_column)s)%(deferrable)s\"\n   121\t    )\n   122\t    sql_create_inline_fk = None\n   123\t    sql_create_column_inline_fk = None\n   124\t    sql_delete_fk = sql_delete_constraint\n   125\t\n   126\t    sql_create_index = (\n   127\t        \"CREATE INDEX %(name)s ON %(table)s \"\n   128\t        \"(%(columns)s)%(include)s%(extra)s%(condition)s\"\n   129\t    )\n   130\t    sql_create_unique_index = (\n   131\t        \"CREATE UNIQUE INDEX %(name)s ON %(table)s \"\n   132\t        \"(%(columns)s)%(include)s%(condition)s\"\n   133\t    )\n   134\t    sql_rename_index = \"ALTER INDEX %(old_name)s RENAME TO %(new_name)s\"\n   135\t    sql_delete_index = \"DROP INDEX %(name)s\"\n   136\t\n   137\t    sql_create_pk = (\n   138\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s PRIMARY KEY (%(columns)s)\"\n   139\t    )\n   140\t    sql_delete_pk = sql_delete_constraint\n   141\t\n   142\t    sql_delete_procedure = \"DROP PROCEDURE %(procedure)s\"\n          # ...\n  1374\t\n  1375\t    def _rename_index_sql(self, model, old_name, new_name):\n  1376\t        return Statement(\n  1377\t            self.sql_rename_index,\n  1378\t            table=Table(model._meta.db_table, self.quote_name),\n  1379\t            old_name=self.quote_name(old_name),\n  1380\t            new_name=self.quote_name(new_name),\n  1381\t        )\n          # ...\n```\n\n</observation>",
                  "type": "tool_result",
                  "cache_control": {
                    "type": "ephemeral"
                  }
                }
              ]
            }
          ],
          "response": {
            "id": "msg_014ugDdc5v16Ki16Go7oYuPf",
            "content": [
              {
                "text": "<thoughts>\n1. Looking at the code, I can see that RenameIndex has two modes:\n   - Renaming an index by old_name \n   - Renaming an unnamed index by old_fields\n\n2. The issue appears to be in the database_backwards() method when dealing with unnamed indexes. The method has a comment \"Backward operation with unnamed index is a no-op\" and just returns without doing anything.\n\n3. This means that when trying to revert an unnamed index rename operation, it doesn't properly restore the old auto-generated name.\n\n4. The fix should be to:\n   - Remove the early return for unnamed indexes in database_backwards()\n   - Handle the reversal properly by swapping names and letting database_forwards() handle it\n\nLet me look at the test file again to understand the exact test case that's failing.\n</thoughts>",
                "type": "text"
              },
              {
                "id": "toolu_018uwp3sxMLYJobTzZfi6xBd",
                "input": {
                  "files": [
                    {
                      "file_path": "tests/migrations/test_operations.py",
                      "start_line": 2980,
                      "end_line": 3000
                    }
                  ]
                },
                "name": "ViewCode",
                "type": "tool_use"
              }
            ],
            "model": "claude-3-5-sonnet-20241022",
            "role": "assistant",
            "stop_reason": "tool_use",
            "stop_sequence": null,
            "type": "message",
            "usage": {
              "cache_creation_input_tokens": 3846,
              "cache_read_input_tokens": 87303,
              "input_tokens": 4,
              "output_tokens": 280
            }
          },
          "usage": {
            "completion_cost": 0.01575,
            "completion_tokens": 280,
            "prompt_tokens": 3850,
            "cached_tokens": 87303
          }
        }
      },
      "possible_actions": [
        "SemanticSearch",
        "FindClass",
        "FindFunction",
        "FindCodeSnippet",
        "ViewCode",
        "ClaudeEditTool"
      ],
      "output": {
        "message": "Here's the contents of the requested code spans:\ntests/migrations/test_operations.py\n```\n     1\tfrom django.core.exceptions import FieldDoesNotExist\n     2\tfrom django.db import IntegrityError, connection, migrations, models, transaction\n     3\tfrom django.db.migrations.migration import Migration\n     4\tfrom django.db.migrations.operations.fields import FieldOperation\n     5\tfrom django.db.migrations.state import ModelState, ProjectState\n     6\tfrom django.db.models.functions import Abs\n     7\tfrom django.db.transaction import atomic\n     8\tfrom django.test import SimpleTestCase, override_settings, skipUnlessDBFeature\n     9\tfrom django.test.utils import CaptureQueriesContext\n    10\t\n    11\tfrom .models import FoodManager, FoodQuerySet, UnicodeModel\n    12\tfrom .test_base import OperationTestBase\n      # ...\n    17\t\n    18\t\n    19\tclass OperationTests(OperationTestBase):\n    20\t    \"\"\"\n    21\t    Tests running the operations and making sure they do what they say they do.\n    22\t    Each test looks at their state changing, and then their database operation -\n    23\t    both forwards and backwards.\n    24\t    \"\"\"\n          # ...\n  2963\t\n  2964\t    def test_rename_index_unnamed_index(self):\n  2965\t        app_label = \"test_rninui\"\n  2966\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  2967\t        table_name = app_label + \"_pony\"\n  2968\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2969\t        operation = migrations.RenameIndex(\n  2970\t            \"Pony\", new_name=\"new_pony_test_idx\", old_fields=(\"weight\", \"pink\")\n  2971\t        )\n  2972\t        self.assertEqual(\n  2973\t            operation.describe(),\n  2974\t            \"Rename unnamed index for ('weight', 'pink') on Pony to new_pony_test_idx\",\n  2975\t        )\n  2976\t        self.assertEqual(\n  2977\t            operation.migration_name_fragment,\n  2978\t            \"rename_pony_weight_pink_new_pony_test_idx\",\n  2979\t        )\n  2980\t\n  2981\t        new_state = project_state.clone()\n  2982\t        operation.state_forwards(app_label, new_state)\n  2983\t        # Rename index.\n  2984\t        with connection.schema_editor() as editor:\n  2985\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2986\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2987\t        # Reverse is a no-op.\n  2988\t        with connection.schema_editor() as editor, self.assertNumQueries(0):\n  2989\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2990\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2991\t        # Deconstruction.\n  2992\t        definition = operation.deconstruct()\n  2993\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2994\t        self.assertEqual(definition[1], [])\n  2995\t        self.assertEqual(\n  2996\t            definition[2],\n  2997\t            {\n  2998\t                \"model_name\": \"Pony\",\n  2999\t                \"new_name\": \"new_pony_test_idx\",\n  3000\t                \"old_fields\": (\"weight\", \"pink\"),\n  3001\t            },\n  3002\t        )\n          # ...\n      # ...\n```\n",
        "summary": "Showed the following code spans:\n\nFile: tests/migrations/test_operations.py\n- Showing all code in file\n\nFile: django/db/migrations/operations/models.py\n- imports\n- RenameIndex\n- RenameIndex.__init__\n- RenameIndex.old_name_lower\n- RenameIndex.new_name_lower\n- RenameIndex.deconstruct\n- RenameIndex.state_forwards\n- RenameIndex.database_forwards\n- RenameIndex.database_backwards\n- RenameIndex.describe\n- RenameIndex.migration_name_fragment\n- RenameIndex.reduce\n\nFile: django/db/backends/base/schema.py\n- imports\n- BaseDatabaseSchemaEditor\n- BaseDatabaseSchemaEditor._rename_index_sql\n",
        "terminal": false,
        "expect_correction": false,
        "properties": {
          "files": {
            "tests/migrations/test_operations.py": {
              "new_span_ids": [
                "OperationTests",
                "OperationTests.test_rename_index_unnamed_index"
              ]
            }
          }
        }
      },
      "parent_id": 2
    },
    {
      "node_id": 4,
      "action": {
        "scratch_pad": "Looking at the test case, I can see that:\n\n1. The test is specifically checking that RenameIndex works with unnamed indexes (created via index_together)\n\n2. The test expects that:\n   - Forward operation renames the unnamed index to \"new_pony_test_idx\"\n   - Backward operation is currently a no-op and keeps \"new_pony_test_idx\"\n\n3. The issue is that this behavior is incorrect - the backward operation should restore the original auto-generated name for the index.\n\n4. The fix needs to:\n   - Remove the early return in database_backwards() for unnamed indexes\n   - Let the normal name swapping and database_forwards() handle restoring the original name\n\nLet me look at the ProjectState code to understand how it handles index names.",
        "query": "ProjectState index_together handling",
        "category": "implementation",
        "action_args_class": "moatless.actions.semantic_search.SemanticSearchArgs"
      },
      "observation": {
        "message": "Found 14 code sections.\n\nViewed relevant code:\ndjango/db/migrations/state.py\n```\n     1\timport copy\n     2\tfrom collections import defaultdict\n     3\tfrom contextlib import contextmanager\n     4\tfrom functools import partial\n     5\t\n     6\tfrom django.apps import AppConfig\n     7\tfrom django.apps.registry import Apps\n     8\tfrom django.apps.registry import apps as global_apps\n     9\tfrom django.conf import settings\n    10\tfrom django.core.exceptions import FieldDoesNotExist\n    11\tfrom django.db import models\n    12\tfrom django.db.migrations.utils import field_is_referenced, get_references\n    13\tfrom django.db.models import NOT_PROVIDED\n    14\tfrom django.db.models.fields.related import RECURSIVE_RELATIONSHIP_CONSTANT\n    15\tfrom django.db.models.options import DEFAULT_NAMES, normalize_together\n    16\tfrom django.db.models.utils import make_model_tuple\n    17\tfrom django.utils.functional import cached_property\n    18\tfrom django.utils.module_loading import import_string\n    19\tfrom django.utils.version import get_docs_version\n    20\t\n    21\tfrom .exceptions import InvalidBasesError\n    22\tfrom .utils import resolve_relation\n      # ...\n    91\t\n    92\t\n    93\tclass ProjectState:\n    94\t    \"\"\"\n    95\t    Represent the entire project's overall state. This is the item that is\n    96\t    passed around - do it here rather than at the app level so that cross-app\n    97\t    FKs/etc. resolve properly.\n    98\t    \"\"\"\n          # ...\n   180\t\n   181\t    def alter_model_options(self, app_label, model_name, options, option_keys=None):\n   182\t        model_state = self.models[app_label, model_name]\n   183\t        model_state.options = {**model_state.options, **options}\n   184\t        if option_keys:\n   185\t            for key in option_keys:\n   186\t                if key not in options:\n   187\t                    model_state.options.pop(key, False)\n   188\t        self.reload_model(app_label, model_name, delay=True)\n   189\t\n   190\t    def remove_model_options(self, app_label, model_name, option_name, value_to_remove):\n   191\t        model_state = self.models[app_label, model_name]\n   192\t        if objs := model_state.options.get(option_name):\n   193\t            model_state.options[option_name] = [\n   194\t                obj for obj in objs if tuple(obj) != tuple(value_to_remove)\n   195\t            ]\n   196\t        self.reload_model(app_label, model_name, delay=True)\n          # ...\n      # ...\n```\n",
        "summary": "Found relevant code sections in the search results.",
        "terminal": false,
        "expect_correction": false,
        "properties": {
          "search_hits": [],
          "search_tokens": 896,
          "new_span_ids": [
            "ProjectState",
            "ProjectState.alter_model_options",
            "ProjectState.remove_model_options"
          ]
        },
        "execution_completion": {
          "model": "claude-3-5-sonnet-20241022",
          "input": [
            {
              "role": "user",
              "content": "Search request:\nSearching for code using the query: ProjectState index_together handling\n\nIdentify the relevant code sections in the search results to use them. \n\n<search_results>\ndjango/db/migrations/state.py\n```\n\n\n\n<span id='imports'>\n     1\timport copy\n     2\tfrom collections import defaultdict\n     3\tfrom contextlib import contextmanager\n     4\tfrom functools import partial\n     5\t\n     6\tfrom django.apps import AppConfig\n     7\tfrom django.apps.registry import Apps\n     8\tfrom django.apps.registry import apps as global_apps\n     9\tfrom django.conf import settings\n    10\tfrom django.core.exceptions import FieldDoesNotExist\n    11\tfrom django.db import models\n    12\tfrom django.db.migrations.utils import field_is_referenced, get_references\n    13\tfrom django.db.models import NOT_PROVIDED\n    14\tfrom django.db.models.fields.related import RECURSIVE_RELATIONSHIP_CONSTANT\n    15\tfrom django.db.models.options import DEFAULT_NAMES, normalize_together\n    16\tfrom django.db.models.utils import make_model_tuple\n    17\tfrom django.utils.functional import cached_property\n    18\tfrom django.utils.module_loading import import_string\n    19\tfrom django.utils.version import get_docs_version\n    20\t\n    21\tfrom .exceptions import InvalidBasesError\n    22\tfrom .utils import resolve_relation\n      # ...\n\n\n<span id='ProjectState'>\n    91\t\n    92\t\n    93\tclass ProjectState:\n    94\t    \"\"\"\n    95\t    Represent the entire project's overall state. This is the item that is\n    96\t    passed around - do it here rather than at the app level so that cross-app\n    97\t    FKs/etc. resolve properly.\n    98\t    \"\"\"\n\n\n<span id='ProjectState.__init__'>\n    99\t\n   100\t    def __init__(self, models=None, real_apps=None):\n   101\t        self.models = models or {}\n   102\t        # Apps to include from main registry, usually unmigrated ones\n   103\t        if real_apps is None:\n   104\t            real_apps = set()\n   105\t        else:\n   106\t            assert isinstance(real_apps, set)\n   107\t        self.real_apps = real_apps\n   108\t        self.is_delayed = False\n   109\t        # {remote_model_key: {model_key: {field_name: field}}}\n   110\t        self._relations = None\n          # ...\n\n\n<span id='ProjectState.alter_model_options'>\n   180\t\n   181\t    def alter_model_options(self, app_label, model_name, options, option_keys=None):\n   182\t        model_state = self.models[app_label, model_name]\n   183\t        model_state.options = {**model_state.options, **options}\n   184\t        if option_keys:\n   185\t            for key in option_keys:\n   186\t                if key not in options:\n   187\t                    model_state.options.pop(key, False)\n   188\t        self.reload_model(app_label, model_name, delay=True)\n\n\n<span id='ProjectState.remove_model_options'>\n   189\t\n   190\t    def remove_model_options(self, app_label, model_name, option_name, value_to_remove):\n   191\t        model_state = self.models[app_label, model_name]\n   192\t        if objs := model_state.options.get(option_name):\n   193\t            model_state.options[option_name] = [\n   194\t                obj for obj in objs if tuple(obj) != tuple(value_to_remove)\n   195\t            ]\n   196\t        self.reload_model(app_label, model_name, delay=True)\n\n\n<span id='ProjectState.alter_model_managers'>\n   197\t\n   198\t    def alter_model_managers(self, app_label, model_name, managers):\n   199\t        model_state = self.models[app_label, model_name]\n   200\t        model_state.managers = list(managers)\n   201\t        self.reload_model(app_label, model_name, delay=True)\n\n\n<span id='ProjectState._append_option'>\n   202\t\n   203\t    def _append_option(self, app_label, model_name, option_name, obj):\n   204\t        model_state = self.models[app_label, model_name]\n   205\t        model_state.options[option_name] = [*model_state.options[option_name], obj]\n   206\t        self.reload_model(app_label, model_name, delay=True)\n\n\n<span id='ProjectState._remove_option'>\n   207\t\n   208\t    def _remove_option(self, app_label, model_name, option_name, obj_name):\n   209\t        model_state = self.models[app_label, model_name]\n   210\t        objs = model_state.options[option_name]\n   211\t        model_state.options[option_name] = [obj for obj in objs if obj.name != obj_name]\n   212\t        self.reload_model(app_label, model_name, delay=True)\n\n\n<span id='ProjectState.add_index'>\n   213\t\n   214\t    def add_index(self, app_label, model_name, index):\n   215\t        self._append_option(app_label, model_name, \"indexes\", index)\n\n\n<span id='ProjectState.remove_index'>\n   216\t\n   217\t    def remove_index(self, app_label, model_name, index_name):\n   218\t        self._remove_option(app_label, model_name, \"indexes\", index_name)\n\n\n<span id='ProjectState.rename_index'>\n   219\t\n   220\t    def rename_index(self, app_label, model_name, old_index_name, new_index_name):\n   221\t        model_state = self.models[app_label, model_name]\n   222\t        objs = model_state.options[\"indexes\"]\n   223\t\n   224\t        new_indexes = []\n   225\t        for obj in objs:\n   226\t            if obj.name == old_index_name:\n   227\t                obj = obj.clone()\n   228\t                obj.name = new_index_name\n   229\t            new_indexes.append(obj)\n   230\t\n   231\t        model_state.options[\"indexes\"] = new_indexes\n   232\t        self.reload_model(app_label, model_name, delay=True)\n\n\n<span id='ProjectState.add_constraint'>\n   233\t\n   234\t    def add_constraint(self, app_label, model_name, constraint):\n   235\t        self._append_option(app_label, model_name, \"constraints\", constraint)\n\n\n<span id='ProjectState.remove_constraint'>\n   236\t\n   237\t    def remove_constraint(self, app_label, model_name, constraint_name):\n   238\t        self._remove_option(app_label, model_name, \"constraints\", constraint_name)\n          # ...\n\n\n<span id='ProjectState.from_apps'>\n   567\t\n   568\t    @classmethod\n   569\t    def from_apps(cls, apps):\n   570\t        \"\"\"Take an Apps and return a ProjectState matching it.\"\"\"\n   571\t        app_models = {}\n   572\t        for model in apps.get_models(include_swapped=True):\n   573\t            model_state = ModelState.from_model(model)\n   574\t            app_models[(model_state.app_label, model_state.name_lower)] = model_state\n   575\t        return cls(app_models)\n          # ...\n      # ...\n```\n\n</search_result>\n"
            }
          ],
          "response": {
            "id": "msg_0156ZKLFvfhN2cEmFbG46hph",
            "content": [
              {
                "text": "I'll analyze the search request and search results to identify relevant code sections for handling `index_together` in `ProjectState`.\n\nAfter reviewing the code, I notice that while there are methods for handling indexes in `ProjectState` (like `add_index`, `remove_index`, `rename_index`), there isn't a direct method specifically for `index_together` handling visible in the provided search results. However, there are related methods that show how model options are modified, which is relevant since `index_together` is a model option.\n\nThe most relevant sections are:\n\n1. The `alter_model_options` method (lines 181-188) which handles updating model options including potentially `index_together`\n2. The `remove_model_options` method (lines 190-196) which can handle removing options like `index_together`\n\nLet me identify these sections using the Action tool:",
                "type": "text"
              },
              {
                "id": "toolu_0135bTavn38Jb7VSeoargZGN",
                "input": {
                  "scratch_pad": "The most relevant code sections for handling index_together in ProjectState are:\n\n1. alter_model_options (lines 181-188):\n   - This method is used to modify model options, which would include index_together modifications\n   - It can both add new options and update existing ones\n   - It handles the general case of modifying any model option\n\n2. remove_model_options (lines 190-196):\n   - This method is used to remove specific values from model options\n   - It would be used when removing specific index_together configurations\n   - It handles removing values while preserving the option structure\n\nThese methods are the primary ways that ProjectState handles modifications to index_together configurations, as index_together is stored in the model's options dictionary.",
                  "identified_spans": [
                    {
                      "file_path": "django/db/migrations/state.py",
                      "start_line": 181,
                      "end_line": 188
                    },
                    {
                      "file_path": "django/db/migrations/state.py",
                      "start_line": 190,
                      "end_line": 196
                    }
                  ]
                },
                "name": "Action",
                "type": "tool_use"
              }
            ],
            "model": "claude-3-5-sonnet-20241022",
            "role": "assistant",
            "stop_reason": "tool_use",
            "stop_sequence": null,
            "type": "message",
            "usage": {
              "cache_creation_input_tokens": 0,
              "cache_read_input_tokens": 0,
              "input_tokens": 2785,
              "output_tokens": 515
            }
          },
          "usage": {
            "completion_cost": 0.01608,
            "completion_tokens": 515,
            "prompt_tokens": 2785,
            "cached_tokens": 0
          }
        }
      },
      "file_context": {
        "max_tokens": 8000,
        "files": [
          {
            "file_path": "tests/migrations/test_operations.py",
            "spans": [
              {
                "span_id": "imports",
                "pinned": false
              },
              {
                "span_id": "OperationTests",
                "pinned": false
              },
              {
                "span_id": "OperationTests.test_rename_index_unnamed_index",
                "pinned": false
              }
            ],
            "show_all_spans": true,
            "patch": null
          },
          {
            "file_path": "django/db/migrations/operations/models.py",
            "spans": [
              {
                "span_id": "imports",
                "pinned": false
              },
              {
                "span_id": "RenameIndex",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.__init__",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.old_name_lower",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.new_name_lower",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.deconstruct",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.state_forwards",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.database_forwards",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.database_backwards",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.describe",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.migration_name_fragment",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.reduce",
                "pinned": false
              }
            ],
            "show_all_spans": false,
            "patch": null
          },
          {
            "file_path": "django/db/backends/base/schema.py",
            "spans": [
              {
                "span_id": "imports",
                "pinned": false
              },
              {
                "span_id": "BaseDatabaseSchemaEditor",
                "pinned": false
              },
              {
                "span_id": "BaseDatabaseSchemaEditor._rename_index_sql",
                "pinned": false
              }
            ],
            "show_all_spans": false,
            "patch": null
          },
          {
            "file_path": "django/db/migrations/state.py",
            "spans": [
              {
                "span_id": "imports",
                "pinned": false
              },
              {
                "span_id": "ProjectState",
                "pinned": false
              },
              {
                "span_id": "ProjectState.alter_model_options",
                "pinned": false
              },
              {
                "span_id": "ProjectState.remove_model_options",
                "pinned": false
              }
            ],
            "show_all_spans": false,
            "patch": null
          }
        ]
      },
      "completions": {
        "build_action": {
          "model": "claude-3-5-sonnet-20241022",
          "input": [
            {
              "role": "user",
              "content": "<task>\nRenameIndex() crashes when unnamed index is moving backward and forward.\nDescription\n\t\nRenameIndex() should restore the old auto-generated name when an unnamed index for unique_together is moving backward. Now re-applying RenameIndex() crashes. For example:\ntests/migrations/test_operations.py\ndiff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex cfd28b1b39..c0a55023bb 100644\n\t\t\t\t\t\n\t\t\t\t\t a\n\t\t\t\t \n\t\t\t\t\t\n\t\t\t\t\t b\n\t\t\t\t \n class OperationTests(OperationTestBase):\u00a0\n29882988\u00a0 \u00a0 \u00a0 \u00a0 with connection.schema_editor() as editor, self.assertNumQueries(0):\n29892989\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 operation.database_backwards(app_label, editor, new_state, project_state)\n29902990\u00a0 \u00a0 \u00a0 \u00a0 self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n\u00a02991\u00a0 \u00a0 \u00a0 \u00a0 # Re-apply renaming.\n\u00a02992\u00a0 \u00a0 \u00a0 \u00a0 with connection.schema_editor() as editor:\n\u00a02993\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 operation.database_forwards(app_label, editor, project_state, new_state)\n\u00a02994\u00a0 \u00a0 \u00a0 \u00a0 self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n29912995\u00a0 \u00a0 \u00a0 \u00a0 # Deconstruction.\n29922996\u00a0 \u00a0 \u00a0 \u00a0 definition = operation.deconstruct()\n29932997\u00a0 \u00a0 \u00a0 \u00a0 self.assertEqual(definition[0], \"RenameIndex\")\ncrashes on PostgreSQL:\ndjango.db.utils.ProgrammingError: relation \"new_pony_test_idx\" already exists\n\n</task>"
            },
            {
              "role": "assistant",
              "content": [
                {
                  "type": "text",
                  "text": "<thoughts>\n1. First, I need to understand the context better by:\n   - Looking at the test file to see the full test case\n   - Finding the RenameIndex operation implementation\n   - Understanding how index naming works in this context\n\n2. Let's start by viewing the test file to see the full test case context.\n</thoughts>"
                },
                {
                  "id": "call_8635dcc7",
                  "input": {
                    "files": [
                      {
                        "file_path": "tests/migrations/test_operations.py",
                        "start_line": null,
                        "end_line": null,
                        "span_ids": []
                      }
                    ]
                  },
                  "type": "tool_use",
                  "name": "ViewCode"
                }
              ]
            },
            {
              "role": "user",
              "content": [
                {
                  "tool_use_id": "call_8635dcc7",
                  "content": "<observation>\nHere's the contents of the requested code spans:\ntests/migrations/test_operations.py\n```\n     1\tfrom django.core.exceptions import FieldDoesNotExist\n     2\tfrom django.db import IntegrityError, connection, migrations, models, transaction\n     3\tfrom django.db.migrations.migration import Migration\n     4\tfrom django.db.migrations.operations.fields import FieldOperation\n     5\tfrom django.db.migrations.state import ModelState, ProjectState\n     6\tfrom django.db.models.functions import Abs\n     7\tfrom django.db.transaction import atomic\n     8\tfrom django.test import SimpleTestCase, override_settings, skipUnlessDBFeature\n     9\tfrom django.test.utils import CaptureQueriesContext\n    10\t\n    11\tfrom .models import FoodManager, FoodQuerySet, UnicodeModel\n    12\tfrom .test_base import OperationTestBase\n    13\t\n    14\t\n    15\tclass Mixin:\n    16\t    pass\n    17\t\n    18\t\n    19\tclass OperationTests(OperationTestBase):\n    20\t    \"\"\"\n    21\t    Tests running the operations and making sure they do what they say they do.\n    22\t    Each test looks at their state changing, and then their database operation -\n    23\t    both forwards and backwards.\n    24\t    \"\"\"\n    25\t\n    26\t    def test_create_model(self):\n    27\t        \"\"\"\n    28\t        Tests the CreateModel operation.\n    29\t        Most other tests use this operation as part of setup, so check failures\n    30\t        here first.\n    31\t        \"\"\"\n    32\t        operation = migrations.CreateModel(\n    33\t            \"Pony\",\n    34\t            [\n    35\t                (\"id\", models.AutoField(primary_key=True)),\n    36\t                (\"pink\", models.IntegerField(default=1)),\n    37\t            ],\n    38\t        )\n    39\t        self.assertEqual(operation.describe(), \"Create model Pony\")\n    40\t        self.assertEqual(operation.migration_name_fragment, \"pony\")\n    41\t        # Test the state alteration\n    42\t        project_state = ProjectState()\n    43\t        new_state = project_state.clone()\n    44\t        operation.state_forwards(\"test_crmo\", new_state)\n    45\t        self.assertEqual(new_state.models[\"test_crmo\", \"pony\"].name, \"Pony\")\n    46\t        self.assertEqual(len(new_state.models[\"test_crmo\", \"pony\"].fields), 2)\n    47\t        # Test the database alteration\n    48\t        self.assertTableNotExists(\"test_crmo_pony\")\n    49\t        with connection.schema_editor() as editor:\n    50\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n    51\t        self.assertTableExists(\"test_crmo_pony\")\n    52\t        # And test reversal\n    53\t        with connection.schema_editor() as editor:\n    54\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n    55\t        self.assertTableNotExists(\"test_crmo_pony\")\n    56\t        # And deconstruction\n    57\t        definition = operation.deconstruct()\n    58\t        self.assertEqual(definition[0], \"CreateModel\")\n    59\t        self.assertEqual(definition[1], [])\n    60\t        self.assertEqual(sorted(definition[2]), [\"fields\", \"name\"])\n    61\t        # And default manager not in set\n    62\t        operation = migrations.CreateModel(\n    63\t            \"Foo\", fields=[], managers=[(\"objects\", models.Manager())]\n    64\t        )\n    65\t        definition = operation.deconstruct()\n    66\t        self.assertNotIn(\"managers\", definition[2])\n    67\t\n    68\t    def test_create_model_with_duplicate_field_name(self):\n    69\t        with self.assertRaisesMessage(\n    70\t            ValueError, \"Found duplicate value pink in CreateModel fields argument.\"\n    71\t        ):\n    72\t            migrations.CreateModel(\n    73\t                \"Pony\",\n    74\t                [\n    75\t                    (\"id\", models.AutoField(primary_key=True)),\n    76\t                    (\"pink\", models.TextField()),\n    77\t                    (\"pink\", models.IntegerField(default=1)),\n    78\t                ],\n    79\t            )\n    80\t\n    81\t    def test_create_model_with_duplicate_base(self):\n    82\t        message = \"Found duplicate value test_crmo.pony in CreateModel bases argument.\"\n    83\t        with self.assertRaisesMessage(ValueError, message):\n    84\t            migrations.CreateModel(\n    85\t                \"Pony\",\n    86\t                fields=[],\n    87\t                bases=(\n    88\t                    \"test_crmo.Pony\",\n    89\t                    \"test_crmo.Pony\",\n    90\t                ),\n    91\t            )\n    92\t        with self.assertRaisesMessage(ValueError, message):\n    93\t            migrations.CreateModel(\n    94\t                \"Pony\",\n    95\t                fields=[],\n    96\t                bases=(\n    97\t                    \"test_crmo.Pony\",\n    98\t                    \"test_crmo.pony\",\n    99\t                ),\n   100\t            )\n   101\t        message = (\n   102\t            \"Found duplicate value migrations.unicodemodel in CreateModel bases \"\n   103\t            \"argument.\"\n   104\t        )\n   105\t        with self.assertRaisesMessage(ValueError, message):\n   106\t            migrations.CreateModel(\n   107\t                \"Pony\",\n   108\t                fields=[],\n   109\t                bases=(\n   110\t                    UnicodeModel,\n   111\t                    UnicodeModel,\n   112\t                ),\n   113\t            )\n   114\t        with self.assertRaisesMessage(ValueError, message):\n   115\t            migrations.CreateModel(\n   116\t                \"Pony\",\n   117\t                fields=[],\n   118\t                bases=(\n   119\t                    UnicodeModel,\n   120\t                    \"migrations.unicodemodel\",\n   121\t                ),\n   122\t            )\n   123\t        with self.assertRaisesMessage(ValueError, message):\n   124\t            migrations.CreateModel(\n   125\t                \"Pony\",\n   126\t                fields=[],\n   127\t                bases=(\n   128\t                    UnicodeModel,\n   129\t                    \"migrations.UnicodeModel\",\n   130\t                ),\n   131\t            )\n   132\t        message = (\n   133\t            \"Found duplicate value <class 'django.db.models.base.Model'> in \"\n   134\t            \"CreateModel bases argument.\"\n   135\t        )\n   136\t        with self.assertRaisesMessage(ValueError, message):\n   137\t            migrations.CreateModel(\n   138\t                \"Pony\",\n   139\t                fields=[],\n   140\t                bases=(\n   141\t                    models.Model,\n   142\t                    models.Model,\n   143\t                ),\n   144\t            )\n   145\t        message = (\n   146\t            \"Found duplicate value <class 'migrations.test_operations.Mixin'> in \"\n   147\t            \"CreateModel bases argument.\"\n   148\t        )\n   149\t        with self.assertRaisesMessage(ValueError, message):\n   150\t            migrations.CreateModel(\n   151\t                \"Pony\",\n   152\t                fields=[],\n   153\t                bases=(\n   154\t                    Mixin,\n   155\t                    Mixin,\n   156\t                ),\n   157\t            )\n   158\t\n   159\t    def test_create_model_with_duplicate_manager_name(self):\n   160\t        with self.assertRaisesMessage(\n   161\t            ValueError,\n   162\t            \"Found duplicate value objects in CreateModel managers argument.\",\n   163\t        ):\n   164\t            migrations.CreateModel(\n   165\t                \"Pony\",\n   166\t                fields=[],\n   167\t                managers=[\n   168\t                    (\"objects\", models.Manager()),\n   169\t                    (\"objects\", models.Manager()),\n   170\t                ],\n   171\t            )\n   172\t\n   173\t    def test_create_model_with_unique_after(self):\n   174\t        \"\"\"\n   175\t        Tests the CreateModel operation directly followed by an\n   176\t        AlterUniqueTogether (bug #22844 - sqlite remake issues)\n   177\t        \"\"\"\n   178\t        operation1 = migrations.CreateModel(\n   179\t            \"Pony\",\n   180\t            [\n   181\t                (\"id\", models.AutoField(primary_key=True)),\n   182\t                (\"pink\", models.IntegerField(default=1)),\n   183\t            ],\n   184\t        )\n   185\t        operation2 = migrations.CreateModel(\n   186\t            \"Rider\",\n   187\t            [\n   188\t                (\"id\", models.AutoField(primary_key=True)),\n   189\t                (\"number\", models.IntegerField(default=1)),\n   190\t                (\"pony\", models.ForeignKey(\"test_crmoua.Pony\", models.CASCADE)),\n   191\t            ],\n   192\t        )\n   193\t        operation3 = migrations.AlterUniqueTogether(\n   194\t            \"Rider\",\n   195\t            [\n   196\t                (\"number\", \"pony\"),\n   197\t            ],\n   198\t        )\n   199\t        # Test the database alteration\n   200\t        project_state = ProjectState()\n   201\t        self.assertTableNotExists(\"test_crmoua_pony\")\n   202\t        self.assertTableNotExists(\"test_crmoua_rider\")\n   203\t        with connection.schema_editor() as editor:\n   204\t            new_state = project_state.clone()\n   205\t            operation1.state_forwards(\"test_crmoua\", new_state)\n   206\t            operation1.database_forwards(\n   207\t                \"test_crmoua\", editor, project_state, new_state\n   208\t            )\n   209\t            project_state, new_state = new_state, new_state.clone()\n   210\t            operation2.state_forwards(\"test_crmoua\", new_state)\n   211\t            operation2.database_forwards(\n   212\t                \"test_crmoua\", editor, project_state, new_state\n   213\t            )\n   214\t            project_state, new_state = new_state, new_state.clone()\n   215\t            operation3.state_forwards(\"test_crmoua\", new_state)\n   216\t            operation3.database_forwards(\n   217\t                \"test_crmoua\", editor, project_state, new_state\n   218\t            )\n   219\t        self.assertTableExists(\"test_crmoua_pony\")\n   220\t        self.assertTableExists(\"test_crmoua_rider\")\n   221\t\n   222\t    def test_create_model_m2m(self):\n   223\t        \"\"\"\n   224\t        Test the creation of a model with a ManyToMany field and the\n   225\t        auto-created \"through\" model.\n   226\t        \"\"\"\n   227\t        project_state = self.set_up_test_model(\"test_crmomm\")\n   228\t        operation = migrations.CreateModel(\n   229\t            \"Stable\",\n   230\t            [\n   231\t                (\"id\", models.AutoField(primary_key=True)),\n   232\t                (\"ponies\", models.ManyToManyField(\"Pony\", related_name=\"stables\")),\n   233\t            ],\n   234\t        )\n   235\t        # Test the state alteration\n   236\t        new_state = project_state.clone()\n   237\t        operation.state_forwards(\"test_crmomm\", new_state)\n   238\t        # Test the database alteration\n   239\t        self.assertTableNotExists(\"test_crmomm_stable_ponies\")\n   240\t        with connection.schema_editor() as editor:\n   241\t            operation.database_forwards(\"test_crmomm\", editor, project_state, new_state)\n   242\t        self.assertTableExists(\"test_crmomm_stable\")\n   243\t        self.assertTableExists(\"test_crmomm_stable_ponies\")\n   244\t        self.assertColumnNotExists(\"test_crmomm_stable\", \"ponies\")\n   245\t        # Make sure the M2M field actually works\n   246\t        with atomic():\n   247\t            Pony = new_state.apps.get_model(\"test_crmomm\", \"Pony\")\n   248\t            Stable = new_state.apps.get_model(\"test_crmomm\", \"Stable\")\n   249\t            stable = Stable.objects.create()\n   250\t            p1 = Pony.objects.create(pink=False, weight=4.55)\n   251\t            p2 = Pony.objects.create(pink=True, weight=5.43)\n   252\t            stable.ponies.add(p1, p2)\n   253\t            self.assertEqual(stable.ponies.count(), 2)\n   254\t            stable.ponies.all().delete()\n   255\t        # And test reversal\n   256\t        with connection.schema_editor() as editor:\n   257\t            operation.database_backwards(\n   258\t                \"test_crmomm\", editor, new_state, project_state\n   259\t            )\n   260\t        self.assertTableNotExists(\"test_crmomm_stable\")\n   261\t        self.assertTableNotExists(\"test_crmomm_stable_ponies\")\n   262\t\n   263\t    @skipUnlessDBFeature(\"supports_collation_on_charfield\", \"supports_foreign_keys\")\n   264\t    def test_create_fk_models_to_pk_field_db_collation(self):\n   265\t        \"\"\"Creation of models with a FK to a PK with db_collation.\"\"\"\n   266\t        collation = connection.features.test_collations.get(\"non_default\")\n   267\t        if not collation:\n   268\t            self.skipTest(\"Language collations are not supported.\")\n   269\t\n   270\t        app_label = \"test_cfkmtopkfdbc\"\n   271\t        operations = [\n   272\t            migrations.CreateModel(\n   273\t                \"Pony\",\n   274\t                [\n   275\t                    (\n   276\t                        \"id\",\n   277\t                        models.CharField(\n   278\t                            primary_key=True,\n   279\t                            max_length=10,\n   280\t                            db_collation=collation,\n   281\t                        ),\n   282\t                    ),\n   283\t                ],\n   284\t            )\n   285\t        ]\n   286\t        project_state = self.apply_operations(app_label, ProjectState(), operations)\n   287\t        # ForeignKey.\n   288\t        new_state = project_state.clone()\n   289\t        operation = migrations.CreateModel(\n   290\t            \"Rider\",\n   291\t            [\n   292\t                (\"id\", models.AutoField(primary_key=True)),\n   293\t                (\"pony\", models.ForeignKey(\"Pony\", models.CASCADE)),\n   294\t            ],\n   295\t        )\n   296\t        operation.state_forwards(app_label, new_state)\n   297\t        with connection.schema_editor() as editor:\n   298\t            operation.database_forwards(app_label, editor, project_state, new_state)\n   299\t        self.assertColumnCollation(f\"{app_label}_rider\", \"pony_id\", collation)\n   300\t        # Reversal.\n   301\t        with connection.schema_editor() as editor:\n   302\t            operation.database_backwards(app_label, editor, new_state, project_state)\n   303\t        # OneToOneField.\n   304\t        new_state = project_state.clone()\n   305\t        operation = migrations.CreateModel(\n   306\t            \"ShetlandPony\",\n   307\t            [\n   308\t                (\n   309\t                    \"pony\",\n   310\t                    models.OneToOneField(\"Pony\", models.CASCADE, primary_key=True),\n   311\t                ),\n   312\t                (\"cuteness\", models.IntegerField(default=1)),\n   313\t            ],\n   314\t        )\n   315\t        operation.state_forwards(app_label, new_state)\n   316\t        with connection.schema_editor() as editor:\n   317\t            operation.database_forwards(app_label, editor, project_state, new_state)\n   318\t        self.assertColumnCollation(f\"{app_label}_shetlandpony\", \"pony_id\", collation)\n   319\t        # Reversal.\n   320\t        with connection.schema_editor() as editor:\n   321\t            operation.database_backwards(app_label, editor, new_state, project_state)\n   322\t\n   323\t    def test_create_model_inheritance(self):\n   324\t        \"\"\"\n   325\t        Tests the CreateModel operation on a multi-table inheritance setup.\n   326\t        \"\"\"\n   327\t        project_state = self.set_up_test_model(\"test_crmoih\")\n   328\t        # Test the state alteration\n   329\t        operation = migrations.CreateModel(\n   330\t            \"ShetlandPony\",\n   331\t            [\n   332\t                (\n   333\t                    \"pony_ptr\",\n   334\t                    models.OneToOneField(\n   335\t                        \"test_crmoih.Pony\",\n   336\t                        models.CASCADE,\n   337\t                        auto_created=True,\n   338\t                        primary_key=True,\n   339\t                        to_field=\"id\",\n   340\t                        serialize=False,\n   341\t                    ),\n   342\t                ),\n   343\t                (\"cuteness\", models.IntegerField(default=1)),\n   344\t            ],\n   345\t        )\n   346\t        new_state = project_state.clone()\n   347\t        operation.state_forwards(\"test_crmoih\", new_state)\n   348\t        self.assertIn((\"test_crmoih\", \"shetlandpony\"), new_state.models)\n   349\t        # Test the database alteration\n   350\t        self.assertTableNotExists(\"test_crmoih_shetlandpony\")\n   351\t        with connection.schema_editor() as editor:\n   352\t            operation.database_forwards(\"test_crmoih\", editor, project_state, new_state)\n   353\t        self.assertTableExists(\"test_crmoih_shetlandpony\")\n   354\t        # And test reversal\n   355\t        with connection.schema_editor() as editor:\n   356\t            operation.database_backwards(\n   357\t                \"test_crmoih\", editor, new_state, project_state\n   358\t            )\n   359\t        self.assertTableNotExists(\"test_crmoih_shetlandpony\")\n   360\t\n   361\t    def test_create_proxy_model(self):\n   362\t        \"\"\"\n   363\t        CreateModel ignores proxy models.\n   364\t        \"\"\"\n   365\t        project_state = self.set_up_test_model(\"test_crprmo\")\n   366\t        # Test the state alteration\n   367\t        operation = migrations.CreateModel(\n   368\t            \"ProxyPony\",\n   369\t            [],\n   370\t            options={\"proxy\": True},\n   371\t            bases=(\"test_crprmo.Pony\",),\n   372\t        )\n   373\t        self.assertEqual(operation.describe(), \"Create proxy model ProxyPony\")\n   374\t        new_state = project_state.clone()\n   375\t        operation.state_forwards(\"test_crprmo\", new_state)\n   376\t        self.assertIn((\"test_crprmo\", \"proxypony\"), new_state.models)\n   377\t        # Test the database alteration\n   378\t        self.assertTableNotExists(\"test_crprmo_proxypony\")\n   379\t        self.assertTableExists(\"test_crprmo_pony\")\n   380\t        with connection.schema_editor() as editor:\n   381\t            operation.database_forwards(\"test_crprmo\", editor, project_state, new_state)\n   382\t        self.assertTableNotExists(\"test_crprmo_proxypony\")\n   383\t        self.assertTableExists(\"test_crprmo_pony\")\n   384\t        # And test reversal\n   385\t        with connection.schema_editor() as editor:\n   386\t            operation.database_backwards(\n   387\t                \"test_crprmo\", editor, new_state, project_state\n   388\t            )\n   389\t        self.assertTableNotExists(\"test_crprmo_proxypony\")\n   390\t        self.assertTableExists(\"test_crprmo_pony\")\n   391\t        # And deconstruction\n   392\t        definition = operation.deconstruct()\n   393\t        self.assertEqual(definition[0], \"CreateModel\")\n   394\t        self.assertEqual(definition[1], [])\n   395\t        self.assertEqual(sorted(definition[2]), [\"bases\", \"fields\", \"name\", \"options\"])\n   396\t\n   397\t    def test_create_unmanaged_model(self):\n   398\t        \"\"\"\n   399\t        CreateModel ignores unmanaged models.\n   400\t        \"\"\"\n   401\t        project_state = self.set_up_test_model(\"test_crummo\")\n   402\t        # Test the state alteration\n   403\t        operation = migrations.CreateModel(\n   404\t            \"UnmanagedPony\",\n   405\t            [],\n   406\t            options={\"proxy\": True},\n   407\t            bases=(\"test_crummo.Pony\",),\n   408\t        )\n   409\t        self.assertEqual(operation.describe(), \"Create proxy model UnmanagedPony\")\n   410\t        new_state = project_state.clone()\n   411\t        operation.state_forwards(\"test_crummo\", new_state)\n   412\t        self.assertIn((\"test_crummo\", \"unmanagedpony\"), new_state.models)\n   413\t        # Test the database alteration\n   414\t        self.assertTableNotExists(\"test_crummo_unmanagedpony\")\n   415\t        self.assertTableExists(\"test_crummo_pony\")\n   416\t        with connection.schema_editor() as editor:\n   417\t            operation.database_forwards(\"test_crummo\", editor, project_state, new_state)\n   418\t        self.assertTableNotExists(\"test_crummo_unmanagedpony\")\n   419\t        self.assertTableExists(\"test_crummo_pony\")\n   420\t        # And test reversal\n   421\t        with connection.schema_editor() as editor:\n   422\t            operation.database_backwards(\n   423\t                \"test_crummo\", editor, new_state, project_state\n   424\t            )\n   425\t        self.assertTableNotExists(\"test_crummo_unmanagedpony\")\n   426\t        self.assertTableExists(\"test_crummo_pony\")\n   427\t\n   428\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n   429\t    def test_create_model_with_constraint(self):\n   430\t        where = models.Q(pink__gt=2)\n   431\t        check_constraint = models.CheckConstraint(\n   432\t            check=where, name=\"test_constraint_pony_pink_gt_2\"\n   433\t        )\n   434\t        operation = migrations.CreateModel(\n   435\t            \"Pony\",\n   436\t            [\n   437\t                (\"id\", models.AutoField(primary_key=True)),\n   438\t                (\"pink\", models.IntegerField(default=3)),\n   439\t            ],\n   440\t            options={\"constraints\": [check_constraint]},\n   441\t        )\n   442\t\n   443\t        # Test the state alteration\n   444\t        project_state = ProjectState()\n   445\t        new_state = project_state.clone()\n   446\t        operation.state_forwards(\"test_crmo\", new_state)\n   447\t        self.assertEqual(\n   448\t            len(new_state.models[\"test_crmo\", \"pony\"].options[\"constraints\"]), 1\n   449\t        )\n   450\t\n   451\t        # Test database alteration\n   452\t        self.assertTableNotExists(\"test_crmo_pony\")\n   453\t        with connection.schema_editor() as editor:\n   454\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n   455\t        self.assertTableExists(\"test_crmo_pony\")\n   456\t        with connection.cursor() as cursor:\n   457\t            with self.assertRaises(IntegrityError):\n   458\t                cursor.execute(\"INSERT INTO test_crmo_pony (id, pink) VALUES (1, 1)\")\n   459\t\n   460\t        # Test reversal\n   461\t        with connection.schema_editor() as editor:\n   462\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n   463\t        self.assertTableNotExists(\"test_crmo_pony\")\n   464\t\n   465\t        # Test deconstruction\n   466\t        definition = operation.deconstruct()\n   467\t        self.assertEqual(definition[0], \"CreateModel\")\n   468\t        self.assertEqual(definition[1], [])\n   469\t        self.assertEqual(definition[2][\"options\"][\"constraints\"], [check_constraint])\n   470\t\n   471\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n   472\t    def test_create_model_with_boolean_expression_in_check_constraint(self):\n   473\t        app_label = \"test_crmobechc\"\n   474\t        rawsql_constraint = models.CheckConstraint(\n   475\t            check=models.expressions.RawSQL(\n   476\t                \"price < %s\", (1000,), output_field=models.BooleanField()\n   477\t            ),\n   478\t            name=f\"{app_label}_price_lt_1000_raw\",\n   479\t        )\n   480\t        wrapper_constraint = models.CheckConstraint(\n   481\t            check=models.expressions.ExpressionWrapper(\n   482\t                models.Q(price__gt=500) | models.Q(price__lt=500),\n   483\t                output_field=models.BooleanField(),\n   484\t            ),\n   485\t            name=f\"{app_label}_price_neq_500_wrap\",\n   486\t        )\n   487\t        operation = migrations.CreateModel(\n   488\t            \"Product\",\n   489\t            [\n   490\t                (\"id\", models.AutoField(primary_key=True)),\n   491\t                (\"price\", models.IntegerField(null=True)),\n   492\t            ],\n   493\t            options={\"constraints\": [rawsql_constraint, wrapper_constraint]},\n   494\t        )\n   495\t\n   496\t        project_state = ProjectState()\n   497\t        new_state = project_state.clone()\n   498\t        operation.state_forwards(app_label, new_state)\n   499\t        # Add table.\n   500\t        self.assertTableNotExists(app_label)\n   501\t        with connection.schema_editor() as editor:\n   502\t            operation.database_forwards(app_label, editor, project_state, new_state)\n   503\t        self.assertTableExists(f\"{app_label}_product\")\n   504\t        insert_sql = f\"INSERT INTO {app_label}_product (id, price) VALUES (%d, %d)\"\n   505\t        with connection.cursor() as cursor:\n   506\t            with self.assertRaises(IntegrityError):\n   507\t                cursor.execute(insert_sql % (1, 1000))\n   508\t            cursor.execute(insert_sql % (1, 999))\n   509\t            with self.assertRaises(IntegrityError):\n   510\t                cursor.execute(insert_sql % (2, 500))\n   511\t            cursor.execute(insert_sql % (2, 499))\n   512\t\n   513\t    def test_create_model_with_partial_unique_constraint(self):\n   514\t        partial_unique_constraint = models.UniqueConstraint(\n   515\t            fields=[\"pink\"],\n   516\t            condition=models.Q(weight__gt=5),\n   517\t            name=\"test_constraint_pony_pink_for_weight_gt_5_uniq\",\n   518\t        )\n   519\t        operation = migrations.CreateModel(\n   520\t            \"Pony\",\n   521\t            [\n   522\t                (\"id\", models.AutoField(primary_key=True)),\n   523\t                (\"pink\", models.IntegerField(default=3)),\n   524\t                (\"weight\", models.FloatField()),\n   525\t            ],\n   526\t            options={\"constraints\": [partial_unique_constraint]},\n   527\t        )\n   528\t        # Test the state alteration\n   529\t        project_state = ProjectState()\n   530\t        new_state = project_state.clone()\n   531\t        operation.state_forwards(\"test_crmo\", new_state)\n   532\t        self.assertEqual(\n   533\t            len(new_state.models[\"test_crmo\", \"pony\"].options[\"constraints\"]), 1\n   534\t        )\n   535\t        # Test database alteration\n   536\t        self.assertTableNotExists(\"test_crmo_pony\")\n   537\t        with connection.schema_editor() as editor:\n   538\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n   539\t        self.assertTableExists(\"test_crmo_pony\")\n   540\t        # Test constraint works\n   541\t        Pony = new_state.apps.get_model(\"test_crmo\", \"Pony\")\n   542\t        Pony.objects.create(pink=1, weight=4.0)\n   543\t        Pony.objects.create(pink=1, weight=4.0)\n   544\t        Pony.objects.create(pink=1, weight=6.0)\n   545\t        if connection.features.supports_partial_indexes:\n   546\t            with self.assertRaises(IntegrityError):\n   547\t                Pony.objects.create(pink=1, weight=7.0)\n   548\t        else:\n   549\t            Pony.objects.create(pink=1, weight=7.0)\n   550\t        # Test reversal\n   551\t        with connection.schema_editor() as editor:\n   552\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n   553\t        self.assertTableNotExists(\"test_crmo_pony\")\n   554\t        # Test deconstruction\n   555\t        definition = operation.deconstruct()\n   556\t        self.assertEqual(definition[0], \"CreateModel\")\n   557\t        self.assertEqual(definition[1], [])\n   558\t        self.assertEqual(\n   559\t            definition[2][\"options\"][\"constraints\"], [partial_unique_constraint]\n   560\t        )\n   561\t\n   562\t    def test_create_model_with_deferred_unique_constraint(self):\n   563\t        deferred_unique_constraint = models.UniqueConstraint(\n   564\t            fields=[\"pink\"],\n   565\t            name=\"deferrable_pink_constraint\",\n   566\t            deferrable=models.Deferrable.DEFERRED,\n   567\t        )\n   568\t        operation = migrations.CreateModel(\n   569\t            \"Pony\",\n   570\t            [\n   571\t                (\"id\", models.AutoField(primary_key=True)),\n   572\t                (\"pink\", models.IntegerField(default=3)),\n   573\t            ],\n   574\t            options={\"constraints\": [deferred_unique_constraint]},\n   575\t        )\n   576\t        project_state = ProjectState()\n   577\t        new_state = project_state.clone()\n   578\t        operation.state_forwards(\"test_crmo\", new_state)\n   579\t        self.assertEqual(\n   580\t            len(new_state.models[\"test_crmo\", \"pony\"].options[\"constraints\"]), 1\n   581\t        )\n   582\t        self.assertTableNotExists(\"test_crmo_pony\")\n   583\t        # Create table.\n   584\t        with connection.schema_editor() as editor:\n   585\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n   586\t        self.assertTableExists(\"test_crmo_pony\")\n   587\t        Pony = new_state.apps.get_model(\"test_crmo\", \"Pony\")\n   588\t        Pony.objects.create(pink=1)\n   589\t        if connection.features.supports_deferrable_unique_constraints:\n   590\t            # Unique constraint is deferred.\n   591\t            with transaction.atomic():\n   592\t                obj = Pony.objects.create(pink=1)\n   593\t                obj.pink = 2\n   594\t                obj.save()\n   595\t            # Constraint behavior can be changed with SET CONSTRAINTS.\n   596\t            with self.assertRaises(IntegrityError):\n   597\t                with transaction.atomic(), connection.cursor() as cursor:\n   598\t                    quoted_name = connection.ops.quote_name(\n   599\t                        deferred_unique_constraint.name\n   600\t                    )\n   601\t                    cursor.execute(\"SET CONSTRAINTS %s IMMEDIATE\" % quoted_name)\n   602\t                    obj = Pony.objects.create(pink=1)\n   603\t                    obj.pink = 3\n   604\t                    obj.save()\n   605\t        else:\n   606\t            Pony.objects.create(pink=1)\n   607\t        # Reversal.\n   608\t        with connection.schema_editor() as editor:\n   609\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n   610\t        self.assertTableNotExists(\"test_crmo_pony\")\n   611\t        # Deconstruction.\n   612\t        definition = operation.deconstruct()\n   613\t        self.assertEqual(definition[0], \"CreateModel\")\n   614\t        self.assertEqual(definition[1], [])\n   615\t        self.assertEqual(\n   616\t            definition[2][\"options\"][\"constraints\"],\n   617\t            [deferred_unique_constraint],\n   618\t        )\n   619\t\n   620\t    @skipUnlessDBFeature(\"supports_covering_indexes\")\n   621\t    def test_create_model_with_covering_unique_constraint(self):\n   622\t        covering_unique_constraint = models.UniqueConstraint(\n   623\t            fields=[\"pink\"],\n   624\t            include=[\"weight\"],\n   625\t            name=\"test_constraint_pony_pink_covering_weight\",\n   626\t        )\n   627\t        operation = migrations.CreateModel(\n   628\t            \"Pony\",\n   629\t            [\n   630\t                (\"id\", models.AutoField(primary_key=True)),\n   631\t                (\"pink\", models.IntegerField(default=3)),\n   632\t                (\"weight\", models.FloatField()),\n   633\t            ],\n   634\t            options={\"constraints\": [covering_unique_constraint]},\n   635\t        )\n   636\t        project_state = ProjectState()\n   637\t        new_state = project_state.clone()\n   638\t        operation.state_forwards(\"test_crmo\", new_state)\n   639\t        self.assertEqual(\n   640\t            len(new_state.models[\"test_crmo\", \"pony\"].options[\"constraints\"]), 1\n   641\t        )\n   642\t        self.assertTableNotExists(\"test_crmo_pony\")\n   643\t        # Create table.\n   644\t        with connection.schema_editor() as editor:\n   645\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n   646\t        self.assertTableExists(\"test_crmo_pony\")\n   647\t        Pony = new_state.apps.get_model(\"test_crmo\", \"Pony\")\n   648\t        Pony.objects.create(pink=1, weight=4.0)\n   649\t        with self.assertRaises(IntegrityError):\n   650\t            Pony.objects.create(pink=1, weight=7.0)\n   651\t        # Reversal.\n   652\t        with connection.schema_editor() as editor:\n   653\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n   654\t        self.assertTableNotExists(\"test_crmo_pony\")\n   655\t        # Deconstruction.\n   656\t        definition = operation.deconstruct()\n   657\t        self.assertEqual(definition[0], \"CreateModel\")\n   658\t        self.assertEqual(definition[1], [])\n   659\t        self.assertEqual(\n   660\t            definition[2][\"options\"][\"constraints\"],\n   661\t            [covering_unique_constraint],\n   662\t        )\n   663\t\n   664\t    def test_create_model_managers(self):\n   665\t        \"\"\"\n   666\t        The managers on a model are set.\n   667\t        \"\"\"\n   668\t        project_state = self.set_up_test_model(\"test_cmoma\")\n   669\t        # Test the state alteration\n   670\t        operation = migrations.CreateModel(\n   671\t            \"Food\",\n   672\t            fields=[\n   673\t                (\"id\", models.AutoField(primary_key=True)),\n   674\t            ],\n   675\t            managers=[\n   676\t                (\"food_qs\", FoodQuerySet.as_manager()),\n   677\t                (\"food_mgr\", FoodManager(\"a\", \"b\")),\n   678\t                (\"food_mgr_kwargs\", FoodManager(\"x\", \"y\", 3, 4)),\n   679\t            ],\n   680\t        )\n   681\t        self.assertEqual(operation.describe(), \"Create model Food\")\n   682\t        new_state = project_state.clone()\n   683\t        operation.state_forwards(\"test_cmoma\", new_state)\n   684\t        self.assertIn((\"test_cmoma\", \"food\"), new_state.models)\n   685\t        managers = new_state.models[\"test_cmoma\", \"food\"].managers\n   686\t        self.assertEqual(managers[0][0], \"food_qs\")\n   687\t        self.assertIsInstance(managers[0][1], models.Manager)\n   688\t        self.assertEqual(managers[1][0], \"food_mgr\")\n   689\t        self.assertIsInstance(managers[1][1], FoodManager)\n   690\t        self.assertEqual(managers[1][1].args, (\"a\", \"b\", 1, 2))\n   691\t        self.assertEqual(managers[2][0], \"food_mgr_kwargs\")\n   692\t        self.assertIsInstance(managers[2][1], FoodManager)\n   693\t        self.assertEqual(managers[2][1].args, (\"x\", \"y\", 3, 4))\n   694\t\n   695\t    def test_delete_model(self):\n   696\t        \"\"\"\n   697\t        Tests the DeleteModel operation.\n   698\t        \"\"\"\n   699\t        project_state = self.set_up_test_model(\"test_dlmo\")\n   700\t        # Test the state alteration\n   701\t        operation = migrations.DeleteModel(\"Pony\")\n   702\t        self.assertEqual(operation.describe(), \"Delete model Pony\")\n   703\t        self.assertEqual(operation.migration_name_fragment, \"delete_pony\")\n   704\t        new_state = project_state.clone()\n   705\t        operation.state_forwards(\"test_dlmo\", new_state)\n   706\t        self.assertNotIn((\"test_dlmo\", \"pony\"), new_state.models)\n   707\t        # Test the database alteration\n   708\t        self.assertTableExists(\"test_dlmo_pony\")\n   709\t        with connection.schema_editor() as editor:\n   710\t            operation.database_forwards(\"test_dlmo\", editor, project_state, new_state)\n   711\t        self.assertTableNotExists(\"test_dlmo_pony\")\n   712\t        # And test reversal\n   713\t        with connection.schema_editor() as editor:\n   714\t            operation.database_backwards(\"test_dlmo\", editor, new_state, project_state)\n   715\t        self.assertTableExists(\"test_dlmo_pony\")\n   716\t        # And deconstruction\n   717\t        definition = operation.deconstruct()\n   718\t        self.assertEqual(definition[0], \"DeleteModel\")\n   719\t        self.assertEqual(definition[1], [])\n   720\t        self.assertEqual(list(definition[2]), [\"name\"])\n   721\t\n   722\t    def test_delete_proxy_model(self):\n   723\t        \"\"\"\n   724\t        Tests the DeleteModel operation ignores proxy models.\n   725\t        \"\"\"\n   726\t        project_state = self.set_up_test_model(\"test_dlprmo\", proxy_model=True)\n   727\t        # Test the state alteration\n   728\t        operation = migrations.DeleteModel(\"ProxyPony\")\n   729\t        new_state = project_state.clone()\n   730\t        operation.state_forwards(\"test_dlprmo\", new_state)\n   731\t        self.assertIn((\"test_dlprmo\", \"proxypony\"), project_state.models)\n   732\t        self.assertNotIn((\"test_dlprmo\", \"proxypony\"), new_state.models)\n   733\t        # Test the database alteration\n   734\t        self.assertTableExists(\"test_dlprmo_pony\")\n   735\t        self.assertTableNotExists(\"test_dlprmo_proxypony\")\n   736\t        with connection.schema_editor() as editor:\n   737\t            operation.database_forwards(\"test_dlprmo\", editor, project_state, new_state)\n   738\t        self.assertTableExists(\"test_dlprmo_pony\")\n   739\t        self.assertTableNotExists(\"test_dlprmo_proxypony\")\n   740\t        # And test reversal\n   741\t        with connection.schema_editor() as editor:\n   742\t            operation.database_backwards(\n   743\t                \"test_dlprmo\", editor, new_state, project_state\n   744\t            )\n   745\t        self.assertTableExists(\"test_dlprmo_pony\")\n   746\t        self.assertTableNotExists(\"test_dlprmo_proxypony\")\n   747\t\n   748\t    def test_delete_mti_model(self):\n   749\t        project_state = self.set_up_test_model(\"test_dlmtimo\", mti_model=True)\n   750\t        # Test the state alteration\n   751\t        operation = migrations.DeleteModel(\"ShetlandPony\")\n   752\t        new_state = project_state.clone()\n   753\t        operation.state_forwards(\"test_dlmtimo\", new_state)\n   754\t        self.assertIn((\"test_dlmtimo\", \"shetlandpony\"), project_state.models)\n   755\t        self.assertNotIn((\"test_dlmtimo\", \"shetlandpony\"), new_state.models)\n   756\t        # Test the database alteration\n   757\t        self.assertTableExists(\"test_dlmtimo_pony\")\n   758\t        self.assertTableExists(\"test_dlmtimo_shetlandpony\")\n   759\t        self.assertColumnExists(\"test_dlmtimo_shetlandpony\", \"pony_ptr_id\")\n   760\t        with connection.schema_editor() as editor:\n   761\t            operation.database_forwards(\n   762\t                \"test_dlmtimo\", editor, project_state, new_state\n   763\t            )\n   764\t        self.assertTableExists(\"test_dlmtimo_pony\")\n   765\t        self.assertTableNotExists(\"test_dlmtimo_shetlandpony\")\n   766\t        # And test reversal\n   767\t        with connection.schema_editor() as editor:\n   768\t            operation.database_backwards(\n   769\t                \"test_dlmtimo\", editor, new_state, project_state\n   770\t            )\n   771\t        self.assertTableExists(\"test_dlmtimo_pony\")\n   772\t        self.assertTableExists(\"test_dlmtimo_shetlandpony\")\n   773\t        self.assertColumnExists(\"test_dlmtimo_shetlandpony\", \"pony_ptr_id\")\n   774\t\n   775\t    def test_rename_model(self):\n   776\t        \"\"\"\n   777\t        Tests the RenameModel operation.\n   778\t        \"\"\"\n   779\t        project_state = self.set_up_test_model(\"test_rnmo\", related_model=True)\n   780\t        # Test the state alteration\n   781\t        operation = migrations.RenameModel(\"Pony\", \"Horse\")\n   782\t        self.assertEqual(operation.describe(), \"Rename model Pony to Horse\")\n   783\t        self.assertEqual(operation.migration_name_fragment, \"rename_pony_horse\")\n   784\t        # Test initial state and database\n   785\t        self.assertIn((\"test_rnmo\", \"pony\"), project_state.models)\n   786\t        self.assertNotIn((\"test_rnmo\", \"horse\"), project_state.models)\n   787\t        self.assertTableExists(\"test_rnmo_pony\")\n   788\t        self.assertTableNotExists(\"test_rnmo_horse\")\n   789\t        if connection.features.supports_foreign_keys:\n   790\t            self.assertFKExists(\n   791\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_pony\", \"id\")\n   792\t            )\n   793\t            self.assertFKNotExists(\n   794\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_horse\", \"id\")\n   795\t            )\n   796\t        # Migrate forwards\n   797\t        new_state = project_state.clone()\n   798\t        atomic_rename = connection.features.supports_atomic_references_rename\n   799\t        new_state = self.apply_operations(\n   800\t            \"test_rnmo\", new_state, [operation], atomic=atomic_rename\n   801\t        )\n   802\t        # Test new state and database\n   803\t        self.assertNotIn((\"test_rnmo\", \"pony\"), new_state.models)\n   804\t        self.assertIn((\"test_rnmo\", \"horse\"), new_state.models)\n   805\t        # RenameModel also repoints all incoming FKs and M2Ms\n   806\t        self.assertEqual(\n   807\t            new_state.models[\"test_rnmo\", \"rider\"].fields[\"pony\"].remote_field.model,\n   808\t            \"test_rnmo.Horse\",\n   809\t        )\n   810\t        self.assertTableNotExists(\"test_rnmo_pony\")\n   811\t        self.assertTableExists(\"test_rnmo_horse\")\n   812\t        if connection.features.supports_foreign_keys:\n   813\t            self.assertFKNotExists(\n   814\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_pony\", \"id\")\n   815\t            )\n   816\t            self.assertFKExists(\n   817\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_horse\", \"id\")\n   818\t            )\n   819\t        # Migrate backwards\n   820\t        original_state = self.unapply_operations(\n   821\t            \"test_rnmo\", project_state, [operation], atomic=atomic_rename\n   822\t        )\n   823\t        # Test original state and database\n   824\t        self.assertIn((\"test_rnmo\", \"pony\"), original_state.models)\n   825\t        self.assertNotIn((\"test_rnmo\", \"horse\"), original_state.models)\n   826\t        self.assertEqual(\n   827\t            original_state.models[\"test_rnmo\", \"rider\"]\n   828\t            .fields[\"pony\"]\n   829\t            .remote_field.model,\n   830\t            \"Pony\",\n   831\t        )\n   832\t        self.assertTableExists(\"test_rnmo_pony\")\n   833\t        self.assertTableNotExists(\"test_rnmo_horse\")\n   834\t        if connection.features.supports_foreign_keys:\n   835\t            self.assertFKExists(\n   836\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_pony\", \"id\")\n   837\t            )\n   838\t            self.assertFKNotExists(\n   839\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_horse\", \"id\")\n   840\t            )\n   841\t        # And deconstruction\n   842\t        definition = operation.deconstruct()\n   843\t        self.assertEqual(definition[0], \"RenameModel\")\n   844\t        self.assertEqual(definition[1], [])\n   845\t        self.assertEqual(definition[2], {\"old_name\": \"Pony\", \"new_name\": \"Horse\"})\n   846\t\n   847\t    def test_rename_model_state_forwards(self):\n   848\t        \"\"\"\n   849\t        RenameModel operations shouldn't trigger the caching of rendered apps\n   850\t        on state without prior apps.\n   851\t        \"\"\"\n   852\t        state = ProjectState()\n   853\t        state.add_model(ModelState(\"migrations\", \"Foo\", []))\n   854\t        operation = migrations.RenameModel(\"Foo\", \"Bar\")\n   855\t        operation.state_forwards(\"migrations\", state)\n   856\t        self.assertNotIn(\"apps\", state.__dict__)\n   857\t        self.assertNotIn((\"migrations\", \"foo\"), state.models)\n   858\t        self.assertIn((\"migrations\", \"bar\"), state.models)\n   859\t        # Now with apps cached.\n   860\t        apps = state.apps\n   861\t        operation = migrations.RenameModel(\"Bar\", \"Foo\")\n   862\t        operation.state_forwards(\"migrations\", state)\n   863\t        self.assertIs(state.apps, apps)\n   864\t        self.assertNotIn((\"migrations\", \"bar\"), state.models)\n   865\t        self.assertIn((\"migrations\", \"foo\"), state.models)\n   866\t\n   867\t    def test_rename_model_with_self_referential_fk(self):\n   868\t        \"\"\"\n   869\t        Tests the RenameModel operation on model with self referential FK.\n   870\t        \"\"\"\n   871\t        project_state = self.set_up_test_model(\"test_rmwsrf\", related_model=True)\n   872\t        # Test the state alteration\n   873\t        operation = migrations.RenameModel(\"Rider\", \"HorseRider\")\n   874\t        self.assertEqual(operation.describe(), \"Rename model Rider to HorseRider\")\n   875\t        new_state = project_state.clone()\n   876\t        operation.state_forwards(\"test_rmwsrf\", new_state)\n   877\t        self.assertNotIn((\"test_rmwsrf\", \"rider\"), new_state.models)\n   878\t        self.assertIn((\"test_rmwsrf\", \"horserider\"), new_state.models)\n   879\t        # Remember, RenameModel also repoints all incoming FKs and M2Ms\n   880\t        self.assertEqual(\n   881\t            \"self\",\n   882\t            new_state.models[\"test_rmwsrf\", \"horserider\"]\n   883\t            .fields[\"friend\"]\n   884\t            .remote_field.model,\n   885\t        )\n   886\t        HorseRider = new_state.apps.get_model(\"test_rmwsrf\", \"horserider\")\n   887\t        self.assertIs(\n   888\t            HorseRider._meta.get_field(\"horserider\").remote_field.model, HorseRider\n   889\t        )\n   890\t        # Test the database alteration\n   891\t        self.assertTableExists(\"test_rmwsrf_rider\")\n   892\t        self.assertTableNotExists(\"test_rmwsrf_horserider\")\n   893\t        if connection.features.supports_foreign_keys:\n   894\t            self.assertFKExists(\n   895\t                \"test_rmwsrf_rider\", [\"friend_id\"], (\"test_rmwsrf_rider\", \"id\")\n   896\t            )\n   897\t            self.assertFKNotExists(\n   898\t                \"test_rmwsrf_rider\", [\"friend_id\"], (\"test_rmwsrf_horserider\", \"id\")\n   899\t            )\n   900\t        atomic_rename = connection.features.supports_atomic_references_rename\n   901\t        with connection.schema_editor(atomic=atomic_rename) as editor:\n   902\t            operation.database_forwards(\"test_rmwsrf\", editor, project_state, new_state)\n   903\t        self.assertTableNotExists(\"test_rmwsrf_rider\")\n   904\t        self.assertTableExists(\"test_rmwsrf_horserider\")\n   905\t        if connection.features.supports_foreign_keys:\n   906\t            self.assertFKNotExists(\n   907\t                \"test_rmwsrf_horserider\", [\"friend_id\"], (\"test_rmwsrf_rider\", \"id\")\n   908\t            )\n   909\t            self.assertFKExists(\n   910\t                \"test_rmwsrf_horserider\",\n   911\t                [\"friend_id\"],\n   912\t                (\"test_rmwsrf_horserider\", \"id\"),\n   913\t            )\n   914\t        # And test reversal\n   915\t        with connection.schema_editor(atomic=atomic_rename) as editor:\n   916\t            operation.database_backwards(\n   917\t                \"test_rmwsrf\", editor, new_state, project_state\n   918\t            )\n   919\t        self.assertTableExists(\"test_rmwsrf_rider\")\n   920\t        self.assertTableNotExists(\"test_rmwsrf_horserider\")\n   921\t        if connection.features.supports_foreign_keys:\n   922\t            self.assertFKExists(\n   923\t                \"test_rmwsrf_rider\", [\"friend_id\"], (\"test_rmwsrf_rider\", \"id\")\n   924\t            )\n   925\t            self.assertFKNotExists(\n   926\t                \"test_rmwsrf_rider\", [\"friend_id\"], (\"test_rmwsrf_horserider\", \"id\")\n   927\t            )\n   928\t\n   929\t    def test_rename_model_with_superclass_fk(self):\n   930\t        \"\"\"\n   931\t        Tests the RenameModel operation on a model which has a superclass that\n   932\t        has a foreign key.\n   933\t        \"\"\"\n   934\t        project_state = self.set_up_test_model(\n   935\t            \"test_rmwsc\", related_model=True, mti_model=True\n   936\t        )\n   937\t        # Test the state alteration\n   938\t        operation = migrations.RenameModel(\"ShetlandPony\", \"LittleHorse\")\n   939\t        self.assertEqual(\n   940\t            operation.describe(), \"Rename model ShetlandPony to LittleHorse\"\n   941\t        )\n   942\t        new_state = project_state.clone()\n   943\t        operation.state_forwards(\"test_rmwsc\", new_state)\n   944\t        self.assertNotIn((\"test_rmwsc\", \"shetlandpony\"), new_state.models)\n   945\t        self.assertIn((\"test_rmwsc\", \"littlehorse\"), new_state.models)\n   946\t        # RenameModel shouldn't repoint the superclass's relations, only local ones\n   947\t        self.assertEqual(\n   948\t            project_state.models[\"test_rmwsc\", \"rider\"]\n   949\t            .fields[\"pony\"]\n   950\t            .remote_field.model,\n   951\t            new_state.models[\"test_rmwsc\", \"rider\"].fields[\"pony\"].remote_field.model,\n   952\t        )\n   953\t        # Before running the migration we have a table for Shetland Pony, not\n   954\t        # Little Horse.\n   955\t        self.assertTableExists(\"test_rmwsc_shetlandpony\")\n   956\t        self.assertTableNotExists(\"test_rmwsc_littlehorse\")\n   957\t        if connection.features.supports_foreign_keys:\n   958\t            # and the foreign key on rider points to pony, not shetland pony\n   959\t            self.assertFKExists(\n   960\t                \"test_rmwsc_rider\", [\"pony_id\"], (\"test_rmwsc_pony\", \"id\")\n   961\t            )\n   962\t            self.assertFKNotExists(\n   963\t                \"test_rmwsc_rider\", [\"pony_id\"], (\"test_rmwsc_shetlandpony\", \"id\")\n   964\t            )\n   965\t        with connection.schema_editor(\n   966\t            atomic=connection.features.supports_atomic_references_rename\n   967\t        ) as editor:\n   968\t            operation.database_forwards(\"test_rmwsc\", editor, project_state, new_state)\n   969\t        # Now we have a little horse table, not shetland pony\n   970\t        self.assertTableNotExists(\"test_rmwsc_shetlandpony\")\n   971\t        self.assertTableExists(\"test_rmwsc_littlehorse\")\n   972\t        if connection.features.supports_foreign_keys:\n   973\t            # but the Foreign keys still point at pony, not little horse\n   974\t            self.assertFKExists(\n   975\t                \"test_rmwsc_rider\", [\"pony_id\"], (\"test_rmwsc_pony\", \"id\")\n   976\t            )\n   977\t            self.assertFKNotExists(\n   978\t                \"test_rmwsc_rider\", [\"pony_id\"], (\"test_rmwsc_littlehorse\", \"id\")\n   979\t            )\n   980\t\n   981\t    def test_rename_model_with_self_referential_m2m(self):\n   982\t        app_label = \"test_rename_model_with_self_referential_m2m\"\n   983\t\n   984\t        project_state = self.apply_operations(\n   985\t            app_label,\n   986\t            ProjectState(),\n   987\t            operations=[\n   988\t                migrations.CreateModel(\n   989\t                    \"ReflexivePony\",\n   990\t                    fields=[\n   991\t                        (\"id\", models.AutoField(primary_key=True)),\n   992\t                        (\"ponies\", models.ManyToManyField(\"self\")),\n   993\t                    ],\n   994\t                ),\n   995\t            ],\n   996\t        )\n   997\t        project_state = self.apply_operations(\n   998\t            app_label,\n   999\t            project_state,\n  1000\t            operations=[\n  1001\t                migrations.RenameModel(\"ReflexivePony\", \"ReflexivePony2\"),\n  1002\t            ],\n  1003\t            atomic=connection.features.supports_atomic_references_rename,\n  1004\t        )\n  1005\t        Pony = project_state.apps.get_model(app_label, \"ReflexivePony2\")\n  1006\t        pony = Pony.objects.create()\n  1007\t        pony.ponies.add(pony)\n  1008\t\n  1009\t    def test_rename_model_with_m2m(self):\n  1010\t        app_label = \"test_rename_model_with_m2m\"\n  1011\t        project_state = self.apply_operations(\n  1012\t            app_label,\n  1013\t            ProjectState(),\n  1014\t            operations=[\n  1015\t                migrations.CreateModel(\n  1016\t                    \"Rider\",\n  1017\t                    fields=[\n  1018\t                        (\"id\", models.AutoField(primary_key=True)),\n  1019\t                    ],\n  1020\t                ),\n  1021\t                migrations.CreateModel(\n  1022\t                    \"Pony\",\n  1023\t                    fields=[\n  1024\t                        (\"id\", models.AutoField(primary_key=True)),\n  1025\t                        (\"riders\", models.ManyToManyField(\"Rider\")),\n  1026\t                    ],\n  1027\t                ),\n  1028\t            ],\n  1029\t        )\n  1030\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1031\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1032\t        pony = Pony.objects.create()\n  1033\t        rider = Rider.objects.create()\n  1034\t        pony.riders.add(rider)\n  1035\t\n  1036\t        project_state = self.apply_operations(\n  1037\t            app_label,\n  1038\t            project_state,\n  1039\t            operations=[\n  1040\t                migrations.RenameModel(\"Pony\", \"Pony2\"),\n  1041\t            ],\n  1042\t            atomic=connection.features.supports_atomic_references_rename,\n  1043\t        )\n  1044\t        Pony = project_state.apps.get_model(app_label, \"Pony2\")\n  1045\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1046\t        pony = Pony.objects.create()\n  1047\t        rider = Rider.objects.create()\n  1048\t        pony.riders.add(rider)\n  1049\t        self.assertEqual(Pony.objects.count(), 2)\n  1050\t        self.assertEqual(Rider.objects.count(), 2)\n  1051\t        self.assertEqual(\n  1052\t            Pony._meta.get_field(\"riders\").remote_field.through.objects.count(), 2\n  1053\t        )\n  1054\t\n  1055\t    def test_rename_model_with_db_table_noop(self):\n  1056\t        app_label = \"test_rmwdbtn\"\n  1057\t        project_state = self.apply_operations(\n  1058\t            app_label,\n  1059\t            ProjectState(),\n  1060\t            operations=[\n  1061\t                migrations.CreateModel(\n  1062\t                    \"Rider\",\n  1063\t                    fields=[\n  1064\t                        (\"id\", models.AutoField(primary_key=True)),\n  1065\t                    ],\n  1066\t                    options={\"db_table\": \"rider\"},\n  1067\t                ),\n  1068\t                migrations.CreateModel(\n  1069\t                    \"Pony\",\n  1070\t                    fields=[\n  1071\t                        (\"id\", models.AutoField(primary_key=True)),\n  1072\t                        (\n  1073\t                            \"rider\",\n  1074\t                            models.ForeignKey(\"%s.Rider\" % app_label, models.CASCADE),\n  1075\t                        ),\n  1076\t                    ],\n  1077\t                ),\n  1078\t            ],\n  1079\t        )\n  1080\t        new_state = project_state.clone()\n  1081\t        operation = migrations.RenameModel(\"Rider\", \"Runner\")\n  1082\t        operation.state_forwards(app_label, new_state)\n  1083\t\n  1084\t        with connection.schema_editor() as editor:\n  1085\t            with self.assertNumQueries(0):\n  1086\t                operation.database_forwards(app_label, editor, project_state, new_state)\n  1087\t        with connection.schema_editor() as editor:\n  1088\t            with self.assertNumQueries(0):\n  1089\t                operation.database_backwards(\n  1090\t                    app_label, editor, new_state, project_state\n  1091\t                )\n  1092\t\n  1093\t    def test_rename_m2m_target_model(self):\n  1094\t        app_label = \"test_rename_m2m_target_model\"\n  1095\t        project_state = self.apply_operations(\n  1096\t            app_label,\n  1097\t            ProjectState(),\n  1098\t            operations=[\n  1099\t                migrations.CreateModel(\n  1100\t                    \"Rider\",\n  1101\t                    fields=[\n  1102\t                        (\"id\", models.AutoField(primary_key=True)),\n  1103\t                    ],\n  1104\t                ),\n  1105\t                migrations.CreateModel(\n  1106\t                    \"Pony\",\n  1107\t                    fields=[\n  1108\t                        (\"id\", models.AutoField(primary_key=True)),\n  1109\t                        (\"riders\", models.ManyToManyField(\"Rider\")),\n  1110\t                    ],\n  1111\t                ),\n  1112\t            ],\n  1113\t        )\n  1114\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1115\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1116\t        pony = Pony.objects.create()\n  1117\t        rider = Rider.objects.create()\n  1118\t        pony.riders.add(rider)\n  1119\t\n  1120\t        project_state = self.apply_operations(\n  1121\t            app_label,\n  1122\t            project_state,\n  1123\t            operations=[\n  1124\t                migrations.RenameModel(\"Rider\", \"Rider2\"),\n  1125\t            ],\n  1126\t            atomic=connection.features.supports_atomic_references_rename,\n  1127\t        )\n  1128\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1129\t        Rider = project_state.apps.get_model(app_label, \"Rider2\")\n  1130\t        pony = Pony.objects.create()\n  1131\t        rider = Rider.objects.create()\n  1132\t        pony.riders.add(rider)\n  1133\t        self.assertEqual(Pony.objects.count(), 2)\n  1134\t        self.assertEqual(Rider.objects.count(), 2)\n  1135\t        self.assertEqual(\n  1136\t            Pony._meta.get_field(\"riders\").remote_field.through.objects.count(), 2\n  1137\t        )\n  1138\t\n  1139\t    def test_rename_m2m_through_model(self):\n  1140\t        app_label = \"test_rename_through\"\n  1141\t        project_state = self.apply_operations(\n  1142\t            app_label,\n  1143\t            ProjectState(),\n  1144\t            operations=[\n  1145\t                migrations.CreateModel(\n  1146\t                    \"Rider\",\n  1147\t                    fields=[\n  1148\t                        (\"id\", models.AutoField(primary_key=True)),\n  1149\t                    ],\n  1150\t                ),\n  1151\t                migrations.CreateModel(\n  1152\t                    \"Pony\",\n  1153\t                    fields=[\n  1154\t                        (\"id\", models.AutoField(primary_key=True)),\n  1155\t                    ],\n  1156\t                ),\n  1157\t                migrations.CreateModel(\n  1158\t                    \"PonyRider\",\n  1159\t                    fields=[\n  1160\t                        (\"id\", models.AutoField(primary_key=True)),\n  1161\t                        (\n  1162\t                            \"rider\",\n  1163\t                            models.ForeignKey(\n  1164\t                                \"test_rename_through.Rider\", models.CASCADE\n  1165\t                            ),\n  1166\t                        ),\n  1167\t                        (\n  1168\t                            \"pony\",\n  1169\t                            models.ForeignKey(\n  1170\t                                \"test_rename_through.Pony\", models.CASCADE\n  1171\t                            ),\n  1172\t                        ),\n  1173\t                    ],\n  1174\t                ),\n  1175\t                migrations.AddField(\n  1176\t                    \"Pony\",\n  1177\t                    \"riders\",\n  1178\t                    models.ManyToManyField(\n  1179\t                        \"test_rename_through.Rider\",\n  1180\t                        through=\"test_rename_through.PonyRider\",\n  1181\t                    ),\n  1182\t                ),\n  1183\t            ],\n  1184\t        )\n  1185\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1186\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1187\t        PonyRider = project_state.apps.get_model(app_label, \"PonyRider\")\n  1188\t        pony = Pony.objects.create()\n  1189\t        rider = Rider.objects.create()\n  1190\t        PonyRider.objects.create(pony=pony, rider=rider)\n  1191\t\n  1192\t        project_state = self.apply_operations(\n  1193\t            app_label,\n  1194\t            project_state,\n  1195\t            operations=[\n  1196\t                migrations.RenameModel(\"PonyRider\", \"PonyRider2\"),\n  1197\t            ],\n  1198\t        )\n  1199\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1200\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1201\t        PonyRider = project_state.apps.get_model(app_label, \"PonyRider2\")\n  1202\t        pony = Pony.objects.first()\n  1203\t        rider = Rider.objects.create()\n  1204\t        PonyRider.objects.create(pony=pony, rider=rider)\n  1205\t        self.assertEqual(Pony.objects.count(), 1)\n  1206\t        self.assertEqual(Rider.objects.count(), 2)\n  1207\t        self.assertEqual(PonyRider.objects.count(), 2)\n  1208\t        self.assertEqual(pony.riders.count(), 2)\n  1209\t\n  1210\t    def test_rename_m2m_model_after_rename_field(self):\n  1211\t        \"\"\"RenameModel renames a many-to-many column after a RenameField.\"\"\"\n  1212\t        app_label = \"test_rename_multiple\"\n  1213\t        project_state = self.apply_operations(\n  1214\t            app_label,\n  1215\t            ProjectState(),\n  1216\t            operations=[\n  1217\t                migrations.CreateModel(\n  1218\t                    \"Pony\",\n  1219\t                    fields=[\n  1220\t                        (\"id\", models.AutoField(primary_key=True)),\n  1221\t                        (\"name\", models.CharField(max_length=20)),\n  1222\t                    ],\n  1223\t                ),\n  1224\t                migrations.CreateModel(\n  1225\t                    \"Rider\",\n  1226\t                    fields=[\n  1227\t                        (\"id\", models.AutoField(primary_key=True)),\n  1228\t                        (\n  1229\t                            \"pony\",\n  1230\t                            models.ForeignKey(\n  1231\t                                \"test_rename_multiple.Pony\", models.CASCADE\n  1232\t                            ),\n  1233\t                        ),\n  1234\t                    ],\n  1235\t                ),\n  1236\t                migrations.CreateModel(\n  1237\t                    \"PonyRider\",\n  1238\t                    fields=[\n  1239\t                        (\"id\", models.AutoField(primary_key=True)),\n  1240\t                        (\"riders\", models.ManyToManyField(\"Rider\")),\n  1241\t                    ],\n  1242\t                ),\n  1243\t                migrations.RenameField(\n  1244\t                    model_name=\"pony\", old_name=\"name\", new_name=\"fancy_name\"\n  1245\t                ),\n  1246\t                migrations.RenameModel(old_name=\"Rider\", new_name=\"Jockey\"),\n  1247\t            ],\n  1248\t            atomic=connection.features.supports_atomic_references_rename,\n  1249\t        )\n  1250\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1251\t        Jockey = project_state.apps.get_model(app_label, \"Jockey\")\n  1252\t        PonyRider = project_state.apps.get_model(app_label, \"PonyRider\")\n  1253\t        # No \"no such column\" error means the column was renamed correctly.\n  1254\t        pony = Pony.objects.create(fancy_name=\"a good name\")\n  1255\t        jockey = Jockey.objects.create(pony=pony)\n  1256\t        ponyrider = PonyRider.objects.create()\n  1257\t        ponyrider.riders.add(jockey)\n  1258\t\n  1259\t    def test_add_field(self):\n  1260\t        \"\"\"\n  1261\t        Tests the AddField operation.\n  1262\t        \"\"\"\n  1263\t        # Test the state alteration\n  1264\t        operation = migrations.AddField(\n  1265\t            \"Pony\",\n  1266\t            \"height\",\n  1267\t            models.FloatField(null=True, default=5),\n  1268\t        )\n  1269\t        self.assertEqual(operation.describe(), \"Add field height to Pony\")\n  1270\t        self.assertEqual(operation.migration_name_fragment, \"pony_height\")\n  1271\t        project_state, new_state = self.make_test_state(\"test_adfl\", operation)\n  1272\t        self.assertEqual(len(new_state.models[\"test_adfl\", \"pony\"].fields), 4)\n  1273\t        field = new_state.models[\"test_adfl\", \"pony\"].fields[\"height\"]\n  1274\t        self.assertEqual(field.default, 5)\n  1275\t        # Test the database alteration\n  1276\t        self.assertColumnNotExists(\"test_adfl_pony\", \"height\")\n  1277\t        with connection.schema_editor() as editor:\n  1278\t            operation.database_forwards(\"test_adfl\", editor, project_state, new_state)\n  1279\t        self.assertColumnExists(\"test_adfl_pony\", \"height\")\n  1280\t        # And test reversal\n  1281\t        with connection.schema_editor() as editor:\n  1282\t            operation.database_backwards(\"test_adfl\", editor, new_state, project_state)\n  1283\t        self.assertColumnNotExists(\"test_adfl_pony\", \"height\")\n  1284\t        # And deconstruction\n  1285\t        definition = operation.deconstruct()\n  1286\t        self.assertEqual(definition[0], \"AddField\")\n  1287\t        self.assertEqual(definition[1], [])\n  1288\t        self.assertEqual(sorted(definition[2]), [\"field\", \"model_name\", \"name\"])\n  1289\t\n  1290\t    def test_add_charfield(self):\n  1291\t        \"\"\"\n  1292\t        Tests the AddField operation on TextField.\n  1293\t        \"\"\"\n  1294\t        project_state = self.set_up_test_model(\"test_adchfl\")\n  1295\t\n  1296\t        Pony = project_state.apps.get_model(\"test_adchfl\", \"Pony\")\n  1297\t        pony = Pony.objects.create(weight=42)\n  1298\t\n  1299\t        new_state = self.apply_operations(\n  1300\t            \"test_adchfl\",\n  1301\t            project_state,\n  1302\t            [\n  1303\t                migrations.AddField(\n  1304\t                    \"Pony\",\n  1305\t                    \"text\",\n  1306\t                    models.CharField(max_length=10, default=\"some text\"),\n  1307\t                ),\n  1308\t                migrations.AddField(\n  1309\t                    \"Pony\",\n  1310\t                    \"empty\",\n  1311\t                    models.CharField(max_length=10, default=\"\"),\n  1312\t                ),\n  1313\t                # If not properly quoted digits would be interpreted as an int.\n  1314\t                migrations.AddField(\n  1315\t                    \"Pony\",\n  1316\t                    \"digits\",\n  1317\t                    models.CharField(max_length=10, default=\"42\"),\n  1318\t                ),\n  1319\t                # Manual quoting is fragile and could trip on quotes. Refs #xyz.\n  1320\t                migrations.AddField(\n  1321\t                    \"Pony\",\n  1322\t                    \"quotes\",\n  1323\t                    models.CharField(max_length=10, default='\"\\'\"'),\n  1324\t                ),\n  1325\t            ],\n  1326\t        )\n  1327\t\n  1328\t        Pony = new_state.apps.get_model(\"test_adchfl\", \"Pony\")\n  1329\t        pony = Pony.objects.get(pk=pony.pk)\n  1330\t        self.assertEqual(pony.text, \"some text\")\n  1331\t        self.assertEqual(pony.empty, \"\")\n  1332\t        self.assertEqual(pony.digits, \"42\")\n  1333\t        self.assertEqual(pony.quotes, '\"\\'\"')\n  1334\t\n  1335\t    def test_add_textfield(self):\n  1336\t        \"\"\"\n  1337\t        Tests the AddField operation on TextField.\n  1338\t        \"\"\"\n  1339\t        project_state = self.set_up_test_model(\"test_adtxtfl\")\n  1340\t\n  1341\t        Pony = project_state.apps.get_model(\"test_adtxtfl\", \"Pony\")\n  1342\t        pony = Pony.objects.create(weight=42)\n  1343\t\n  1344\t        new_state = self.apply_operations(\n  1345\t            \"test_adtxtfl\",\n  1346\t            project_state,\n  1347\t            [\n  1348\t                migrations.AddField(\n  1349\t                    \"Pony\",\n  1350\t                    \"text\",\n  1351\t                    models.TextField(default=\"some text\"),\n  1352\t                ),\n  1353\t                migrations.AddField(\n  1354\t                    \"Pony\",\n  1355\t                    \"empty\",\n  1356\t                    models.TextField(default=\"\"),\n  1357\t                ),\n  1358\t                # If not properly quoted digits would be interpreted as an int.\n  1359\t                migrations.AddField(\n  1360\t                    \"Pony\",\n  1361\t                    \"digits\",\n  1362\t                    models.TextField(default=\"42\"),\n  1363\t                ),\n  1364\t                # Manual quoting is fragile and could trip on quotes. Refs #xyz.\n  1365\t                migrations.AddField(\n  1366\t                    \"Pony\",\n  1367\t                    \"quotes\",\n  1368\t                    models.TextField(default='\"\\'\"'),\n  1369\t                ),\n  1370\t            ],\n  1371\t        )\n  1372\t\n  1373\t        Pony = new_state.apps.get_model(\"test_adtxtfl\", \"Pony\")\n  1374\t        pony = Pony.objects.get(pk=pony.pk)\n  1375\t        self.assertEqual(pony.text, \"some text\")\n  1376\t        self.assertEqual(pony.empty, \"\")\n  1377\t        self.assertEqual(pony.digits, \"42\")\n  1378\t        self.assertEqual(pony.quotes, '\"\\'\"')\n  1379\t\n  1380\t    def test_add_binaryfield(self):\n  1381\t        \"\"\"\n  1382\t        Tests the AddField operation on TextField/BinaryField.\n  1383\t        \"\"\"\n  1384\t        project_state = self.set_up_test_model(\"test_adbinfl\")\n  1385\t\n  1386\t        Pony = project_state.apps.get_model(\"test_adbinfl\", \"Pony\")\n  1387\t        pony = Pony.objects.create(weight=42)\n  1388\t\n  1389\t        new_state = self.apply_operations(\n  1390\t            \"test_adbinfl\",\n  1391\t            project_state,\n  1392\t            [\n  1393\t                migrations.AddField(\n  1394\t                    \"Pony\",\n  1395\t                    \"blob\",\n  1396\t                    models.BinaryField(default=b\"some text\"),\n  1397\t                ),\n  1398\t                migrations.AddField(\n  1399\t                    \"Pony\",\n  1400\t                    \"empty\",\n  1401\t                    models.BinaryField(default=b\"\"),\n  1402\t                ),\n  1403\t                # If not properly quoted digits would be interpreted as an int.\n  1404\t                migrations.AddField(\n  1405\t                    \"Pony\",\n  1406\t                    \"digits\",\n  1407\t                    models.BinaryField(default=b\"42\"),\n  1408\t                ),\n  1409\t                # Manual quoting is fragile and could trip on quotes. Refs #xyz.\n  1410\t                migrations.AddField(\n  1411\t                    \"Pony\",\n  1412\t                    \"quotes\",\n  1413\t                    models.BinaryField(default=b'\"\\'\"'),\n  1414\t                ),\n  1415\t            ],\n  1416\t        )\n  1417\t\n  1418\t        Pony = new_state.apps.get_model(\"test_adbinfl\", \"Pony\")\n  1419\t        pony = Pony.objects.get(pk=pony.pk)\n  1420\t        # SQLite returns buffer/memoryview, cast to bytes for checking.\n  1421\t        self.assertEqual(bytes(pony.blob), b\"some text\")\n  1422\t        self.assertEqual(bytes(pony.empty), b\"\")\n  1423\t        self.assertEqual(bytes(pony.digits), b\"42\")\n  1424\t        self.assertEqual(bytes(pony.quotes), b'\"\\'\"')\n  1425\t\n  1426\t    def test_column_name_quoting(self):\n  1427\t        \"\"\"\n  1428\t        Column names that are SQL keywords shouldn't cause problems when used\n  1429\t        in migrations (#22168).\n  1430\t        \"\"\"\n  1431\t        project_state = self.set_up_test_model(\"test_regr22168\")\n  1432\t        operation = migrations.AddField(\n  1433\t            \"Pony\",\n  1434\t            \"order\",\n  1435\t            models.IntegerField(default=0),\n  1436\t        )\n  1437\t        new_state = project_state.clone()\n  1438\t        operation.state_forwards(\"test_regr22168\", new_state)\n  1439\t        with connection.schema_editor() as editor:\n  1440\t            operation.database_forwards(\n  1441\t                \"test_regr22168\", editor, project_state, new_state\n  1442\t            )\n  1443\t        self.assertColumnExists(\"test_regr22168_pony\", \"order\")\n  1444\t\n  1445\t    def test_add_field_preserve_default(self):\n  1446\t        \"\"\"\n  1447\t        Tests the AddField operation's state alteration\n  1448\t        when preserve_default = False.\n  1449\t        \"\"\"\n  1450\t        project_state = self.set_up_test_model(\"test_adflpd\")\n  1451\t        # Test the state alteration\n  1452\t        operation = migrations.AddField(\n  1453\t            \"Pony\",\n  1454\t            \"height\",\n  1455\t            models.FloatField(null=True, default=4),\n  1456\t            preserve_default=False,\n  1457\t        )\n  1458\t        new_state = project_state.clone()\n  1459\t        operation.state_forwards(\"test_adflpd\", new_state)\n  1460\t        self.assertEqual(len(new_state.models[\"test_adflpd\", \"pony\"].fields), 4)\n  1461\t        field = new_state.models[\"test_adflpd\", \"pony\"].fields[\"height\"]\n  1462\t        self.assertEqual(field.default, models.NOT_PROVIDED)\n  1463\t        # Test the database alteration\n  1464\t        project_state.apps.get_model(\"test_adflpd\", \"pony\").objects.create(\n  1465\t            weight=4,\n  1466\t        )\n  1467\t        self.assertColumnNotExists(\"test_adflpd_pony\", \"height\")\n  1468\t        with connection.schema_editor() as editor:\n  1469\t            operation.database_forwards(\"test_adflpd\", editor, project_state, new_state)\n  1470\t        self.assertColumnExists(\"test_adflpd_pony\", \"height\")\n  1471\t        # And deconstruction\n  1472\t        definition = operation.deconstruct()\n  1473\t        self.assertEqual(definition[0], \"AddField\")\n  1474\t        self.assertEqual(definition[1], [])\n  1475\t        self.assertEqual(\n  1476\t            sorted(definition[2]), [\"field\", \"model_name\", \"name\", \"preserve_default\"]\n  1477\t        )\n  1478\t\n  1479\t    def test_add_field_m2m(self):\n  1480\t        \"\"\"\n  1481\t        Tests the AddField operation with a ManyToManyField.\n  1482\t        \"\"\"\n  1483\t        project_state = self.set_up_test_model(\"test_adflmm\", second_model=True)\n  1484\t        # Test the state alteration\n  1485\t        operation = migrations.AddField(\n  1486\t            \"Pony\", \"stables\", models.ManyToManyField(\"Stable\", related_name=\"ponies\")\n  1487\t        )\n  1488\t        new_state = project_state.clone()\n  1489\t        operation.state_forwards(\"test_adflmm\", new_state)\n  1490\t        self.assertEqual(len(new_state.models[\"test_adflmm\", \"pony\"].fields), 4)\n  1491\t        # Test the database alteration\n  1492\t        self.assertTableNotExists(\"test_adflmm_pony_stables\")\n  1493\t        with connection.schema_editor() as editor:\n  1494\t            operation.database_forwards(\"test_adflmm\", editor, project_state, new_state)\n  1495\t        self.assertTableExists(\"test_adflmm_pony_stables\")\n  1496\t        self.assertColumnNotExists(\"test_adflmm_pony\", \"stables\")\n  1497\t        # Make sure the M2M field actually works\n  1498\t        with atomic():\n  1499\t            Pony = new_state.apps.get_model(\"test_adflmm\", \"Pony\")\n  1500\t            p = Pony.objects.create(pink=False, weight=4.55)\n  1501\t            p.stables.create()\n  1502\t            self.assertEqual(p.stables.count(), 1)\n  1503\t            p.stables.all().delete()\n  1504\t        # And test reversal\n  1505\t        with connection.schema_editor() as editor:\n  1506\t            operation.database_backwards(\n  1507\t                \"test_adflmm\", editor, new_state, project_state\n  1508\t            )\n  1509\t        self.assertTableNotExists(\"test_adflmm_pony_stables\")\n  1510\t\n  1511\t    def test_alter_field_m2m(self):\n  1512\t        project_state = self.set_up_test_model(\"test_alflmm\", second_model=True)\n  1513\t\n  1514\t        project_state = self.apply_operations(\n  1515\t            \"test_alflmm\",\n  1516\t            project_state,\n  1517\t            operations=[\n  1518\t                migrations.AddField(\n  1519\t                    \"Pony\",\n  1520\t                    \"stables\",\n  1521\t                    models.ManyToManyField(\"Stable\", related_name=\"ponies\"),\n  1522\t                )\n  1523\t            ],\n  1524\t        )\n  1525\t        Pony = project_state.apps.get_model(\"test_alflmm\", \"Pony\")\n  1526\t        self.assertFalse(Pony._meta.get_field(\"stables\").blank)\n  1527\t\n  1528\t        project_state = self.apply_operations(\n  1529\t            \"test_alflmm\",\n  1530\t            project_state,\n  1531\t            operations=[\n  1532\t                migrations.AlterField(\n  1533\t                    \"Pony\",\n  1534\t                    \"stables\",\n  1535\t                    models.ManyToManyField(\n  1536\t                        to=\"Stable\", related_name=\"ponies\", blank=True\n  1537\t                    ),\n  1538\t                )\n  1539\t            ],\n  1540\t        )\n  1541\t        Pony = project_state.apps.get_model(\"test_alflmm\", \"Pony\")\n  1542\t        self.assertTrue(Pony._meta.get_field(\"stables\").blank)\n  1543\t\n  1544\t    def test_repoint_field_m2m(self):\n  1545\t        project_state = self.set_up_test_model(\n  1546\t            \"test_alflmm\", second_model=True, third_model=True\n  1547\t        )\n  1548\t\n  1549\t        project_state = self.apply_operations(\n  1550\t            \"test_alflmm\",\n  1551\t            project_state,\n  1552\t            operations=[\n  1553\t                migrations.AddField(\n  1554\t                    \"Pony\",\n  1555\t                    \"places\",\n  1556\t                    models.ManyToManyField(\"Stable\", related_name=\"ponies\"),\n  1557\t                )\n  1558\t            ],\n  1559\t        )\n  1560\t        Pony = project_state.apps.get_model(\"test_alflmm\", \"Pony\")\n  1561\t\n  1562\t        project_state = self.apply_operations(\n  1563\t            \"test_alflmm\",\n  1564\t            project_state,\n  1565\t            operations=[\n  1566\t                migrations.AlterField(\n  1567\t                    \"Pony\",\n  1568\t                    \"places\",\n  1569\t                    models.ManyToManyField(to=\"Van\", related_name=\"ponies\"),\n  1570\t                )\n  1571\t            ],\n  1572\t        )\n  1573\t\n  1574\t        # Ensure the new field actually works\n  1575\t        Pony = project_state.apps.get_model(\"test_alflmm\", \"Pony\")\n  1576\t        p = Pony.objects.create(pink=False, weight=4.55)\n  1577\t        p.places.create()\n  1578\t        self.assertEqual(p.places.count(), 1)\n  1579\t        p.places.all().delete()\n  1580\t\n  1581\t    def test_remove_field_m2m(self):\n  1582\t        project_state = self.set_up_test_model(\"test_rmflmm\", second_model=True)\n  1583\t\n  1584\t        project_state = self.apply_operations(\n  1585\t            \"test_rmflmm\",\n  1586\t            project_state,\n  1587\t            operations=[\n  1588\t                migrations.AddField(\n  1589\t                    \"Pony\",\n  1590\t                    \"stables\",\n  1591\t                    models.ManyToManyField(\"Stable\", related_name=\"ponies\"),\n  1592\t                )\n  1593\t            ],\n  1594\t        )\n  1595\t        self.assertTableExists(\"test_rmflmm_pony_stables\")\n  1596\t\n  1597\t        with_field_state = project_state.clone()\n  1598\t        operations = [migrations.RemoveField(\"Pony\", \"stables\")]\n  1599\t        project_state = self.apply_operations(\n  1600\t            \"test_rmflmm\", project_state, operations=operations\n  1601\t        )\n  1602\t        self.assertTableNotExists(\"test_rmflmm_pony_stables\")\n  1603\t\n  1604\t        # And test reversal\n  1605\t        self.unapply_operations(\"test_rmflmm\", with_field_state, operations=operations)\n  1606\t        self.assertTableExists(\"test_rmflmm_pony_stables\")\n  1607\t\n  1608\t    def test_remove_field_m2m_with_through(self):\n  1609\t        project_state = self.set_up_test_model(\"test_rmflmmwt\", second_model=True)\n  1610\t\n  1611\t        self.assertTableNotExists(\"test_rmflmmwt_ponystables\")\n  1612\t        project_state = self.apply_operations(\n  1613\t            \"test_rmflmmwt\",\n  1614\t            project_state,\n  1615\t            operations=[\n  1616\t                migrations.CreateModel(\n  1617\t                    \"PonyStables\",\n  1618\t                    fields=[\n  1619\t                        (\n  1620\t                            \"pony\",\n  1621\t                            models.ForeignKey(\"test_rmflmmwt.Pony\", models.CASCADE),\n  1622\t                        ),\n  1623\t                        (\n  1624\t                            \"stable\",\n  1625\t                            models.ForeignKey(\"test_rmflmmwt.Stable\", models.CASCADE),\n  1626\t                        ),\n  1627\t                    ],\n  1628\t                ),\n  1629\t                migrations.AddField(\n  1630\t                    \"Pony\",\n  1631\t                    \"stables\",\n  1632\t                    models.ManyToManyField(\n  1633\t                        \"Stable\",\n  1634\t                        related_name=\"ponies\",\n  1635\t                        through=\"test_rmflmmwt.PonyStables\",\n  1636\t                    ),\n  1637\t                ),\n  1638\t            ],\n  1639\t        )\n  1640\t        self.assertTableExists(\"test_rmflmmwt_ponystables\")\n  1641\t\n  1642\t        operations = [\n  1643\t            migrations.RemoveField(\"Pony\", \"stables\"),\n  1644\t            migrations.DeleteModel(\"PonyStables\"),\n  1645\t        ]\n  1646\t        self.apply_operations(\"test_rmflmmwt\", project_state, operations=operations)\n  1647\t\n  1648\t    def test_remove_field(self):\n  1649\t        \"\"\"\n  1650\t        Tests the RemoveField operation.\n  1651\t        \"\"\"\n  1652\t        project_state = self.set_up_test_model(\"test_rmfl\")\n  1653\t        # Test the state alteration\n  1654\t        operation = migrations.RemoveField(\"Pony\", \"pink\")\n  1655\t        self.assertEqual(operation.describe(), \"Remove field pink from Pony\")\n  1656\t        self.assertEqual(operation.migration_name_fragment, \"remove_pony_pink\")\n  1657\t        new_state = project_state.clone()\n  1658\t        operation.state_forwards(\"test_rmfl\", new_state)\n  1659\t        self.assertEqual(len(new_state.models[\"test_rmfl\", \"pony\"].fields), 2)\n  1660\t        # Test the database alteration\n  1661\t        self.assertColumnExists(\"test_rmfl_pony\", \"pink\")\n  1662\t        with connection.schema_editor() as editor:\n  1663\t            operation.database_forwards(\"test_rmfl\", editor, project_state, new_state)\n  1664\t        self.assertColumnNotExists(\"test_rmfl_pony\", \"pink\")\n  1665\t        # And test reversal\n  1666\t        with connection.schema_editor() as editor:\n  1667\t            operation.database_backwards(\"test_rmfl\", editor, new_state, project_state)\n  1668\t        self.assertColumnExists(\"test_rmfl_pony\", \"pink\")\n  1669\t        # And deconstruction\n  1670\t        definition = operation.deconstruct()\n  1671\t        self.assertEqual(definition[0], \"RemoveField\")\n  1672\t        self.assertEqual(definition[1], [])\n  1673\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"name\": \"pink\"})\n  1674\t\n  1675\t    def test_remove_fk(self):\n  1676\t        \"\"\"\n  1677\t        Tests the RemoveField operation on a foreign key.\n  1678\t        \"\"\"\n  1679\t        project_state = self.set_up_test_model(\"test_rfk\", related_model=True)\n  1680\t        self.assertColumnExists(\"test_rfk_rider\", \"pony_id\")\n  1681\t        operation = migrations.RemoveField(\"Rider\", \"pony\")\n  1682\t\n  1683\t        new_state = project_state.clone()\n  1684\t        operation.state_forwards(\"test_rfk\", new_state)\n  1685\t        with connection.schema_editor() as editor:\n  1686\t            operation.database_forwards(\"test_rfk\", editor, project_state, new_state)\n  1687\t        self.assertColumnNotExists(\"test_rfk_rider\", \"pony_id\")\n  1688\t        with connection.schema_editor() as editor:\n  1689\t            operation.database_backwards(\"test_rfk\", editor, new_state, project_state)\n  1690\t        self.assertColumnExists(\"test_rfk_rider\", \"pony_id\")\n  1691\t\n  1692\t    def test_alter_model_table(self):\n  1693\t        \"\"\"\n  1694\t        Tests the AlterModelTable operation.\n  1695\t        \"\"\"\n  1696\t        project_state = self.set_up_test_model(\"test_almota\")\n  1697\t        # Test the state alteration\n  1698\t        operation = migrations.AlterModelTable(\"Pony\", \"test_almota_pony_2\")\n  1699\t        self.assertEqual(\n  1700\t            operation.describe(), \"Rename table for Pony to test_almota_pony_2\"\n  1701\t        )\n  1702\t        self.assertEqual(operation.migration_name_fragment, \"alter_pony_table\")\n  1703\t        new_state = project_state.clone()\n  1704\t        operation.state_forwards(\"test_almota\", new_state)\n  1705\t        self.assertEqual(\n  1706\t            new_state.models[\"test_almota\", \"pony\"].options[\"db_table\"],\n  1707\t            \"test_almota_pony_2\",\n  1708\t        )\n  1709\t        # Test the database alteration\n  1710\t        self.assertTableExists(\"test_almota_pony\")\n  1711\t        self.assertTableNotExists(\"test_almota_pony_2\")\n  1712\t        with connection.schema_editor() as editor:\n  1713\t            operation.database_forwards(\"test_almota\", editor, project_state, new_state)\n  1714\t        self.assertTableNotExists(\"test_almota_pony\")\n  1715\t        self.assertTableExists(\"test_almota_pony_2\")\n  1716\t        # And test reversal\n  1717\t        with connection.schema_editor() as editor:\n  1718\t            operation.database_backwards(\n  1719\t                \"test_almota\", editor, new_state, project_state\n  1720\t            )\n  1721\t        self.assertTableExists(\"test_almota_pony\")\n  1722\t        self.assertTableNotExists(\"test_almota_pony_2\")\n  1723\t        # And deconstruction\n  1724\t        definition = operation.deconstruct()\n  1725\t        self.assertEqual(definition[0], \"AlterModelTable\")\n  1726\t        self.assertEqual(definition[1], [])\n  1727\t        self.assertEqual(definition[2], {\"name\": \"Pony\", \"table\": \"test_almota_pony_2\"})\n  1728\t\n  1729\t    def test_alter_model_table_none(self):\n  1730\t        \"\"\"\n  1731\t        Tests the AlterModelTable operation if the table name is set to None.\n  1732\t        \"\"\"\n  1733\t        operation = migrations.AlterModelTable(\"Pony\", None)\n  1734\t        self.assertEqual(operation.describe(), \"Rename table for Pony to (default)\")\n  1735\t\n  1736\t    def test_alter_model_table_noop(self):\n  1737\t        \"\"\"\n  1738\t        Tests the AlterModelTable operation if the table name is not changed.\n  1739\t        \"\"\"\n  1740\t        project_state = self.set_up_test_model(\"test_almota\")\n  1741\t        # Test the state alteration\n  1742\t        operation = migrations.AlterModelTable(\"Pony\", \"test_almota_pony\")\n  1743\t        new_state = project_state.clone()\n  1744\t        operation.state_forwards(\"test_almota\", new_state)\n  1745\t        self.assertEqual(\n  1746\t            new_state.models[\"test_almota\", \"pony\"].options[\"db_table\"],\n  1747\t            \"test_almota_pony\",\n  1748\t        )\n  1749\t        # Test the database alteration\n  1750\t        self.assertTableExists(\"test_almota_pony\")\n  1751\t        with connection.schema_editor() as editor:\n  1752\t            operation.database_forwards(\"test_almota\", editor, project_state, new_state)\n  1753\t        self.assertTableExists(\"test_almota_pony\")\n  1754\t        # And test reversal\n  1755\t        with connection.schema_editor() as editor:\n  1756\t            operation.database_backwards(\n  1757\t                \"test_almota\", editor, new_state, project_state\n  1758\t            )\n  1759\t        self.assertTableExists(\"test_almota_pony\")\n  1760\t\n  1761\t    def test_alter_model_table_m2m(self):\n  1762\t        \"\"\"\n  1763\t        AlterModelTable should rename auto-generated M2M tables.\n  1764\t        \"\"\"\n  1765\t        app_label = \"test_talflmltlm2m\"\n  1766\t        pony_db_table = \"pony_foo\"\n  1767\t        project_state = self.set_up_test_model(\n  1768\t            app_label, second_model=True, db_table=pony_db_table\n  1769\t        )\n  1770\t        # Add the M2M field\n  1771\t        first_state = project_state.clone()\n  1772\t        operation = migrations.AddField(\n  1773\t            \"Pony\", \"stables\", models.ManyToManyField(\"Stable\")\n  1774\t        )\n  1775\t        operation.state_forwards(app_label, first_state)\n  1776\t        with connection.schema_editor() as editor:\n  1777\t            operation.database_forwards(app_label, editor, project_state, first_state)\n  1778\t        original_m2m_table = \"%s_%s\" % (pony_db_table, \"stables\")\n  1779\t        new_m2m_table = \"%s_%s\" % (app_label, \"pony_stables\")\n  1780\t        self.assertTableExists(original_m2m_table)\n  1781\t        self.assertTableNotExists(new_m2m_table)\n  1782\t        # Rename the Pony db_table which should also rename the m2m table.\n  1783\t        second_state = first_state.clone()\n  1784\t        operation = migrations.AlterModelTable(name=\"pony\", table=None)\n  1785\t        operation.state_forwards(app_label, second_state)\n  1786\t        atomic_rename = connection.features.supports_atomic_references_rename\n  1787\t        with connection.schema_editor(atomic=atomic_rename) as editor:\n  1788\t            operation.database_forwards(app_label, editor, first_state, second_state)\n  1789\t        self.assertTableExists(new_m2m_table)\n  1790\t        self.assertTableNotExists(original_m2m_table)\n  1791\t        # And test reversal\n  1792\t        with connection.schema_editor(atomic=atomic_rename) as editor:\n  1793\t            operation.database_backwards(app_label, editor, second_state, first_state)\n  1794\t        self.assertTableExists(original_m2m_table)\n  1795\t        self.assertTableNotExists(new_m2m_table)\n  1796\t\n  1797\t    def test_alter_field(self):\n  1798\t        \"\"\"\n  1799\t        Tests the AlterField operation.\n  1800\t        \"\"\"\n  1801\t        project_state = self.set_up_test_model(\"test_alfl\")\n  1802\t        # Test the state alteration\n  1803\t        operation = migrations.AlterField(\n  1804\t            \"Pony\", \"pink\", models.IntegerField(null=True)\n  1805\t        )\n  1806\t        self.assertEqual(operation.describe(), \"Alter field pink on Pony\")\n  1807\t        self.assertEqual(operation.migration_name_fragment, \"alter_pony_pink\")\n  1808\t        new_state = project_state.clone()\n  1809\t        operation.state_forwards(\"test_alfl\", new_state)\n  1810\t        self.assertIs(\n  1811\t            project_state.models[\"test_alfl\", \"pony\"].fields[\"pink\"].null, False\n  1812\t        )\n  1813\t        self.assertIs(new_state.models[\"test_alfl\", \"pony\"].fields[\"pink\"].null, True)\n  1814\t        # Test the database alteration\n  1815\t        self.assertColumnNotNull(\"test_alfl_pony\", \"pink\")\n  1816\t        with connection.schema_editor() as editor:\n  1817\t            operation.database_forwards(\"test_alfl\", editor, project_state, new_state)\n  1818\t        self.assertColumnNull(\"test_alfl_pony\", \"pink\")\n  1819\t        # And test reversal\n  1820\t        with connection.schema_editor() as editor:\n  1821\t            operation.database_backwards(\"test_alfl\", editor, new_state, project_state)\n  1822\t        self.assertColumnNotNull(\"test_alfl_pony\", \"pink\")\n  1823\t        # And deconstruction\n  1824\t        definition = operation.deconstruct()\n  1825\t        self.assertEqual(definition[0], \"AlterField\")\n  1826\t        self.assertEqual(definition[1], [])\n  1827\t        self.assertEqual(sorted(definition[2]), [\"field\", \"model_name\", \"name\"])\n  1828\t\n  1829\t    def test_alter_field_add_db_column_noop(self):\n  1830\t        \"\"\"\n  1831\t        AlterField operation is a noop when adding only a db_column and the\n  1832\t        column name is not changed.\n  1833\t        \"\"\"\n  1834\t        app_label = \"test_afadbn\"\n  1835\t        project_state = self.set_up_test_model(app_label, related_model=True)\n  1836\t        pony_table = \"%s_pony\" % app_label\n  1837\t        new_state = project_state.clone()\n  1838\t        operation = migrations.AlterField(\n  1839\t            \"Pony\", \"weight\", models.FloatField(db_column=\"weight\")\n  1840\t        )\n  1841\t        operation.state_forwards(app_label, new_state)\n  1842\t        self.assertIsNone(\n  1843\t            project_state.models[app_label, \"pony\"].fields[\"weight\"].db_column,\n  1844\t        )\n  1845\t        self.assertEqual(\n  1846\t            new_state.models[app_label, \"pony\"].fields[\"weight\"].db_column,\n  1847\t            \"weight\",\n  1848\t        )\n  1849\t        self.assertColumnExists(pony_table, \"weight\")\n  1850\t        with connection.schema_editor() as editor:\n  1851\t            with self.assertNumQueries(0):\n  1852\t                operation.database_forwards(app_label, editor, project_state, new_state)\n  1853\t        self.assertColumnExists(pony_table, \"weight\")\n  1854\t        with connection.schema_editor() as editor:\n  1855\t            with self.assertNumQueries(0):\n  1856\t                operation.database_backwards(\n  1857\t                    app_label, editor, new_state, project_state\n  1858\t                )\n  1859\t        self.assertColumnExists(pony_table, \"weight\")\n  1860\t\n  1861\t        rider_table = \"%s_rider\" % app_label\n  1862\t        new_state = project_state.clone()\n  1863\t        operation = migrations.AlterField(\n  1864\t            \"Rider\",\n  1865\t            \"pony\",\n  1866\t            models.ForeignKey(\"Pony\", models.CASCADE, db_column=\"pony_id\"),\n  1867\t        )\n  1868\t        operation.state_forwards(app_label, new_state)\n  1869\t        self.assertIsNone(\n  1870\t            project_state.models[app_label, \"rider\"].fields[\"pony\"].db_column,\n  1871\t        )\n  1872\t        self.assertIs(\n  1873\t            new_state.models[app_label, \"rider\"].fields[\"pony\"].db_column,\n  1874\t            \"pony_id\",\n  1875\t        )\n  1876\t        self.assertColumnExists(rider_table, \"pony_id\")\n  1877\t        with connection.schema_editor() as editor:\n  1878\t            with self.assertNumQueries(0):\n  1879\t                operation.database_forwards(app_label, editor, project_state, new_state)\n  1880\t        self.assertColumnExists(rider_table, \"pony_id\")\n  1881\t        with connection.schema_editor() as editor:\n  1882\t            with self.assertNumQueries(0):\n  1883\t                operation.database_forwards(app_label, editor, new_state, project_state)\n  1884\t        self.assertColumnExists(rider_table, \"pony_id\")\n  1885\t\n  1886\t    def test_alter_field_pk(self):\n  1887\t        \"\"\"\n  1888\t        The AlterField operation on primary keys (things like PostgreSQL's\n  1889\t        SERIAL weirdness).\n  1890\t        \"\"\"\n  1891\t        project_state = self.set_up_test_model(\"test_alflpk\")\n  1892\t        # Test the state alteration\n  1893\t        operation = migrations.AlterField(\n  1894\t            \"Pony\", \"id\", models.IntegerField(primary_key=True)\n  1895\t        )\n  1896\t        new_state = project_state.clone()\n  1897\t        operation.state_forwards(\"test_alflpk\", new_state)\n  1898\t        self.assertIsInstance(\n  1899\t            project_state.models[\"test_alflpk\", \"pony\"].fields[\"id\"],\n  1900\t            models.AutoField,\n  1901\t        )\n  1902\t        self.assertIsInstance(\n  1903\t            new_state.models[\"test_alflpk\", \"pony\"].fields[\"id\"],\n  1904\t            models.IntegerField,\n  1905\t        )\n  1906\t        # Test the database alteration\n  1907\t        with connection.schema_editor() as editor:\n  1908\t            operation.database_forwards(\"test_alflpk\", editor, project_state, new_state)\n  1909\t        # And test reversal\n  1910\t        with connection.schema_editor() as editor:\n  1911\t            operation.database_backwards(\n  1912\t                \"test_alflpk\", editor, new_state, project_state\n  1913\t            )\n  1914\t\n  1915\t    @skipUnlessDBFeature(\"supports_foreign_keys\")\n  1916\t    def test_alter_field_pk_fk(self):\n  1917\t        \"\"\"\n  1918\t        Tests the AlterField operation on primary keys changes any FKs pointing to it.\n  1919\t        \"\"\"\n  1920\t        project_state = self.set_up_test_model(\"test_alflpkfk\", related_model=True)\n  1921\t        project_state = self.apply_operations(\n  1922\t            \"test_alflpkfk\",\n  1923\t            project_state,\n  1924\t            [\n  1925\t                migrations.CreateModel(\n  1926\t                    \"Stable\",\n  1927\t                    fields=[\n  1928\t                        (\"ponies\", models.ManyToManyField(\"Pony\")),\n  1929\t                    ],\n  1930\t                ),\n  1931\t                migrations.AddField(\n  1932\t                    \"Pony\",\n  1933\t                    \"stables\",\n  1934\t                    models.ManyToManyField(\"Stable\"),\n  1935\t                ),\n  1936\t            ],\n  1937\t        )\n  1938\t        # Test the state alteration\n  1939\t        operation = migrations.AlterField(\n  1940\t            \"Pony\", \"id\", models.FloatField(primary_key=True)\n  1941\t        )\n  1942\t        new_state = project_state.clone()\n  1943\t        operation.state_forwards(\"test_alflpkfk\", new_state)\n  1944\t        self.assertIsInstance(\n  1945\t            project_state.models[\"test_alflpkfk\", \"pony\"].fields[\"id\"],\n  1946\t            models.AutoField,\n  1947\t        )\n  1948\t        self.assertIsInstance(\n  1949\t            new_state.models[\"test_alflpkfk\", \"pony\"].fields[\"id\"],\n  1950\t            models.FloatField,\n  1951\t        )\n  1952\t\n  1953\t        def assertIdTypeEqualsFkType():\n  1954\t            with connection.cursor() as cursor:\n  1955\t                id_type, id_null = [\n  1956\t                    (c.type_code, c.null_ok)\n  1957\t                    for c in connection.introspection.get_table_description(\n  1958\t                        cursor, \"test_alflpkfk_pony\"\n  1959\t                    )\n  1960\t                    if c.name == \"id\"\n  1961\t                ][0]\n  1962\t                fk_type, fk_null = [\n  1963\t                    (c.type_code, c.null_ok)\n  1964\t                    for c in connection.introspection.get_table_description(\n  1965\t                        cursor, \"test_alflpkfk_rider\"\n  1966\t                    )\n  1967\t                    if c.name == \"pony_id\"\n  1968\t                ][0]\n  1969\t                m2m_fk_type, m2m_fk_null = [\n  1970\t                    (c.type_code, c.null_ok)\n  1971\t                    for c in connection.introspection.get_table_description(\n  1972\t                        cursor,\n  1973\t                        \"test_alflpkfk_pony_stables\",\n  1974\t                    )\n  1975\t                    if c.name == \"pony_id\"\n  1976\t                ][0]\n  1977\t                remote_m2m_fk_type, remote_m2m_fk_null = [\n  1978\t                    (c.type_code, c.null_ok)\n  1979\t                    for c in connection.introspection.get_table_description(\n  1980\t                        cursor,\n  1981\t                        \"test_alflpkfk_stable_ponies\",\n  1982\t                    )\n  1983\t                    if c.name == \"pony_id\"\n  1984\t                ][0]\n  1985\t            self.assertEqual(id_type, fk_type)\n  1986\t            self.assertEqual(id_type, m2m_fk_type)\n  1987\t            self.assertEqual(id_type, remote_m2m_fk_type)\n  1988\t            self.assertEqual(id_null, fk_null)\n  1989\t            self.assertEqual(id_null, m2m_fk_null)\n  1990\t            self.assertEqual(id_null, remote_m2m_fk_null)\n  1991\t\n  1992\t        assertIdTypeEqualsFkType()\n  1993\t        # Test the database alteration\n  1994\t        with connection.schema_editor() as editor:\n  1995\t            operation.database_forwards(\n  1996\t                \"test_alflpkfk\", editor, project_state, new_state\n  1997\t            )\n  1998\t        assertIdTypeEqualsFkType()\n  1999\t        if connection.features.supports_foreign_keys:\n  2000\t            self.assertFKExists(\n  2001\t                \"test_alflpkfk_pony_stables\",\n  2002\t                [\"pony_id\"],\n  2003\t                (\"test_alflpkfk_pony\", \"id\"),\n  2004\t            )\n  2005\t            self.assertFKExists(\n  2006\t                \"test_alflpkfk_stable_ponies\",\n  2007\t                [\"pony_id\"],\n  2008\t                (\"test_alflpkfk_pony\", \"id\"),\n  2009\t            )\n  2010\t        # And test reversal\n  2011\t        with connection.schema_editor() as editor:\n  2012\t            operation.database_backwards(\n  2013\t                \"test_alflpkfk\", editor, new_state, project_state\n  2014\t            )\n  2015\t        assertIdTypeEqualsFkType()\n  2016\t        if connection.features.supports_foreign_keys:\n  2017\t            self.assertFKExists(\n  2018\t                \"test_alflpkfk_pony_stables\",\n  2019\t                [\"pony_id\"],\n  2020\t                (\"test_alflpkfk_pony\", \"id\"),\n  2021\t            )\n  2022\t            self.assertFKExists(\n  2023\t                \"test_alflpkfk_stable_ponies\",\n  2024\t                [\"pony_id\"],\n  2025\t                (\"test_alflpkfk_pony\", \"id\"),\n  2026\t            )\n  2027\t\n  2028\t    @skipUnlessDBFeature(\"supports_collation_on_charfield\", \"supports_foreign_keys\")\n  2029\t    def test_alter_field_pk_fk_db_collation(self):\n  2030\t        \"\"\"\n  2031\t        AlterField operation of db_collation on primary keys changes any FKs\n  2032\t        pointing to it.\n  2033\t        \"\"\"\n  2034\t        collation = connection.features.test_collations.get(\"non_default\")\n  2035\t        if not collation:\n  2036\t            self.skipTest(\"Language collations are not supported.\")\n  2037\t\n  2038\t        app_label = \"test_alflpkfkdbc\"\n  2039\t        project_state = self.apply_operations(\n  2040\t            app_label,\n  2041\t            ProjectState(),\n  2042\t            [\n  2043\t                migrations.CreateModel(\n  2044\t                    \"Pony\",\n  2045\t                    [\n  2046\t                        (\"id\", models.CharField(primary_key=True, max_length=10)),\n  2047\t                    ],\n  2048\t                ),\n  2049\t                migrations.CreateModel(\n  2050\t                    \"Rider\",\n  2051\t                    [\n  2052\t                        (\"pony\", models.ForeignKey(\"Pony\", models.CASCADE)),\n  2053\t                    ],\n  2054\t                ),\n  2055\t                migrations.CreateModel(\n  2056\t                    \"Stable\",\n  2057\t                    [\n  2058\t                        (\"ponies\", models.ManyToManyField(\"Pony\")),\n  2059\t                    ],\n  2060\t                ),\n  2061\t            ],\n  2062\t        )\n  2063\t        # State alteration.\n  2064\t        operation = migrations.AlterField(\n  2065\t            \"Pony\",\n  2066\t            \"id\",\n  2067\t            models.CharField(\n  2068\t                primary_key=True,\n  2069\t                max_length=10,\n  2070\t                db_collation=collation,\n  2071\t            ),\n  2072\t        )\n  2073\t        new_state = project_state.clone()\n  2074\t        operation.state_forwards(app_label, new_state)\n  2075\t        # Database alteration.\n  2076\t        with connection.schema_editor() as editor:\n  2077\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2078\t        self.assertColumnCollation(f\"{app_label}_pony\", \"id\", collation)\n  2079\t        self.assertColumnCollation(f\"{app_label}_rider\", \"pony_id\", collation)\n  2080\t        self.assertColumnCollation(f\"{app_label}_stable_ponies\", \"pony_id\", collation)\n  2081\t        # Reversal.\n  2082\t        with connection.schema_editor() as editor:\n  2083\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2084\t\n  2085\t    def test_alter_field_pk_mti_fk(self):\n  2086\t        app_label = \"test_alflpkmtifk\"\n  2087\t        project_state = self.set_up_test_model(app_label, mti_model=True)\n  2088\t        project_state = self.apply_operations(\n  2089\t            app_label,\n  2090\t            project_state,\n  2091\t            [\n  2092\t                migrations.CreateModel(\n  2093\t                    \"ShetlandRider\",\n  2094\t                    fields=[\n  2095\t                        (\n  2096\t                            \"pony\",\n  2097\t                            models.ForeignKey(\n  2098\t                                f\"{app_label}.ShetlandPony\", models.CASCADE\n  2099\t                            ),\n  2100\t                        ),\n  2101\t                    ],\n  2102\t                ),\n  2103\t            ],\n  2104\t        )\n  2105\t        operation = migrations.AlterField(\n  2106\t            \"Pony\",\n  2107\t            \"id\",\n  2108\t            models.BigAutoField(primary_key=True),\n  2109\t        )\n  2110\t        new_state = project_state.clone()\n  2111\t        operation.state_forwards(app_label, new_state)\n  2112\t        self.assertIsInstance(\n  2113\t            new_state.models[app_label, \"pony\"].fields[\"id\"],\n  2114\t            models.BigAutoField,\n  2115\t        )\n  2116\t\n  2117\t        def _get_column_id_type(cursor, table, column):\n  2118\t            return [\n  2119\t                c.type_code\n  2120\t                for c in connection.introspection.get_table_description(\n  2121\t                    cursor,\n  2122\t                    f\"{app_label}_{table}\",\n  2123\t                )\n  2124\t                if c.name == column\n  2125\t            ][0]\n  2126\t\n  2127\t        def assertIdTypeEqualsMTIFkType():\n  2128\t            with connection.cursor() as cursor:\n  2129\t                parent_id_type = _get_column_id_type(cursor, \"pony\", \"id\")\n  2130\t                child_id_type = _get_column_id_type(\n  2131\t                    cursor, \"shetlandpony\", \"pony_ptr_id\"\n  2132\t                )\n  2133\t                mti_id_type = _get_column_id_type(cursor, \"shetlandrider\", \"pony_id\")\n  2134\t            self.assertEqual(parent_id_type, child_id_type)\n  2135\t            self.assertEqual(parent_id_type, mti_id_type)\n  2136\t\n  2137\t        assertIdTypeEqualsMTIFkType()\n  2138\t        # Alter primary key.\n  2139\t        with connection.schema_editor() as editor:\n  2140\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2141\t        assertIdTypeEqualsMTIFkType()\n  2142\t        if connection.features.supports_foreign_keys:\n  2143\t            self.assertFKExists(\n  2144\t                f\"{app_label}_shetlandpony\",\n  2145\t                [\"pony_ptr_id\"],\n  2146\t                (f\"{app_label}_pony\", \"id\"),\n  2147\t            )\n  2148\t            self.assertFKExists(\n  2149\t                f\"{app_label}_shetlandrider\",\n  2150\t                [\"pony_id\"],\n  2151\t                (f\"{app_label}_shetlandpony\", \"pony_ptr_id\"),\n  2152\t            )\n  2153\t        # Reversal.\n  2154\t        with connection.schema_editor() as editor:\n  2155\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2156\t        assertIdTypeEqualsMTIFkType()\n  2157\t        if connection.features.supports_foreign_keys:\n  2158\t            self.assertFKExists(\n  2159\t                f\"{app_label}_shetlandpony\",\n  2160\t                [\"pony_ptr_id\"],\n  2161\t                (f\"{app_label}_pony\", \"id\"),\n  2162\t            )\n  2163\t            self.assertFKExists(\n  2164\t                f\"{app_label}_shetlandrider\",\n  2165\t                [\"pony_id\"],\n  2166\t                (f\"{app_label}_shetlandpony\", \"pony_ptr_id\"),\n  2167\t            )\n  2168\t\n  2169\t    def test_alter_field_pk_mti_and_fk_to_base(self):\n  2170\t        app_label = \"test_alflpkmtiftb\"\n  2171\t        project_state = self.set_up_test_model(\n  2172\t            app_label,\n  2173\t            mti_model=True,\n  2174\t            related_model=True,\n  2175\t        )\n  2176\t        operation = migrations.AlterField(\n  2177\t            \"Pony\",\n  2178\t            \"id\",\n  2179\t            models.BigAutoField(primary_key=True),\n  2180\t        )\n  2181\t        new_state = project_state.clone()\n  2182\t        operation.state_forwards(app_label, new_state)\n  2183\t        self.assertIsInstance(\n  2184\t            new_state.models[app_label, \"pony\"].fields[\"id\"],\n  2185\t            models.BigAutoField,\n  2186\t        )\n  2187\t\n  2188\t        def _get_column_id_type(cursor, table, column):\n  2189\t            return [\n  2190\t                c.type_code\n  2191\t                for c in connection.introspection.get_table_description(\n  2192\t                    cursor,\n  2193\t                    f\"{app_label}_{table}\",\n  2194\t                )\n  2195\t                if c.name == column\n  2196\t            ][0]\n  2197\t\n  2198\t        def assertIdTypeEqualsMTIFkType():\n  2199\t            with connection.cursor() as cursor:\n  2200\t                parent_id_type = _get_column_id_type(cursor, \"pony\", \"id\")\n  2201\t                fk_id_type = _get_column_id_type(cursor, \"rider\", \"pony_id\")\n  2202\t                child_id_type = _get_column_id_type(\n  2203\t                    cursor, \"shetlandpony\", \"pony_ptr_id\"\n  2204\t                )\n  2205\t            self.assertEqual(parent_id_type, child_id_type)\n  2206\t            self.assertEqual(parent_id_type, fk_id_type)\n  2207\t\n  2208\t        assertIdTypeEqualsMTIFkType()\n  2209\t        # Alter primary key.\n  2210\t        with connection.schema_editor() as editor:\n  2211\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2212\t        assertIdTypeEqualsMTIFkType()\n  2213\t        if connection.features.supports_foreign_keys:\n  2214\t            self.assertFKExists(\n  2215\t                f\"{app_label}_shetlandpony\",\n  2216\t                [\"pony_ptr_id\"],\n  2217\t                (f\"{app_label}_pony\", \"id\"),\n  2218\t            )\n  2219\t            self.assertFKExists(\n  2220\t                f\"{app_label}_rider\",\n  2221\t                [\"pony_id\"],\n  2222\t                (f\"{app_label}_pony\", \"id\"),\n  2223\t            )\n  2224\t        # Reversal.\n  2225\t        with connection.schema_editor() as editor:\n  2226\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2227\t        assertIdTypeEqualsMTIFkType()\n  2228\t        if connection.features.supports_foreign_keys:\n  2229\t            self.assertFKExists(\n  2230\t                f\"{app_label}_shetlandpony\",\n  2231\t                [\"pony_ptr_id\"],\n  2232\t                (f\"{app_label}_pony\", \"id\"),\n  2233\t            )\n  2234\t            self.assertFKExists(\n  2235\t                f\"{app_label}_rider\",\n  2236\t                [\"pony_id\"],\n  2237\t                (f\"{app_label}_pony\", \"id\"),\n  2238\t            )\n  2239\t\n  2240\t    @skipUnlessDBFeature(\"supports_foreign_keys\")\n  2241\t    def test_alter_field_reloads_state_on_fk_with_to_field_target_type_change(self):\n  2242\t        app_label = \"test_alflrsfkwtflttc\"\n  2243\t        project_state = self.apply_operations(\n  2244\t            app_label,\n  2245\t            ProjectState(),\n  2246\t            operations=[\n  2247\t                migrations.CreateModel(\n  2248\t                    \"Rider\",\n  2249\t                    fields=[\n  2250\t                        (\"id\", models.AutoField(primary_key=True)),\n  2251\t                        (\"code\", models.IntegerField(unique=True)),\n  2252\t                    ],\n  2253\t                ),\n  2254\t                migrations.CreateModel(\n  2255\t                    \"Pony\",\n  2256\t                    fields=[\n  2257\t                        (\"id\", models.AutoField(primary_key=True)),\n  2258\t                        (\n  2259\t                            \"rider\",\n  2260\t                            models.ForeignKey(\n  2261\t                                \"%s.Rider\" % app_label, models.CASCADE, to_field=\"code\"\n  2262\t                            ),\n  2263\t                        ),\n  2264\t                    ],\n  2265\t                ),\n  2266\t            ],\n  2267\t        )\n  2268\t        operation = migrations.AlterField(\n  2269\t            \"Rider\",\n  2270\t            \"code\",\n  2271\t            models.CharField(max_length=100, unique=True),\n  2272\t        )\n  2273\t        self.apply_operations(app_label, project_state, operations=[operation])\n  2274\t        id_type, id_null = [\n  2275\t            (c.type_code, c.null_ok)\n  2276\t            for c in self.get_table_description(\"%s_rider\" % app_label)\n  2277\t            if c.name == \"code\"\n  2278\t        ][0]\n  2279\t        fk_type, fk_null = [\n  2280\t            (c.type_code, c.null_ok)\n  2281\t            for c in self.get_table_description(\"%s_pony\" % app_label)\n  2282\t            if c.name == \"rider_id\"\n  2283\t        ][0]\n  2284\t        self.assertEqual(id_type, fk_type)\n  2285\t        self.assertEqual(id_null, fk_null)\n  2286\t\n  2287\t    @skipUnlessDBFeature(\"supports_foreign_keys\")\n  2288\t    def test_alter_field_reloads_state_fk_with_to_field_related_name_target_type_change(\n  2289\t        self,\n  2290\t    ):\n  2291\t        app_label = \"test_alflrsfkwtflrnttc\"\n  2292\t        project_state = self.apply_operations(\n  2293\t            app_label,\n  2294\t            ProjectState(),\n  2295\t            operations=[\n  2296\t                migrations.CreateModel(\n  2297\t                    \"Rider\",\n  2298\t                    fields=[\n  2299\t                        (\"id\", models.AutoField(primary_key=True)),\n  2300\t                        (\"code\", models.PositiveIntegerField(unique=True)),\n  2301\t                    ],\n  2302\t                ),\n  2303\t                migrations.CreateModel(\n  2304\t                    \"Pony\",\n  2305\t                    fields=[\n  2306\t                        (\"id\", models.AutoField(primary_key=True)),\n  2307\t                        (\n  2308\t                            \"rider\",\n  2309\t                            models.ForeignKey(\n  2310\t                                \"%s.Rider\" % app_label,\n  2311\t                                models.CASCADE,\n  2312\t                                to_field=\"code\",\n  2313\t                                related_name=\"+\",\n  2314\t                            ),\n  2315\t                        ),\n  2316\t                    ],\n  2317\t                ),\n  2318\t            ],\n  2319\t        )\n  2320\t        operation = migrations.AlterField(\n  2321\t            \"Rider\",\n  2322\t            \"code\",\n  2323\t            models.CharField(max_length=100, unique=True),\n  2324\t        )\n  2325\t        self.apply_operations(app_label, project_state, operations=[operation])\n  2326\t\n  2327\t    def test_alter_field_reloads_state_on_fk_target_changes(self):\n  2328\t        \"\"\"\n  2329\t        If AlterField doesn't reload state appropriately, the second AlterField\n  2330\t        crashes on MySQL due to not dropping the PonyRider.pony foreign key\n  2331\t        constraint before modifying the column.\n  2332\t        \"\"\"\n  2333\t        app_label = \"alter_alter_field_reloads_state_on_fk_target_changes\"\n  2334\t        project_state = self.apply_operations(\n  2335\t            app_label,\n  2336\t            ProjectState(),\n  2337\t            operations=[\n  2338\t                migrations.CreateModel(\n  2339\t                    \"Rider\",\n  2340\t                    fields=[\n  2341\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2342\t                    ],\n  2343\t                ),\n  2344\t                migrations.CreateModel(\n  2345\t                    \"Pony\",\n  2346\t                    fields=[\n  2347\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2348\t                        (\n  2349\t                            \"rider\",\n  2350\t                            models.ForeignKey(\"%s.Rider\" % app_label, models.CASCADE),\n  2351\t                        ),\n  2352\t                    ],\n  2353\t                ),\n  2354\t                migrations.CreateModel(\n  2355\t                    \"PonyRider\",\n  2356\t                    fields=[\n  2357\t                        (\"id\", models.AutoField(primary_key=True)),\n  2358\t                        (\n  2359\t                            \"pony\",\n  2360\t                            models.ForeignKey(\"%s.Pony\" % app_label, models.CASCADE),\n  2361\t                        ),\n  2362\t                    ],\n  2363\t                ),\n  2364\t            ],\n  2365\t        )\n  2366\t        project_state = self.apply_operations(\n  2367\t            app_label,\n  2368\t            project_state,\n  2369\t            operations=[\n  2370\t                migrations.AlterField(\n  2371\t                    \"Rider\", \"id\", models.CharField(primary_key=True, max_length=99)\n  2372\t                ),\n  2373\t                migrations.AlterField(\n  2374\t                    \"Pony\", \"id\", models.CharField(primary_key=True, max_length=99)\n  2375\t                ),\n  2376\t            ],\n  2377\t        )\n  2378\t\n  2379\t    def test_alter_field_reloads_state_on_fk_with_to_field_target_changes(self):\n  2380\t        \"\"\"\n  2381\t        If AlterField doesn't reload state appropriately, the second AlterField\n  2382\t        crashes on MySQL due to not dropping the PonyRider.pony foreign key\n  2383\t        constraint before modifying the column.\n  2384\t        \"\"\"\n  2385\t        app_label = \"alter_alter_field_reloads_state_on_fk_with_to_field_target_changes\"\n  2386\t        project_state = self.apply_operations(\n  2387\t            app_label,\n  2388\t            ProjectState(),\n  2389\t            operations=[\n  2390\t                migrations.CreateModel(\n  2391\t                    \"Rider\",\n  2392\t                    fields=[\n  2393\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2394\t                        (\"slug\", models.CharField(unique=True, max_length=100)),\n  2395\t                    ],\n  2396\t                ),\n  2397\t                migrations.CreateModel(\n  2398\t                    \"Pony\",\n  2399\t                    fields=[\n  2400\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2401\t                        (\n  2402\t                            \"rider\",\n  2403\t                            models.ForeignKey(\n  2404\t                                \"%s.Rider\" % app_label, models.CASCADE, to_field=\"slug\"\n  2405\t                            ),\n  2406\t                        ),\n  2407\t                        (\"slug\", models.CharField(unique=True, max_length=100)),\n  2408\t                    ],\n  2409\t                ),\n  2410\t                migrations.CreateModel(\n  2411\t                    \"PonyRider\",\n  2412\t                    fields=[\n  2413\t                        (\"id\", models.AutoField(primary_key=True)),\n  2414\t                        (\n  2415\t                            \"pony\",\n  2416\t                            models.ForeignKey(\n  2417\t                                \"%s.Pony\" % app_label, models.CASCADE, to_field=\"slug\"\n  2418\t                            ),\n  2419\t                        ),\n  2420\t                    ],\n  2421\t                ),\n  2422\t            ],\n  2423\t        )\n  2424\t        project_state = self.apply_operations(\n  2425\t            app_label,\n  2426\t            project_state,\n  2427\t            operations=[\n  2428\t                migrations.AlterField(\n  2429\t                    \"Rider\", \"slug\", models.CharField(unique=True, max_length=99)\n  2430\t                ),\n  2431\t                migrations.AlterField(\n  2432\t                    \"Pony\", \"slug\", models.CharField(unique=True, max_length=99)\n  2433\t                ),\n  2434\t            ],\n  2435\t        )\n  2436\t\n  2437\t    def test_rename_field_reloads_state_on_fk_target_changes(self):\n  2438\t        \"\"\"\n  2439\t        If RenameField doesn't reload state appropriately, the AlterField\n  2440\t        crashes on MySQL due to not dropping the PonyRider.pony foreign key\n  2441\t        constraint before modifying the column.\n  2442\t        \"\"\"\n  2443\t        app_label = \"alter_rename_field_reloads_state_on_fk_target_changes\"\n  2444\t        project_state = self.apply_operations(\n  2445\t            app_label,\n  2446\t            ProjectState(),\n  2447\t            operations=[\n  2448\t                migrations.CreateModel(\n  2449\t                    \"Rider\",\n  2450\t                    fields=[\n  2451\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2452\t                    ],\n  2453\t                ),\n  2454\t                migrations.CreateModel(\n  2455\t                    \"Pony\",\n  2456\t                    fields=[\n  2457\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2458\t                        (\n  2459\t                            \"rider\",\n  2460\t                            models.ForeignKey(\"%s.Rider\" % app_label, models.CASCADE),\n  2461\t                        ),\n  2462\t                    ],\n  2463\t                ),\n  2464\t                migrations.CreateModel(\n  2465\t                    \"PonyRider\",\n  2466\t                    fields=[\n  2467\t                        (\"id\", models.AutoField(primary_key=True)),\n  2468\t                        (\n  2469\t                            \"pony\",\n  2470\t                            models.ForeignKey(\"%s.Pony\" % app_label, models.CASCADE),\n  2471\t                        ),\n  2472\t                    ],\n  2473\t                ),\n  2474\t            ],\n  2475\t        )\n  2476\t        project_state = self.apply_operations(\n  2477\t            app_label,\n  2478\t            project_state,\n  2479\t            operations=[\n  2480\t                migrations.RenameField(\"Rider\", \"id\", \"id2\"),\n  2481\t                migrations.AlterField(\n  2482\t                    \"Pony\", \"id\", models.CharField(primary_key=True, max_length=99)\n  2483\t                ),\n  2484\t            ],\n  2485\t            atomic=connection.features.supports_atomic_references_rename,\n  2486\t        )\n  2487\t\n  2488\t    def test_rename_field(self):\n  2489\t        \"\"\"\n  2490\t        Tests the RenameField operation.\n  2491\t        \"\"\"\n  2492\t        project_state = self.set_up_test_model(\n  2493\t            \"test_rnfl\", unique_together=True, index_together=True\n  2494\t        )\n  2495\t        # Test the state alteration\n  2496\t        operation = migrations.RenameField(\"Pony\", \"pink\", \"blue\")\n  2497\t        self.assertEqual(operation.describe(), \"Rename field pink on Pony to blue\")\n  2498\t        self.assertEqual(operation.migration_name_fragment, \"rename_pink_pony_blue\")\n  2499\t        new_state = project_state.clone()\n  2500\t        operation.state_forwards(\"test_rnfl\", new_state)\n  2501\t        self.assertIn(\"blue\", new_state.models[\"test_rnfl\", \"pony\"].fields)\n  2502\t        self.assertNotIn(\"pink\", new_state.models[\"test_rnfl\", \"pony\"].fields)\n  2503\t        # Make sure the unique_together has the renamed column too\n  2504\t        self.assertIn(\n  2505\t            \"blue\", new_state.models[\"test_rnfl\", \"pony\"].options[\"unique_together\"][0]\n  2506\t        )\n  2507\t        self.assertNotIn(\n  2508\t            \"pink\", new_state.models[\"test_rnfl\", \"pony\"].options[\"unique_together\"][0]\n  2509\t        )\n  2510\t        # Make sure the index_together has the renamed column too\n  2511\t        self.assertIn(\n  2512\t            \"blue\", new_state.models[\"test_rnfl\", \"pony\"].options[\"index_together\"][0]\n  2513\t        )\n  2514\t        self.assertNotIn(\n  2515\t            \"pink\", new_state.models[\"test_rnfl\", \"pony\"].options[\"index_together\"][0]\n  2516\t        )\n  2517\t        # Test the database alteration\n  2518\t        self.assertColumnExists(\"test_rnfl_pony\", \"pink\")\n  2519\t        self.assertColumnNotExists(\"test_rnfl_pony\", \"blue\")\n  2520\t        with connection.schema_editor() as editor:\n  2521\t            operation.database_forwards(\"test_rnfl\", editor, project_state, new_state)\n  2522\t        self.assertColumnExists(\"test_rnfl_pony\", \"blue\")\n  2523\t        self.assertColumnNotExists(\"test_rnfl_pony\", \"pink\")\n  2524\t        # Ensure the unique constraint has been ported over\n  2525\t        with connection.cursor() as cursor:\n  2526\t            cursor.execute(\"INSERT INTO test_rnfl_pony (blue, weight) VALUES (1, 1)\")\n  2527\t            with self.assertRaises(IntegrityError):\n  2528\t                with atomic():\n  2529\t                    cursor.execute(\n  2530\t                        \"INSERT INTO test_rnfl_pony (blue, weight) VALUES (1, 1)\"\n  2531\t                    )\n  2532\t            cursor.execute(\"DELETE FROM test_rnfl_pony\")\n  2533\t        # Ensure the index constraint has been ported over\n  2534\t        self.assertIndexExists(\"test_rnfl_pony\", [\"weight\", \"blue\"])\n  2535\t        # And test reversal\n  2536\t        with connection.schema_editor() as editor:\n  2537\t            operation.database_backwards(\"test_rnfl\", editor, new_state, project_state)\n  2538\t        self.assertColumnExists(\"test_rnfl_pony\", \"pink\")\n  2539\t        self.assertColumnNotExists(\"test_rnfl_pony\", \"blue\")\n  2540\t        # Ensure the index constraint has been reset\n  2541\t        self.assertIndexExists(\"test_rnfl_pony\", [\"weight\", \"pink\"])\n  2542\t        # And deconstruction\n  2543\t        definition = operation.deconstruct()\n  2544\t        self.assertEqual(definition[0], \"RenameField\")\n  2545\t        self.assertEqual(definition[1], [])\n  2546\t        self.assertEqual(\n  2547\t            definition[2],\n  2548\t            {\"model_name\": \"Pony\", \"old_name\": \"pink\", \"new_name\": \"blue\"},\n  2549\t        )\n  2550\t\n  2551\t    def test_rename_field_with_db_column(self):\n  2552\t        project_state = self.apply_operations(\n  2553\t            \"test_rfwdbc\",\n  2554\t            ProjectState(),\n  2555\t            operations=[\n  2556\t                migrations.CreateModel(\n  2557\t                    \"Pony\",\n  2558\t                    fields=[\n  2559\t                        (\"id\", models.AutoField(primary_key=True)),\n  2560\t                        (\"field\", models.IntegerField(db_column=\"db_field\")),\n  2561\t                        (\n  2562\t                            \"fk_field\",\n  2563\t                            models.ForeignKey(\n  2564\t                                \"Pony\",\n  2565\t                                models.CASCADE,\n  2566\t                                db_column=\"db_fk_field\",\n  2567\t                            ),\n  2568\t                        ),\n  2569\t                    ],\n  2570\t                ),\n  2571\t            ],\n  2572\t        )\n  2573\t        new_state = project_state.clone()\n  2574\t        operation = migrations.RenameField(\"Pony\", \"field\", \"renamed_field\")\n  2575\t        operation.state_forwards(\"test_rfwdbc\", new_state)\n  2576\t        self.assertIn(\"renamed_field\", new_state.models[\"test_rfwdbc\", \"pony\"].fields)\n  2577\t        self.assertNotIn(\"field\", new_state.models[\"test_rfwdbc\", \"pony\"].fields)\n  2578\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_field\")\n  2579\t        with connection.schema_editor() as editor:\n  2580\t            with self.assertNumQueries(0):\n  2581\t                operation.database_forwards(\n  2582\t                    \"test_rfwdbc\", editor, project_state, new_state\n  2583\t                )\n  2584\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_field\")\n  2585\t        with connection.schema_editor() as editor:\n  2586\t            with self.assertNumQueries(0):\n  2587\t                operation.database_backwards(\n  2588\t                    \"test_rfwdbc\", editor, new_state, project_state\n  2589\t                )\n  2590\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_field\")\n  2591\t\n  2592\t        new_state = project_state.clone()\n  2593\t        operation = migrations.RenameField(\"Pony\", \"fk_field\", \"renamed_fk_field\")\n  2594\t        operation.state_forwards(\"test_rfwdbc\", new_state)\n  2595\t        self.assertIn(\n  2596\t            \"renamed_fk_field\", new_state.models[\"test_rfwdbc\", \"pony\"].fields\n  2597\t        )\n  2598\t        self.assertNotIn(\"fk_field\", new_state.models[\"test_rfwdbc\", \"pony\"].fields)\n  2599\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_fk_field\")\n  2600\t        with connection.schema_editor() as editor:\n  2601\t            with self.assertNumQueries(0):\n  2602\t                operation.database_forwards(\n  2603\t                    \"test_rfwdbc\", editor, project_state, new_state\n  2604\t                )\n  2605\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_fk_field\")\n  2606\t        with connection.schema_editor() as editor:\n  2607\t            with self.assertNumQueries(0):\n  2608\t                operation.database_backwards(\n  2609\t                    \"test_rfwdbc\", editor, new_state, project_state\n  2610\t                )\n  2611\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_fk_field\")\n  2612\t\n  2613\t    def test_rename_field_case(self):\n  2614\t        project_state = self.apply_operations(\n  2615\t            \"test_rfmx\",\n  2616\t            ProjectState(),\n  2617\t            operations=[\n  2618\t                migrations.CreateModel(\n  2619\t                    \"Pony\",\n  2620\t                    fields=[\n  2621\t                        (\"id\", models.AutoField(primary_key=True)),\n  2622\t                        (\"field\", models.IntegerField()),\n  2623\t                    ],\n  2624\t                ),\n  2625\t            ],\n  2626\t        )\n  2627\t        new_state = project_state.clone()\n  2628\t        operation = migrations.RenameField(\"Pony\", \"field\", \"FiElD\")\n  2629\t        operation.state_forwards(\"test_rfmx\", new_state)\n  2630\t        self.assertIn(\"FiElD\", new_state.models[\"test_rfmx\", \"pony\"].fields)\n  2631\t        self.assertColumnExists(\"test_rfmx_pony\", \"field\")\n  2632\t        with connection.schema_editor() as editor:\n  2633\t            operation.database_forwards(\"test_rfmx\", editor, project_state, new_state)\n  2634\t        self.assertColumnExists(\n  2635\t            \"test_rfmx_pony\",\n  2636\t            connection.introspection.identifier_converter(\"FiElD\"),\n  2637\t        )\n  2638\t        with connection.schema_editor() as editor:\n  2639\t            operation.database_backwards(\"test_rfmx\", editor, new_state, project_state)\n  2640\t        self.assertColumnExists(\"test_rfmx_pony\", \"field\")\n  2641\t\n  2642\t    def test_rename_missing_field(self):\n  2643\t        state = ProjectState()\n  2644\t        state.add_model(ModelState(\"app\", \"model\", []))\n  2645\t        with self.assertRaisesMessage(\n  2646\t            FieldDoesNotExist, \"app.model has no field named 'field'\"\n  2647\t        ):\n  2648\t            migrations.RenameField(\"model\", \"field\", \"new_field\").state_forwards(\n  2649\t                \"app\", state\n  2650\t            )\n  2651\t\n  2652\t    def test_rename_referenced_field_state_forward(self):\n  2653\t        state = ProjectState()\n  2654\t        state.add_model(\n  2655\t            ModelState(\n  2656\t                \"app\",\n  2657\t                \"Model\",\n  2658\t                [\n  2659\t                    (\"id\", models.AutoField(primary_key=True)),\n  2660\t                    (\"field\", models.IntegerField(unique=True)),\n  2661\t                ],\n  2662\t            )\n  2663\t        )\n  2664\t        state.add_model(\n  2665\t            ModelState(\n  2666\t                \"app\",\n  2667\t                \"OtherModel\",\n  2668\t                [\n  2669\t                    (\"id\", models.AutoField(primary_key=True)),\n  2670\t                    (\n  2671\t                        \"fk\",\n  2672\t                        models.ForeignKey(\"Model\", models.CASCADE, to_field=\"field\"),\n  2673\t                    ),\n  2674\t                    (\n  2675\t                        \"fo\",\n  2676\t                        models.ForeignObject(\n  2677\t                            \"Model\",\n  2678\t                            models.CASCADE,\n  2679\t                            from_fields=(\"fk\",),\n  2680\t                            to_fields=(\"field\",),\n  2681\t                        ),\n  2682\t                    ),\n  2683\t                ],\n  2684\t            )\n  2685\t        )\n  2686\t        operation = migrations.RenameField(\"Model\", \"field\", \"renamed\")\n  2687\t        new_state = state.clone()\n  2688\t        operation.state_forwards(\"app\", new_state)\n  2689\t        self.assertEqual(\n  2690\t            new_state.models[\"app\", \"othermodel\"].fields[\"fk\"].remote_field.field_name,\n  2691\t            \"renamed\",\n  2692\t        )\n  2693\t        self.assertEqual(\n  2694\t            new_state.models[\"app\", \"othermodel\"].fields[\"fk\"].from_fields, [\"self\"]\n  2695\t        )\n  2696\t        self.assertEqual(\n  2697\t            new_state.models[\"app\", \"othermodel\"].fields[\"fk\"].to_fields, (\"renamed\",)\n  2698\t        )\n  2699\t        self.assertEqual(\n  2700\t            new_state.models[\"app\", \"othermodel\"].fields[\"fo\"].from_fields, (\"fk\",)\n  2701\t        )\n  2702\t        self.assertEqual(\n  2703\t            new_state.models[\"app\", \"othermodel\"].fields[\"fo\"].to_fields, (\"renamed\",)\n  2704\t        )\n  2705\t        operation = migrations.RenameField(\"OtherModel\", \"fk\", \"renamed_fk\")\n  2706\t        new_state = state.clone()\n  2707\t        operation.state_forwards(\"app\", new_state)\n  2708\t        self.assertEqual(\n  2709\t            new_state.models[\"app\", \"othermodel\"]\n  2710\t            .fields[\"renamed_fk\"]\n  2711\t            .remote_field.field_name,\n  2712\t            \"renamed\",\n  2713\t        )\n  2714\t        self.assertEqual(\n  2715\t            new_state.models[\"app\", \"othermodel\"].fields[\"renamed_fk\"].from_fields,\n  2716\t            (\"self\",),\n  2717\t        )\n  2718\t        self.assertEqual(\n  2719\t            new_state.models[\"app\", \"othermodel\"].fields[\"renamed_fk\"].to_fields,\n  2720\t            (\"renamed\",),\n  2721\t        )\n  2722\t        self.assertEqual(\n  2723\t            new_state.models[\"app\", \"othermodel\"].fields[\"fo\"].from_fields,\n  2724\t            (\"renamed_fk\",),\n  2725\t        )\n  2726\t        self.assertEqual(\n  2727\t            new_state.models[\"app\", \"othermodel\"].fields[\"fo\"].to_fields, (\"renamed\",)\n  2728\t        )\n  2729\t\n  2730\t    def test_alter_unique_together(self):\n  2731\t        \"\"\"\n  2732\t        Tests the AlterUniqueTogether operation.\n  2733\t        \"\"\"\n  2734\t        project_state = self.set_up_test_model(\"test_alunto\")\n  2735\t        # Test the state alteration\n  2736\t        operation = migrations.AlterUniqueTogether(\"Pony\", [(\"pink\", \"weight\")])\n  2737\t        self.assertEqual(\n  2738\t            operation.describe(), \"Alter unique_together for Pony (1 constraint(s))\"\n  2739\t        )\n  2740\t        self.assertEqual(\n  2741\t            operation.migration_name_fragment,\n  2742\t            \"alter_pony_unique_together\",\n  2743\t        )\n  2744\t        new_state = project_state.clone()\n  2745\t        operation.state_forwards(\"test_alunto\", new_state)\n  2746\t        self.assertEqual(\n  2747\t            len(\n  2748\t                project_state.models[\"test_alunto\", \"pony\"].options.get(\n  2749\t                    \"unique_together\", set()\n  2750\t                )\n  2751\t            ),\n  2752\t            0,\n  2753\t        )\n  2754\t        self.assertEqual(\n  2755\t            len(\n  2756\t                new_state.models[\"test_alunto\", \"pony\"].options.get(\n  2757\t                    \"unique_together\", set()\n  2758\t                )\n  2759\t            ),\n  2760\t            1,\n  2761\t        )\n  2762\t        # Make sure we can insert duplicate rows\n  2763\t        with connection.cursor() as cursor:\n  2764\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2765\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2766\t            cursor.execute(\"DELETE FROM test_alunto_pony\")\n  2767\t            # Test the database alteration\n  2768\t            with connection.schema_editor() as editor:\n  2769\t                operation.database_forwards(\n  2770\t                    \"test_alunto\", editor, project_state, new_state\n  2771\t                )\n  2772\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2773\t            with self.assertRaises(IntegrityError):\n  2774\t                with atomic():\n  2775\t                    cursor.execute(\n  2776\t                        \"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\"\n  2777\t                    )\n  2778\t            cursor.execute(\"DELETE FROM test_alunto_pony\")\n  2779\t            # And test reversal\n  2780\t            with connection.schema_editor() as editor:\n  2781\t                operation.database_backwards(\n  2782\t                    \"test_alunto\", editor, new_state, project_state\n  2783\t                )\n  2784\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2785\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2786\t            cursor.execute(\"DELETE FROM test_alunto_pony\")\n  2787\t        # Test flat unique_together\n  2788\t        operation = migrations.AlterUniqueTogether(\"Pony\", (\"pink\", \"weight\"))\n  2789\t        operation.state_forwards(\"test_alunto\", new_state)\n  2790\t        self.assertEqual(\n  2791\t            len(\n  2792\t                new_state.models[\"test_alunto\", \"pony\"].options.get(\n  2793\t                    \"unique_together\", set()\n  2794\t                )\n  2795\t            ),\n  2796\t            1,\n  2797\t        )\n  2798\t        # And deconstruction\n  2799\t        definition = operation.deconstruct()\n  2800\t        self.assertEqual(definition[0], \"AlterUniqueTogether\")\n  2801\t        self.assertEqual(definition[1], [])\n  2802\t        self.assertEqual(\n  2803\t            definition[2], {\"name\": \"Pony\", \"unique_together\": {(\"pink\", \"weight\")}}\n  2804\t        )\n  2805\t\n  2806\t    def test_alter_unique_together_remove(self):\n  2807\t        operation = migrations.AlterUniqueTogether(\"Pony\", None)\n  2808\t        self.assertEqual(\n  2809\t            operation.describe(), \"Alter unique_together for Pony (0 constraint(s))\"\n  2810\t        )\n  2811\t\n  2812\t    def test_add_index(self):\n  2813\t        \"\"\"\n  2814\t        Test the AddIndex operation.\n  2815\t        \"\"\"\n  2816\t        project_state = self.set_up_test_model(\"test_adin\")\n  2817\t        msg = (\n  2818\t            \"Indexes passed to AddIndex operations require a name argument. \"\n  2819\t            \"<Index: fields=['pink']> doesn't have one.\"\n  2820\t        )\n  2821\t        with self.assertRaisesMessage(ValueError, msg):\n  2822\t            migrations.AddIndex(\"Pony\", models.Index(fields=[\"pink\"]))\n  2823\t        index = models.Index(fields=[\"pink\"], name=\"test_adin_pony_pink_idx\")\n  2824\t        operation = migrations.AddIndex(\"Pony\", index)\n  2825\t        self.assertEqual(\n  2826\t            operation.describe(),\n  2827\t            \"Create index test_adin_pony_pink_idx on field(s) pink of model Pony\",\n  2828\t        )\n  2829\t        self.assertEqual(\n  2830\t            operation.migration_name_fragment,\n  2831\t            \"pony_test_adin_pony_pink_idx\",\n  2832\t        )\n  2833\t        new_state = project_state.clone()\n  2834\t        operation.state_forwards(\"test_adin\", new_state)\n  2835\t        # Test the database alteration\n  2836\t        self.assertEqual(\n  2837\t            len(new_state.models[\"test_adin\", \"pony\"].options[\"indexes\"]), 1\n  2838\t        )\n  2839\t        self.assertIndexNotExists(\"test_adin_pony\", [\"pink\"])\n  2840\t        with connection.schema_editor() as editor:\n  2841\t            operation.database_forwards(\"test_adin\", editor, project_state, new_state)\n  2842\t        self.assertIndexExists(\"test_adin_pony\", [\"pink\"])\n  2843\t        # And test reversal\n  2844\t        with connection.schema_editor() as editor:\n  2845\t            operation.database_backwards(\"test_adin\", editor, new_state, project_state)\n  2846\t        self.assertIndexNotExists(\"test_adin_pony\", [\"pink\"])\n  2847\t        # And deconstruction\n  2848\t        definition = operation.deconstruct()\n  2849\t        self.assertEqual(definition[0], \"AddIndex\")\n  2850\t        self.assertEqual(definition[1], [])\n  2851\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"index\": index})\n  2852\t\n  2853\t    def test_remove_index(self):\n  2854\t        \"\"\"\n  2855\t        Test the RemoveIndex operation.\n  2856\t        \"\"\"\n  2857\t        project_state = self.set_up_test_model(\"test_rmin\", multicol_index=True)\n  2858\t        self.assertTableExists(\"test_rmin_pony\")\n  2859\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2860\t        operation = migrations.RemoveIndex(\"Pony\", \"pony_test_idx\")\n  2861\t        self.assertEqual(operation.describe(), \"Remove index pony_test_idx from Pony\")\n  2862\t        self.assertEqual(\n  2863\t            operation.migration_name_fragment,\n  2864\t            \"remove_pony_pony_test_idx\",\n  2865\t        )\n  2866\t        new_state = project_state.clone()\n  2867\t        operation.state_forwards(\"test_rmin\", new_state)\n  2868\t        # Test the state alteration\n  2869\t        self.assertEqual(\n  2870\t            len(new_state.models[\"test_rmin\", \"pony\"].options[\"indexes\"]), 0\n  2871\t        )\n  2872\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2873\t        # Test the database alteration\n  2874\t        with connection.schema_editor() as editor:\n  2875\t            operation.database_forwards(\"test_rmin\", editor, project_state, new_state)\n  2876\t        self.assertIndexNotExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2877\t        # And test reversal\n  2878\t        with connection.schema_editor() as editor:\n  2879\t            operation.database_backwards(\"test_rmin\", editor, new_state, project_state)\n  2880\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2881\t        # And deconstruction\n  2882\t        definition = operation.deconstruct()\n  2883\t        self.assertEqual(definition[0], \"RemoveIndex\")\n  2884\t        self.assertEqual(definition[1], [])\n  2885\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"name\": \"pony_test_idx\"})\n  2886\t\n  2887\t        # Also test a field dropped with index - sqlite remake issue\n  2888\t        operations = [\n  2889\t            migrations.RemoveIndex(\"Pony\", \"pony_test_idx\"),\n  2890\t            migrations.RemoveField(\"Pony\", \"pink\"),\n  2891\t        ]\n  2892\t        self.assertColumnExists(\"test_rmin_pony\", \"pink\")\n  2893\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2894\t        # Test database alteration\n  2895\t        new_state = project_state.clone()\n  2896\t        self.apply_operations(\"test_rmin\", new_state, operations=operations)\n  2897\t        self.assertColumnNotExists(\"test_rmin_pony\", \"pink\")\n  2898\t        self.assertIndexNotExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2899\t        # And test reversal\n  2900\t        self.unapply_operations(\"test_rmin\", project_state, operations=operations)\n  2901\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2902\t\n  2903\t    def test_rename_index(self):\n  2904\t        app_label = \"test_rnin\"\n  2905\t        project_state = self.set_up_test_model(app_label, index=True)\n  2906\t        table_name = app_label + \"_pony\"\n  2907\t        self.assertIndexNameExists(table_name, \"pony_pink_idx\")\n  2908\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2909\t        operation = migrations.RenameIndex(\n  2910\t            \"Pony\", new_name=\"new_pony_test_idx\", old_name=\"pony_pink_idx\"\n  2911\t        )\n  2912\t        self.assertEqual(\n  2913\t            operation.describe(),\n  2914\t            \"Rename index pony_pink_idx on Pony to new_pony_test_idx\",\n  2915\t        )\n  2916\t        self.assertEqual(\n  2917\t            operation.migration_name_fragment,\n  2918\t            \"rename_pony_pink_idx_new_pony_test_idx\",\n  2919\t        )\n  2920\t\n  2921\t        new_state = project_state.clone()\n  2922\t        operation.state_forwards(app_label, new_state)\n  2923\t        # Rename index.\n  2924\t        expected_queries = 1 if connection.features.can_rename_index else 2\n  2925\t        with connection.schema_editor() as editor, self.assertNumQueries(\n  2926\t            expected_queries\n  2927\t        ):\n  2928\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2929\t        self.assertIndexNameNotExists(table_name, \"pony_pink_idx\")\n  2930\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2931\t        # Reversal.\n  2932\t        with connection.schema_editor() as editor, self.assertNumQueries(\n  2933\t            expected_queries\n  2934\t        ):\n  2935\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2936\t        self.assertIndexNameExists(table_name, \"pony_pink_idx\")\n  2937\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2938\t        # Deconstruction.\n  2939\t        definition = operation.deconstruct()\n  2940\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2941\t        self.assertEqual(definition[1], [])\n  2942\t        self.assertEqual(\n  2943\t            definition[2],\n  2944\t            {\n  2945\t                \"model_name\": \"Pony\",\n  2946\t                \"old_name\": \"pony_pink_idx\",\n  2947\t                \"new_name\": \"new_pony_test_idx\",\n  2948\t            },\n  2949\t        )\n  2950\t\n  2951\t    def test_rename_index_arguments(self):\n  2952\t        msg = \"RenameIndex.old_name and old_fields are mutually exclusive.\"\n  2953\t        with self.assertRaisesMessage(ValueError, msg):\n  2954\t            migrations.RenameIndex(\n  2955\t                \"Pony\",\n  2956\t                new_name=\"new_idx_name\",\n  2957\t                old_name=\"old_idx_name\",\n  2958\t                old_fields=(\"weight\", \"pink\"),\n  2959\t            )\n  2960\t        msg = \"RenameIndex requires one of old_name and old_fields arguments to be set.\"\n  2961\t        with self.assertRaisesMessage(ValueError, msg):\n  2962\t            migrations.RenameIndex(\"Pony\", new_name=\"new_idx_name\")\n  2963\t\n  2964\t    def test_rename_index_unnamed_index(self):\n  2965\t        app_label = \"test_rninui\"\n  2966\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  2967\t        table_name = app_label + \"_pony\"\n  2968\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2969\t        operation = migrations.RenameIndex(\n  2970\t            \"Pony\", new_name=\"new_pony_test_idx\", old_fields=(\"weight\", \"pink\")\n  2971\t        )\n  2972\t        self.assertEqual(\n  2973\t            operation.describe(),\n  2974\t            \"Rename unnamed index for ('weight', 'pink') on Pony to new_pony_test_idx\",\n  2975\t        )\n  2976\t        self.assertEqual(\n  2977\t            operation.migration_name_fragment,\n  2978\t            \"rename_pony_weight_pink_new_pony_test_idx\",\n  2979\t        )\n  2980\t\n  2981\t        new_state = project_state.clone()\n  2982\t        operation.state_forwards(app_label, new_state)\n  2983\t        # Rename index.\n  2984\t        with connection.schema_editor() as editor:\n  2985\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2986\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2987\t        # Reverse is a no-op.\n  2988\t        with connection.schema_editor() as editor, self.assertNumQueries(0):\n  2989\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2990\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2991\t        # Deconstruction.\n  2992\t        definition = operation.deconstruct()\n  2993\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2994\t        self.assertEqual(definition[1], [])\n  2995\t        self.assertEqual(\n  2996\t            definition[2],\n  2997\t            {\n  2998\t                \"model_name\": \"Pony\",\n  2999\t                \"new_name\": \"new_pony_test_idx\",\n  3000\t                \"old_fields\": (\"weight\", \"pink\"),\n  3001\t            },\n  3002\t        )\n  3003\t\n  3004\t    def test_rename_index_unknown_unnamed_index(self):\n  3005\t        app_label = \"test_rninuui\"\n  3006\t        project_state = self.set_up_test_model(app_label)\n  3007\t        operation = migrations.RenameIndex(\n  3008\t            \"Pony\", new_name=\"new_pony_test_idx\", old_fields=(\"weight\", \"pink\")\n  3009\t        )\n  3010\t        new_state = project_state.clone()\n  3011\t        operation.state_forwards(app_label, new_state)\n  3012\t        msg = \"Found wrong number (0) of indexes for test_rninuui_pony(weight, pink).\"\n  3013\t        with connection.schema_editor() as editor:\n  3014\t            with self.assertRaisesMessage(ValueError, msg):\n  3015\t                operation.database_forwards(app_label, editor, project_state, new_state)\n  3016\t\n  3017\t    def test_add_index_state_forwards(self):\n  3018\t        project_state = self.set_up_test_model(\"test_adinsf\")\n  3019\t        index = models.Index(fields=[\"pink\"], name=\"test_adinsf_pony_pink_idx\")\n  3020\t        old_model = project_state.apps.get_model(\"test_adinsf\", \"Pony\")\n  3021\t        new_state = project_state.clone()\n  3022\t\n  3023\t        operation = migrations.AddIndex(\"Pony\", index)\n  3024\t        operation.state_forwards(\"test_adinsf\", new_state)\n  3025\t        new_model = new_state.apps.get_model(\"test_adinsf\", \"Pony\")\n  3026\t        self.assertIsNot(old_model, new_model)\n  3027\t\n  3028\t    def test_remove_index_state_forwards(self):\n  3029\t        project_state = self.set_up_test_model(\"test_rminsf\")\n  3030\t        index = models.Index(fields=[\"pink\"], name=\"test_rminsf_pony_pink_idx\")\n  3031\t        migrations.AddIndex(\"Pony\", index).state_forwards(\"test_rminsf\", project_state)\n  3032\t        old_model = project_state.apps.get_model(\"test_rminsf\", \"Pony\")\n  3033\t        new_state = project_state.clone()\n  3034\t\n  3035\t        operation = migrations.RemoveIndex(\"Pony\", \"test_rminsf_pony_pink_idx\")\n  3036\t        operation.state_forwards(\"test_rminsf\", new_state)\n  3037\t        new_model = new_state.apps.get_model(\"test_rminsf\", \"Pony\")\n  3038\t        self.assertIsNot(old_model, new_model)\n  3039\t\n  3040\t    def test_rename_index_state_forwards(self):\n  3041\t        app_label = \"test_rnidsf\"\n  3042\t        project_state = self.set_up_test_model(app_label, index=True)\n  3043\t        old_model = project_state.apps.get_model(app_label, \"Pony\")\n  3044\t        new_state = project_state.clone()\n  3045\t\n  3046\t        operation = migrations.RenameIndex(\n  3047\t            \"Pony\", new_name=\"new_pony_pink_idx\", old_name=\"pony_pink_idx\"\n  3048\t        )\n  3049\t        operation.state_forwards(app_label, new_state)\n  3050\t        new_model = new_state.apps.get_model(app_label, \"Pony\")\n  3051\t        self.assertIsNot(old_model, new_model)\n  3052\t        self.assertEqual(new_model._meta.indexes[0].name, \"new_pony_pink_idx\")\n  3053\t\n  3054\t    def test_rename_index_state_forwards_unnamed_index(self):\n  3055\t        app_label = \"test_rnidsfui\"\n  3056\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  3057\t        old_model = project_state.apps.get_model(app_label, \"Pony\")\n  3058\t        new_state = project_state.clone()\n  3059\t\n  3060\t        operation = migrations.RenameIndex(\n  3061\t            \"Pony\", new_name=\"new_pony_pink_idx\", old_fields=(\"weight\", \"pink\")\n  3062\t        )\n  3063\t        operation.state_forwards(app_label, new_state)\n  3064\t        new_model = new_state.apps.get_model(app_label, \"Pony\")\n  3065\t        self.assertIsNot(old_model, new_model)\n  3066\t        self.assertEqual(new_model._meta.index_together, tuple())\n  3067\t        self.assertEqual(new_model._meta.indexes[0].name, \"new_pony_pink_idx\")\n  3068\t\n  3069\t    @skipUnlessDBFeature(\"supports_expression_indexes\")\n  3070\t    def test_add_func_index(self):\n  3071\t        app_label = \"test_addfuncin\"\n  3072\t        index_name = f\"{app_label}_pony_abs_idx\"\n  3073\t        table_name = f\"{app_label}_pony\"\n  3074\t        project_state = self.set_up_test_model(app_label)\n  3075\t        index = models.Index(Abs(\"weight\"), name=index_name)\n  3076\t        operation = migrations.AddIndex(\"Pony\", index)\n  3077\t        self.assertEqual(\n  3078\t            operation.describe(),\n  3079\t            \"Create index test_addfuncin_pony_abs_idx on Abs(F(weight)) on model Pony\",\n  3080\t        )\n  3081\t        self.assertEqual(\n  3082\t            operation.migration_name_fragment,\n  3083\t            \"pony_test_addfuncin_pony_abs_idx\",\n  3084\t        )\n  3085\t        new_state = project_state.clone()\n  3086\t        operation.state_forwards(app_label, new_state)\n  3087\t        self.assertEqual(len(new_state.models[app_label, \"pony\"].options[\"indexes\"]), 1)\n  3088\t        self.assertIndexNameNotExists(table_name, index_name)\n  3089\t        # Add index.\n  3090\t        with connection.schema_editor() as editor:\n  3091\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3092\t        self.assertIndexNameExists(table_name, index_name)\n  3093\t        # Reversal.\n  3094\t        with connection.schema_editor() as editor:\n  3095\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3096\t        self.assertIndexNameNotExists(table_name, index_name)\n  3097\t        # Deconstruction.\n  3098\t        definition = operation.deconstruct()\n  3099\t        self.assertEqual(definition[0], \"AddIndex\")\n  3100\t        self.assertEqual(definition[1], [])\n  3101\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"index\": index})\n  3102\t\n  3103\t    @skipUnlessDBFeature(\"supports_expression_indexes\")\n  3104\t    def test_remove_func_index(self):\n  3105\t        app_label = \"test_rmfuncin\"\n  3106\t        index_name = f\"{app_label}_pony_abs_idx\"\n  3107\t        table_name = f\"{app_label}_pony\"\n  3108\t        project_state = self.set_up_test_model(\n  3109\t            app_label,\n  3110\t            indexes=[\n  3111\t                models.Index(Abs(\"weight\"), name=index_name),\n  3112\t            ],\n  3113\t        )\n  3114\t        self.assertTableExists(table_name)\n  3115\t        self.assertIndexNameExists(table_name, index_name)\n  3116\t        operation = migrations.RemoveIndex(\"Pony\", index_name)\n  3117\t        self.assertEqual(\n  3118\t            operation.describe(),\n  3119\t            \"Remove index test_rmfuncin_pony_abs_idx from Pony\",\n  3120\t        )\n  3121\t        self.assertEqual(\n  3122\t            operation.migration_name_fragment,\n  3123\t            \"remove_pony_test_rmfuncin_pony_abs_idx\",\n  3124\t        )\n  3125\t        new_state = project_state.clone()\n  3126\t        operation.state_forwards(app_label, new_state)\n  3127\t        self.assertEqual(len(new_state.models[app_label, \"pony\"].options[\"indexes\"]), 0)\n  3128\t        # Remove index.\n  3129\t        with connection.schema_editor() as editor:\n  3130\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3131\t        self.assertIndexNameNotExists(table_name, index_name)\n  3132\t        # Reversal.\n  3133\t        with connection.schema_editor() as editor:\n  3134\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3135\t        self.assertIndexNameExists(table_name, index_name)\n  3136\t        # Deconstruction.\n  3137\t        definition = operation.deconstruct()\n  3138\t        self.assertEqual(definition[0], \"RemoveIndex\")\n  3139\t        self.assertEqual(definition[1], [])\n  3140\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"name\": index_name})\n  3141\t\n  3142\t    @skipUnlessDBFeature(\"supports_expression_indexes\")\n  3143\t    def test_alter_field_with_func_index(self):\n  3144\t        app_label = \"test_alfuncin\"\n  3145\t        index_name = f\"{app_label}_pony_idx\"\n  3146\t        table_name = f\"{app_label}_pony\"\n  3147\t        project_state = self.set_up_test_model(\n  3148\t            app_label,\n  3149\t            indexes=[models.Index(Abs(\"pink\"), name=index_name)],\n  3150\t        )\n  3151\t        operation = migrations.AlterField(\n  3152\t            \"Pony\", \"pink\", models.IntegerField(null=True)\n  3153\t        )\n  3154\t        new_state = project_state.clone()\n  3155\t        operation.state_forwards(app_label, new_state)\n  3156\t        with connection.schema_editor() as editor:\n  3157\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3158\t        self.assertIndexNameExists(table_name, index_name)\n  3159\t        with connection.schema_editor() as editor:\n  3160\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3161\t        self.assertIndexNameExists(table_name, index_name)\n  3162\t\n  3163\t    def test_alter_field_with_index(self):\n  3164\t        \"\"\"\n  3165\t        Test AlterField operation with an index to ensure indexes created via\n  3166\t        Meta.indexes don't get dropped with sqlite3 remake.\n  3167\t        \"\"\"\n  3168\t        project_state = self.set_up_test_model(\"test_alflin\", index=True)\n  3169\t        operation = migrations.AlterField(\n  3170\t            \"Pony\", \"pink\", models.IntegerField(null=True)\n  3171\t        )\n  3172\t        new_state = project_state.clone()\n  3173\t        operation.state_forwards(\"test_alflin\", new_state)\n  3174\t        # Test the database alteration\n  3175\t        self.assertColumnNotNull(\"test_alflin_pony\", \"pink\")\n  3176\t        with connection.schema_editor() as editor:\n  3177\t            operation.database_forwards(\"test_alflin\", editor, project_state, new_state)\n  3178\t        # Index hasn't been dropped\n  3179\t        self.assertIndexExists(\"test_alflin_pony\", [\"pink\"])\n  3180\t        # And test reversal\n  3181\t        with connection.schema_editor() as editor:\n  3182\t            operation.database_backwards(\n  3183\t                \"test_alflin\", editor, new_state, project_state\n  3184\t            )\n  3185\t        # Ensure the index is still there\n  3186\t        self.assertIndexExists(\"test_alflin_pony\", [\"pink\"])\n  3187\t\n  3188\t    def test_alter_index_together(self):\n  3189\t        \"\"\"\n  3190\t        Tests the AlterIndexTogether operation.\n  3191\t        \"\"\"\n  3192\t        project_state = self.set_up_test_model(\"test_alinto\")\n  3193\t        # Test the state alteration\n  3194\t        operation = migrations.AlterIndexTogether(\"Pony\", [(\"pink\", \"weight\")])\n  3195\t        self.assertEqual(\n  3196\t            operation.describe(), \"Alter index_together for Pony (1 constraint(s))\"\n  3197\t        )\n  3198\t        self.assertEqual(\n  3199\t            operation.migration_name_fragment,\n  3200\t            \"alter_pony_index_together\",\n  3201\t        )\n  3202\t        new_state = project_state.clone()\n  3203\t        operation.state_forwards(\"test_alinto\", new_state)\n  3204\t        self.assertEqual(\n  3205\t            len(\n  3206\t                project_state.models[\"test_alinto\", \"pony\"].options.get(\n  3207\t                    \"index_together\", set()\n  3208\t                )\n  3209\t            ),\n  3210\t            0,\n  3211\t        )\n  3212\t        self.assertEqual(\n  3213\t            len(\n  3214\t                new_state.models[\"test_alinto\", \"pony\"].options.get(\n  3215\t                    \"index_together\", set()\n  3216\t                )\n  3217\t            ),\n  3218\t            1,\n  3219\t        )\n  3220\t        # Make sure there's no matching index\n  3221\t        self.assertIndexNotExists(\"test_alinto_pony\", [\"pink\", \"weight\"])\n  3222\t        # Test the database alteration\n  3223\t        with connection.schema_editor() as editor:\n  3224\t            operation.database_forwards(\"test_alinto\", editor, project_state, new_state)\n  3225\t        self.assertIndexExists(\"test_alinto_pony\", [\"pink\", \"weight\"])\n  3226\t        # And test reversal\n  3227\t        with connection.schema_editor() as editor:\n  3228\t            operation.database_backwards(\n  3229\t                \"test_alinto\", editor, new_state, project_state\n  3230\t            )\n  3231\t        self.assertIndexNotExists(\"test_alinto_pony\", [\"pink\", \"weight\"])\n  3232\t        # And deconstruction\n  3233\t        definition = operation.deconstruct()\n  3234\t        self.assertEqual(definition[0], \"AlterIndexTogether\")\n  3235\t        self.assertEqual(definition[1], [])\n  3236\t        self.assertEqual(\n  3237\t            definition[2], {\"name\": \"Pony\", \"index_together\": {(\"pink\", \"weight\")}}\n  3238\t        )\n  3239\t\n  3240\t    def test_alter_index_together_remove(self):\n  3241\t        operation = migrations.AlterIndexTogether(\"Pony\", None)\n  3242\t        self.assertEqual(\n  3243\t            operation.describe(), \"Alter index_together for Pony (0 constraint(s))\"\n  3244\t        )\n  3245\t\n  3246\t    @skipUnlessDBFeature(\"allows_multiple_constraints_on_same_fields\")\n  3247\t    def test_alter_index_together_remove_with_unique_together(self):\n  3248\t        app_label = \"test_alintoremove_wunto\"\n  3249\t        table_name = \"%s_pony\" % app_label\n  3250\t        project_state = self.set_up_test_model(app_label, unique_together=True)\n  3251\t        self.assertUniqueConstraintExists(table_name, [\"pink\", \"weight\"])\n  3252\t        # Add index together.\n  3253\t        new_state = project_state.clone()\n  3254\t        operation = migrations.AlterIndexTogether(\"Pony\", [(\"pink\", \"weight\")])\n  3255\t        operation.state_forwards(app_label, new_state)\n  3256\t        with connection.schema_editor() as editor:\n  3257\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3258\t        self.assertIndexExists(table_name, [\"pink\", \"weight\"])\n  3259\t        # Remove index together.\n  3260\t        project_state = new_state\n  3261\t        new_state = project_state.clone()\n  3262\t        operation = migrations.AlterIndexTogether(\"Pony\", set())\n  3263\t        operation.state_forwards(app_label, new_state)\n  3264\t        with connection.schema_editor() as editor:\n  3265\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3266\t        self.assertIndexNotExists(table_name, [\"pink\", \"weight\"])\n  3267\t        self.assertUniqueConstraintExists(table_name, [\"pink\", \"weight\"])\n  3268\t\n  3269\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3270\t    def test_add_constraint(self):\n  3271\t        project_state = self.set_up_test_model(\"test_addconstraint\")\n  3272\t        gt_check = models.Q(pink__gt=2)\n  3273\t        gt_constraint = models.CheckConstraint(\n  3274\t            check=gt_check, name=\"test_add_constraint_pony_pink_gt_2\"\n  3275\t        )\n  3276\t        gt_operation = migrations.AddConstraint(\"Pony\", gt_constraint)\n  3277\t        self.assertEqual(\n  3278\t            gt_operation.describe(),\n  3279\t            \"Create constraint test_add_constraint_pony_pink_gt_2 on model Pony\",\n  3280\t        )\n  3281\t        self.assertEqual(\n  3282\t            gt_operation.migration_name_fragment,\n  3283\t            \"pony_test_add_constraint_pony_pink_gt_2\",\n  3284\t        )\n  3285\t        # Test the state alteration\n  3286\t        new_state = project_state.clone()\n  3287\t        gt_operation.state_forwards(\"test_addconstraint\", new_state)\n  3288\t        self.assertEqual(\n  3289\t            len(new_state.models[\"test_addconstraint\", \"pony\"].options[\"constraints\"]),\n  3290\t            1,\n  3291\t        )\n  3292\t        Pony = new_state.apps.get_model(\"test_addconstraint\", \"Pony\")\n  3293\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3294\t        # Test the database alteration\n  3295\t        with connection.schema_editor() as editor:\n  3296\t            gt_operation.database_forwards(\n  3297\t                \"test_addconstraint\", editor, project_state, new_state\n  3298\t            )\n  3299\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3300\t            Pony.objects.create(pink=1, weight=1.0)\n  3301\t        # Add another one.\n  3302\t        lt_check = models.Q(pink__lt=100)\n  3303\t        lt_constraint = models.CheckConstraint(\n  3304\t            check=lt_check, name=\"test_add_constraint_pony_pink_lt_100\"\n  3305\t        )\n  3306\t        lt_operation = migrations.AddConstraint(\"Pony\", lt_constraint)\n  3307\t        lt_operation.state_forwards(\"test_addconstraint\", new_state)\n  3308\t        self.assertEqual(\n  3309\t            len(new_state.models[\"test_addconstraint\", \"pony\"].options[\"constraints\"]),\n  3310\t            2,\n  3311\t        )\n  3312\t        Pony = new_state.apps.get_model(\"test_addconstraint\", \"Pony\")\n  3313\t        self.assertEqual(len(Pony._meta.constraints), 2)\n  3314\t        with connection.schema_editor() as editor:\n  3315\t            lt_operation.database_forwards(\n  3316\t                \"test_addconstraint\", editor, project_state, new_state\n  3317\t            )\n  3318\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3319\t            Pony.objects.create(pink=100, weight=1.0)\n  3320\t        # Test reversal\n  3321\t        with connection.schema_editor() as editor:\n  3322\t            gt_operation.database_backwards(\n  3323\t                \"test_addconstraint\", editor, new_state, project_state\n  3324\t            )\n  3325\t        Pony.objects.create(pink=1, weight=1.0)\n  3326\t        # Test deconstruction\n  3327\t        definition = gt_operation.deconstruct()\n  3328\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3329\t        self.assertEqual(definition[1], [])\n  3330\t        self.assertEqual(\n  3331\t            definition[2], {\"model_name\": \"Pony\", \"constraint\": gt_constraint}\n  3332\t        )\n  3333\t\n  3334\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3335\t    def test_add_constraint_percent_escaping(self):\n  3336\t        app_label = \"add_constraint_string_quoting\"\n  3337\t        operations = [\n  3338\t            migrations.CreateModel(\n  3339\t                \"Author\",\n  3340\t                fields=[\n  3341\t                    (\"id\", models.AutoField(primary_key=True)),\n  3342\t                    (\"name\", models.CharField(max_length=100)),\n  3343\t                    (\"surname\", models.CharField(max_length=100, default=\"\")),\n  3344\t                    (\"rebate\", models.CharField(max_length=100)),\n  3345\t                ],\n  3346\t            ),\n  3347\t        ]\n  3348\t        from_state = self.apply_operations(app_label, ProjectState(), operations)\n  3349\t        # \"%\" generated in startswith lookup should be escaped in a way that is\n  3350\t        # considered a leading wildcard.\n  3351\t        check = models.Q(name__startswith=\"Albert\")\n  3352\t        constraint = models.CheckConstraint(check=check, name=\"name_constraint\")\n  3353\t        operation = migrations.AddConstraint(\"Author\", constraint)\n  3354\t        to_state = from_state.clone()\n  3355\t        operation.state_forwards(app_label, to_state)\n  3356\t        with connection.schema_editor() as editor:\n  3357\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3358\t        Author = to_state.apps.get_model(app_label, \"Author\")\n  3359\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3360\t            Author.objects.create(name=\"Artur\")\n  3361\t        # Literal \"%\" should be escaped in a way that is not a considered a\n  3362\t        # wildcard.\n  3363\t        check = models.Q(rebate__endswith=\"%\")\n  3364\t        constraint = models.CheckConstraint(check=check, name=\"rebate_constraint\")\n  3365\t        operation = migrations.AddConstraint(\"Author\", constraint)\n  3366\t        from_state = to_state\n  3367\t        to_state = from_state.clone()\n  3368\t        operation.state_forwards(app_label, to_state)\n  3369\t        Author = to_state.apps.get_model(app_label, \"Author\")\n  3370\t        with connection.schema_editor() as editor:\n  3371\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3372\t        Author = to_state.apps.get_model(app_label, \"Author\")\n  3373\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3374\t            Author.objects.create(name=\"Albert\", rebate=\"10$\")\n  3375\t        author = Author.objects.create(name=\"Albert\", rebate=\"10%\")\n  3376\t        self.assertEqual(Author.objects.get(), author)\n  3377\t        # Right-hand-side baked \"%\" literals should not be used for parameters\n  3378\t        # interpolation.\n  3379\t        check = ~models.Q(surname__startswith=models.F(\"name\"))\n  3380\t        constraint = models.CheckConstraint(check=check, name=\"name_constraint_rhs\")\n  3381\t        operation = migrations.AddConstraint(\"Author\", constraint)\n  3382\t        from_state = to_state\n  3383\t        to_state = from_state.clone()\n  3384\t        operation.state_forwards(app_label, to_state)\n  3385\t        with connection.schema_editor() as editor:\n  3386\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3387\t        Author = to_state.apps.get_model(app_label, \"Author\")\n  3388\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3389\t            Author.objects.create(name=\"Albert\", surname=\"Alberto\")\n  3390\t\n  3391\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3392\t    def test_add_or_constraint(self):\n  3393\t        app_label = \"test_addorconstraint\"\n  3394\t        constraint_name = \"add_constraint_or\"\n  3395\t        from_state = self.set_up_test_model(app_label)\n  3396\t        check = models.Q(pink__gt=2, weight__gt=2) | models.Q(weight__lt=0)\n  3397\t        constraint = models.CheckConstraint(check=check, name=constraint_name)\n  3398\t        operation = migrations.AddConstraint(\"Pony\", constraint)\n  3399\t        to_state = from_state.clone()\n  3400\t        operation.state_forwards(app_label, to_state)\n  3401\t        with connection.schema_editor() as editor:\n  3402\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3403\t        Pony = to_state.apps.get_model(app_label, \"Pony\")\n  3404\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3405\t            Pony.objects.create(pink=2, weight=3.0)\n  3406\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3407\t            Pony.objects.create(pink=3, weight=1.0)\n  3408\t        Pony.objects.bulk_create(\n  3409\t            [\n  3410\t                Pony(pink=3, weight=-1.0),\n  3411\t                Pony(pink=1, weight=-1.0),\n  3412\t                Pony(pink=3, weight=3.0),\n  3413\t            ]\n  3414\t        )\n  3415\t\n  3416\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3417\t    def test_add_constraint_combinable(self):\n  3418\t        app_label = \"test_addconstraint_combinable\"\n  3419\t        operations = [\n  3420\t            migrations.CreateModel(\n  3421\t                \"Book\",\n  3422\t                fields=[\n  3423\t                    (\"id\", models.AutoField(primary_key=True)),\n  3424\t                    (\"read\", models.PositiveIntegerField()),\n  3425\t                    (\"unread\", models.PositiveIntegerField()),\n  3426\t                ],\n  3427\t            ),\n  3428\t        ]\n  3429\t        from_state = self.apply_operations(app_label, ProjectState(), operations)\n  3430\t        constraint = models.CheckConstraint(\n  3431\t            check=models.Q(read=(100 - models.F(\"unread\"))),\n  3432\t            name=\"test_addconstraint_combinable_sum_100\",\n  3433\t        )\n  3434\t        operation = migrations.AddConstraint(\"Book\", constraint)\n  3435\t        to_state = from_state.clone()\n  3436\t        operation.state_forwards(app_label, to_state)\n  3437\t        with connection.schema_editor() as editor:\n  3438\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3439\t        Book = to_state.apps.get_model(app_label, \"Book\")\n  3440\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3441\t            Book.objects.create(read=70, unread=10)\n  3442\t        Book.objects.create(read=70, unread=30)\n  3443\t\n  3444\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3445\t    def test_remove_constraint(self):\n  3446\t        project_state = self.set_up_test_model(\n  3447\t            \"test_removeconstraint\",\n  3448\t            constraints=[\n  3449\t                models.CheckConstraint(\n  3450\t                    check=models.Q(pink__gt=2),\n  3451\t                    name=\"test_remove_constraint_pony_pink_gt_2\",\n  3452\t                ),\n  3453\t                models.CheckConstraint(\n  3454\t                    check=models.Q(pink__lt=100),\n  3455\t                    name=\"test_remove_constraint_pony_pink_lt_100\",\n  3456\t                ),\n  3457\t            ],\n  3458\t        )\n  3459\t        gt_operation = migrations.RemoveConstraint(\n  3460\t            \"Pony\", \"test_remove_constraint_pony_pink_gt_2\"\n  3461\t        )\n  3462\t        self.assertEqual(\n  3463\t            gt_operation.describe(),\n  3464\t            \"Remove constraint test_remove_constraint_pony_pink_gt_2 from model Pony\",\n  3465\t        )\n  3466\t        self.assertEqual(\n  3467\t            gt_operation.migration_name_fragment,\n  3468\t            \"remove_pony_test_remove_constraint_pony_pink_gt_2\",\n  3469\t        )\n  3470\t        # Test state alteration\n  3471\t        new_state = project_state.clone()\n  3472\t        gt_operation.state_forwards(\"test_removeconstraint\", new_state)\n  3473\t        self.assertEqual(\n  3474\t            len(\n  3475\t                new_state.models[\"test_removeconstraint\", \"pony\"].options[\"constraints\"]\n  3476\t            ),\n  3477\t            1,\n  3478\t        )\n  3479\t        Pony = new_state.apps.get_model(\"test_removeconstraint\", \"Pony\")\n  3480\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3481\t        # Test database alteration\n  3482\t        with connection.schema_editor() as editor:\n  3483\t            gt_operation.database_forwards(\n  3484\t                \"test_removeconstraint\", editor, project_state, new_state\n  3485\t            )\n  3486\t        Pony.objects.create(pink=1, weight=1.0).delete()\n  3487\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3488\t            Pony.objects.create(pink=100, weight=1.0)\n  3489\t        # Remove the other one.\n  3490\t        lt_operation = migrations.RemoveConstraint(\n  3491\t            \"Pony\", \"test_remove_constraint_pony_pink_lt_100\"\n  3492\t        )\n  3493\t        lt_operation.state_forwards(\"test_removeconstraint\", new_state)\n  3494\t        self.assertEqual(\n  3495\t            len(\n  3496\t                new_state.models[\"test_removeconstraint\", \"pony\"].options[\"constraints\"]\n  3497\t            ),\n  3498\t            0,\n  3499\t        )\n  3500\t        Pony = new_state.apps.get_model(\"test_removeconstraint\", \"Pony\")\n  3501\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3502\t        with connection.schema_editor() as editor:\n  3503\t            lt_operation.database_forwards(\n  3504\t                \"test_removeconstraint\", editor, project_state, new_state\n  3505\t            )\n  3506\t        Pony.objects.create(pink=100, weight=1.0).delete()\n  3507\t        # Test reversal\n  3508\t        with connection.schema_editor() as editor:\n  3509\t            gt_operation.database_backwards(\n  3510\t                \"test_removeconstraint\", editor, new_state, project_state\n  3511\t            )\n  3512\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3513\t            Pony.objects.create(pink=1, weight=1.0)\n  3514\t        # Test deconstruction\n  3515\t        definition = gt_operation.deconstruct()\n  3516\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3517\t        self.assertEqual(definition[1], [])\n  3518\t        self.assertEqual(\n  3519\t            definition[2],\n  3520\t            {\"model_name\": \"Pony\", \"name\": \"test_remove_constraint_pony_pink_gt_2\"},\n  3521\t        )\n  3522\t\n  3523\t    def test_add_partial_unique_constraint(self):\n  3524\t        project_state = self.set_up_test_model(\"test_addpartialuniqueconstraint\")\n  3525\t        partial_unique_constraint = models.UniqueConstraint(\n  3526\t            fields=[\"pink\"],\n  3527\t            condition=models.Q(weight__gt=5),\n  3528\t            name=\"test_constraint_pony_pink_for_weight_gt_5_uniq\",\n  3529\t        )\n  3530\t        operation = migrations.AddConstraint(\"Pony\", partial_unique_constraint)\n  3531\t        self.assertEqual(\n  3532\t            operation.describe(),\n  3533\t            \"Create constraint test_constraint_pony_pink_for_weight_gt_5_uniq \"\n  3534\t            \"on model Pony\",\n  3535\t        )\n  3536\t        # Test the state alteration\n  3537\t        new_state = project_state.clone()\n  3538\t        operation.state_forwards(\"test_addpartialuniqueconstraint\", new_state)\n  3539\t        self.assertEqual(\n  3540\t            len(\n  3541\t                new_state.models[\"test_addpartialuniqueconstraint\", \"pony\"].options[\n  3542\t                    \"constraints\"\n  3543\t                ]\n  3544\t            ),\n  3545\t            1,\n  3546\t        )\n  3547\t        Pony = new_state.apps.get_model(\"test_addpartialuniqueconstraint\", \"Pony\")\n  3548\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3549\t        # Test the database alteration\n  3550\t        with connection.schema_editor() as editor:\n  3551\t            operation.database_forwards(\n  3552\t                \"test_addpartialuniqueconstraint\", editor, project_state, new_state\n  3553\t            )\n  3554\t        # Test constraint works\n  3555\t        Pony.objects.create(pink=1, weight=4.0)\n  3556\t        Pony.objects.create(pink=1, weight=4.0)\n  3557\t        Pony.objects.create(pink=1, weight=6.0)\n  3558\t        if connection.features.supports_partial_indexes:\n  3559\t            with self.assertRaises(IntegrityError), transaction.atomic():\n  3560\t                Pony.objects.create(pink=1, weight=7.0)\n  3561\t        else:\n  3562\t            Pony.objects.create(pink=1, weight=7.0)\n  3563\t        # Test reversal\n  3564\t        with connection.schema_editor() as editor:\n  3565\t            operation.database_backwards(\n  3566\t                \"test_addpartialuniqueconstraint\", editor, new_state, project_state\n  3567\t            )\n  3568\t        # Test constraint doesn't work\n  3569\t        Pony.objects.create(pink=1, weight=7.0)\n  3570\t        # Test deconstruction\n  3571\t        definition = operation.deconstruct()\n  3572\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3573\t        self.assertEqual(definition[1], [])\n  3574\t        self.assertEqual(\n  3575\t            definition[2],\n  3576\t            {\"model_name\": \"Pony\", \"constraint\": partial_unique_constraint},\n  3577\t        )\n  3578\t\n  3579\t    def test_remove_partial_unique_constraint(self):\n  3580\t        project_state = self.set_up_test_model(\n  3581\t            \"test_removepartialuniqueconstraint\",\n  3582\t            constraints=[\n  3583\t                models.UniqueConstraint(\n  3584\t                    fields=[\"pink\"],\n  3585\t                    condition=models.Q(weight__gt=5),\n  3586\t                    name=\"test_constraint_pony_pink_for_weight_gt_5_uniq\",\n  3587\t                ),\n  3588\t            ],\n  3589\t        )\n  3590\t        gt_operation = migrations.RemoveConstraint(\n  3591\t            \"Pony\", \"test_constraint_pony_pink_for_weight_gt_5_uniq\"\n  3592\t        )\n  3593\t        self.assertEqual(\n  3594\t            gt_operation.describe(),\n  3595\t            \"Remove constraint test_constraint_pony_pink_for_weight_gt_5_uniq from \"\n  3596\t            \"model Pony\",\n  3597\t        )\n  3598\t        # Test state alteration\n  3599\t        new_state = project_state.clone()\n  3600\t        gt_operation.state_forwards(\"test_removepartialuniqueconstraint\", new_state)\n  3601\t        self.assertEqual(\n  3602\t            len(\n  3603\t                new_state.models[\"test_removepartialuniqueconstraint\", \"pony\"].options[\n  3604\t                    \"constraints\"\n  3605\t                ]\n  3606\t            ),\n  3607\t            0,\n  3608\t        )\n  3609\t        Pony = new_state.apps.get_model(\"test_removepartialuniqueconstraint\", \"Pony\")\n  3610\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3611\t        # Test database alteration\n  3612\t        with connection.schema_editor() as editor:\n  3613\t            gt_operation.database_forwards(\n  3614\t                \"test_removepartialuniqueconstraint\", editor, project_state, new_state\n  3615\t            )\n  3616\t        # Test constraint doesn't work\n  3617\t        Pony.objects.create(pink=1, weight=4.0)\n  3618\t        Pony.objects.create(pink=1, weight=4.0)\n  3619\t        Pony.objects.create(pink=1, weight=6.0)\n  3620\t        Pony.objects.create(pink=1, weight=7.0).delete()\n  3621\t        # Test reversal\n  3622\t        with connection.schema_editor() as editor:\n  3623\t            gt_operation.database_backwards(\n  3624\t                \"test_removepartialuniqueconstraint\", editor, new_state, project_state\n  3625\t            )\n  3626\t        # Test constraint works\n  3627\t        if connection.features.supports_partial_indexes:\n  3628\t            with self.assertRaises(IntegrityError), transaction.atomic():\n  3629\t                Pony.objects.create(pink=1, weight=7.0)\n  3630\t        else:\n  3631\t            Pony.objects.create(pink=1, weight=7.0)\n  3632\t        # Test deconstruction\n  3633\t        definition = gt_operation.deconstruct()\n  3634\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3635\t        self.assertEqual(definition[1], [])\n  3636\t        self.assertEqual(\n  3637\t            definition[2],\n  3638\t            {\n  3639\t                \"model_name\": \"Pony\",\n  3640\t                \"name\": \"test_constraint_pony_pink_for_weight_gt_5_uniq\",\n  3641\t            },\n  3642\t        )\n  3643\t\n  3644\t    def test_add_deferred_unique_constraint(self):\n  3645\t        app_label = \"test_adddeferred_uc\"\n  3646\t        project_state = self.set_up_test_model(app_label)\n  3647\t        deferred_unique_constraint = models.UniqueConstraint(\n  3648\t            fields=[\"pink\"],\n  3649\t            name=\"deferred_pink_constraint_add\",\n  3650\t            deferrable=models.Deferrable.DEFERRED,\n  3651\t        )\n  3652\t        operation = migrations.AddConstraint(\"Pony\", deferred_unique_constraint)\n  3653\t        self.assertEqual(\n  3654\t            operation.describe(),\n  3655\t            \"Create constraint deferred_pink_constraint_add on model Pony\",\n  3656\t        )\n  3657\t        # Add constraint.\n  3658\t        new_state = project_state.clone()\n  3659\t        operation.state_forwards(app_label, new_state)\n  3660\t        self.assertEqual(\n  3661\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 1\n  3662\t        )\n  3663\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3664\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3665\t        with connection.schema_editor() as editor, CaptureQueriesContext(\n  3666\t            connection\n  3667\t        ) as ctx:\n  3668\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3669\t        Pony.objects.create(pink=1, weight=4.0)\n  3670\t        if connection.features.supports_deferrable_unique_constraints:\n  3671\t            # Unique constraint is deferred.\n  3672\t            with transaction.atomic():\n  3673\t                obj = Pony.objects.create(pink=1, weight=4.0)\n  3674\t                obj.pink = 2\n  3675\t                obj.save()\n  3676\t            # Constraint behavior can be changed with SET CONSTRAINTS.\n  3677\t            with self.assertRaises(IntegrityError):\n  3678\t                with transaction.atomic(), connection.cursor() as cursor:\n  3679\t                    quoted_name = connection.ops.quote_name(\n  3680\t                        deferred_unique_constraint.name\n  3681\t                    )\n  3682\t                    cursor.execute(\"SET CONSTRAINTS %s IMMEDIATE\" % quoted_name)\n  3683\t                    obj = Pony.objects.create(pink=1, weight=4.0)\n  3684\t                    obj.pink = 3\n  3685\t                    obj.save()\n  3686\t        else:\n  3687\t            self.assertEqual(len(ctx), 0)\n  3688\t            Pony.objects.create(pink=1, weight=4.0)\n  3689\t        # Reversal.\n  3690\t        with connection.schema_editor() as editor:\n  3691\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3692\t        # Constraint doesn't work.\n  3693\t        Pony.objects.create(pink=1, weight=4.0)\n  3694\t        # Deconstruction.\n  3695\t        definition = operation.deconstruct()\n  3696\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3697\t        self.assertEqual(definition[1], [])\n  3698\t        self.assertEqual(\n  3699\t            definition[2],\n  3700\t            {\"model_name\": \"Pony\", \"constraint\": deferred_unique_constraint},\n  3701\t        )\n  3702\t\n  3703\t    def test_remove_deferred_unique_constraint(self):\n  3704\t        app_label = \"test_removedeferred_uc\"\n  3705\t        deferred_unique_constraint = models.UniqueConstraint(\n  3706\t            fields=[\"pink\"],\n  3707\t            name=\"deferred_pink_constraint_rm\",\n  3708\t            deferrable=models.Deferrable.DEFERRED,\n  3709\t        )\n  3710\t        project_state = self.set_up_test_model(\n  3711\t            app_label, constraints=[deferred_unique_constraint]\n  3712\t        )\n  3713\t        operation = migrations.RemoveConstraint(\"Pony\", deferred_unique_constraint.name)\n  3714\t        self.assertEqual(\n  3715\t            operation.describe(),\n  3716\t            \"Remove constraint deferred_pink_constraint_rm from model Pony\",\n  3717\t        )\n  3718\t        # Remove constraint.\n  3719\t        new_state = project_state.clone()\n  3720\t        operation.state_forwards(app_label, new_state)\n  3721\t        self.assertEqual(\n  3722\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 0\n  3723\t        )\n  3724\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3725\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3726\t        with connection.schema_editor() as editor, CaptureQueriesContext(\n  3727\t            connection\n  3728\t        ) as ctx:\n  3729\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3730\t        # Constraint doesn't work.\n  3731\t        Pony.objects.create(pink=1, weight=4.0)\n  3732\t        Pony.objects.create(pink=1, weight=4.0).delete()\n  3733\t        if not connection.features.supports_deferrable_unique_constraints:\n  3734\t            self.assertEqual(len(ctx), 0)\n  3735\t        # Reversal.\n  3736\t        with connection.schema_editor() as editor:\n  3737\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3738\t        if connection.features.supports_deferrable_unique_constraints:\n  3739\t            # Unique constraint is deferred.\n  3740\t            with transaction.atomic():\n  3741\t                obj = Pony.objects.create(pink=1, weight=4.0)\n  3742\t                obj.pink = 2\n  3743\t                obj.save()\n  3744\t            # Constraint behavior can be changed with SET CONSTRAINTS.\n  3745\t            with self.assertRaises(IntegrityError):\n  3746\t                with transaction.atomic(), connection.cursor() as cursor:\n  3747\t                    quoted_name = connection.ops.quote_name(\n  3748\t                        deferred_unique_constraint.name\n  3749\t                    )\n  3750\t                    cursor.execute(\"SET CONSTRAINTS %s IMMEDIATE\" % quoted_name)\n  3751\t                    obj = Pony.objects.create(pink=1, weight=4.0)\n  3752\t                    obj.pink = 3\n  3753\t                    obj.save()\n  3754\t        else:\n  3755\t            Pony.objects.create(pink=1, weight=4.0)\n  3756\t        # Deconstruction.\n  3757\t        definition = operation.deconstruct()\n  3758\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3759\t        self.assertEqual(definition[1], [])\n  3760\t        self.assertEqual(\n  3761\t            definition[2],\n  3762\t            {\n  3763\t                \"model_name\": \"Pony\",\n  3764\t                \"name\": \"deferred_pink_constraint_rm\",\n  3765\t            },\n  3766\t        )\n  3767\t\n  3768\t    def test_add_covering_unique_constraint(self):\n  3769\t        app_label = \"test_addcovering_uc\"\n  3770\t        project_state = self.set_up_test_model(app_label)\n  3771\t        covering_unique_constraint = models.UniqueConstraint(\n  3772\t            fields=[\"pink\"],\n  3773\t            name=\"covering_pink_constraint_add\",\n  3774\t            include=[\"weight\"],\n  3775\t        )\n  3776\t        operation = migrations.AddConstraint(\"Pony\", covering_unique_constraint)\n  3777\t        self.assertEqual(\n  3778\t            operation.describe(),\n  3779\t            \"Create constraint covering_pink_constraint_add on model Pony\",\n  3780\t        )\n  3781\t        # Add constraint.\n  3782\t        new_state = project_state.clone()\n  3783\t        operation.state_forwards(app_label, new_state)\n  3784\t        self.assertEqual(\n  3785\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 1\n  3786\t        )\n  3787\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3788\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3789\t        with connection.schema_editor() as editor, CaptureQueriesContext(\n  3790\t            connection\n  3791\t        ) as ctx:\n  3792\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3793\t        Pony.objects.create(pink=1, weight=4.0)\n  3794\t        if connection.features.supports_covering_indexes:\n  3795\t            with self.assertRaises(IntegrityError):\n  3796\t                Pony.objects.create(pink=1, weight=4.0)\n  3797\t        else:\n  3798\t            self.assertEqual(len(ctx), 0)\n  3799\t            Pony.objects.create(pink=1, weight=4.0)\n  3800\t        # Reversal.\n  3801\t        with connection.schema_editor() as editor:\n  3802\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3803\t        # Constraint doesn't work.\n  3804\t        Pony.objects.create(pink=1, weight=4.0)\n  3805\t        # Deconstruction.\n  3806\t        definition = operation.deconstruct()\n  3807\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3808\t        self.assertEqual(definition[1], [])\n  3809\t        self.assertEqual(\n  3810\t            definition[2],\n  3811\t            {\"model_name\": \"Pony\", \"constraint\": covering_unique_constraint},\n  3812\t        )\n  3813\t\n  3814\t    def test_remove_covering_unique_constraint(self):\n  3815\t        app_label = \"test_removecovering_uc\"\n  3816\t        covering_unique_constraint = models.UniqueConstraint(\n  3817\t            fields=[\"pink\"],\n  3818\t            name=\"covering_pink_constraint_rm\",\n  3819\t            include=[\"weight\"],\n  3820\t        )\n  3821\t        project_state = self.set_up_test_model(\n  3822\t            app_label, constraints=[covering_unique_constraint]\n  3823\t        )\n  3824\t        operation = migrations.RemoveConstraint(\"Pony\", covering_unique_constraint.name)\n  3825\t        self.assertEqual(\n  3826\t            operation.describe(),\n  3827\t            \"Remove constraint covering_pink_constraint_rm from model Pony\",\n  3828\t        )\n  3829\t        # Remove constraint.\n  3830\t        new_state = project_state.clone()\n  3831\t        operation.state_forwards(app_label, new_state)\n  3832\t        self.assertEqual(\n  3833\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 0\n  3834\t        )\n  3835\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3836\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3837\t        with connection.schema_editor() as editor, CaptureQueriesContext(\n  3838\t            connection\n  3839\t        ) as ctx:\n  3840\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3841\t        # Constraint doesn't work.\n  3842\t        Pony.objects.create(pink=1, weight=4.0)\n  3843\t        Pony.objects.create(pink=1, weight=4.0).delete()\n  3844\t        if not connection.features.supports_covering_indexes:\n  3845\t            self.assertEqual(len(ctx), 0)\n  3846\t        # Reversal.\n  3847\t        with connection.schema_editor() as editor:\n  3848\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3849\t        if connection.features.supports_covering_indexes:\n  3850\t            with self.assertRaises(IntegrityError):\n  3851\t                Pony.objects.create(pink=1, weight=4.0)\n  3852\t        else:\n  3853\t            Pony.objects.create(pink=1, weight=4.0)\n  3854\t        # Deconstruction.\n  3855\t        definition = operation.deconstruct()\n  3856\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3857\t        self.assertEqual(definition[1], [])\n  3858\t        self.assertEqual(\n  3859\t            definition[2],\n  3860\t            {\n  3861\t                \"model_name\": \"Pony\",\n  3862\t                \"name\": \"covering_pink_constraint_rm\",\n  3863\t            },\n  3864\t        )\n  3865\t\n  3866\t    def test_alter_field_with_func_unique_constraint(self):\n  3867\t        app_label = \"test_alfuncuc\"\n  3868\t        constraint_name = f\"{app_label}_pony_uq\"\n  3869\t        table_name = f\"{app_label}_pony\"\n  3870\t        project_state = self.set_up_test_model(\n  3871\t            app_label,\n  3872\t            constraints=[\n  3873\t                models.UniqueConstraint(\"pink\", \"weight\", name=constraint_name)\n  3874\t            ],\n  3875\t        )\n  3876\t        operation = migrations.AlterField(\n  3877\t            \"Pony\", \"pink\", models.IntegerField(null=True)\n  3878\t        )\n  3879\t        new_state = project_state.clone()\n  3880\t        operation.state_forwards(app_label, new_state)\n  3881\t        with connection.schema_editor() as editor:\n  3882\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3883\t        if connection.features.supports_expression_indexes:\n  3884\t            self.assertIndexNameExists(table_name, constraint_name)\n  3885\t        with connection.schema_editor() as editor:\n  3886\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3887\t        if connection.features.supports_expression_indexes:\n  3888\t            self.assertIndexNameExists(table_name, constraint_name)\n  3889\t\n  3890\t    def test_add_func_unique_constraint(self):\n  3891\t        app_label = \"test_adfuncuc\"\n  3892\t        constraint_name = f\"{app_label}_pony_abs_uq\"\n  3893\t        table_name = f\"{app_label}_pony\"\n  3894\t        project_state = self.set_up_test_model(app_label)\n  3895\t        constraint = models.UniqueConstraint(Abs(\"weight\"), name=constraint_name)\n  3896\t        operation = migrations.AddConstraint(\"Pony\", constraint)\n  3897\t        self.assertEqual(\n  3898\t            operation.describe(),\n  3899\t            \"Create constraint test_adfuncuc_pony_abs_uq on model Pony\",\n  3900\t        )\n  3901\t        self.assertEqual(\n  3902\t            operation.migration_name_fragment,\n  3903\t            \"pony_test_adfuncuc_pony_abs_uq\",\n  3904\t        )\n  3905\t        new_state = project_state.clone()\n  3906\t        operation.state_forwards(app_label, new_state)\n  3907\t        self.assertEqual(\n  3908\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 1\n  3909\t        )\n  3910\t        self.assertIndexNameNotExists(table_name, constraint_name)\n  3911\t        # Add constraint.\n  3912\t        with connection.schema_editor() as editor:\n  3913\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3914\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3915\t        Pony.objects.create(weight=4.0)\n  3916\t        if connection.features.supports_expression_indexes:\n  3917\t            self.assertIndexNameExists(table_name, constraint_name)\n  3918\t            with self.assertRaises(IntegrityError):\n  3919\t                Pony.objects.create(weight=-4.0)\n  3920\t        else:\n  3921\t            self.assertIndexNameNotExists(table_name, constraint_name)\n  3922\t            Pony.objects.create(weight=-4.0)\n  3923\t        # Reversal.\n  3924\t        with connection.schema_editor() as editor:\n  3925\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3926\t        self.assertIndexNameNotExists(table_name, constraint_name)\n  3927\t        # Constraint doesn't work.\n  3928\t        Pony.objects.create(weight=-4.0)\n  3929\t        # Deconstruction.\n  3930\t        definition = operation.deconstruct()\n  3931\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3932\t        self.assertEqual(definition[1], [])\n  3933\t        self.assertEqual(\n  3934\t            definition[2],\n  3935\t            {\"model_name\": \"Pony\", \"constraint\": constraint},\n  3936\t        )\n  3937\t\n  3938\t    def test_remove_func_unique_constraint(self):\n  3939\t        app_label = \"test_rmfuncuc\"\n  3940\t        constraint_name = f\"{app_label}_pony_abs_uq\"\n  3941\t        table_name = f\"{app_label}_pony\"\n  3942\t        project_state = self.set_up_test_model(\n  3943\t            app_label,\n  3944\t            constraints=[\n  3945\t                models.UniqueConstraint(Abs(\"weight\"), name=constraint_name),\n  3946\t            ],\n  3947\t        )\n  3948\t        self.assertTableExists(table_name)\n  3949\t        if connection.features.supports_expression_indexes:\n  3950\t            self.assertIndexNameExists(table_name, constraint_name)\n  3951\t        operation = migrations.RemoveConstraint(\"Pony\", constraint_name)\n  3952\t        self.assertEqual(\n  3953\t            operation.describe(),\n  3954\t            \"Remove constraint test_rmfuncuc_pony_abs_uq from model Pony\",\n  3955\t        )\n  3956\t        self.assertEqual(\n  3957\t            operation.migration_name_fragment,\n  3958\t            \"remove_pony_test_rmfuncuc_pony_abs_uq\",\n  3959\t        )\n  3960\t        new_state = project_state.clone()\n  3961\t        operation.state_forwards(app_label, new_state)\n  3962\t        self.assertEqual(\n  3963\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 0\n  3964\t        )\n  3965\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3966\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3967\t        # Remove constraint.\n  3968\t        with connection.schema_editor() as editor:\n  3969\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3970\t        self.assertIndexNameNotExists(table_name, constraint_name)\n  3971\t        # Constraint doesn't work.\n  3972\t        Pony.objects.create(pink=1, weight=4.0)\n  3973\t        Pony.objects.create(pink=1, weight=-4.0).delete()\n  3974\t        # Reversal.\n  3975\t        with connection.schema_editor() as editor:\n  3976\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3977\t        if connection.features.supports_expression_indexes:\n  3978\t            self.assertIndexNameExists(table_name, constraint_name)\n  3979\t            with self.assertRaises(IntegrityError):\n  3980\t                Pony.objects.create(weight=-4.0)\n  3981\t        else:\n  3982\t            self.assertIndexNameNotExists(table_name, constraint_name)\n  3983\t            Pony.objects.create(weight=-4.0)\n  3984\t        # Deconstruction.\n  3985\t        definition = operation.deconstruct()\n  3986\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3987\t        self.assertEqual(definition[1], [])\n  3988\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"name\": constraint_name})\n  3989\t\n  3990\t    def test_alter_model_options(self):\n  3991\t        \"\"\"\n  3992\t        Tests the AlterModelOptions operation.\n  3993\t        \"\"\"\n  3994\t        project_state = self.set_up_test_model(\"test_almoop\")\n  3995\t        # Test the state alteration (no DB alteration to test)\n  3996\t        operation = migrations.AlterModelOptions(\n  3997\t            \"Pony\", {\"permissions\": [(\"can_groom\", \"Can groom\")]}\n  3998\t        )\n  3999\t        self.assertEqual(operation.describe(), \"Change Meta options on Pony\")\n  4000\t        self.assertEqual(operation.migration_name_fragment, \"alter_pony_options\")\n  4001\t        new_state = project_state.clone()\n  4002\t        operation.state_forwards(\"test_almoop\", new_state)\n  4003\t        self.assertEqual(\n  4004\t            len(\n  4005\t                project_state.models[\"test_almoop\", \"pony\"].options.get(\n  4006\t                    \"permissions\", []\n  4007\t                )\n  4008\t            ),\n  4009\t            0,\n  4010\t        )\n  4011\t        self.assertEqual(\n  4012\t            len(new_state.models[\"test_almoop\", \"pony\"].options.get(\"permissions\", [])),\n  4013\t            1,\n  4014\t        )\n  4015\t        self.assertEqual(\n  4016\t            new_state.models[\"test_almoop\", \"pony\"].options[\"permissions\"][0][0],\n  4017\t            \"can_groom\",\n  4018\t        )\n  4019\t        # And deconstruction\n  4020\t        definition = operation.deconstruct()\n  4021\t        self.assertEqual(definition[0], \"AlterModelOptions\")\n  4022\t        self.assertEqual(definition[1], [])\n  4023\t        self.assertEqual(\n  4024\t            definition[2],\n  4025\t            {\"name\": \"Pony\", \"options\": {\"permissions\": [(\"can_groom\", \"Can groom\")]}},\n  4026\t        )\n  4027\t\n  4028\t    def test_alter_model_options_emptying(self):\n  4029\t        \"\"\"\n  4030\t        The AlterModelOptions operation removes keys from the dict (#23121)\n  4031\t        \"\"\"\n  4032\t        project_state = self.set_up_test_model(\"test_almoop\", options=True)\n  4033\t        # Test the state alteration (no DB alteration to test)\n  4034\t        operation = migrations.AlterModelOptions(\"Pony\", {})\n  4035\t        self.assertEqual(operation.describe(), \"Change Meta options on Pony\")\n  4036\t        new_state = project_state.clone()\n  4037\t        operation.state_forwards(\"test_almoop\", new_state)\n  4038\t        self.assertEqual(\n  4039\t            len(\n  4040\t                project_state.models[\"test_almoop\", \"pony\"].options.get(\n  4041\t                    \"permissions\", []\n  4042\t                )\n  4043\t            ),\n  4044\t            1,\n  4045\t        )\n  4046\t        self.assertEqual(\n  4047\t            len(new_state.models[\"test_almoop\", \"pony\"].options.get(\"permissions\", [])),\n  4048\t            0,\n  4049\t        )\n  4050\t        # And deconstruction\n  4051\t        definition = operation.deconstruct()\n  4052\t        self.assertEqual(definition[0], \"AlterModelOptions\")\n  4053\t        self.assertEqual(definition[1], [])\n  4054\t        self.assertEqual(definition[2], {\"name\": \"Pony\", \"options\": {}})\n  4055\t\n  4056\t    def test_alter_order_with_respect_to(self):\n  4057\t        \"\"\"\n  4058\t        Tests the AlterOrderWithRespectTo operation.\n  4059\t        \"\"\"\n  4060\t        project_state = self.set_up_test_model(\"test_alorwrtto\", related_model=True)\n  4061\t        # Test the state alteration\n  4062\t        operation = migrations.AlterOrderWithRespectTo(\"Rider\", \"pony\")\n  4063\t        self.assertEqual(\n  4064\t            operation.describe(), \"Set order_with_respect_to on Rider to pony\"\n  4065\t        )\n  4066\t        self.assertEqual(\n  4067\t            operation.migration_name_fragment,\n  4068\t            \"alter_rider_order_with_respect_to\",\n  4069\t        )\n  4070\t        new_state = project_state.clone()\n  4071\t        operation.state_forwards(\"test_alorwrtto\", new_state)\n  4072\t        self.assertIsNone(\n  4073\t            project_state.models[\"test_alorwrtto\", \"rider\"].options.get(\n  4074\t                \"order_with_respect_to\", None\n  4075\t            )\n  4076\t        )\n  4077\t        self.assertEqual(\n  4078\t            new_state.models[\"test_alorwrtto\", \"rider\"].options.get(\n  4079\t                \"order_with_respect_to\", None\n  4080\t            ),\n  4081\t            \"pony\",\n  4082\t        )\n  4083\t        # Make sure there's no matching index\n  4084\t        self.assertColumnNotExists(\"test_alorwrtto_rider\", \"_order\")\n  4085\t        # Create some rows before alteration\n  4086\t        rendered_state = project_state.apps\n  4087\t        pony = rendered_state.get_model(\"test_alorwrtto\", \"Pony\").objects.create(\n  4088\t            weight=50\n  4089\t        )\n  4090\t        rider1 = rendered_state.get_model(\"test_alorwrtto\", \"Rider\").objects.create(\n  4091\t            pony=pony\n  4092\t        )\n  4093\t        rider1.friend = rider1\n  4094\t        rider1.save()\n  4095\t        rider2 = rendered_state.get_model(\"test_alorwrtto\", \"Rider\").objects.create(\n  4096\t            pony=pony\n  4097\t        )\n  4098\t        rider2.friend = rider2\n  4099\t        rider2.save()\n  4100\t        # Test the database alteration\n  4101\t        with connection.schema_editor() as editor:\n  4102\t            operation.database_forwards(\n  4103\t                \"test_alorwrtto\", editor, project_state, new_state\n  4104\t            )\n  4105\t        self.assertColumnExists(\"test_alorwrtto_rider\", \"_order\")\n  4106\t        # Check for correct value in rows\n  4107\t        updated_riders = new_state.apps.get_model(\n  4108\t            \"test_alorwrtto\", \"Rider\"\n  4109\t        ).objects.all()\n  4110\t        self.assertEqual(updated_riders[0]._order, 0)\n  4111\t        self.assertEqual(updated_riders[1]._order, 0)\n  4112\t        # And test reversal\n  4113\t        with connection.schema_editor() as editor:\n  4114\t            operation.database_backwards(\n  4115\t                \"test_alorwrtto\", editor, new_state, project_state\n  4116\t            )\n  4117\t        self.assertColumnNotExists(\"test_alorwrtto_rider\", \"_order\")\n  4118\t        # And deconstruction\n  4119\t        definition = operation.deconstruct()\n  4120\t        self.assertEqual(definition[0], \"AlterOrderWithRespectTo\")\n  4121\t        self.assertEqual(definition[1], [])\n  4122\t        self.assertEqual(\n  4123\t            definition[2], {\"name\": \"Rider\", \"order_with_respect_to\": \"pony\"}\n  4124\t        )\n  4125\t\n  4126\t    def test_alter_model_managers(self):\n  4127\t        \"\"\"\n  4128\t        The managers on a model are set.\n  4129\t        \"\"\"\n  4130\t        project_state = self.set_up_test_model(\"test_almoma\")\n  4131\t        # Test the state alteration\n  4132\t        operation = migrations.AlterModelManagers(\n  4133\t            \"Pony\",\n  4134\t            managers=[\n  4135\t                (\"food_qs\", FoodQuerySet.as_manager()),\n  4136\t                (\"food_mgr\", FoodManager(\"a\", \"b\")),\n  4137\t                (\"food_mgr_kwargs\", FoodManager(\"x\", \"y\", 3, 4)),\n  4138\t            ],\n  4139\t        )\n  4140\t        self.assertEqual(operation.describe(), \"Change managers on Pony\")\n  4141\t        self.assertEqual(operation.migration_name_fragment, \"alter_pony_managers\")\n  4142\t        managers = project_state.models[\"test_almoma\", \"pony\"].managers\n  4143\t        self.assertEqual(managers, [])\n  4144\t\n  4145\t        new_state = project_state.clone()\n  4146\t        operation.state_forwards(\"test_almoma\", new_state)\n  4147\t        self.assertIn((\"test_almoma\", \"pony\"), new_state.models)\n  4148\t        managers = new_state.models[\"test_almoma\", \"pony\"].managers\n  4149\t        self.assertEqual(managers[0][0], \"food_qs\")\n  4150\t        self.assertIsInstance(managers[0][1], models.Manager)\n  4151\t        self.assertEqual(managers[1][0], \"food_mgr\")\n  4152\t        self.assertIsInstance(managers[1][1], FoodManager)\n  4153\t        self.assertEqual(managers[1][1].args, (\"a\", \"b\", 1, 2))\n  4154\t        self.assertEqual(managers[2][0], \"food_mgr_kwargs\")\n  4155\t        self.assertIsInstance(managers[2][1], FoodManager)\n  4156\t        self.assertEqual(managers[2][1].args, (\"x\", \"y\", 3, 4))\n  4157\t        rendered_state = new_state.apps\n  4158\t        model = rendered_state.get_model(\"test_almoma\", \"pony\")\n  4159\t        self.assertIsInstance(model.food_qs, models.Manager)\n  4160\t        self.assertIsInstance(model.food_mgr, FoodManager)\n  4161\t        self.assertIsInstance(model.food_mgr_kwargs, FoodManager)\n  4162\t\n  4163\t    def test_alter_model_managers_emptying(self):\n  4164\t        \"\"\"\n  4165\t        The managers on a model are set.\n  4166\t        \"\"\"\n  4167\t        project_state = self.set_up_test_model(\"test_almomae\", manager_model=True)\n  4168\t        # Test the state alteration\n  4169\t        operation = migrations.AlterModelManagers(\"Food\", managers=[])\n  4170\t        self.assertEqual(operation.describe(), \"Change managers on Food\")\n  4171\t        self.assertIn((\"test_almomae\", \"food\"), project_state.models)\n  4172\t        managers = project_state.models[\"test_almomae\", \"food\"].managers\n  4173\t        self.assertEqual(managers[0][0], \"food_qs\")\n  4174\t        self.assertIsInstance(managers[0][1], models.Manager)\n  4175\t        self.assertEqual(managers[1][0], \"food_mgr\")\n  4176\t        self.assertIsInstance(managers[1][1], FoodManager)\n  4177\t        self.assertEqual(managers[1][1].args, (\"a\", \"b\", 1, 2))\n  4178\t        self.assertEqual(managers[2][0], \"food_mgr_kwargs\")\n  4179\t        self.assertIsInstance(managers[2][1], FoodManager)\n  4180\t        self.assertEqual(managers[2][1].args, (\"x\", \"y\", 3, 4))\n  4181\t\n  4182\t        new_state = project_state.clone()\n  4183\t        operation.state_forwards(\"test_almomae\", new_state)\n  4184\t        managers = new_state.models[\"test_almomae\", \"food\"].managers\n  4185\t        self.assertEqual(managers, [])\n  4186\t\n  4187\t    def test_alter_fk(self):\n  4188\t        \"\"\"\n  4189\t        Creating and then altering an FK works correctly\n  4190\t        and deals with the pending SQL (#23091)\n  4191\t        \"\"\"\n  4192\t        project_state = self.set_up_test_model(\"test_alfk\")\n  4193\t        # Test adding and then altering the FK in one go\n  4194\t        create_operation = migrations.CreateModel(\n  4195\t            name=\"Rider\",\n  4196\t            fields=[\n  4197\t                (\"id\", models.AutoField(primary_key=True)),\n  4198\t                (\"pony\", models.ForeignKey(\"Pony\", models.CASCADE)),\n  4199\t            ],\n  4200\t        )\n  4201\t        create_state = project_state.clone()\n  4202\t        create_operation.state_forwards(\"test_alfk\", create_state)\n  4203\t        alter_operation = migrations.AlterField(\n  4204\t            model_name=\"Rider\",\n  4205\t            name=\"pony\",\n  4206\t            field=models.ForeignKey(\"Pony\", models.CASCADE, editable=False),\n  4207\t        )\n  4208\t        alter_state = create_state.clone()\n  4209\t        alter_operation.state_forwards(\"test_alfk\", alter_state)\n  4210\t        with connection.schema_editor() as editor:\n  4211\t            create_operation.database_forwards(\n  4212\t                \"test_alfk\", editor, project_state, create_state\n  4213\t            )\n  4214\t            alter_operation.database_forwards(\n  4215\t                \"test_alfk\", editor, create_state, alter_state\n  4216\t            )\n  4217\t\n  4218\t    def test_alter_fk_non_fk(self):\n  4219\t        \"\"\"\n  4220\t        Altering an FK to a non-FK works (#23244)\n  4221\t        \"\"\"\n  4222\t        # Test the state alteration\n  4223\t        operation = migrations.AlterField(\n  4224\t            model_name=\"Rider\",\n  4225\t            name=\"pony\",\n  4226\t            field=models.FloatField(),\n  4227\t        )\n  4228\t        project_state, new_state = self.make_test_state(\n  4229\t            \"test_afknfk\", operation, related_model=True\n  4230\t        )\n  4231\t        # Test the database alteration\n  4232\t        self.assertColumnExists(\"test_afknfk_rider\", \"pony_id\")\n  4233\t        self.assertColumnNotExists(\"test_afknfk_rider\", \"pony\")\n  4234\t        with connection.schema_editor() as editor:\n  4235\t            operation.database_forwards(\"test_afknfk\", editor, project_state, new_state)\n  4236\t        self.assertColumnExists(\"test_afknfk_rider\", \"pony\")\n  4237\t        self.assertColumnNotExists(\"test_afknfk_rider\", \"pony_id\")\n  4238\t        # And test reversal\n  4239\t        with connection.schema_editor() as editor:\n  4240\t            operation.database_backwards(\n  4241\t                \"test_afknfk\", editor, new_state, project_state\n  4242\t            )\n  4243\t        self.assertColumnExists(\"test_afknfk_rider\", \"pony_id\")\n  4244\t        self.assertColumnNotExists(\"test_afknfk_rider\", \"pony\")\n  4245\t\n  4246\t    def test_run_sql(self):\n  4247\t        \"\"\"\n  4248\t        Tests the RunSQL operation.\n  4249\t        \"\"\"\n  4250\t        project_state = self.set_up_test_model(\"test_runsql\")\n  4251\t        # Create the operation\n  4252\t        operation = migrations.RunSQL(\n  4253\t            # Use a multi-line string with a comment to test splitting on\n  4254\t            # SQLite and MySQL respectively.\n  4255\t            \"CREATE TABLE i_love_ponies (id int, special_thing varchar(15));\\n\"\n  4256\t            \"INSERT INTO i_love_ponies (id, special_thing) \"\n  4257\t            \"VALUES (1, 'i love ponies'); -- this is magic!\\n\"\n  4258\t            \"INSERT INTO i_love_ponies (id, special_thing) \"\n  4259\t            \"VALUES (2, 'i love django');\\n\"\n  4260\t            \"UPDATE i_love_ponies SET special_thing = 'Ponies' \"\n  4261\t            \"WHERE special_thing LIKE '%%ponies';\"\n  4262\t            \"UPDATE i_love_ponies SET special_thing = 'Django' \"\n  4263\t            \"WHERE special_thing LIKE '%django';\",\n  4264\t            # Run delete queries to test for parameter substitution failure\n  4265\t            # reported in #23426\n  4266\t            \"DELETE FROM i_love_ponies WHERE special_thing LIKE '%Django%';\"\n  4267\t            \"DELETE FROM i_love_ponies WHERE special_thing LIKE '%%Ponies%%';\"\n  4268\t            \"DROP TABLE i_love_ponies\",\n  4269\t            state_operations=[\n  4270\t                migrations.CreateModel(\n  4271\t                    \"SomethingElse\", [(\"id\", models.AutoField(primary_key=True))]\n  4272\t                )\n  4273\t            ],\n  4274\t        )\n  4275\t        self.assertEqual(operation.describe(), \"Raw SQL operation\")\n  4276\t        # Test the state alteration\n  4277\t        new_state = project_state.clone()\n  4278\t        operation.state_forwards(\"test_runsql\", new_state)\n  4279\t        self.assertEqual(\n  4280\t            len(new_state.models[\"test_runsql\", \"somethingelse\"].fields), 1\n  4281\t        )\n  4282\t        # Make sure there's no table\n  4283\t        self.assertTableNotExists(\"i_love_ponies\")\n  4284\t        # Test SQL collection\n  4285\t        with connection.schema_editor(collect_sql=True) as editor:\n  4286\t            operation.database_forwards(\"test_runsql\", editor, project_state, new_state)\n  4287\t            self.assertIn(\"LIKE '%%ponies';\", \"\\n\".join(editor.collected_sql))\n  4288\t            operation.database_backwards(\n  4289\t                \"test_runsql\", editor, project_state, new_state\n  4290\t            )\n  4291\t            self.assertIn(\"LIKE '%%Ponies%%';\", \"\\n\".join(editor.collected_sql))\n  4292\t        # Test the database alteration\n  4293\t        with connection.schema_editor() as editor:\n  4294\t            operation.database_forwards(\"test_runsql\", editor, project_state, new_state)\n  4295\t        self.assertTableExists(\"i_love_ponies\")\n  4296\t        # Make sure all the SQL was processed\n  4297\t        with connection.cursor() as cursor:\n  4298\t            cursor.execute(\"SELECT COUNT(*) FROM i_love_ponies\")\n  4299\t            self.assertEqual(cursor.fetchall()[0][0], 2)\n  4300\t            cursor.execute(\n  4301\t                \"SELECT COUNT(*) FROM i_love_ponies WHERE special_thing = 'Django'\"\n  4302\t            )\n  4303\t            self.assertEqual(cursor.fetchall()[0][0], 1)\n  4304\t            cursor.execute(\n  4305\t                \"SELECT COUNT(*) FROM i_love_ponies WHERE special_thing = 'Ponies'\"\n  4306\t            )\n  4307\t            self.assertEqual(cursor.fetchall()[0][0], 1)\n  4308\t        # And test reversal\n  4309\t        self.assertTrue(operation.reversible)\n  4310\t        with connection.schema_editor() as editor:\n  4311\t            operation.database_backwards(\n  4312\t                \"test_runsql\", editor, new_state, project_state\n  4313\t            )\n  4314\t        self.assertTableNotExists(\"i_love_ponies\")\n  4315\t        # And deconstruction\n  4316\t        definition = operation.deconstruct()\n  4317\t        self.assertEqual(definition[0], \"RunSQL\")\n  4318\t        self.assertEqual(definition[1], [])\n  4319\t        self.assertEqual(\n  4320\t            sorted(definition[2]), [\"reverse_sql\", \"sql\", \"state_operations\"]\n  4321\t        )\n  4322\t        # And elidable reduction\n  4323\t        self.assertIs(False, operation.reduce(operation, []))\n  4324\t        elidable_operation = migrations.RunSQL(\"SELECT 1 FROM void;\", elidable=True)\n  4325\t        self.assertEqual(elidable_operation.reduce(operation, []), [operation])\n  4326\t\n  4327\t    def test_run_sql_params(self):\n  4328\t        \"\"\"\n  4329\t        #23426 - RunSQL should accept parameters.\n  4330\t        \"\"\"\n  4331\t        project_state = self.set_up_test_model(\"test_runsql\")\n  4332\t        # Create the operation\n  4333\t        operation = migrations.RunSQL(\n  4334\t            [\"CREATE TABLE i_love_ponies (id int, special_thing varchar(15));\"],\n  4335\t            [\"DROP TABLE i_love_ponies\"],\n  4336\t        )\n  4337\t        param_operation = migrations.RunSQL(\n  4338\t            # forwards\n  4339\t            (\n  4340\t                \"INSERT INTO i_love_ponies (id, special_thing) VALUES (1, 'Django');\",\n  4341\t                [\n  4342\t                    \"INSERT INTO i_love_ponies (id, special_thing) VALUES (2, %s);\",\n  4343\t                    [\"Ponies\"],\n  4344\t                ],\n  4345\t                (\n  4346\t                    \"INSERT INTO i_love_ponies (id, special_thing) VALUES (%s, %s);\",\n  4347\t                    (\n  4348\t                        3,\n  4349\t                        \"Python\",\n  4350\t                    ),\n  4351\t                ),\n  4352\t            ),\n  4353\t            # backwards\n  4354\t            [\n  4355\t                \"DELETE FROM i_love_ponies WHERE special_thing = 'Django';\",\n  4356\t                [\"DELETE FROM i_love_ponies WHERE special_thing = 'Ponies';\", None],\n  4357\t                (\n  4358\t                    \"DELETE FROM i_love_ponies WHERE id = %s OR special_thing = %s;\",\n  4359\t                    [3, \"Python\"],\n  4360\t                ),\n  4361\t            ],\n  4362\t        )\n  4363\t\n  4364\t        # Make sure there's no table\n  4365\t        self.assertTableNotExists(\"i_love_ponies\")\n  4366\t        new_state = project_state.clone()\n  4367\t        # Test the database alteration\n  4368\t        with connection.schema_editor() as editor:\n  4369\t            operation.database_forwards(\"test_runsql\", editor, project_state, new_state)\n  4370\t\n  4371\t        # Test parameter passing\n  4372\t        with connection.schema_editor() as editor:\n  4373\t            param_operation.database_forwards(\n  4374\t                \"test_runsql\", editor, project_state, new_state\n  4375\t            )\n  4376\t        # Make sure all the SQL was processed\n  4377\t        with connection.cursor() as cursor:\n  4378\t            cursor.execute(\"SELECT COUNT(*) FROM i_love_ponies\")\n  4379\t            self.assertEqual(cursor.fetchall()[0][0], 3)\n  4380\t\n  4381\t        with connection.schema_editor() as editor:\n  4382\t            param_operation.database_backwards(\n  4383\t                \"test_runsql\", editor, new_state, project_state\n  4384\t            )\n  4385\t        with connection.cursor() as cursor:\n  4386\t            cursor.execute(\"SELECT COUNT(*) FROM i_love_ponies\")\n  4387\t            self.assertEqual(cursor.fetchall()[0][0], 0)\n  4388\t\n  4389\t        # And test reversal\n  4390\t        with connection.schema_editor() as editor:\n  4391\t            operation.database_backwards(\n  4392\t                \"test_runsql\", editor, new_state, project_state\n  4393\t            )\n  4394\t        self.assertTableNotExists(\"i_love_ponies\")\n  4395\t\n  4396\t    def test_run_sql_params_invalid(self):\n  4397\t        \"\"\"\n  4398\t        #23426 - RunSQL should fail when a list of statements with an incorrect\n  4399\t        number of tuples is given.\n  4400\t        \"\"\"\n  4401\t        project_state = self.set_up_test_model(\"test_runsql\")\n  4402\t        new_state = project_state.clone()\n  4403\t        operation = migrations.RunSQL(\n  4404\t            # forwards\n  4405\t            [[\"INSERT INTO foo (bar) VALUES ('buz');\"]],\n  4406\t            # backwards\n  4407\t            ((\"DELETE FROM foo WHERE bar = 'buz';\", \"invalid\", \"parameter count\"),),\n  4408\t        )\n  4409\t\n  4410\t        with connection.schema_editor() as editor:\n  4411\t            with self.assertRaisesMessage(ValueError, \"Expected a 2-tuple but got 1\"):\n  4412\t                operation.database_forwards(\n  4413\t                    \"test_runsql\", editor, project_state, new_state\n  4414\t                )\n  4415\t\n  4416\t        with connection.schema_editor() as editor:\n  4417\t            with self.assertRaisesMessage(ValueError, \"Expected a 2-tuple but got 3\"):\n  4418\t                operation.database_backwards(\n  4419\t                    \"test_runsql\", editor, new_state, project_state\n  4420\t                )\n  4421\t\n  4422\t    def test_run_sql_noop(self):\n  4423\t        \"\"\"\n  4424\t        #24098 - Tests no-op RunSQL operations.\n  4425\t        \"\"\"\n  4426\t        operation = migrations.RunSQL(migrations.RunSQL.noop, migrations.RunSQL.noop)\n  4427\t        with connection.schema_editor() as editor:\n  4428\t            operation.database_forwards(\"test_runsql\", editor, None, None)\n  4429\t            operation.database_backwards(\"test_runsql\", editor, None, None)\n  4430\t\n  4431\t    def test_run_sql_add_missing_semicolon_on_collect_sql(self):\n  4432\t        project_state = self.set_up_test_model(\"test_runsql\")\n  4433\t        new_state = project_state.clone()\n  4434\t        tests = [\n  4435\t            \"INSERT INTO test_runsql_pony (pink, weight) VALUES (1, 1);\\n\",\n  4436\t            \"INSERT INTO test_runsql_pony (pink, weight) VALUES (1, 1)\\n\",\n  4437\t        ]\n  4438\t        for sql in tests:\n  4439\t            with self.subTest(sql=sql):\n  4440\t                operation = migrations.RunSQL(sql, migrations.RunPython.noop)\n  4441\t                with connection.schema_editor(collect_sql=True) as editor:\n  4442\t                    operation.database_forwards(\n  4443\t                        \"test_runsql\", editor, project_state, new_state\n  4444\t                    )\n  4445\t                    collected_sql = \"\\n\".join(editor.collected_sql)\n  4446\t                    self.assertEqual(collected_sql.count(\";\"), 1)\n  4447\t\n  4448\t    def test_run_python(self):\n  4449\t        \"\"\"\n  4450\t        Tests the RunPython operation\n  4451\t        \"\"\"\n  4452\t\n  4453\t        project_state = self.set_up_test_model(\"test_runpython\", mti_model=True)\n  4454\t\n  4455\t        # Create the operation\n  4456\t        def inner_method(models, schema_editor):\n  4457\t            Pony = models.get_model(\"test_runpython\", \"Pony\")\n  4458\t            Pony.objects.create(pink=1, weight=3.55)\n  4459\t            Pony.objects.create(weight=5)\n  4460\t\n  4461\t        def inner_method_reverse(models, schema_editor):\n  4462\t            Pony = models.get_model(\"test_runpython\", \"Pony\")\n  4463\t            Pony.objects.filter(pink=1, weight=3.55).delete()\n  4464\t            Pony.objects.filter(weight=5).delete()\n  4465\t\n  4466\t        operation = migrations.RunPython(\n  4467\t            inner_method, reverse_code=inner_method_reverse\n  4468\t        )\n  4469\t        self.assertEqual(operation.describe(), \"Raw Python operation\")\n  4470\t        # Test the state alteration does nothing\n  4471\t        new_state = project_state.clone()\n  4472\t        operation.state_forwards(\"test_runpython\", new_state)\n  4473\t        self.assertEqual(new_state, project_state)\n  4474\t        # Test the database alteration\n  4475\t        self.assertEqual(\n  4476\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 0\n  4477\t        )\n  4478\t        with connection.schema_editor() as editor:\n  4479\t            operation.database_forwards(\n  4480\t                \"test_runpython\", editor, project_state, new_state\n  4481\t            )\n  4482\t        self.assertEqual(\n  4483\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 2\n  4484\t        )\n  4485\t        # Now test reversal\n  4486\t        self.assertTrue(operation.reversible)\n  4487\t        with connection.schema_editor() as editor:\n  4488\t            operation.database_backwards(\n  4489\t                \"test_runpython\", editor, project_state, new_state\n  4490\t            )\n  4491\t        self.assertEqual(\n  4492\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 0\n  4493\t        )\n  4494\t        # Now test we can't use a string\n  4495\t        with self.assertRaisesMessage(\n  4496\t            ValueError, \"RunPython must be supplied with a callable\"\n  4497\t        ):\n  4498\t            migrations.RunPython(\"print 'ahahaha'\")\n  4499\t        # And deconstruction\n  4500\t        definition = operation.deconstruct()\n  4501\t        self.assertEqual(definition[0], \"RunPython\")\n  4502\t        self.assertEqual(definition[1], [])\n  4503\t        self.assertEqual(sorted(definition[2]), [\"code\", \"reverse_code\"])\n  4504\t\n  4505\t        # Also test reversal fails, with an operation identical to above but\n  4506\t        # without reverse_code set.\n  4507\t        no_reverse_operation = migrations.RunPython(inner_method)\n  4508\t        self.assertFalse(no_reverse_operation.reversible)\n  4509\t        with connection.schema_editor() as editor:\n  4510\t            no_reverse_operation.database_forwards(\n  4511\t                \"test_runpython\", editor, project_state, new_state\n  4512\t            )\n  4513\t            with self.assertRaises(NotImplementedError):\n  4514\t                no_reverse_operation.database_backwards(\n  4515\t                    \"test_runpython\", editor, new_state, project_state\n  4516\t                )\n  4517\t        self.assertEqual(\n  4518\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 2\n  4519\t        )\n  4520\t\n  4521\t        def create_ponies(models, schema_editor):\n  4522\t            Pony = models.get_model(\"test_runpython\", \"Pony\")\n  4523\t            pony1 = Pony.objects.create(pink=1, weight=3.55)\n  4524\t            self.assertIsNot(pony1.pk, None)\n  4525\t            pony2 = Pony.objects.create(weight=5)\n  4526\t            self.assertIsNot(pony2.pk, None)\n  4527\t            self.assertNotEqual(pony1.pk, pony2.pk)\n  4528\t\n  4529\t        operation = migrations.RunPython(create_ponies)\n  4530\t        with connection.schema_editor() as editor:\n  4531\t            operation.database_forwards(\n  4532\t                \"test_runpython\", editor, project_state, new_state\n  4533\t            )\n  4534\t        self.assertEqual(\n  4535\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 4\n  4536\t        )\n  4537\t        # And deconstruction\n  4538\t        definition = operation.deconstruct()\n  4539\t        self.assertEqual(definition[0], \"RunPython\")\n  4540\t        self.assertEqual(definition[1], [])\n  4541\t        self.assertEqual(sorted(definition[2]), [\"code\"])\n  4542\t\n  4543\t        def create_shetlandponies(models, schema_editor):\n  4544\t            ShetlandPony = models.get_model(\"test_runpython\", \"ShetlandPony\")\n  4545\t            pony1 = ShetlandPony.objects.create(weight=4.0)\n  4546\t            self.assertIsNot(pony1.pk, None)\n  4547\t            pony2 = ShetlandPony.objects.create(weight=5.0)\n  4548\t            self.assertIsNot(pony2.pk, None)\n  4549\t            self.assertNotEqual(pony1.pk, pony2.pk)\n  4550\t\n  4551\t        operation = migrations.RunPython(create_shetlandponies)\n  4552\t        with connection.schema_editor() as editor:\n  4553\t            operation.database_forwards(\n  4554\t                \"test_runpython\", editor, project_state, new_state\n  4555\t            )\n  4556\t        self.assertEqual(\n  4557\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 6\n  4558\t        )\n  4559\t        self.assertEqual(\n  4560\t            project_state.apps.get_model(\n  4561\t                \"test_runpython\", \"ShetlandPony\"\n  4562\t            ).objects.count(),\n  4563\t            2,\n  4564\t        )\n  4565\t        # And elidable reduction\n  4566\t        self.assertIs(False, operation.reduce(operation, []))\n  4567\t        elidable_operation = migrations.RunPython(inner_method, elidable=True)\n  4568\t        self.assertEqual(elidable_operation.reduce(operation, []), [operation])\n  4569\t\n  4570\t    def test_run_python_atomic(self):\n  4571\t        \"\"\"\n  4572\t        Tests the RunPython operation correctly handles the \"atomic\" keyword\n  4573\t        \"\"\"\n  4574\t        project_state = self.set_up_test_model(\"test_runpythonatomic\", mti_model=True)\n  4575\t\n  4576\t        def inner_method(models, schema_editor):\n  4577\t            Pony = models.get_model(\"test_runpythonatomic\", \"Pony\")\n  4578\t            Pony.objects.create(pink=1, weight=3.55)\n  4579\t            raise ValueError(\"Adrian hates ponies.\")\n  4580\t\n  4581\t        # Verify atomicity when applying.\n  4582\t        atomic_migration = Migration(\"test\", \"test_runpythonatomic\")\n  4583\t        atomic_migration.operations = [\n  4584\t            migrations.RunPython(inner_method, reverse_code=inner_method)\n  4585\t        ]\n  4586\t        non_atomic_migration = Migration(\"test\", \"test_runpythonatomic\")\n  4587\t        non_atomic_migration.operations = [\n  4588\t            migrations.RunPython(inner_method, reverse_code=inner_method, atomic=False)\n  4589\t        ]\n  4590\t        # If we're a fully-transactional database, both versions should rollback\n  4591\t        if connection.features.can_rollback_ddl:\n  4592\t            self.assertEqual(\n  4593\t                project_state.apps.get_model(\n  4594\t                    \"test_runpythonatomic\", \"Pony\"\n  4595\t                ).objects.count(),\n  4596\t                0,\n  4597\t            )\n  4598\t            with self.assertRaises(ValueError):\n  4599\t                with connection.schema_editor() as editor:\n  4600\t                    atomic_migration.apply(project_state, editor)\n  4601\t            self.assertEqual(\n  4602\t                project_state.apps.get_model(\n  4603\t                    \"test_runpythonatomic\", \"Pony\"\n  4604\t                ).objects.count(),\n  4605\t                0,\n  4606\t            )\n  4607\t            with self.assertRaises(ValueError):\n  4608\t                with connection.schema_editor() as editor:\n  4609\t                    non_atomic_migration.apply(project_state, editor)\n  4610\t            self.assertEqual(\n  4611\t                project_state.apps.get_model(\n  4612\t                    \"test_runpythonatomic\", \"Pony\"\n  4613\t                ).objects.count(),\n  4614\t                0,\n  4615\t            )\n  4616\t        # Otherwise, the non-atomic operation should leave a row there\n  4617\t        else:\n  4618\t            self.assertEqual(\n  4619\t                project_state.apps.get_model(\n  4620\t                    \"test_runpythonatomic\", \"Pony\"\n  4621\t                ).objects.count(),\n  4622\t                0,\n  4623\t            )\n  4624\t            with self.assertRaises(ValueError):\n  4625\t                with connection.schema_editor() as editor:\n  4626\t                    atomic_migration.apply(project_state, editor)\n  4627\t            self.assertEqual(\n  4628\t                project_state.apps.get_model(\n  4629\t                    \"test_runpythonatomic\", \"Pony\"\n  4630\t                ).objects.count(),\n  4631\t                0,\n  4632\t            )\n  4633\t            with self.assertRaises(ValueError):\n  4634\t                with connection.schema_editor() as editor:\n  4635\t                    non_atomic_migration.apply(project_state, editor)\n  4636\t            self.assertEqual(\n  4637\t                project_state.apps.get_model(\n  4638\t                    \"test_runpythonatomic\", \"Pony\"\n  4639\t                ).objects.count(),\n  4640\t                1,\n  4641\t            )\n  4642\t        # Reset object count to zero and verify atomicity when unapplying.\n  4643\t        project_state.apps.get_model(\n  4644\t            \"test_runpythonatomic\", \"Pony\"\n  4645\t        ).objects.all().delete()\n  4646\t        # On a fully-transactional database, both versions rollback.\n  4647\t        if connection.features.can_rollback_ddl:\n  4648\t            self.assertEqual(\n  4649\t                project_state.apps.get_model(\n  4650\t                    \"test_runpythonatomic\", \"Pony\"\n  4651\t                ).objects.count(),\n  4652\t                0,\n  4653\t            )\n  4654\t            with self.assertRaises(ValueError):\n  4655\t                with connection.schema_editor() as editor:\n  4656\t                    atomic_migration.unapply(project_state, editor)\n  4657\t            self.assertEqual(\n  4658\t                project_state.apps.get_model(\n  4659\t                    \"test_runpythonatomic\", \"Pony\"\n  4660\t                ).objects.count(),\n  4661\t                0,\n  4662\t            )\n  4663\t            with self.assertRaises(ValueError):\n  4664\t                with connection.schema_editor() as editor:\n  4665\t                    non_atomic_migration.unapply(project_state, editor)\n  4666\t            self.assertEqual(\n  4667\t                project_state.apps.get_model(\n  4668\t                    \"test_runpythonatomic\", \"Pony\"\n  4669\t                ).objects.count(),\n  4670\t                0,\n  4671\t            )\n  4672\t        # Otherwise, the non-atomic operation leaves a row there.\n  4673\t        else:\n  4674\t            self.assertEqual(\n  4675\t                project_state.apps.get_model(\n  4676\t                    \"test_runpythonatomic\", \"Pony\"\n  4677\t                ).objects.count(),\n  4678\t                0,\n  4679\t            )\n  4680\t            with self.assertRaises(ValueError):\n  4681\t                with connection.schema_editor() as editor:\n  4682\t                    atomic_migration.unapply(project_state, editor)\n  4683\t            self.assertEqual(\n  4684\t                project_state.apps.get_model(\n  4685\t                    \"test_runpythonatomic\", \"Pony\"\n  4686\t                ).objects.count(),\n  4687\t                0,\n  4688\t            )\n  4689\t            with self.assertRaises(ValueError):\n  4690\t                with connection.schema_editor() as editor:\n  4691\t                    non_atomic_migration.unapply(project_state, editor)\n  4692\t            self.assertEqual(\n  4693\t                project_state.apps.get_model(\n  4694\t                    \"test_runpythonatomic\", \"Pony\"\n  4695\t                ).objects.count(),\n  4696\t                1,\n  4697\t            )\n  4698\t        # Verify deconstruction.\n  4699\t        definition = non_atomic_migration.operations[0].deconstruct()\n  4700\t        self.assertEqual(definition[0], \"RunPython\")\n  4701\t        self.assertEqual(definition[1], [])\n  4702\t        self.assertEqual(sorted(definition[2]), [\"atomic\", \"code\", \"reverse_code\"])\n  4703\t\n  4704\t    def test_run_python_related_assignment(self):\n  4705\t        \"\"\"\n  4706\t        #24282 - Model changes to a FK reverse side update the model\n  4707\t        on the FK side as well.\n  4708\t        \"\"\"\n  4709\t\n  4710\t        def inner_method(models, schema_editor):\n  4711\t            Author = models.get_model(\"test_authors\", \"Author\")\n  4712\t            Book = models.get_model(\"test_books\", \"Book\")\n  4713\t            author = Author.objects.create(name=\"Hemingway\")\n  4714\t            Book.objects.create(title=\"Old Man and The Sea\", author=author)\n  4715\t\n  4716\t        create_author = migrations.CreateModel(\n  4717\t            \"Author\",\n  4718\t            [\n  4719\t                (\"id\", models.AutoField(primary_key=True)),\n  4720\t                (\"name\", models.CharField(max_length=100)),\n  4721\t            ],\n  4722\t            options={},\n  4723\t        )\n  4724\t        create_book = migrations.CreateModel(\n  4725\t            \"Book\",\n  4726\t            [\n  4727\t                (\"id\", models.AutoField(primary_key=True)),\n  4728\t                (\"title\", models.CharField(max_length=100)),\n  4729\t                (\"author\", models.ForeignKey(\"test_authors.Author\", models.CASCADE)),\n  4730\t            ],\n  4731\t            options={},\n  4732\t        )\n  4733\t        add_hometown = migrations.AddField(\n  4734\t            \"Author\",\n  4735\t            \"hometown\",\n  4736\t            models.CharField(max_length=100),\n  4737\t        )\n  4738\t        create_old_man = migrations.RunPython(inner_method, inner_method)\n  4739\t\n  4740\t        project_state = ProjectState()\n  4741\t        new_state = project_state.clone()\n  4742\t        with connection.schema_editor() as editor:\n  4743\t            create_author.state_forwards(\"test_authors\", new_state)\n  4744\t            create_author.database_forwards(\n  4745\t                \"test_authors\", editor, project_state, new_state\n  4746\t            )\n  4747\t        project_state = new_state\n  4748\t        new_state = new_state.clone()\n  4749\t        with connection.schema_editor() as editor:\n  4750\t            create_book.state_forwards(\"test_books\", new_state)\n  4751\t            create_book.database_forwards(\n  4752\t                \"test_books\", editor, project_state, new_state\n  4753\t            )\n  4754\t        project_state = new_state\n  4755\t        new_state = new_state.clone()\n  4756\t        with connection.schema_editor() as editor:\n  4757\t            add_hometown.state_forwards(\"test_authors\", new_state)\n  4758\t            add_hometown.database_forwards(\n  4759\t                \"test_authors\", editor, project_state, new_state\n  4760\t            )\n  4761\t        project_state = new_state\n  4762\t        new_state = new_state.clone()\n  4763\t        with connection.schema_editor() as editor:\n  4764\t            create_old_man.state_forwards(\"test_books\", new_state)\n  4765\t            create_old_man.database_forwards(\n  4766\t                \"test_books\", editor, project_state, new_state\n  4767\t            )\n  4768\t\n  4769\t    def test_model_with_bigautofield(self):\n  4770\t        \"\"\"\n  4771\t        A model with BigAutoField can be created.\n  4772\t        \"\"\"\n  4773\t\n  4774\t        def create_data(models, schema_editor):\n  4775\t            Author = models.get_model(\"test_author\", \"Author\")\n  4776\t            Book = models.get_model(\"test_book\", \"Book\")\n  4777\t            author1 = Author.objects.create(name=\"Hemingway\")\n  4778\t            Book.objects.create(title=\"Old Man and The Sea\", author=author1)\n  4779\t            Book.objects.create(id=2**33, title=\"A farewell to arms\", author=author1)\n  4780\t\n  4781\t            author2 = Author.objects.create(id=2**33, name=\"Remarque\")\n  4782\t            Book.objects.create(title=\"All quiet on the western front\", author=author2)\n  4783\t            Book.objects.create(title=\"Arc de Triomphe\", author=author2)\n  4784\t\n  4785\t        create_author = migrations.CreateModel(\n  4786\t            \"Author\",\n  4787\t            [\n  4788\t                (\"id\", models.BigAutoField(primary_key=True)),\n  4789\t                (\"name\", models.CharField(max_length=100)),\n  4790\t            ],\n  4791\t            options={},\n  4792\t        )\n  4793\t        create_book = migrations.CreateModel(\n  4794\t            \"Book\",\n  4795\t            [\n  4796\t                (\"id\", models.BigAutoField(primary_key=True)),\n  4797\t                (\"title\", models.CharField(max_length=100)),\n  4798\t                (\n  4799\t                    \"author\",\n  4800\t                    models.ForeignKey(\n  4801\t                        to=\"test_author.Author\", on_delete=models.CASCADE\n  4802\t                    ),\n  4803\t                ),\n  4804\t            ],\n  4805\t            options={},\n  4806\t        )\n  4807\t        fill_data = migrations.RunPython(create_data)\n  4808\t\n  4809\t        project_state = ProjectState()\n  4810\t        new_state = project_state.clone()\n  4811\t        with connection.schema_editor() as editor:\n  4812\t            create_author.state_forwards(\"test_author\", new_state)\n  4813\t            create_author.database_forwards(\n  4814\t                \"test_author\", editor, project_state, new_state\n  4815\t            )\n  4816\t\n  4817\t        project_state = new_state\n  4818\t        new_state = new_state.clone()\n  4819\t        with connection.schema_editor() as editor:\n  4820\t            create_book.state_forwards(\"test_book\", new_state)\n  4821\t            create_book.database_forwards(\"test_book\", editor, project_state, new_state)\n  4822\t\n  4823\t        project_state = new_state\n  4824\t        new_state = new_state.clone()\n  4825\t        with connection.schema_editor() as editor:\n  4826\t            fill_data.state_forwards(\"fill_data\", new_state)\n  4827\t            fill_data.database_forwards(\"fill_data\", editor, project_state, new_state)\n  4828\t\n  4829\t    def _test_autofield_foreignfield_growth(\n  4830\t        self, source_field, target_field, target_value\n  4831\t    ):\n  4832\t        \"\"\"\n  4833\t        A field may be migrated in the following ways:\n  4834\t\n  4835\t        - AutoField to BigAutoField\n  4836\t        - SmallAutoField to AutoField\n  4837\t        - SmallAutoField to BigAutoField\n  4838\t        \"\"\"\n  4839\t\n  4840\t        def create_initial_data(models, schema_editor):\n  4841\t            Article = models.get_model(\"test_article\", \"Article\")\n  4842\t            Blog = models.get_model(\"test_blog\", \"Blog\")\n  4843\t            blog = Blog.objects.create(name=\"web development done right\")\n  4844\t            Article.objects.create(name=\"Frameworks\", blog=blog)\n  4845\t            Article.objects.create(name=\"Programming Languages\", blog=blog)\n  4846\t\n  4847\t        def create_big_data(models, schema_editor):\n  4848\t            Article = models.get_model(\"test_article\", \"Article\")\n  4849\t            Blog = models.get_model(\"test_blog\", \"Blog\")\n  4850\t            blog2 = Blog.objects.create(name=\"Frameworks\", id=target_value)\n  4851\t            Article.objects.create(name=\"Django\", blog=blog2)\n  4852\t            Article.objects.create(id=target_value, name=\"Django2\", blog=blog2)\n  4853\t\n  4854\t        create_blog = migrations.CreateModel(\n  4855\t            \"Blog\",\n  4856\t            [\n  4857\t                (\"id\", source_field(primary_key=True)),\n  4858\t                (\"name\", models.CharField(max_length=100)),\n  4859\t            ],\n  4860\t            options={},\n  4861\t        )\n  4862\t        create_article = migrations.CreateModel(\n  4863\t            \"Article\",\n  4864\t            [\n  4865\t                (\"id\", source_field(primary_key=True)),\n  4866\t                (\n  4867\t                    \"blog\",\n  4868\t                    models.ForeignKey(to=\"test_blog.Blog\", on_delete=models.CASCADE),\n  4869\t                ),\n  4870\t                (\"name\", models.CharField(max_length=100)),\n  4871\t                (\"data\", models.TextField(default=\"\")),\n  4872\t            ],\n  4873\t            options={},\n  4874\t        )\n  4875\t        fill_initial_data = migrations.RunPython(\n  4876\t            create_initial_data, create_initial_data\n  4877\t        )\n  4878\t        fill_big_data = migrations.RunPython(create_big_data, create_big_data)\n  4879\t\n  4880\t        grow_article_id = migrations.AlterField(\n  4881\t            \"Article\", \"id\", target_field(primary_key=True)\n  4882\t        )\n  4883\t        grow_blog_id = migrations.AlterField(\n  4884\t            \"Blog\", \"id\", target_field(primary_key=True)\n  4885\t        )\n  4886\t\n  4887\t        project_state = ProjectState()\n  4888\t        new_state = project_state.clone()\n  4889\t        with connection.schema_editor() as editor:\n  4890\t            create_blog.state_forwards(\"test_blog\", new_state)\n  4891\t            create_blog.database_forwards(\"test_blog\", editor, project_state, new_state)\n  4892\t\n  4893\t        project_state = new_state\n  4894\t        new_state = new_state.clone()\n  4895\t        with connection.schema_editor() as editor:\n  4896\t            create_article.state_forwards(\"test_article\", new_state)\n  4897\t            create_article.database_forwards(\n  4898\t                \"test_article\", editor, project_state, new_state\n  4899\t            )\n  4900\t\n  4901\t        project_state = new_state\n  4902\t        new_state = new_state.clone()\n  4903\t        with connection.schema_editor() as editor:\n  4904\t            fill_initial_data.state_forwards(\"fill_initial_data\", new_state)\n  4905\t            fill_initial_data.database_forwards(\n  4906\t                \"fill_initial_data\", editor, project_state, new_state\n  4907\t            )\n  4908\t\n  4909\t        project_state = new_state\n  4910\t        new_state = new_state.clone()\n  4911\t        with connection.schema_editor() as editor:\n  4912\t            grow_article_id.state_forwards(\"test_article\", new_state)\n  4913\t            grow_article_id.database_forwards(\n  4914\t                \"test_article\", editor, project_state, new_state\n  4915\t            )\n  4916\t\n  4917\t        state = new_state.clone()\n  4918\t        article = state.apps.get_model(\"test_article.Article\")\n  4919\t        self.assertIsInstance(article._meta.pk, target_field)\n  4920\t\n  4921\t        project_state = new_state\n  4922\t        new_state = new_state.clone()\n  4923\t        with connection.schema_editor() as editor:\n  4924\t            grow_blog_id.state_forwards(\"test_blog\", new_state)\n  4925\t            grow_blog_id.database_forwards(\n  4926\t                \"test_blog\", editor, project_state, new_state\n  4927\t            )\n  4928\t\n  4929\t        state = new_state.clone()\n  4930\t        blog = state.apps.get_model(\"test_blog.Blog\")\n  4931\t        self.assertIsInstance(blog._meta.pk, target_field)\n  4932\t\n  4933\t        project_state = new_state\n  4934\t        new_state = new_state.clone()\n  4935\t        with connection.schema_editor() as editor:\n  4936\t            fill_big_data.state_forwards(\"fill_big_data\", new_state)\n  4937\t            fill_big_data.database_forwards(\n  4938\t                \"fill_big_data\", editor, project_state, new_state\n  4939\t            )\n  4940\t\n  4941\t    def test_autofield__bigautofield_foreignfield_growth(self):\n  4942\t        \"\"\"A field may be migrated from AutoField to BigAutoField.\"\"\"\n  4943\t        self._test_autofield_foreignfield_growth(\n  4944\t            models.AutoField,\n  4945\t            models.BigAutoField,\n  4946\t            2**33,\n  4947\t        )\n  4948\t\n  4949\t    def test_smallfield_autofield_foreignfield_growth(self):\n  4950\t        \"\"\"A field may be migrated from SmallAutoField to AutoField.\"\"\"\n  4951\t        self._test_autofield_foreignfield_growth(\n  4952\t            models.SmallAutoField,\n  4953\t            models.AutoField,\n  4954\t            2**22,\n  4955\t        )\n  4956\t\n  4957\t    def test_smallfield_bigautofield_foreignfield_growth(self):\n  4958\t        \"\"\"A field may be migrated from SmallAutoField to BigAutoField.\"\"\"\n  4959\t        self._test_autofield_foreignfield_growth(\n  4960\t            models.SmallAutoField,\n  4961\t            models.BigAutoField,\n  4962\t            2**33,\n  4963\t        )\n  4964\t\n  4965\t    def test_run_python_noop(self):\n  4966\t        \"\"\"\n  4967\t        #24098 - Tests no-op RunPython operations.\n  4968\t        \"\"\"\n  4969\t        project_state = ProjectState()\n  4970\t        new_state = project_state.clone()\n  4971\t        operation = migrations.RunPython(\n  4972\t            migrations.RunPython.noop, migrations.RunPython.noop\n  4973\t        )\n  4974\t        with connection.schema_editor() as editor:\n  4975\t            operation.database_forwards(\n  4976\t                \"test_runpython\", editor, project_state, new_state\n  4977\t            )\n  4978\t            operation.database_backwards(\n  4979\t                \"test_runpython\", editor, new_state, project_state\n  4980\t            )\n  4981\t\n  4982\t    def test_separate_database_and_state(self):\n  4983\t        \"\"\"\n  4984\t        Tests the SeparateDatabaseAndState operation.\n  4985\t        \"\"\"\n  4986\t        project_state = self.set_up_test_model(\"test_separatedatabaseandstate\")\n  4987\t        # Create the operation\n  4988\t        database_operation = migrations.RunSQL(\n  4989\t            \"CREATE TABLE i_love_ponies (id int, special_thing int);\",\n  4990\t            \"DROP TABLE i_love_ponies;\",\n  4991\t        )\n  4992\t        state_operation = migrations.CreateModel(\n  4993\t            \"SomethingElse\", [(\"id\", models.AutoField(primary_key=True))]\n  4994\t        )\n  4995\t        operation = migrations.SeparateDatabaseAndState(\n  4996\t            state_operations=[state_operation], database_operations=[database_operation]\n  4997\t        )\n  4998\t        self.assertEqual(\n  4999\t            operation.describe(), \"Custom state/database change combination\"\n  5000\t        )\n  5001\t        # Test the state alteration\n  5002\t        new_state = project_state.clone()\n  5003\t        operation.state_forwards(\"test_separatedatabaseandstate\", new_state)\n  5004\t        self.assertEqual(\n  5005\t            len(\n  5006\t                new_state.models[\n  5007\t                    \"test_separatedatabaseandstate\", \"somethingelse\"\n  5008\t                ].fields\n  5009\t            ),\n  5010\t            1,\n  5011\t        )\n  5012\t        # Make sure there's no table\n  5013\t        self.assertTableNotExists(\"i_love_ponies\")\n  5014\t        # Test the database alteration\n  5015\t        with connection.schema_editor() as editor:\n  5016\t            operation.database_forwards(\n  5017\t                \"test_separatedatabaseandstate\", editor, project_state, new_state\n  5018\t            )\n  5019\t        self.assertTableExists(\"i_love_ponies\")\n  5020\t        # And test reversal\n  5021\t        self.assertTrue(operation.reversible)\n  5022\t        with connection.schema_editor() as editor:\n  5023\t            operation.database_backwards(\n  5024\t                \"test_separatedatabaseandstate\", editor, new_state, project_state\n  5025\t            )\n  5026\t        self.assertTableNotExists(\"i_love_ponies\")\n  5027\t        # And deconstruction\n  5028\t        definition = operation.deconstruct()\n  5029\t        self.assertEqual(definition[0], \"SeparateDatabaseAndState\")\n  5030\t        self.assertEqual(definition[1], [])\n  5031\t        self.assertEqual(\n  5032\t            sorted(definition[2]), [\"database_operations\", \"state_operations\"]\n  5033\t        )\n  5034\t\n  5035\t    def test_separate_database_and_state2(self):\n  5036\t        \"\"\"\n  5037\t        A complex SeparateDatabaseAndState operation: Multiple operations both\n  5038\t        for state and database. Verify the state dependencies within each list\n  5039\t        and that state ops don't affect the database.\n  5040\t        \"\"\"\n  5041\t        app_label = \"test_separatedatabaseandstate2\"\n  5042\t        project_state = self.set_up_test_model(app_label)\n  5043\t        # Create the operation\n  5044\t        database_operations = [\n  5045\t            migrations.CreateModel(\n  5046\t                \"ILovePonies\",\n  5047\t                [(\"id\", models.AutoField(primary_key=True))],\n  5048\t                options={\"db_table\": \"iloveponies\"},\n  5049\t            ),\n  5050\t            migrations.CreateModel(\n  5051\t                \"ILoveMorePonies\",\n  5052\t                # We use IntegerField and not AutoField because\n  5053\t                # the model is going to be deleted immediately\n  5054\t                # and with an AutoField this fails on Oracle\n  5055\t                [(\"id\", models.IntegerField(primary_key=True))],\n  5056\t                options={\"db_table\": \"ilovemoreponies\"},\n  5057\t            ),\n  5058\t            migrations.DeleteModel(\"ILoveMorePonies\"),\n  5059\t            migrations.CreateModel(\n  5060\t                \"ILoveEvenMorePonies\",\n  5061\t                [(\"id\", models.AutoField(primary_key=True))],\n  5062\t                options={\"db_table\": \"iloveevenmoreponies\"},\n  5063\t            ),\n  5064\t        ]\n  5065\t        state_operations = [\n  5066\t            migrations.CreateModel(\n  5067\t                \"SomethingElse\",\n  5068\t                [(\"id\", models.AutoField(primary_key=True))],\n  5069\t                options={\"db_table\": \"somethingelse\"},\n  5070\t            ),\n  5071\t            migrations.DeleteModel(\"SomethingElse\"),\n  5072\t            migrations.CreateModel(\n  5073\t                \"SomethingCompletelyDifferent\",\n  5074\t                [(\"id\", models.AutoField(primary_key=True))],\n  5075\t                options={\"db_table\": \"somethingcompletelydifferent\"},\n  5076\t            ),\n  5077\t        ]\n  5078\t        operation = migrations.SeparateDatabaseAndState(\n  5079\t            state_operations=state_operations,\n  5080\t            database_operations=database_operations,\n  5081\t        )\n  5082\t        # Test the state alteration\n  5083\t        new_state = project_state.clone()\n  5084\t        operation.state_forwards(app_label, new_state)\n  5085\t\n  5086\t        def assertModelsAndTables(after_db):\n  5087\t            # Tables and models exist, or don't, as they should:\n  5088\t            self.assertNotIn((app_label, \"somethingelse\"), new_state.models)\n  5089\t            self.assertEqual(\n  5090\t                len(new_state.models[app_label, \"somethingcompletelydifferent\"].fields),\n  5091\t                1,\n  5092\t            )\n  5093\t            self.assertNotIn((app_label, \"iloveponiesonies\"), new_state.models)\n  5094\t            self.assertNotIn((app_label, \"ilovemoreponies\"), new_state.models)\n  5095\t            self.assertNotIn((app_label, \"iloveevenmoreponies\"), new_state.models)\n  5096\t            self.assertTableNotExists(\"somethingelse\")\n  5097\t            self.assertTableNotExists(\"somethingcompletelydifferent\")\n  5098\t            self.assertTableNotExists(\"ilovemoreponies\")\n  5099\t            if after_db:\n  5100\t                self.assertTableExists(\"iloveponies\")\n  5101\t                self.assertTableExists(\"iloveevenmoreponies\")\n  5102\t            else:\n  5103\t                self.assertTableNotExists(\"iloveponies\")\n  5104\t                self.assertTableNotExists(\"iloveevenmoreponies\")\n  5105\t\n  5106\t        assertModelsAndTables(after_db=False)\n  5107\t        # Test the database alteration\n  5108\t        with connection.schema_editor() as editor:\n  5109\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  5110\t        assertModelsAndTables(after_db=True)\n  5111\t        # And test reversal\n  5112\t        self.assertTrue(operation.reversible)\n  5113\t        with connection.schema_editor() as editor:\n  5114\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  5115\t        assertModelsAndTables(after_db=False)\n  5116\t\n  5117\t\n  5118\tclass SwappableOperationTests(OperationTestBase):\n  5119\t    \"\"\"\n  5120\t    Key operations ignore swappable models\n  5121\t    (we don't want to replicate all of them here, as the functionality\n  5122\t    is in a common base class anyway)\n  5123\t    \"\"\"\n  5124\t\n  5125\t    available_apps = [\"migrations\"]\n  5126\t\n  5127\t    @override_settings(TEST_SWAP_MODEL=\"migrations.SomeFakeModel\")\n  5128\t    def test_create_ignore_swapped(self):\n  5129\t        \"\"\"\n  5130\t        The CreateTable operation ignores swapped models.\n  5131\t        \"\"\"\n  5132\t        operation = migrations.CreateModel(\n  5133\t            \"Pony\",\n  5134\t            [\n  5135\t                (\"id\", models.AutoField(primary_key=True)),\n  5136\t                (\"pink\", models.IntegerField(default=1)),\n  5137\t            ],\n  5138\t            options={\n  5139\t                \"swappable\": \"TEST_SWAP_MODEL\",\n  5140\t            },\n  5141\t        )\n  5142\t        # Test the state alteration (it should still be there!)\n  5143\t        project_state = ProjectState()\n  5144\t        new_state = project_state.clone()\n  5145\t        operation.state_forwards(\"test_crigsw\", new_state)\n  5146\t        self.assertEqual(new_state.models[\"test_crigsw\", \"pony\"].name, \"Pony\")\n  5147\t        self.assertEqual(len(new_state.models[\"test_crigsw\", \"pony\"].fields), 2)\n  5148\t        # Test the database alteration\n  5149\t        self.assertTableNotExists(\"test_crigsw_pony\")\n  5150\t        with connection.schema_editor() as editor:\n  5151\t            operation.database_forwards(\"test_crigsw\", editor, project_state, new_state)\n  5152\t        self.assertTableNotExists(\"test_crigsw_pony\")\n  5153\t        # And test reversal\n  5154\t        with connection.schema_editor() as editor:\n  5155\t            operation.database_backwards(\n  5156\t                \"test_crigsw\", editor, new_state, project_state\n  5157\t            )\n  5158\t        self.assertTableNotExists(\"test_crigsw_pony\")\n  5159\t\n  5160\t    @override_settings(TEST_SWAP_MODEL=\"migrations.SomeFakeModel\")\n  5161\t    def test_delete_ignore_swapped(self):\n  5162\t        \"\"\"\n  5163\t        Tests the DeleteModel operation ignores swapped models.\n  5164\t        \"\"\"\n  5165\t        operation = migrations.DeleteModel(\"Pony\")\n  5166\t        project_state, new_state = self.make_test_state(\"test_dligsw\", operation)\n  5167\t        # Test the database alteration\n  5168\t        self.assertTableNotExists(\"test_dligsw_pony\")\n  5169\t        with connection.schema_editor() as editor:\n  5170\t            operation.database_forwards(\"test_dligsw\", editor, project_state, new_state)\n  5171\t        self.assertTableNotExists(\"test_dligsw_pony\")\n  5172\t        # And test reversal\n  5173\t        with connection.schema_editor() as editor:\n  5174\t            operation.database_backwards(\n  5175\t                \"test_dligsw\", editor, new_state, project_state\n  5176\t            )\n  5177\t        self.assertTableNotExists(\"test_dligsw_pony\")\n  5178\t\n  5179\t    @override_settings(TEST_SWAP_MODEL=\"migrations.SomeFakeModel\")\n  5180\t    def test_add_field_ignore_swapped(self):\n  5181\t        \"\"\"\n  5182\t        Tests the AddField operation.\n  5183\t        \"\"\"\n  5184\t        # Test the state alteration\n  5185\t        operation = migrations.AddField(\n  5186\t            \"Pony\",\n  5187\t            \"height\",\n  5188\t            models.FloatField(null=True, default=5),\n  5189\t        )\n  5190\t        project_state, new_state = self.make_test_state(\"test_adfligsw\", operation)\n  5191\t        # Test the database alteration\n  5192\t        self.assertTableNotExists(\"test_adfligsw_pony\")\n  5193\t        with connection.schema_editor() as editor:\n  5194\t            operation.database_forwards(\n  5195\t                \"test_adfligsw\", editor, project_state, new_state\n  5196\t            )\n  5197\t        self.assertTableNotExists(\"test_adfligsw_pony\")\n  5198\t        # And test reversal\n  5199\t        with connection.schema_editor() as editor:\n  5200\t            operation.database_backwards(\n  5201\t                \"test_adfligsw\", editor, new_state, project_state\n  5202\t            )\n  5203\t        self.assertTableNotExists(\"test_adfligsw_pony\")\n  5204\t\n  5205\t    @override_settings(TEST_SWAP_MODEL=\"migrations.SomeFakeModel\")\n  5206\t    def test_indexes_ignore_swapped(self):\n  5207\t        \"\"\"\n  5208\t        Add/RemoveIndex operations ignore swapped models.\n  5209\t        \"\"\"\n  5210\t        operation = migrations.AddIndex(\n  5211\t            \"Pony\", models.Index(fields=[\"pink\"], name=\"my_name_idx\")\n  5212\t        )\n  5213\t        project_state, new_state = self.make_test_state(\"test_adinigsw\", operation)\n  5214\t        with connection.schema_editor() as editor:\n  5215\t            # No database queries should be run for swapped models\n  5216\t            operation.database_forwards(\n  5217\t                \"test_adinigsw\", editor, project_state, new_state\n  5218\t            )\n  5219\t            operation.database_backwards(\n  5220\t                \"test_adinigsw\", editor, new_state, project_state\n  5221\t            )\n  5222\t\n  5223\t        operation = migrations.RemoveIndex(\n  5224\t            \"Pony\", models.Index(fields=[\"pink\"], name=\"my_name_idx\")\n  5225\t        )\n  5226\t        project_state, new_state = self.make_test_state(\"test_rminigsw\", operation)\n  5227\t        with connection.schema_editor() as editor:\n  5228\t            operation.database_forwards(\n  5229\t                \"test_rminigsw\", editor, project_state, new_state\n  5230\t            )\n  5231\t            operation.database_backwards(\n  5232\t                \"test_rminigsw\", editor, new_state, project_state\n  5233\t            )\n  5234\t\n  5235\t\n  5236\tclass TestCreateModel(SimpleTestCase):\n  5237\t    def test_references_model_mixin(self):\n  5238\t        migrations.CreateModel(\n  5239\t            \"name\",\n  5240\t            fields=[],\n  5241\t            bases=(Mixin, models.Model),\n  5242\t        ).references_model(\"other_model\", \"migrations\")\n  5243\t\n  5244\t\n  5245\tclass FieldOperationTests(SimpleTestCase):\n  5246\t    def test_references_model(self):\n  5247\t        operation = FieldOperation(\n  5248\t            \"MoDel\", \"field\", models.ForeignKey(\"Other\", models.CASCADE)\n  5249\t        )\n  5250\t        # Model name match.\n  5251\t        self.assertIs(operation.references_model(\"mOdEl\", \"migrations\"), True)\n  5252\t        # Referenced field.\n  5253\t        self.assertIs(operation.references_model(\"oTher\", \"migrations\"), True)\n  5254\t        # Doesn't reference.\n  5255\t        self.assertIs(operation.references_model(\"Whatever\", \"migrations\"), False)\n  5256\t\n  5257\t    def test_references_field_by_name(self):\n  5258\t        operation = FieldOperation(\"MoDel\", \"field\", models.BooleanField(default=False))\n  5259\t        self.assertIs(operation.references_field(\"model\", \"field\", \"migrations\"), True)\n  5260\t\n  5261\t    def test_references_field_by_remote_field_model(self):\n  5262\t        operation = FieldOperation(\n  5263\t            \"Model\", \"field\", models.ForeignKey(\"Other\", models.CASCADE)\n  5264\t        )\n  5265\t        self.assertIs(\n  5266\t            operation.references_field(\"Other\", \"whatever\", \"migrations\"), True\n  5267\t        )\n  5268\t        self.assertIs(\n  5269\t            operation.references_field(\"Missing\", \"whatever\", \"migrations\"), False\n  5270\t        )\n  5271\t\n  5272\t    def test_references_field_by_from_fields(self):\n  5273\t        operation = FieldOperation(\n  5274\t            \"Model\",\n  5275\t            \"field\",\n  5276\t            models.fields.related.ForeignObject(\n  5277\t                \"Other\", models.CASCADE, [\"from\"], [\"to\"]\n  5278\t            ),\n  5279\t        )\n  5280\t        self.assertIs(operation.references_field(\"Model\", \"from\", \"migrations\"), True)\n  5281\t        self.assertIs(operation.references_field(\"Model\", \"to\", \"migrations\"), False)\n  5282\t        self.assertIs(operation.references_field(\"Other\", \"from\", \"migrations\"), False)\n  5283\t        self.assertIs(operation.references_field(\"Model\", \"to\", \"migrations\"), False)\n  5284\t\n  5285\t    def test_references_field_by_to_fields(self):\n  5286\t        operation = FieldOperation(\n  5287\t            \"Model\",\n  5288\t            \"field\",\n  5289\t            models.ForeignKey(\"Other\", models.CASCADE, to_field=\"field\"),\n  5290\t        )\n  5291\t        self.assertIs(operation.references_field(\"Other\", \"field\", \"migrations\"), True)\n  5292\t        self.assertIs(\n  5293\t            operation.references_field(\"Other\", \"whatever\", \"migrations\"), False\n  5294\t        )\n  5295\t        self.assertIs(\n  5296\t            operation.references_field(\"Missing\", \"whatever\", \"migrations\"), False\n  5297\t        )\n  5298\t\n  5299\t    def test_references_field_by_through(self):\n  5300\t        operation = FieldOperation(\n  5301\t            \"Model\", \"field\", models.ManyToManyField(\"Other\", through=\"Through\")\n  5302\t        )\n  5303\t        self.assertIs(\n  5304\t            operation.references_field(\"Other\", \"whatever\", \"migrations\"), True\n  5305\t        )\n  5306\t        self.assertIs(\n  5307\t            operation.references_field(\"Through\", \"whatever\", \"migrations\"), True\n  5308\t        )\n  5309\t        self.assertIs(\n  5310\t            operation.references_field(\"Missing\", \"whatever\", \"migrations\"), False\n  5311\t        )\n  5312\t\n  5313\t    def test_reference_field_by_through_fields(self):\n  5314\t        operation = FieldOperation(\n  5315\t            \"Model\",\n  5316\t            \"field\",\n  5317\t            models.ManyToManyField(\n  5318\t                \"Other\", through=\"Through\", through_fields=(\"first\", \"second\")\n  5319\t            ),\n  5320\t        )\n  5321\t        self.assertIs(\n  5322\t            operation.references_field(\"Other\", \"whatever\", \"migrations\"), True\n  5323\t        )\n  5324\t        self.assertIs(\n  5325\t            operation.references_field(\"Through\", \"whatever\", \"migrations\"), False\n  5326\t        )\n  5327\t        self.assertIs(\n  5328\t            operation.references_field(\"Through\", \"first\", \"migrations\"), True\n  5329\t        )\n  5330\t        self.assertIs(\n  5331\t            operation.references_field(\"Through\", \"second\", \"migrations\"), True\n  5332\t        )\n  5333\t\n```\n\n</observation>",
                  "type": "tool_result"
                }
              ]
            },
            {
              "role": "assistant",
              "content": [
                {
                  "type": "text",
                  "text": "<thoughts>\n1. From the test file, I can see this is related to the RenameIndex operation and how it handles unnamed indexes when moving backward and forward.\n\n2. Let me search for the RenameIndex operation implementation to understand how it currently works.\n</thoughts>"
                },
                {
                  "id": "call_459acff2",
                  "input": {
                    "file_pattern": null,
                    "query": "RenameIndex operation implementation",
                    "category": "implementation"
                  },
                  "type": "tool_use",
                  "name": "SemanticSearch"
                }
              ]
            },
            {
              "role": "user",
              "content": [
                {
                  "tool_use_id": "call_459acff2",
                  "content": "<observation>\nFound 15 code sections.\n\nViewed relevant code:\ndjango/db/migrations/operations/models.py\n```\n     1\tfrom django.db import models\n     2\tfrom django.db.migrations.operations.base import Operation\n     3\tfrom django.db.migrations.state import ModelState\n     4\tfrom django.db.migrations.utils import field_references, resolve_relation\n     5\tfrom django.db.models.options import normalize_together\n     6\tfrom django.utils.functional import cached_property\n     7\t\n     8\tfrom .fields import AddField, AlterField, FieldOperation, RemoveField, RenameField\n      # ...\n   877\t\n   878\t\n   879\tclass RenameIndex(IndexOperation):\n   880\t    \"\"\"Rename an index.\"\"\"\n   881\t\n   882\t    def __init__(self, model_name, new_name, old_name=None, old_fields=None):\n   883\t        if not old_name and not old_fields:\n   884\t            raise ValueError(\n   885\t                \"RenameIndex requires one of old_name and old_fields arguments to be \"\n   886\t                \"set.\"\n   887\t            )\n   888\t        if old_name and old_fields:\n   889\t            raise ValueError(\n   890\t                \"RenameIndex.old_name and old_fields are mutually exclusive.\"\n   891\t            )\n   892\t        self.model_name = model_name\n   893\t        self.new_name = new_name\n   894\t        self.old_name = old_name\n   895\t        self.old_fields = old_fields\n   896\t\n   897\t    @cached_property\n   898\t    def old_name_lower(self):\n   899\t        return self.old_name.lower()\n   900\t\n   901\t    @cached_property\n   902\t    def new_name_lower(self):\n   903\t        return self.new_name.lower()\n   904\t\n   905\t    def deconstruct(self):\n   906\t        kwargs = {\n   907\t            \"model_name\": self.model_name,\n   908\t            \"new_name\": self.new_name,\n   909\t        }\n   910\t        if self.old_name:\n   911\t            kwargs[\"old_name\"] = self.old_name\n   912\t        if self.old_fields:\n   913\t            kwargs[\"old_fields\"] = self.old_fields\n   914\t        return (self.__class__.__qualname__, [], kwargs)\n   915\t\n   916\t    def state_forwards(self, app_label, state):\n   917\t        if self.old_fields:\n   918\t            state.add_index(\n   919\t                app_label,\n   920\t                self.model_name_lower,\n   921\t                models.Index(fields=self.old_fields, name=self.new_name),\n   922\t            )\n   923\t            state.remove_model_options(\n   924\t                app_label,\n   925\t                self.model_name_lower,\n   926\t                AlterIndexTogether.option_name,\n   927\t                self.old_fields,\n   928\t            )\n   929\t        else:\n   930\t            state.rename_index(\n   931\t                app_label, self.model_name_lower, self.old_name, self.new_name\n   932\t            )\n   933\t\n   934\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n   935\t        model = to_state.apps.get_model(app_label, self.model_name)\n   936\t        if not self.allow_migrate_model(schema_editor.connection.alias, model):\n   937\t            return\n   938\t\n   939\t        if self.old_fields:\n   940\t            from_model = from_state.apps.get_model(app_label, self.model_name)\n   941\t            columns = [\n   942\t                from_model._meta.get_field(field).column for field in self.old_fields\n   943\t            ]\n   944\t            matching_index_name = schema_editor._constraint_names(\n   945\t                from_model, column_names=columns, index=True\n   946\t            )\n   947\t            if len(matching_index_name) != 1:\n   948\t                raise ValueError(\n   949\t                    \"Found wrong number (%s) of indexes for %s(%s).\"\n   950\t                    % (\n   951\t                        len(matching_index_name),\n   952\t                        from_model._meta.db_table,\n   953\t                        \", \".join(columns),\n   954\t                    )\n   955\t                )\n   956\t            old_index = models.Index(\n   957\t                fields=self.old_fields,\n   958\t                name=matching_index_name[0],\n   959\t            )\n   960\t        else:\n   961\t            from_model_state = from_state.models[app_label, self.model_name_lower]\n   962\t            old_index = from_model_state.get_index_by_name(self.old_name)\n   963\t\n   964\t        to_model_state = to_state.models[app_label, self.model_name_lower]\n   965\t        new_index = to_model_state.get_index_by_name(self.new_name)\n   966\t        schema_editor.rename_index(model, old_index, new_index)\n   967\t\n   968\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n   969\t        if self.old_fields:\n   970\t            # Backward operation with unnamed index is a no-op.\n   971\t            return\n   972\t\n   973\t        self.new_name_lower, self.old_name_lower = (\n   974\t            self.old_name_lower,\n   975\t            self.new_name_lower,\n   976\t        )\n   977\t        self.new_name, self.old_name = self.old_name, self.new_name\n   978\t\n   979\t        self.database_forwards(app_label, schema_editor, from_state, to_state)\n   980\t\n   981\t        self.new_name_lower, self.old_name_lower = (\n   982\t            self.old_name_lower,\n   983\t            self.new_name_lower,\n   984\t        )\n   985\t        self.new_name, self.old_name = self.old_name, self.new_name\n   986\t\n   987\t    def describe(self):\n   988\t        if self.old_name:\n   989\t            return (\n   990\t                f\"Rename index {self.old_name} on {self.model_name} to {self.new_name}\"\n   991\t            )\n   992\t        return (\n   993\t            f\"Rename unnamed index for {self.old_fields} on {self.model_name} to \"\n   994\t            f\"{self.new_name}\"\n   995\t        )\n   996\t\n   997\t    @property\n   998\t    def migration_name_fragment(self):\n   999\t        if self.old_name:\n  1000\t            return \"rename_%s_%s\" % (self.old_name_lower, self.new_name_lower)\n  1001\t        return \"rename_%s_%s_%s\" % (\n  1002\t            self.model_name_lower,\n  1003\t            \"_\".join(self.old_fields),\n  1004\t            self.new_name_lower,\n  1005\t        )\n  1006\t\n  1007\t    def reduce(self, operation, app_label):\n  1008\t        if (\n  1009\t            isinstance(operation, RenameIndex)\n  1010\t            and self.model_name_lower == operation.model_name_lower\n  1011\t            and operation.old_name\n  1012\t            and self.new_name_lower == operation.old_name_lower\n  1013\t        ):\n  1014\t            return [\n  1015\t                RenameIndex(\n  1016\t                    self.model_name,\n  1017\t                    new_name=operation.new_name,\n  1018\t                    old_name=self.old_name,\n  1019\t                    old_fields=self.old_fields,\n  1020\t                )\n  1021\t            ]\n  1022\t        return super().reduce(operation, app_label)\n      # ...\n```\n\n\ndjango/db/backends/base/schema.py\n```\n     1\timport logging\n     2\timport operator\n     3\tfrom datetime import datetime\n     4\t\n     5\tfrom django.db.backends.ddl_references import (\n     6\t    Columns,\n     7\t    Expressions,\n     8\t    ForeignKeyName,\n     9\t    IndexName,\n    10\t    Statement,\n    11\t    Table,\n    12\t)\n    13\tfrom django.db.backends.utils import names_digest, split_identifier\n    14\tfrom django.db.models import Deferrable, Index\n    15\tfrom django.db.models.sql import Query\n    16\tfrom django.db.transaction import TransactionManagementError, atomic\n    17\tfrom django.utils import timezone\n    18\t\n    19\tlogger = logging.getLogger(\"django.db.backends.schema\")\n      # ...\n    72\t\n    73\t\n    74\tclass BaseDatabaseSchemaEditor:\n    75\t    \"\"\"\n    76\t    This class and its subclasses are responsible for emitting schema-changing\n    77\t    statements to the databases - model creation/removal/alteration, field\n    78\t    renaming, index fiddling, and so on.\n    79\t    \"\"\"\n    80\t\n    81\t    # Overrideable SQL templates\n    82\t    sql_create_table = \"CREATE TABLE %(table)s (%(definition)s)\"\n    83\t    sql_rename_table = \"ALTER TABLE %(old_table)s RENAME TO %(new_table)s\"\n    84\t    sql_retablespace_table = \"ALTER TABLE %(table)s SET TABLESPACE %(new_tablespace)s\"\n    85\t    sql_delete_table = \"DROP TABLE %(table)s CASCADE\"\n    86\t\n    87\t    sql_create_column = \"ALTER TABLE %(table)s ADD COLUMN %(column)s %(definition)s\"\n    88\t    sql_alter_column = \"ALTER TABLE %(table)s %(changes)s\"\n    89\t    sql_alter_column_type = \"ALTER COLUMN %(column)s TYPE %(type)s\"\n    90\t    sql_alter_column_null = \"ALTER COLUMN %(column)s DROP NOT NULL\"\n    91\t    sql_alter_column_not_null = \"ALTER COLUMN %(column)s SET NOT NULL\"\n    92\t    sql_alter_column_default = \"ALTER COLUMN %(column)s SET DEFAULT %(default)s\"\n    93\t    sql_alter_column_no_default = \"ALTER COLUMN %(column)s DROP DEFAULT\"\n    94\t    sql_alter_column_no_default_null = sql_alter_column_no_default\n    95\t    sql_alter_column_collate = \"ALTER COLUMN %(column)s TYPE %(type)s%(collation)s\"\n    96\t    sql_delete_column = \"ALTER TABLE %(table)s DROP COLUMN %(column)s CASCADE\"\n    97\t    sql_rename_column = (\n    98\t        \"ALTER TABLE %(table)s RENAME COLUMN %(old_column)s TO %(new_column)s\"\n    99\t    )\n   100\t    sql_update_with_default = (\n   101\t        \"UPDATE %(table)s SET %(column)s = %(default)s WHERE %(column)s IS NULL\"\n   102\t    )\n   103\t\n   104\t    sql_unique_constraint = \"UNIQUE (%(columns)s)%(deferrable)s\"\n   105\t    sql_check_constraint = \"CHECK (%(check)s)\"\n   106\t    sql_delete_constraint = \"ALTER TABLE %(table)s DROP CONSTRAINT %(name)s\"\n   107\t    sql_constraint = \"CONSTRAINT %(name)s %(constraint)s\"\n   108\t\n   109\t    sql_create_check = \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s CHECK (%(check)s)\"\n   110\t    sql_delete_check = sql_delete_constraint\n   111\t\n   112\t    sql_create_unique = (\n   113\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s \"\n   114\t        \"UNIQUE (%(columns)s)%(deferrable)s\"\n   115\t    )\n   116\t    sql_delete_unique = sql_delete_constraint\n   117\t\n   118\t    sql_create_fk = (\n   119\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s FOREIGN KEY (%(column)s) \"\n   120\t        \"REFERENCES %(to_table)s (%(to_column)s)%(deferrable)s\"\n   121\t    )\n   122\t    sql_create_inline_fk = None\n   123\t    sql_create_column_inline_fk = None\n   124\t    sql_delete_fk = sql_delete_constraint\n   125\t\n   126\t    sql_create_index = (\n   127\t        \"CREATE INDEX %(name)s ON %(table)s \"\n   128\t        \"(%(columns)s)%(include)s%(extra)s%(condition)s\"\n   129\t    )\n   130\t    sql_create_unique_index = (\n   131\t        \"CREATE UNIQUE INDEX %(name)s ON %(table)s \"\n   132\t        \"(%(columns)s)%(include)s%(condition)s\"\n   133\t    )\n   134\t    sql_rename_index = \"ALTER INDEX %(old_name)s RENAME TO %(new_name)s\"\n   135\t    sql_delete_index = \"DROP INDEX %(name)s\"\n   136\t\n   137\t    sql_create_pk = (\n   138\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s PRIMARY KEY (%(columns)s)\"\n   139\t    )\n   140\t    sql_delete_pk = sql_delete_constraint\n   141\t\n   142\t    sql_delete_procedure = \"DROP PROCEDURE %(procedure)s\"\n          # ...\n  1374\t\n  1375\t    def _rename_index_sql(self, model, old_name, new_name):\n  1376\t        return Statement(\n  1377\t            self.sql_rename_index,\n  1378\t            table=Table(model._meta.db_table, self.quote_name),\n  1379\t            old_name=self.quote_name(old_name),\n  1380\t            new_name=self.quote_name(new_name),\n  1381\t        )\n          # ...\n```\n\n</observation>",
                  "type": "tool_result",
                  "cache_control": {
                    "type": "ephemeral"
                  }
                }
              ]
            },
            {
              "role": "assistant",
              "content": [
                {
                  "type": "text",
                  "text": "<thoughts>\n1. Looking at the code, I can see that RenameIndex has two modes:\n   - Renaming an index by old_name \n   - Renaming an unnamed index by old_fields\n\n2. The issue appears to be in the database_backwards() method when dealing with unnamed indexes. The method has a comment \"Backward operation with unnamed index is a no-op\" and just returns without doing anything.\n\n3. This means that when trying to revert an unnamed index rename operation, it doesn't properly restore the old auto-generated name.\n\n4. The fix should be to:\n   - Remove the early return for unnamed indexes in database_backwards()\n   - Handle the reversal properly by swapping names and letting database_forwards() handle it\n\nLet me look at the test file again to understand the exact test case that's failing.\n</thoughts>"
                },
                {
                  "id": "call_a879f7cc",
                  "input": {
                    "files": [
                      {
                        "file_path": "tests/migrations/test_operations.py",
                        "start_line": 2980,
                        "end_line": 3000,
                        "span_ids": []
                      }
                    ]
                  },
                  "type": "tool_use",
                  "name": "ViewCode",
                  "cache_control": {
                    "type": "ephemeral"
                  }
                }
              ]
            },
            {
              "role": "user",
              "content": [
                {
                  "tool_use_id": "call_a879f7cc",
                  "content": "<observation>\nHere's the contents of the requested code spans:\ntests/migrations/test_operations.py\n```\n     1\tfrom django.core.exceptions import FieldDoesNotExist\n     2\tfrom django.db import IntegrityError, connection, migrations, models, transaction\n     3\tfrom django.db.migrations.migration import Migration\n     4\tfrom django.db.migrations.operations.fields import FieldOperation\n     5\tfrom django.db.migrations.state import ModelState, ProjectState\n     6\tfrom django.db.models.functions import Abs\n     7\tfrom django.db.transaction import atomic\n     8\tfrom django.test import SimpleTestCase, override_settings, skipUnlessDBFeature\n     9\tfrom django.test.utils import CaptureQueriesContext\n    10\t\n    11\tfrom .models import FoodManager, FoodQuerySet, UnicodeModel\n    12\tfrom .test_base import OperationTestBase\n      # ...\n    17\t\n    18\t\n    19\tclass OperationTests(OperationTestBase):\n    20\t    \"\"\"\n    21\t    Tests running the operations and making sure they do what they say they do.\n    22\t    Each test looks at their state changing, and then their database operation -\n    23\t    both forwards and backwards.\n    24\t    \"\"\"\n          # ...\n  2963\t\n  2964\t    def test_rename_index_unnamed_index(self):\n  2965\t        app_label = \"test_rninui\"\n  2966\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  2967\t        table_name = app_label + \"_pony\"\n  2968\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2969\t        operation = migrations.RenameIndex(\n  2970\t            \"Pony\", new_name=\"new_pony_test_idx\", old_fields=(\"weight\", \"pink\")\n  2971\t        )\n  2972\t        self.assertEqual(\n  2973\t            operation.describe(),\n  2974\t            \"Rename unnamed index for ('weight', 'pink') on Pony to new_pony_test_idx\",\n  2975\t        )\n  2976\t        self.assertEqual(\n  2977\t            operation.migration_name_fragment,\n  2978\t            \"rename_pony_weight_pink_new_pony_test_idx\",\n  2979\t        )\n  2980\t\n  2981\t        new_state = project_state.clone()\n  2982\t        operation.state_forwards(app_label, new_state)\n  2983\t        # Rename index.\n  2984\t        with connection.schema_editor() as editor:\n  2985\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2986\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2987\t        # Reverse is a no-op.\n  2988\t        with connection.schema_editor() as editor, self.assertNumQueries(0):\n  2989\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2990\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2991\t        # Deconstruction.\n  2992\t        definition = operation.deconstruct()\n  2993\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2994\t        self.assertEqual(definition[1], [])\n  2995\t        self.assertEqual(\n  2996\t            definition[2],\n  2997\t            {\n  2998\t                \"model_name\": \"Pony\",\n  2999\t                \"new_name\": \"new_pony_test_idx\",\n  3000\t                \"old_fields\": (\"weight\", \"pink\"),\n  3001\t            },\n  3002\t        )\n          # ...\n      # ...\n```\n\n</observation>",
                  "type": "tool_result",
                  "cache_control": {
                    "type": "ephemeral"
                  }
                }
              ]
            }
          ],
          "response": {
            "id": "msg_01CT7SSTkPwAFe4WRH1v82yM",
            "content": [
              {
                "text": "<thoughts>\nLooking at the test case, I can see that:\n\n1. The test is specifically checking that RenameIndex works with unnamed indexes (created via index_together)\n\n2. The test expects that:\n   - Forward operation renames the unnamed index to \"new_pony_test_idx\"\n   - Backward operation is currently a no-op and keeps \"new_pony_test_idx\"\n\n3. The issue is that this behavior is incorrect - the backward operation should restore the original auto-generated name for the index.\n\n4. The fix needs to:\n   - Remove the early return in database_backwards() for unnamed indexes\n   - Let the normal name swapping and database_forwards() handle restoring the original name\n\nLet me look at the ProjectState code to understand how it handles index names.\n</thoughts>",
                "type": "text"
              },
              {
                "id": "toolu_017x5H2BHrG8oTVeSveDYbpo",
                "input": {
                  "query": "ProjectState index_together handling",
                  "category": "implementation",
                  "file_pattern": null
                },
                "name": "SemanticSearch",
                "type": "tool_use"
              }
            ],
            "model": "claude-3-5-sonnet-20241022",
            "role": "assistant",
            "stop_reason": "tool_use",
            "stop_sequence": null,
            "type": "message",
            "usage": {
              "cache_creation_input_tokens": 1287,
              "cache_read_input_tokens": 91149,
              "input_tokens": 3,
              "output_tokens": 280
            }
          },
          "usage": {
            "completion_cost": 0.00807,
            "completion_tokens": 280,
            "prompt_tokens": 1290,
            "cached_tokens": 91149
          }
        },
        "execute_action": {
          "model": "claude-3-5-sonnet-20241022",
          "input": [
            {
              "role": "user",
              "content": "Search request:\nSearching for code using the query: ProjectState index_together handling\n\nIdentify the relevant code sections in the search results to use them. \n\n<search_results>\ndjango/db/migrations/state.py\n```\n\n\n\n<span id='imports'>\n     1\timport copy\n     2\tfrom collections import defaultdict\n     3\tfrom contextlib import contextmanager\n     4\tfrom functools import partial\n     5\t\n     6\tfrom django.apps import AppConfig\n     7\tfrom django.apps.registry import Apps\n     8\tfrom django.apps.registry import apps as global_apps\n     9\tfrom django.conf import settings\n    10\tfrom django.core.exceptions import FieldDoesNotExist\n    11\tfrom django.db import models\n    12\tfrom django.db.migrations.utils import field_is_referenced, get_references\n    13\tfrom django.db.models import NOT_PROVIDED\n    14\tfrom django.db.models.fields.related import RECURSIVE_RELATIONSHIP_CONSTANT\n    15\tfrom django.db.models.options import DEFAULT_NAMES, normalize_together\n    16\tfrom django.db.models.utils import make_model_tuple\n    17\tfrom django.utils.functional import cached_property\n    18\tfrom django.utils.module_loading import import_string\n    19\tfrom django.utils.version import get_docs_version\n    20\t\n    21\tfrom .exceptions import InvalidBasesError\n    22\tfrom .utils import resolve_relation\n      # ...\n\n\n<span id='ProjectState'>\n    91\t\n    92\t\n    93\tclass ProjectState:\n    94\t    \"\"\"\n    95\t    Represent the entire project's overall state. This is the item that is\n    96\t    passed around - do it here rather than at the app level so that cross-app\n    97\t    FKs/etc. resolve properly.\n    98\t    \"\"\"\n\n\n<span id='ProjectState.__init__'>\n    99\t\n   100\t    def __init__(self, models=None, real_apps=None):\n   101\t        self.models = models or {}\n   102\t        # Apps to include from main registry, usually unmigrated ones\n   103\t        if real_apps is None:\n   104\t            real_apps = set()\n   105\t        else:\n   106\t            assert isinstance(real_apps, set)\n   107\t        self.real_apps = real_apps\n   108\t        self.is_delayed = False\n   109\t        # {remote_model_key: {model_key: {field_name: field}}}\n   110\t        self._relations = None\n          # ...\n\n\n<span id='ProjectState.alter_model_options'>\n   180\t\n   181\t    def alter_model_options(self, app_label, model_name, options, option_keys=None):\n   182\t        model_state = self.models[app_label, model_name]\n   183\t        model_state.options = {**model_state.options, **options}\n   184\t        if option_keys:\n   185\t            for key in option_keys:\n   186\t                if key not in options:\n   187\t                    model_state.options.pop(key, False)\n   188\t        self.reload_model(app_label, model_name, delay=True)\n\n\n<span id='ProjectState.remove_model_options'>\n   189\t\n   190\t    def remove_model_options(self, app_label, model_name, option_name, value_to_remove):\n   191\t        model_state = self.models[app_label, model_name]\n   192\t        if objs := model_state.options.get(option_name):\n   193\t            model_state.options[option_name] = [\n   194\t                obj for obj in objs if tuple(obj) != tuple(value_to_remove)\n   195\t            ]\n   196\t        self.reload_model(app_label, model_name, delay=True)\n\n\n<span id='ProjectState.alter_model_managers'>\n   197\t\n   198\t    def alter_model_managers(self, app_label, model_name, managers):\n   199\t        model_state = self.models[app_label, model_name]\n   200\t        model_state.managers = list(managers)\n   201\t        self.reload_model(app_label, model_name, delay=True)\n\n\n<span id='ProjectState._append_option'>\n   202\t\n   203\t    def _append_option(self, app_label, model_name, option_name, obj):\n   204\t        model_state = self.models[app_label, model_name]\n   205\t        model_state.options[option_name] = [*model_state.options[option_name], obj]\n   206\t        self.reload_model(app_label, model_name, delay=True)\n\n\n<span id='ProjectState._remove_option'>\n   207\t\n   208\t    def _remove_option(self, app_label, model_name, option_name, obj_name):\n   209\t        model_state = self.models[app_label, model_name]\n   210\t        objs = model_state.options[option_name]\n   211\t        model_state.options[option_name] = [obj for obj in objs if obj.name != obj_name]\n   212\t        self.reload_model(app_label, model_name, delay=True)\n\n\n<span id='ProjectState.add_index'>\n   213\t\n   214\t    def add_index(self, app_label, model_name, index):\n   215\t        self._append_option(app_label, model_name, \"indexes\", index)\n\n\n<span id='ProjectState.remove_index'>\n   216\t\n   217\t    def remove_index(self, app_label, model_name, index_name):\n   218\t        self._remove_option(app_label, model_name, \"indexes\", index_name)\n\n\n<span id='ProjectState.rename_index'>\n   219\t\n   220\t    def rename_index(self, app_label, model_name, old_index_name, new_index_name):\n   221\t        model_state = self.models[app_label, model_name]\n   222\t        objs = model_state.options[\"indexes\"]\n   223\t\n   224\t        new_indexes = []\n   225\t        for obj in objs:\n   226\t            if obj.name == old_index_name:\n   227\t                obj = obj.clone()\n   228\t                obj.name = new_index_name\n   229\t            new_indexes.append(obj)\n   230\t\n   231\t        model_state.options[\"indexes\"] = new_indexes\n   232\t        self.reload_model(app_label, model_name, delay=True)\n\n\n<span id='ProjectState.add_constraint'>\n   233\t\n   234\t    def add_constraint(self, app_label, model_name, constraint):\n   235\t        self._append_option(app_label, model_name, \"constraints\", constraint)\n\n\n<span id='ProjectState.remove_constraint'>\n   236\t\n   237\t    def remove_constraint(self, app_label, model_name, constraint_name):\n   238\t        self._remove_option(app_label, model_name, \"constraints\", constraint_name)\n          # ...\n\n\n<span id='ProjectState.from_apps'>\n   567\t\n   568\t    @classmethod\n   569\t    def from_apps(cls, apps):\n   570\t        \"\"\"Take an Apps and return a ProjectState matching it.\"\"\"\n   571\t        app_models = {}\n   572\t        for model in apps.get_models(include_swapped=True):\n   573\t            model_state = ModelState.from_model(model)\n   574\t            app_models[(model_state.app_label, model_state.name_lower)] = model_state\n   575\t        return cls(app_models)\n          # ...\n      # ...\n```\n\n</search_result>\n"
            }
          ],
          "response": {
            "id": "msg_0156ZKLFvfhN2cEmFbG46hph",
            "content": [
              {
                "text": "I'll analyze the search request and search results to identify relevant code sections for handling `index_together` in `ProjectState`.\n\nAfter reviewing the code, I notice that while there are methods for handling indexes in `ProjectState` (like `add_index`, `remove_index`, `rename_index`), there isn't a direct method specifically for `index_together` handling visible in the provided search results. However, there are related methods that show how model options are modified, which is relevant since `index_together` is a model option.\n\nThe most relevant sections are:\n\n1. The `alter_model_options` method (lines 181-188) which handles updating model options including potentially `index_together`\n2. The `remove_model_options` method (lines 190-196) which can handle removing options like `index_together`\n\nLet me identify these sections using the Action tool:",
                "type": "text"
              },
              {
                "id": "toolu_0135bTavn38Jb7VSeoargZGN",
                "input": {
                  "scratch_pad": "The most relevant code sections for handling index_together in ProjectState are:\n\n1. alter_model_options (lines 181-188):\n   - This method is used to modify model options, which would include index_together modifications\n   - It can both add new options and update existing ones\n   - It handles the general case of modifying any model option\n\n2. remove_model_options (lines 190-196):\n   - This method is used to remove specific values from model options\n   - It would be used when removing specific index_together configurations\n   - It handles removing values while preserving the option structure\n\nThese methods are the primary ways that ProjectState handles modifications to index_together configurations, as index_together is stored in the model's options dictionary.",
                  "identified_spans": [
                    {
                      "file_path": "django/db/migrations/state.py",
                      "start_line": 181,
                      "end_line": 188
                    },
                    {
                      "file_path": "django/db/migrations/state.py",
                      "start_line": 190,
                      "end_line": 196
                    }
                  ]
                },
                "name": "Action",
                "type": "tool_use"
              }
            ],
            "model": "claude-3-5-sonnet-20241022",
            "role": "assistant",
            "stop_reason": "tool_use",
            "stop_sequence": null,
            "type": "message",
            "usage": {
              "cache_creation_input_tokens": 0,
              "cache_read_input_tokens": 0,
              "input_tokens": 2785,
              "output_tokens": 515
            }
          },
          "usage": {
            "completion_cost": 0.01608,
            "completion_tokens": 515,
            "prompt_tokens": 2785,
            "cached_tokens": 0
          }
        }
      },
      "possible_actions": [
        "SemanticSearch",
        "FindClass",
        "FindFunction",
        "FindCodeSnippet",
        "ViewCode",
        "ClaudeEditTool"
      ],
      "output": {
        "message": "Found 14 code sections.\n\nViewed relevant code:\ndjango/db/migrations/state.py\n```\n     1\timport copy\n     2\tfrom collections import defaultdict\n     3\tfrom contextlib import contextmanager\n     4\tfrom functools import partial\n     5\t\n     6\tfrom django.apps import AppConfig\n     7\tfrom django.apps.registry import Apps\n     8\tfrom django.apps.registry import apps as global_apps\n     9\tfrom django.conf import settings\n    10\tfrom django.core.exceptions import FieldDoesNotExist\n    11\tfrom django.db import models\n    12\tfrom django.db.migrations.utils import field_is_referenced, get_references\n    13\tfrom django.db.models import NOT_PROVIDED\n    14\tfrom django.db.models.fields.related import RECURSIVE_RELATIONSHIP_CONSTANT\n    15\tfrom django.db.models.options import DEFAULT_NAMES, normalize_together\n    16\tfrom django.db.models.utils import make_model_tuple\n    17\tfrom django.utils.functional import cached_property\n    18\tfrom django.utils.module_loading import import_string\n    19\tfrom django.utils.version import get_docs_version\n    20\t\n    21\tfrom .exceptions import InvalidBasesError\n    22\tfrom .utils import resolve_relation\n      # ...\n    91\t\n    92\t\n    93\tclass ProjectState:\n    94\t    \"\"\"\n    95\t    Represent the entire project's overall state. This is the item that is\n    96\t    passed around - do it here rather than at the app level so that cross-app\n    97\t    FKs/etc. resolve properly.\n    98\t    \"\"\"\n          # ...\n   180\t\n   181\t    def alter_model_options(self, app_label, model_name, options, option_keys=None):\n   182\t        model_state = self.models[app_label, model_name]\n   183\t        model_state.options = {**model_state.options, **options}\n   184\t        if option_keys:\n   185\t            for key in option_keys:\n   186\t                if key not in options:\n   187\t                    model_state.options.pop(key, False)\n   188\t        self.reload_model(app_label, model_name, delay=True)\n   189\t\n   190\t    def remove_model_options(self, app_label, model_name, option_name, value_to_remove):\n   191\t        model_state = self.models[app_label, model_name]\n   192\t        if objs := model_state.options.get(option_name):\n   193\t            model_state.options[option_name] = [\n   194\t                obj for obj in objs if tuple(obj) != tuple(value_to_remove)\n   195\t            ]\n   196\t        self.reload_model(app_label, model_name, delay=True)\n          # ...\n      # ...\n```\n",
        "summary": "Found relevant code sections in the search results.",
        "terminal": false,
        "expect_correction": false,
        "properties": {
          "search_hits": [],
          "search_tokens": 896,
          "new_span_ids": [
            "ProjectState",
            "ProjectState.alter_model_options",
            "ProjectState.remove_model_options"
          ]
        },
        "execution_completion": {
          "model": "claude-3-5-sonnet-20241022",
          "input": [
            {
              "role": "user",
              "content": "Search request:\nSearching for code using the query: ProjectState index_together handling\n\nIdentify the relevant code sections in the search results to use them. \n\n<search_results>\ndjango/db/migrations/state.py\n```\n\n\n\n<span id='imports'>\n     1\timport copy\n     2\tfrom collections import defaultdict\n     3\tfrom contextlib import contextmanager\n     4\tfrom functools import partial\n     5\t\n     6\tfrom django.apps import AppConfig\n     7\tfrom django.apps.registry import Apps\n     8\tfrom django.apps.registry import apps as global_apps\n     9\tfrom django.conf import settings\n    10\tfrom django.core.exceptions import FieldDoesNotExist\n    11\tfrom django.db import models\n    12\tfrom django.db.migrations.utils import field_is_referenced, get_references\n    13\tfrom django.db.models import NOT_PROVIDED\n    14\tfrom django.db.models.fields.related import RECURSIVE_RELATIONSHIP_CONSTANT\n    15\tfrom django.db.models.options import DEFAULT_NAMES, normalize_together\n    16\tfrom django.db.models.utils import make_model_tuple\n    17\tfrom django.utils.functional import cached_property\n    18\tfrom django.utils.module_loading import import_string\n    19\tfrom django.utils.version import get_docs_version\n    20\t\n    21\tfrom .exceptions import InvalidBasesError\n    22\tfrom .utils import resolve_relation\n      # ...\n\n\n<span id='ProjectState'>\n    91\t\n    92\t\n    93\tclass ProjectState:\n    94\t    \"\"\"\n    95\t    Represent the entire project's overall state. This is the item that is\n    96\t    passed around - do it here rather than at the app level so that cross-app\n    97\t    FKs/etc. resolve properly.\n    98\t    \"\"\"\n\n\n<span id='ProjectState.__init__'>\n    99\t\n   100\t    def __init__(self, models=None, real_apps=None):\n   101\t        self.models = models or {}\n   102\t        # Apps to include from main registry, usually unmigrated ones\n   103\t        if real_apps is None:\n   104\t            real_apps = set()\n   105\t        else:\n   106\t            assert isinstance(real_apps, set)\n   107\t        self.real_apps = real_apps\n   108\t        self.is_delayed = False\n   109\t        # {remote_model_key: {model_key: {field_name: field}}}\n   110\t        self._relations = None\n          # ...\n\n\n<span id='ProjectState.alter_model_options'>\n   180\t\n   181\t    def alter_model_options(self, app_label, model_name, options, option_keys=None):\n   182\t        model_state = self.models[app_label, model_name]\n   183\t        model_state.options = {**model_state.options, **options}\n   184\t        if option_keys:\n   185\t            for key in option_keys:\n   186\t                if key not in options:\n   187\t                    model_state.options.pop(key, False)\n   188\t        self.reload_model(app_label, model_name, delay=True)\n\n\n<span id='ProjectState.remove_model_options'>\n   189\t\n   190\t    def remove_model_options(self, app_label, model_name, option_name, value_to_remove):\n   191\t        model_state = self.models[app_label, model_name]\n   192\t        if objs := model_state.options.get(option_name):\n   193\t            model_state.options[option_name] = [\n   194\t                obj for obj in objs if tuple(obj) != tuple(value_to_remove)\n   195\t            ]\n   196\t        self.reload_model(app_label, model_name, delay=True)\n\n\n<span id='ProjectState.alter_model_managers'>\n   197\t\n   198\t    def alter_model_managers(self, app_label, model_name, managers):\n   199\t        model_state = self.models[app_label, model_name]\n   200\t        model_state.managers = list(managers)\n   201\t        self.reload_model(app_label, model_name, delay=True)\n\n\n<span id='ProjectState._append_option'>\n   202\t\n   203\t    def _append_option(self, app_label, model_name, option_name, obj):\n   204\t        model_state = self.models[app_label, model_name]\n   205\t        model_state.options[option_name] = [*model_state.options[option_name], obj]\n   206\t        self.reload_model(app_label, model_name, delay=True)\n\n\n<span id='ProjectState._remove_option'>\n   207\t\n   208\t    def _remove_option(self, app_label, model_name, option_name, obj_name):\n   209\t        model_state = self.models[app_label, model_name]\n   210\t        objs = model_state.options[option_name]\n   211\t        model_state.options[option_name] = [obj for obj in objs if obj.name != obj_name]\n   212\t        self.reload_model(app_label, model_name, delay=True)\n\n\n<span id='ProjectState.add_index'>\n   213\t\n   214\t    def add_index(self, app_label, model_name, index):\n   215\t        self._append_option(app_label, model_name, \"indexes\", index)\n\n\n<span id='ProjectState.remove_index'>\n   216\t\n   217\t    def remove_index(self, app_label, model_name, index_name):\n   218\t        self._remove_option(app_label, model_name, \"indexes\", index_name)\n\n\n<span id='ProjectState.rename_index'>\n   219\t\n   220\t    def rename_index(self, app_label, model_name, old_index_name, new_index_name):\n   221\t        model_state = self.models[app_label, model_name]\n   222\t        objs = model_state.options[\"indexes\"]\n   223\t\n   224\t        new_indexes = []\n   225\t        for obj in objs:\n   226\t            if obj.name == old_index_name:\n   227\t                obj = obj.clone()\n   228\t                obj.name = new_index_name\n   229\t            new_indexes.append(obj)\n   230\t\n   231\t        model_state.options[\"indexes\"] = new_indexes\n   232\t        self.reload_model(app_label, model_name, delay=True)\n\n\n<span id='ProjectState.add_constraint'>\n   233\t\n   234\t    def add_constraint(self, app_label, model_name, constraint):\n   235\t        self._append_option(app_label, model_name, \"constraints\", constraint)\n\n\n<span id='ProjectState.remove_constraint'>\n   236\t\n   237\t    def remove_constraint(self, app_label, model_name, constraint_name):\n   238\t        self._remove_option(app_label, model_name, \"constraints\", constraint_name)\n          # ...\n\n\n<span id='ProjectState.from_apps'>\n   567\t\n   568\t    @classmethod\n   569\t    def from_apps(cls, apps):\n   570\t        \"\"\"Take an Apps and return a ProjectState matching it.\"\"\"\n   571\t        app_models = {}\n   572\t        for model in apps.get_models(include_swapped=True):\n   573\t            model_state = ModelState.from_model(model)\n   574\t            app_models[(model_state.app_label, model_state.name_lower)] = model_state\n   575\t        return cls(app_models)\n          # ...\n      # ...\n```\n\n</search_result>\n"
            }
          ],
          "response": {
            "id": "msg_0156ZKLFvfhN2cEmFbG46hph",
            "content": [
              {
                "text": "I'll analyze the search request and search results to identify relevant code sections for handling `index_together` in `ProjectState`.\n\nAfter reviewing the code, I notice that while there are methods for handling indexes in `ProjectState` (like `add_index`, `remove_index`, `rename_index`), there isn't a direct method specifically for `index_together` handling visible in the provided search results. However, there are related methods that show how model options are modified, which is relevant since `index_together` is a model option.\n\nThe most relevant sections are:\n\n1. The `alter_model_options` method (lines 181-188) which handles updating model options including potentially `index_together`\n2. The `remove_model_options` method (lines 190-196) which can handle removing options like `index_together`\n\nLet me identify these sections using the Action tool:",
                "type": "text"
              },
              {
                "id": "toolu_0135bTavn38Jb7VSeoargZGN",
                "input": {
                  "scratch_pad": "The most relevant code sections for handling index_together in ProjectState are:\n\n1. alter_model_options (lines 181-188):\n   - This method is used to modify model options, which would include index_together modifications\n   - It can both add new options and update existing ones\n   - It handles the general case of modifying any model option\n\n2. remove_model_options (lines 190-196):\n   - This method is used to remove specific values from model options\n   - It would be used when removing specific index_together configurations\n   - It handles removing values while preserving the option structure\n\nThese methods are the primary ways that ProjectState handles modifications to index_together configurations, as index_together is stored in the model's options dictionary.",
                  "identified_spans": [
                    {
                      "file_path": "django/db/migrations/state.py",
                      "start_line": 181,
                      "end_line": 188
                    },
                    {
                      "file_path": "django/db/migrations/state.py",
                      "start_line": 190,
                      "end_line": 196
                    }
                  ]
                },
                "name": "Action",
                "type": "tool_use"
              }
            ],
            "model": "claude-3-5-sonnet-20241022",
            "role": "assistant",
            "stop_reason": "tool_use",
            "stop_sequence": null,
            "type": "message",
            "usage": {
              "cache_creation_input_tokens": 0,
              "cache_read_input_tokens": 0,
              "input_tokens": 2785,
              "output_tokens": 515
            }
          },
          "usage": {
            "completion_cost": 0.01608,
            "completion_tokens": 515,
            "prompt_tokens": 2785,
            "cached_tokens": 0
          }
        }
      },
      "parent_id": 3
    },
    {
      "node_id": 5,
      "action": {
        "scratch_pad": "Let me view the specific RenameIndex operation code to make the changes.",
        "files": [
          {
            "file_path": "django/db/migrations/operations/models.py",
            "start_line": 879,
            "end_line": 986,
            "span_ids": []
          }
        ],
        "action_args_class": "moatless.actions.view_code.ViewCodeArgs"
      },
      "observation": {
        "message": "Here's the contents of the requested code spans:\ndjango/db/migrations/operations/models.py\n```\n     1\tfrom django.db import models\n     2\tfrom django.db.migrations.operations.base import Operation\n     3\tfrom django.db.migrations.state import ModelState\n     4\tfrom django.db.migrations.utils import field_references, resolve_relation\n     5\tfrom django.db.models.options import normalize_together\n     6\tfrom django.utils.functional import cached_property\n     7\t\n     8\tfrom .fields import AddField, AlterField, FieldOperation, RemoveField, RenameField\n      # ...\n   877\t\n   878\t\n   879\tclass RenameIndex(IndexOperation):\n   880\t    \"\"\"Rename an index.\"\"\"\n   881\t\n   882\t    def __init__(self, model_name, new_name, old_name=None, old_fields=None):\n   883\t        if not old_name and not old_fields:\n   884\t            raise ValueError(\n   885\t                \"RenameIndex requires one of old_name and old_fields arguments to be \"\n   886\t                \"set.\"\n   887\t            )\n   888\t        if old_name and old_fields:\n   889\t            raise ValueError(\n   890\t                \"RenameIndex.old_name and old_fields are mutually exclusive.\"\n   891\t            )\n   892\t        self.model_name = model_name\n   893\t        self.new_name = new_name\n   894\t        self.old_name = old_name\n   895\t        self.old_fields = old_fields\n   896\t\n   897\t    @cached_property\n   898\t    def old_name_lower(self):\n   899\t        return self.old_name.lower()\n   900\t\n   901\t    @cached_property\n   902\t    def new_name_lower(self):\n   903\t        return self.new_name.lower()\n   904\t\n   905\t    def deconstruct(self):\n   906\t        kwargs = {\n   907\t            \"model_name\": self.model_name,\n   908\t            \"new_name\": self.new_name,\n   909\t        }\n   910\t        if self.old_name:\n   911\t            kwargs[\"old_name\"] = self.old_name\n   912\t        if self.old_fields:\n   913\t            kwargs[\"old_fields\"] = self.old_fields\n   914\t        return (self.__class__.__qualname__, [], kwargs)\n   915\t\n   916\t    def state_forwards(self, app_label, state):\n   917\t        if self.old_fields:\n   918\t            state.add_index(\n   919\t                app_label,\n   920\t                self.model_name_lower,\n   921\t                models.Index(fields=self.old_fields, name=self.new_name),\n   922\t            )\n   923\t            state.remove_model_options(\n   924\t                app_label,\n   925\t                self.model_name_lower,\n   926\t                AlterIndexTogether.option_name,\n   927\t                self.old_fields,\n   928\t            )\n   929\t        else:\n   930\t            state.rename_index(\n   931\t                app_label, self.model_name_lower, self.old_name, self.new_name\n   932\t            )\n   933\t\n   934\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n   935\t        model = to_state.apps.get_model(app_label, self.model_name)\n   936\t        if not self.allow_migrate_model(schema_editor.connection.alias, model):\n   937\t            return\n   938\t\n   939\t        if self.old_fields:\n   940\t            from_model = from_state.apps.get_model(app_label, self.model_name)\n   941\t            columns = [\n   942\t                from_model._meta.get_field(field).column for field in self.old_fields\n   943\t            ]\n   944\t            matching_index_name = schema_editor._constraint_names(\n   945\t                from_model, column_names=columns, index=True\n   946\t            )\n   947\t            if len(matching_index_name) != 1:\n   948\t                raise ValueError(\n   949\t                    \"Found wrong number (%s) of indexes for %s(%s).\"\n   950\t                    % (\n   951\t                        len(matching_index_name),\n   952\t                        from_model._meta.db_table,\n   953\t                        \", \".join(columns),\n   954\t                    )\n   955\t                )\n   956\t            old_index = models.Index(\n   957\t                fields=self.old_fields,\n   958\t                name=matching_index_name[0],\n   959\t            )\n   960\t        else:\n   961\t            from_model_state = from_state.models[app_label, self.model_name_lower]\n   962\t            old_index = from_model_state.get_index_by_name(self.old_name)\n   963\t\n   964\t        to_model_state = to_state.models[app_label, self.model_name_lower]\n   965\t        new_index = to_model_state.get_index_by_name(self.new_name)\n   966\t        schema_editor.rename_index(model, old_index, new_index)\n   967\t\n   968\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n   969\t        if self.old_fields:\n   970\t            # Backward operation with unnamed index is a no-op.\n   971\t            return\n   972\t\n   973\t        self.new_name_lower, self.old_name_lower = (\n   974\t            self.old_name_lower,\n   975\t            self.new_name_lower,\n   976\t        )\n   977\t        self.new_name, self.old_name = self.old_name, self.new_name\n   978\t\n   979\t        self.database_forwards(app_label, schema_editor, from_state, to_state)\n   980\t\n   981\t        self.new_name_lower, self.old_name_lower = (\n   982\t            self.old_name_lower,\n   983\t            self.new_name_lower,\n   984\t        )\n   985\t        self.new_name, self.old_name = self.old_name, self.new_name\n          # ...\n      # ...\n```\n",
        "summary": "Showed the following code spans:\n\nFile: tests/migrations/test_operations.py\n- Showing all code in file\n\nFile: django/db/migrations/operations/models.py\n- imports\n- RenameIndex\n- RenameIndex.__init__\n- RenameIndex.old_name_lower\n- RenameIndex.new_name_lower\n- RenameIndex.deconstruct\n- RenameIndex.state_forwards\n- RenameIndex.database_forwards\n- RenameIndex.database_backwards\n- RenameIndex.describe\n- RenameIndex.migration_name_fragment\n- RenameIndex.reduce\n\nFile: django/db/backends/base/schema.py\n- imports\n- BaseDatabaseSchemaEditor\n- BaseDatabaseSchemaEditor._rename_index_sql\n\nFile: django/db/migrations/state.py\n- imports\n- ProjectState\n- ProjectState.alter_model_options\n- ProjectState.remove_model_options\n",
        "terminal": false,
        "expect_correction": false,
        "properties": {
          "files": {
            "django/db/migrations/operations/models.py": {
              "new_span_ids": []
            }
          },
          "fail_reason": "no_spans_added",
          "retries": 1
        }
      },
      "file_context": {
        "max_tokens": 8000,
        "files": [
          {
            "file_path": "tests/migrations/test_operations.py",
            "spans": [
              {
                "span_id": "imports",
                "pinned": false
              },
              {
                "span_id": "OperationTests",
                "pinned": false
              },
              {
                "span_id": "OperationTests.test_rename_index_unnamed_index",
                "pinned": false
              }
            ],
            "show_all_spans": true,
            "patch": null
          },
          {
            "file_path": "django/db/migrations/operations/models.py",
            "spans": [
              {
                "span_id": "imports",
                "pinned": false
              },
              {
                "span_id": "RenameIndex",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.__init__",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.old_name_lower",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.new_name_lower",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.deconstruct",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.state_forwards",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.database_forwards",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.database_backwards",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.describe",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.migration_name_fragment",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.reduce",
                "pinned": false
              }
            ],
            "show_all_spans": false,
            "patch": null
          },
          {
            "file_path": "django/db/backends/base/schema.py",
            "spans": [
              {
                "span_id": "imports",
                "pinned": false
              },
              {
                "span_id": "BaseDatabaseSchemaEditor",
                "pinned": false
              },
              {
                "span_id": "BaseDatabaseSchemaEditor._rename_index_sql",
                "pinned": false
              }
            ],
            "show_all_spans": false,
            "patch": null
          },
          {
            "file_path": "django/db/migrations/state.py",
            "spans": [
              {
                "span_id": "imports",
                "pinned": false
              },
              {
                "span_id": "ProjectState",
                "pinned": false
              },
              {
                "span_id": "ProjectState.alter_model_options",
                "pinned": false
              },
              {
                "span_id": "ProjectState.remove_model_options",
                "pinned": false
              }
            ],
            "show_all_spans": false,
            "patch": null
          }
        ]
      },
      "completions": {
        "build_action": {
          "model": "claude-3-5-sonnet-20241022",
          "input": [
            {
              "role": "user",
              "content": "<task>\nRenameIndex() crashes when unnamed index is moving backward and forward.\nDescription\n\t\nRenameIndex() should restore the old auto-generated name when an unnamed index for unique_together is moving backward. Now re-applying RenameIndex() crashes. For example:\ntests/migrations/test_operations.py\ndiff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex cfd28b1b39..c0a55023bb 100644\n\t\t\t\t\t\n\t\t\t\t\t a\n\t\t\t\t \n\t\t\t\t\t\n\t\t\t\t\t b\n\t\t\t\t \n class OperationTests(OperationTestBase):\u00a0\n29882988\u00a0 \u00a0 \u00a0 \u00a0 with connection.schema_editor() as editor, self.assertNumQueries(0):\n29892989\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 operation.database_backwards(app_label, editor, new_state, project_state)\n29902990\u00a0 \u00a0 \u00a0 \u00a0 self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n\u00a02991\u00a0 \u00a0 \u00a0 \u00a0 # Re-apply renaming.\n\u00a02992\u00a0 \u00a0 \u00a0 \u00a0 with connection.schema_editor() as editor:\n\u00a02993\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 operation.database_forwards(app_label, editor, project_state, new_state)\n\u00a02994\u00a0 \u00a0 \u00a0 \u00a0 self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n29912995\u00a0 \u00a0 \u00a0 \u00a0 # Deconstruction.\n29922996\u00a0 \u00a0 \u00a0 \u00a0 definition = operation.deconstruct()\n29932997\u00a0 \u00a0 \u00a0 \u00a0 self.assertEqual(definition[0], \"RenameIndex\")\ncrashes on PostgreSQL:\ndjango.db.utils.ProgrammingError: relation \"new_pony_test_idx\" already exists\n\n</task>"
            },
            {
              "role": "assistant",
              "content": [
                {
                  "type": "text",
                  "text": "<thoughts>\n1. First, I need to understand the context better by:\n   - Looking at the test file to see the full test case\n   - Finding the RenameIndex operation implementation\n   - Understanding how index naming works in this context\n\n2. Let's start by viewing the test file to see the full test case context.\n</thoughts>"
                },
                {
                  "id": "call_8635dcc7",
                  "input": {
                    "files": [
                      {
                        "file_path": "tests/migrations/test_operations.py",
                        "start_line": null,
                        "end_line": null,
                        "span_ids": []
                      }
                    ]
                  },
                  "type": "tool_use",
                  "name": "ViewCode"
                }
              ]
            },
            {
              "role": "user",
              "content": [
                {
                  "tool_use_id": "call_8635dcc7",
                  "content": "<observation>\nHere's the contents of the requested code spans:\ntests/migrations/test_operations.py\n```\n     1\tfrom django.core.exceptions import FieldDoesNotExist\n     2\tfrom django.db import IntegrityError, connection, migrations, models, transaction\n     3\tfrom django.db.migrations.migration import Migration\n     4\tfrom django.db.migrations.operations.fields import FieldOperation\n     5\tfrom django.db.migrations.state import ModelState, ProjectState\n     6\tfrom django.db.models.functions import Abs\n     7\tfrom django.db.transaction import atomic\n     8\tfrom django.test import SimpleTestCase, override_settings, skipUnlessDBFeature\n     9\tfrom django.test.utils import CaptureQueriesContext\n    10\t\n    11\tfrom .models import FoodManager, FoodQuerySet, UnicodeModel\n    12\tfrom .test_base import OperationTestBase\n    13\t\n    14\t\n    15\tclass Mixin:\n    16\t    pass\n    17\t\n    18\t\n    19\tclass OperationTests(OperationTestBase):\n    20\t    \"\"\"\n    21\t    Tests running the operations and making sure they do what they say they do.\n    22\t    Each test looks at their state changing, and then their database operation -\n    23\t    both forwards and backwards.\n    24\t    \"\"\"\n    25\t\n    26\t    def test_create_model(self):\n    27\t        \"\"\"\n    28\t        Tests the CreateModel operation.\n    29\t        Most other tests use this operation as part of setup, so check failures\n    30\t        here first.\n    31\t        \"\"\"\n    32\t        operation = migrations.CreateModel(\n    33\t            \"Pony\",\n    34\t            [\n    35\t                (\"id\", models.AutoField(primary_key=True)),\n    36\t                (\"pink\", models.IntegerField(default=1)),\n    37\t            ],\n    38\t        )\n    39\t        self.assertEqual(operation.describe(), \"Create model Pony\")\n    40\t        self.assertEqual(operation.migration_name_fragment, \"pony\")\n    41\t        # Test the state alteration\n    42\t        project_state = ProjectState()\n    43\t        new_state = project_state.clone()\n    44\t        operation.state_forwards(\"test_crmo\", new_state)\n    45\t        self.assertEqual(new_state.models[\"test_crmo\", \"pony\"].name, \"Pony\")\n    46\t        self.assertEqual(len(new_state.models[\"test_crmo\", \"pony\"].fields), 2)\n    47\t        # Test the database alteration\n    48\t        self.assertTableNotExists(\"test_crmo_pony\")\n    49\t        with connection.schema_editor() as editor:\n    50\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n    51\t        self.assertTableExists(\"test_crmo_pony\")\n    52\t        # And test reversal\n    53\t        with connection.schema_editor() as editor:\n    54\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n    55\t        self.assertTableNotExists(\"test_crmo_pony\")\n    56\t        # And deconstruction\n    57\t        definition = operation.deconstruct()\n    58\t        self.assertEqual(definition[0], \"CreateModel\")\n    59\t        self.assertEqual(definition[1], [])\n    60\t        self.assertEqual(sorted(definition[2]), [\"fields\", \"name\"])\n    61\t        # And default manager not in set\n    62\t        operation = migrations.CreateModel(\n    63\t            \"Foo\", fields=[], managers=[(\"objects\", models.Manager())]\n    64\t        )\n    65\t        definition = operation.deconstruct()\n    66\t        self.assertNotIn(\"managers\", definition[2])\n    67\t\n    68\t    def test_create_model_with_duplicate_field_name(self):\n    69\t        with self.assertRaisesMessage(\n    70\t            ValueError, \"Found duplicate value pink in CreateModel fields argument.\"\n    71\t        ):\n    72\t            migrations.CreateModel(\n    73\t                \"Pony\",\n    74\t                [\n    75\t                    (\"id\", models.AutoField(primary_key=True)),\n    76\t                    (\"pink\", models.TextField()),\n    77\t                    (\"pink\", models.IntegerField(default=1)),\n    78\t                ],\n    79\t            )\n    80\t\n    81\t    def test_create_model_with_duplicate_base(self):\n    82\t        message = \"Found duplicate value test_crmo.pony in CreateModel bases argument.\"\n    83\t        with self.assertRaisesMessage(ValueError, message):\n    84\t            migrations.CreateModel(\n    85\t                \"Pony\",\n    86\t                fields=[],\n    87\t                bases=(\n    88\t                    \"test_crmo.Pony\",\n    89\t                    \"test_crmo.Pony\",\n    90\t                ),\n    91\t            )\n    92\t        with self.assertRaisesMessage(ValueError, message):\n    93\t            migrations.CreateModel(\n    94\t                \"Pony\",\n    95\t                fields=[],\n    96\t                bases=(\n    97\t                    \"test_crmo.Pony\",\n    98\t                    \"test_crmo.pony\",\n    99\t                ),\n   100\t            )\n   101\t        message = (\n   102\t            \"Found duplicate value migrations.unicodemodel in CreateModel bases \"\n   103\t            \"argument.\"\n   104\t        )\n   105\t        with self.assertRaisesMessage(ValueError, message):\n   106\t            migrations.CreateModel(\n   107\t                \"Pony\",\n   108\t                fields=[],\n   109\t                bases=(\n   110\t                    UnicodeModel,\n   111\t                    UnicodeModel,\n   112\t                ),\n   113\t            )\n   114\t        with self.assertRaisesMessage(ValueError, message):\n   115\t            migrations.CreateModel(\n   116\t                \"Pony\",\n   117\t                fields=[],\n   118\t                bases=(\n   119\t                    UnicodeModel,\n   120\t                    \"migrations.unicodemodel\",\n   121\t                ),\n   122\t            )\n   123\t        with self.assertRaisesMessage(ValueError, message):\n   124\t            migrations.CreateModel(\n   125\t                \"Pony\",\n   126\t                fields=[],\n   127\t                bases=(\n   128\t                    UnicodeModel,\n   129\t                    \"migrations.UnicodeModel\",\n   130\t                ),\n   131\t            )\n   132\t        message = (\n   133\t            \"Found duplicate value <class 'django.db.models.base.Model'> in \"\n   134\t            \"CreateModel bases argument.\"\n   135\t        )\n   136\t        with self.assertRaisesMessage(ValueError, message):\n   137\t            migrations.CreateModel(\n   138\t                \"Pony\",\n   139\t                fields=[],\n   140\t                bases=(\n   141\t                    models.Model,\n   142\t                    models.Model,\n   143\t                ),\n   144\t            )\n   145\t        message = (\n   146\t            \"Found duplicate value <class 'migrations.test_operations.Mixin'> in \"\n   147\t            \"CreateModel bases argument.\"\n   148\t        )\n   149\t        with self.assertRaisesMessage(ValueError, message):\n   150\t            migrations.CreateModel(\n   151\t                \"Pony\",\n   152\t                fields=[],\n   153\t                bases=(\n   154\t                    Mixin,\n   155\t                    Mixin,\n   156\t                ),\n   157\t            )\n   158\t\n   159\t    def test_create_model_with_duplicate_manager_name(self):\n   160\t        with self.assertRaisesMessage(\n   161\t            ValueError,\n   162\t            \"Found duplicate value objects in CreateModel managers argument.\",\n   163\t        ):\n   164\t            migrations.CreateModel(\n   165\t                \"Pony\",\n   166\t                fields=[],\n   167\t                managers=[\n   168\t                    (\"objects\", models.Manager()),\n   169\t                    (\"objects\", models.Manager()),\n   170\t                ],\n   171\t            )\n   172\t\n   173\t    def test_create_model_with_unique_after(self):\n   174\t        \"\"\"\n   175\t        Tests the CreateModel operation directly followed by an\n   176\t        AlterUniqueTogether (bug #22844 - sqlite remake issues)\n   177\t        \"\"\"\n   178\t        operation1 = migrations.CreateModel(\n   179\t            \"Pony\",\n   180\t            [\n   181\t                (\"id\", models.AutoField(primary_key=True)),\n   182\t                (\"pink\", models.IntegerField(default=1)),\n   183\t            ],\n   184\t        )\n   185\t        operation2 = migrations.CreateModel(\n   186\t            \"Rider\",\n   187\t            [\n   188\t                (\"id\", models.AutoField(primary_key=True)),\n   189\t                (\"number\", models.IntegerField(default=1)),\n   190\t                (\"pony\", models.ForeignKey(\"test_crmoua.Pony\", models.CASCADE)),\n   191\t            ],\n   192\t        )\n   193\t        operation3 = migrations.AlterUniqueTogether(\n   194\t            \"Rider\",\n   195\t            [\n   196\t                (\"number\", \"pony\"),\n   197\t            ],\n   198\t        )\n   199\t        # Test the database alteration\n   200\t        project_state = ProjectState()\n   201\t        self.assertTableNotExists(\"test_crmoua_pony\")\n   202\t        self.assertTableNotExists(\"test_crmoua_rider\")\n   203\t        with connection.schema_editor() as editor:\n   204\t            new_state = project_state.clone()\n   205\t            operation1.state_forwards(\"test_crmoua\", new_state)\n   206\t            operation1.database_forwards(\n   207\t                \"test_crmoua\", editor, project_state, new_state\n   208\t            )\n   209\t            project_state, new_state = new_state, new_state.clone()\n   210\t            operation2.state_forwards(\"test_crmoua\", new_state)\n   211\t            operation2.database_forwards(\n   212\t                \"test_crmoua\", editor, project_state, new_state\n   213\t            )\n   214\t            project_state, new_state = new_state, new_state.clone()\n   215\t            operation3.state_forwards(\"test_crmoua\", new_state)\n   216\t            operation3.database_forwards(\n   217\t                \"test_crmoua\", editor, project_state, new_state\n   218\t            )\n   219\t        self.assertTableExists(\"test_crmoua_pony\")\n   220\t        self.assertTableExists(\"test_crmoua_rider\")\n   221\t\n   222\t    def test_create_model_m2m(self):\n   223\t        \"\"\"\n   224\t        Test the creation of a model with a ManyToMany field and the\n   225\t        auto-created \"through\" model.\n   226\t        \"\"\"\n   227\t        project_state = self.set_up_test_model(\"test_crmomm\")\n   228\t        operation = migrations.CreateModel(\n   229\t            \"Stable\",\n   230\t            [\n   231\t                (\"id\", models.AutoField(primary_key=True)),\n   232\t                (\"ponies\", models.ManyToManyField(\"Pony\", related_name=\"stables\")),\n   233\t            ],\n   234\t        )\n   235\t        # Test the state alteration\n   236\t        new_state = project_state.clone()\n   237\t        operation.state_forwards(\"test_crmomm\", new_state)\n   238\t        # Test the database alteration\n   239\t        self.assertTableNotExists(\"test_crmomm_stable_ponies\")\n   240\t        with connection.schema_editor() as editor:\n   241\t            operation.database_forwards(\"test_crmomm\", editor, project_state, new_state)\n   242\t        self.assertTableExists(\"test_crmomm_stable\")\n   243\t        self.assertTableExists(\"test_crmomm_stable_ponies\")\n   244\t        self.assertColumnNotExists(\"test_crmomm_stable\", \"ponies\")\n   245\t        # Make sure the M2M field actually works\n   246\t        with atomic():\n   247\t            Pony = new_state.apps.get_model(\"test_crmomm\", \"Pony\")\n   248\t            Stable = new_state.apps.get_model(\"test_crmomm\", \"Stable\")\n   249\t            stable = Stable.objects.create()\n   250\t            p1 = Pony.objects.create(pink=False, weight=4.55)\n   251\t            p2 = Pony.objects.create(pink=True, weight=5.43)\n   252\t            stable.ponies.add(p1, p2)\n   253\t            self.assertEqual(stable.ponies.count(), 2)\n   254\t            stable.ponies.all().delete()\n   255\t        # And test reversal\n   256\t        with connection.schema_editor() as editor:\n   257\t            operation.database_backwards(\n   258\t                \"test_crmomm\", editor, new_state, project_state\n   259\t            )\n   260\t        self.assertTableNotExists(\"test_crmomm_stable\")\n   261\t        self.assertTableNotExists(\"test_crmomm_stable_ponies\")\n   262\t\n   263\t    @skipUnlessDBFeature(\"supports_collation_on_charfield\", \"supports_foreign_keys\")\n   264\t    def test_create_fk_models_to_pk_field_db_collation(self):\n   265\t        \"\"\"Creation of models with a FK to a PK with db_collation.\"\"\"\n   266\t        collation = connection.features.test_collations.get(\"non_default\")\n   267\t        if not collation:\n   268\t            self.skipTest(\"Language collations are not supported.\")\n   269\t\n   270\t        app_label = \"test_cfkmtopkfdbc\"\n   271\t        operations = [\n   272\t            migrations.CreateModel(\n   273\t                \"Pony\",\n   274\t                [\n   275\t                    (\n   276\t                        \"id\",\n   277\t                        models.CharField(\n   278\t                            primary_key=True,\n   279\t                            max_length=10,\n   280\t                            db_collation=collation,\n   281\t                        ),\n   282\t                    ),\n   283\t                ],\n   284\t            )\n   285\t        ]\n   286\t        project_state = self.apply_operations(app_label, ProjectState(), operations)\n   287\t        # ForeignKey.\n   288\t        new_state = project_state.clone()\n   289\t        operation = migrations.CreateModel(\n   290\t            \"Rider\",\n   291\t            [\n   292\t                (\"id\", models.AutoField(primary_key=True)),\n   293\t                (\"pony\", models.ForeignKey(\"Pony\", models.CASCADE)),\n   294\t            ],\n   295\t        )\n   296\t        operation.state_forwards(app_label, new_state)\n   297\t        with connection.schema_editor() as editor:\n   298\t            operation.database_forwards(app_label, editor, project_state, new_state)\n   299\t        self.assertColumnCollation(f\"{app_label}_rider\", \"pony_id\", collation)\n   300\t        # Reversal.\n   301\t        with connection.schema_editor() as editor:\n   302\t            operation.database_backwards(app_label, editor, new_state, project_state)\n   303\t        # OneToOneField.\n   304\t        new_state = project_state.clone()\n   305\t        operation = migrations.CreateModel(\n   306\t            \"ShetlandPony\",\n   307\t            [\n   308\t                (\n   309\t                    \"pony\",\n   310\t                    models.OneToOneField(\"Pony\", models.CASCADE, primary_key=True),\n   311\t                ),\n   312\t                (\"cuteness\", models.IntegerField(default=1)),\n   313\t            ],\n   314\t        )\n   315\t        operation.state_forwards(app_label, new_state)\n   316\t        with connection.schema_editor() as editor:\n   317\t            operation.database_forwards(app_label, editor, project_state, new_state)\n   318\t        self.assertColumnCollation(f\"{app_label}_shetlandpony\", \"pony_id\", collation)\n   319\t        # Reversal.\n   320\t        with connection.schema_editor() as editor:\n   321\t            operation.database_backwards(app_label, editor, new_state, project_state)\n   322\t\n   323\t    def test_create_model_inheritance(self):\n   324\t        \"\"\"\n   325\t        Tests the CreateModel operation on a multi-table inheritance setup.\n   326\t        \"\"\"\n   327\t        project_state = self.set_up_test_model(\"test_crmoih\")\n   328\t        # Test the state alteration\n   329\t        operation = migrations.CreateModel(\n   330\t            \"ShetlandPony\",\n   331\t            [\n   332\t                (\n   333\t                    \"pony_ptr\",\n   334\t                    models.OneToOneField(\n   335\t                        \"test_crmoih.Pony\",\n   336\t                        models.CASCADE,\n   337\t                        auto_created=True,\n   338\t                        primary_key=True,\n   339\t                        to_field=\"id\",\n   340\t                        serialize=False,\n   341\t                    ),\n   342\t                ),\n   343\t                (\"cuteness\", models.IntegerField(default=1)),\n   344\t            ],\n   345\t        )\n   346\t        new_state = project_state.clone()\n   347\t        operation.state_forwards(\"test_crmoih\", new_state)\n   348\t        self.assertIn((\"test_crmoih\", \"shetlandpony\"), new_state.models)\n   349\t        # Test the database alteration\n   350\t        self.assertTableNotExists(\"test_crmoih_shetlandpony\")\n   351\t        with connection.schema_editor() as editor:\n   352\t            operation.database_forwards(\"test_crmoih\", editor, project_state, new_state)\n   353\t        self.assertTableExists(\"test_crmoih_shetlandpony\")\n   354\t        # And test reversal\n   355\t        with connection.schema_editor() as editor:\n   356\t            operation.database_backwards(\n   357\t                \"test_crmoih\", editor, new_state, project_state\n   358\t            )\n   359\t        self.assertTableNotExists(\"test_crmoih_shetlandpony\")\n   360\t\n   361\t    def test_create_proxy_model(self):\n   362\t        \"\"\"\n   363\t        CreateModel ignores proxy models.\n   364\t        \"\"\"\n   365\t        project_state = self.set_up_test_model(\"test_crprmo\")\n   366\t        # Test the state alteration\n   367\t        operation = migrations.CreateModel(\n   368\t            \"ProxyPony\",\n   369\t            [],\n   370\t            options={\"proxy\": True},\n   371\t            bases=(\"test_crprmo.Pony\",),\n   372\t        )\n   373\t        self.assertEqual(operation.describe(), \"Create proxy model ProxyPony\")\n   374\t        new_state = project_state.clone()\n   375\t        operation.state_forwards(\"test_crprmo\", new_state)\n   376\t        self.assertIn((\"test_crprmo\", \"proxypony\"), new_state.models)\n   377\t        # Test the database alteration\n   378\t        self.assertTableNotExists(\"test_crprmo_proxypony\")\n   379\t        self.assertTableExists(\"test_crprmo_pony\")\n   380\t        with connection.schema_editor() as editor:\n   381\t            operation.database_forwards(\"test_crprmo\", editor, project_state, new_state)\n   382\t        self.assertTableNotExists(\"test_crprmo_proxypony\")\n   383\t        self.assertTableExists(\"test_crprmo_pony\")\n   384\t        # And test reversal\n   385\t        with connection.schema_editor() as editor:\n   386\t            operation.database_backwards(\n   387\t                \"test_crprmo\", editor, new_state, project_state\n   388\t            )\n   389\t        self.assertTableNotExists(\"test_crprmo_proxypony\")\n   390\t        self.assertTableExists(\"test_crprmo_pony\")\n   391\t        # And deconstruction\n   392\t        definition = operation.deconstruct()\n   393\t        self.assertEqual(definition[0], \"CreateModel\")\n   394\t        self.assertEqual(definition[1], [])\n   395\t        self.assertEqual(sorted(definition[2]), [\"bases\", \"fields\", \"name\", \"options\"])\n   396\t\n   397\t    def test_create_unmanaged_model(self):\n   398\t        \"\"\"\n   399\t        CreateModel ignores unmanaged models.\n   400\t        \"\"\"\n   401\t        project_state = self.set_up_test_model(\"test_crummo\")\n   402\t        # Test the state alteration\n   403\t        operation = migrations.CreateModel(\n   404\t            \"UnmanagedPony\",\n   405\t            [],\n   406\t            options={\"proxy\": True},\n   407\t            bases=(\"test_crummo.Pony\",),\n   408\t        )\n   409\t        self.assertEqual(operation.describe(), \"Create proxy model UnmanagedPony\")\n   410\t        new_state = project_state.clone()\n   411\t        operation.state_forwards(\"test_crummo\", new_state)\n   412\t        self.assertIn((\"test_crummo\", \"unmanagedpony\"), new_state.models)\n   413\t        # Test the database alteration\n   414\t        self.assertTableNotExists(\"test_crummo_unmanagedpony\")\n   415\t        self.assertTableExists(\"test_crummo_pony\")\n   416\t        with connection.schema_editor() as editor:\n   417\t            operation.database_forwards(\"test_crummo\", editor, project_state, new_state)\n   418\t        self.assertTableNotExists(\"test_crummo_unmanagedpony\")\n   419\t        self.assertTableExists(\"test_crummo_pony\")\n   420\t        # And test reversal\n   421\t        with connection.schema_editor() as editor:\n   422\t            operation.database_backwards(\n   423\t                \"test_crummo\", editor, new_state, project_state\n   424\t            )\n   425\t        self.assertTableNotExists(\"test_crummo_unmanagedpony\")\n   426\t        self.assertTableExists(\"test_crummo_pony\")\n   427\t\n   428\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n   429\t    def test_create_model_with_constraint(self):\n   430\t        where = models.Q(pink__gt=2)\n   431\t        check_constraint = models.CheckConstraint(\n   432\t            check=where, name=\"test_constraint_pony_pink_gt_2\"\n   433\t        )\n   434\t        operation = migrations.CreateModel(\n   435\t            \"Pony\",\n   436\t            [\n   437\t                (\"id\", models.AutoField(primary_key=True)),\n   438\t                (\"pink\", models.IntegerField(default=3)),\n   439\t            ],\n   440\t            options={\"constraints\": [check_constraint]},\n   441\t        )\n   442\t\n   443\t        # Test the state alteration\n   444\t        project_state = ProjectState()\n   445\t        new_state = project_state.clone()\n   446\t        operation.state_forwards(\"test_crmo\", new_state)\n   447\t        self.assertEqual(\n   448\t            len(new_state.models[\"test_crmo\", \"pony\"].options[\"constraints\"]), 1\n   449\t        )\n   450\t\n   451\t        # Test database alteration\n   452\t        self.assertTableNotExists(\"test_crmo_pony\")\n   453\t        with connection.schema_editor() as editor:\n   454\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n   455\t        self.assertTableExists(\"test_crmo_pony\")\n   456\t        with connection.cursor() as cursor:\n   457\t            with self.assertRaises(IntegrityError):\n   458\t                cursor.execute(\"INSERT INTO test_crmo_pony (id, pink) VALUES (1, 1)\")\n   459\t\n   460\t        # Test reversal\n   461\t        with connection.schema_editor() as editor:\n   462\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n   463\t        self.assertTableNotExists(\"test_crmo_pony\")\n   464\t\n   465\t        # Test deconstruction\n   466\t        definition = operation.deconstruct()\n   467\t        self.assertEqual(definition[0], \"CreateModel\")\n   468\t        self.assertEqual(definition[1], [])\n   469\t        self.assertEqual(definition[2][\"options\"][\"constraints\"], [check_constraint])\n   470\t\n   471\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n   472\t    def test_create_model_with_boolean_expression_in_check_constraint(self):\n   473\t        app_label = \"test_crmobechc\"\n   474\t        rawsql_constraint = models.CheckConstraint(\n   475\t            check=models.expressions.RawSQL(\n   476\t                \"price < %s\", (1000,), output_field=models.BooleanField()\n   477\t            ),\n   478\t            name=f\"{app_label}_price_lt_1000_raw\",\n   479\t        )\n   480\t        wrapper_constraint = models.CheckConstraint(\n   481\t            check=models.expressions.ExpressionWrapper(\n   482\t                models.Q(price__gt=500) | models.Q(price__lt=500),\n   483\t                output_field=models.BooleanField(),\n   484\t            ),\n   485\t            name=f\"{app_label}_price_neq_500_wrap\",\n   486\t        )\n   487\t        operation = migrations.CreateModel(\n   488\t            \"Product\",\n   489\t            [\n   490\t                (\"id\", models.AutoField(primary_key=True)),\n   491\t                (\"price\", models.IntegerField(null=True)),\n   492\t            ],\n   493\t            options={\"constraints\": [rawsql_constraint, wrapper_constraint]},\n   494\t        )\n   495\t\n   496\t        project_state = ProjectState()\n   497\t        new_state = project_state.clone()\n   498\t        operation.state_forwards(app_label, new_state)\n   499\t        # Add table.\n   500\t        self.assertTableNotExists(app_label)\n   501\t        with connection.schema_editor() as editor:\n   502\t            operation.database_forwards(app_label, editor, project_state, new_state)\n   503\t        self.assertTableExists(f\"{app_label}_product\")\n   504\t        insert_sql = f\"INSERT INTO {app_label}_product (id, price) VALUES (%d, %d)\"\n   505\t        with connection.cursor() as cursor:\n   506\t            with self.assertRaises(IntegrityError):\n   507\t                cursor.execute(insert_sql % (1, 1000))\n   508\t            cursor.execute(insert_sql % (1, 999))\n   509\t            with self.assertRaises(IntegrityError):\n   510\t                cursor.execute(insert_sql % (2, 500))\n   511\t            cursor.execute(insert_sql % (2, 499))\n   512\t\n   513\t    def test_create_model_with_partial_unique_constraint(self):\n   514\t        partial_unique_constraint = models.UniqueConstraint(\n   515\t            fields=[\"pink\"],\n   516\t            condition=models.Q(weight__gt=5),\n   517\t            name=\"test_constraint_pony_pink_for_weight_gt_5_uniq\",\n   518\t        )\n   519\t        operation = migrations.CreateModel(\n   520\t            \"Pony\",\n   521\t            [\n   522\t                (\"id\", models.AutoField(primary_key=True)),\n   523\t                (\"pink\", models.IntegerField(default=3)),\n   524\t                (\"weight\", models.FloatField()),\n   525\t            ],\n   526\t            options={\"constraints\": [partial_unique_constraint]},\n   527\t        )\n   528\t        # Test the state alteration\n   529\t        project_state = ProjectState()\n   530\t        new_state = project_state.clone()\n   531\t        operation.state_forwards(\"test_crmo\", new_state)\n   532\t        self.assertEqual(\n   533\t            len(new_state.models[\"test_crmo\", \"pony\"].options[\"constraints\"]), 1\n   534\t        )\n   535\t        # Test database alteration\n   536\t        self.assertTableNotExists(\"test_crmo_pony\")\n   537\t        with connection.schema_editor() as editor:\n   538\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n   539\t        self.assertTableExists(\"test_crmo_pony\")\n   540\t        # Test constraint works\n   541\t        Pony = new_state.apps.get_model(\"test_crmo\", \"Pony\")\n   542\t        Pony.objects.create(pink=1, weight=4.0)\n   543\t        Pony.objects.create(pink=1, weight=4.0)\n   544\t        Pony.objects.create(pink=1, weight=6.0)\n   545\t        if connection.features.supports_partial_indexes:\n   546\t            with self.assertRaises(IntegrityError):\n   547\t                Pony.objects.create(pink=1, weight=7.0)\n   548\t        else:\n   549\t            Pony.objects.create(pink=1, weight=7.0)\n   550\t        # Test reversal\n   551\t        with connection.schema_editor() as editor:\n   552\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n   553\t        self.assertTableNotExists(\"test_crmo_pony\")\n   554\t        # Test deconstruction\n   555\t        definition = operation.deconstruct()\n   556\t        self.assertEqual(definition[0], \"CreateModel\")\n   557\t        self.assertEqual(definition[1], [])\n   558\t        self.assertEqual(\n   559\t            definition[2][\"options\"][\"constraints\"], [partial_unique_constraint]\n   560\t        )\n   561\t\n   562\t    def test_create_model_with_deferred_unique_constraint(self):\n   563\t        deferred_unique_constraint = models.UniqueConstraint(\n   564\t            fields=[\"pink\"],\n   565\t            name=\"deferrable_pink_constraint\",\n   566\t            deferrable=models.Deferrable.DEFERRED,\n   567\t        )\n   568\t        operation = migrations.CreateModel(\n   569\t            \"Pony\",\n   570\t            [\n   571\t                (\"id\", models.AutoField(primary_key=True)),\n   572\t                (\"pink\", models.IntegerField(default=3)),\n   573\t            ],\n   574\t            options={\"constraints\": [deferred_unique_constraint]},\n   575\t        )\n   576\t        project_state = ProjectState()\n   577\t        new_state = project_state.clone()\n   578\t        operation.state_forwards(\"test_crmo\", new_state)\n   579\t        self.assertEqual(\n   580\t            len(new_state.models[\"test_crmo\", \"pony\"].options[\"constraints\"]), 1\n   581\t        )\n   582\t        self.assertTableNotExists(\"test_crmo_pony\")\n   583\t        # Create table.\n   584\t        with connection.schema_editor() as editor:\n   585\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n   586\t        self.assertTableExists(\"test_crmo_pony\")\n   587\t        Pony = new_state.apps.get_model(\"test_crmo\", \"Pony\")\n   588\t        Pony.objects.create(pink=1)\n   589\t        if connection.features.supports_deferrable_unique_constraints:\n   590\t            # Unique constraint is deferred.\n   591\t            with transaction.atomic():\n   592\t                obj = Pony.objects.create(pink=1)\n   593\t                obj.pink = 2\n   594\t                obj.save()\n   595\t            # Constraint behavior can be changed with SET CONSTRAINTS.\n   596\t            with self.assertRaises(IntegrityError):\n   597\t                with transaction.atomic(), connection.cursor() as cursor:\n   598\t                    quoted_name = connection.ops.quote_name(\n   599\t                        deferred_unique_constraint.name\n   600\t                    )\n   601\t                    cursor.execute(\"SET CONSTRAINTS %s IMMEDIATE\" % quoted_name)\n   602\t                    obj = Pony.objects.create(pink=1)\n   603\t                    obj.pink = 3\n   604\t                    obj.save()\n   605\t        else:\n   606\t            Pony.objects.create(pink=1)\n   607\t        # Reversal.\n   608\t        with connection.schema_editor() as editor:\n   609\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n   610\t        self.assertTableNotExists(\"test_crmo_pony\")\n   611\t        # Deconstruction.\n   612\t        definition = operation.deconstruct()\n   613\t        self.assertEqual(definition[0], \"CreateModel\")\n   614\t        self.assertEqual(definition[1], [])\n   615\t        self.assertEqual(\n   616\t            definition[2][\"options\"][\"constraints\"],\n   617\t            [deferred_unique_constraint],\n   618\t        )\n   619\t\n   620\t    @skipUnlessDBFeature(\"supports_covering_indexes\")\n   621\t    def test_create_model_with_covering_unique_constraint(self):\n   622\t        covering_unique_constraint = models.UniqueConstraint(\n   623\t            fields=[\"pink\"],\n   624\t            include=[\"weight\"],\n   625\t            name=\"test_constraint_pony_pink_covering_weight\",\n   626\t        )\n   627\t        operation = migrations.CreateModel(\n   628\t            \"Pony\",\n   629\t            [\n   630\t                (\"id\", models.AutoField(primary_key=True)),\n   631\t                (\"pink\", models.IntegerField(default=3)),\n   632\t                (\"weight\", models.FloatField()),\n   633\t            ],\n   634\t            options={\"constraints\": [covering_unique_constraint]},\n   635\t        )\n   636\t        project_state = ProjectState()\n   637\t        new_state = project_state.clone()\n   638\t        operation.state_forwards(\"test_crmo\", new_state)\n   639\t        self.assertEqual(\n   640\t            len(new_state.models[\"test_crmo\", \"pony\"].options[\"constraints\"]), 1\n   641\t        )\n   642\t        self.assertTableNotExists(\"test_crmo_pony\")\n   643\t        # Create table.\n   644\t        with connection.schema_editor() as editor:\n   645\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n   646\t        self.assertTableExists(\"test_crmo_pony\")\n   647\t        Pony = new_state.apps.get_model(\"test_crmo\", \"Pony\")\n   648\t        Pony.objects.create(pink=1, weight=4.0)\n   649\t        with self.assertRaises(IntegrityError):\n   650\t            Pony.objects.create(pink=1, weight=7.0)\n   651\t        # Reversal.\n   652\t        with connection.schema_editor() as editor:\n   653\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n   654\t        self.assertTableNotExists(\"test_crmo_pony\")\n   655\t        # Deconstruction.\n   656\t        definition = operation.deconstruct()\n   657\t        self.assertEqual(definition[0], \"CreateModel\")\n   658\t        self.assertEqual(definition[1], [])\n   659\t        self.assertEqual(\n   660\t            definition[2][\"options\"][\"constraints\"],\n   661\t            [covering_unique_constraint],\n   662\t        )\n   663\t\n   664\t    def test_create_model_managers(self):\n   665\t        \"\"\"\n   666\t        The managers on a model are set.\n   667\t        \"\"\"\n   668\t        project_state = self.set_up_test_model(\"test_cmoma\")\n   669\t        # Test the state alteration\n   670\t        operation = migrations.CreateModel(\n   671\t            \"Food\",\n   672\t            fields=[\n   673\t                (\"id\", models.AutoField(primary_key=True)),\n   674\t            ],\n   675\t            managers=[\n   676\t                (\"food_qs\", FoodQuerySet.as_manager()),\n   677\t                (\"food_mgr\", FoodManager(\"a\", \"b\")),\n   678\t                (\"food_mgr_kwargs\", FoodManager(\"x\", \"y\", 3, 4)),\n   679\t            ],\n   680\t        )\n   681\t        self.assertEqual(operation.describe(), \"Create model Food\")\n   682\t        new_state = project_state.clone()\n   683\t        operation.state_forwards(\"test_cmoma\", new_state)\n   684\t        self.assertIn((\"test_cmoma\", \"food\"), new_state.models)\n   685\t        managers = new_state.models[\"test_cmoma\", \"food\"].managers\n   686\t        self.assertEqual(managers[0][0], \"food_qs\")\n   687\t        self.assertIsInstance(managers[0][1], models.Manager)\n   688\t        self.assertEqual(managers[1][0], \"food_mgr\")\n   689\t        self.assertIsInstance(managers[1][1], FoodManager)\n   690\t        self.assertEqual(managers[1][1].args, (\"a\", \"b\", 1, 2))\n   691\t        self.assertEqual(managers[2][0], \"food_mgr_kwargs\")\n   692\t        self.assertIsInstance(managers[2][1], FoodManager)\n   693\t        self.assertEqual(managers[2][1].args, (\"x\", \"y\", 3, 4))\n   694\t\n   695\t    def test_delete_model(self):\n   696\t        \"\"\"\n   697\t        Tests the DeleteModel operation.\n   698\t        \"\"\"\n   699\t        project_state = self.set_up_test_model(\"test_dlmo\")\n   700\t        # Test the state alteration\n   701\t        operation = migrations.DeleteModel(\"Pony\")\n   702\t        self.assertEqual(operation.describe(), \"Delete model Pony\")\n   703\t        self.assertEqual(operation.migration_name_fragment, \"delete_pony\")\n   704\t        new_state = project_state.clone()\n   705\t        operation.state_forwards(\"test_dlmo\", new_state)\n   706\t        self.assertNotIn((\"test_dlmo\", \"pony\"), new_state.models)\n   707\t        # Test the database alteration\n   708\t        self.assertTableExists(\"test_dlmo_pony\")\n   709\t        with connection.schema_editor() as editor:\n   710\t            operation.database_forwards(\"test_dlmo\", editor, project_state, new_state)\n   711\t        self.assertTableNotExists(\"test_dlmo_pony\")\n   712\t        # And test reversal\n   713\t        with connection.schema_editor() as editor:\n   714\t            operation.database_backwards(\"test_dlmo\", editor, new_state, project_state)\n   715\t        self.assertTableExists(\"test_dlmo_pony\")\n   716\t        # And deconstruction\n   717\t        definition = operation.deconstruct()\n   718\t        self.assertEqual(definition[0], \"DeleteModel\")\n   719\t        self.assertEqual(definition[1], [])\n   720\t        self.assertEqual(list(definition[2]), [\"name\"])\n   721\t\n   722\t    def test_delete_proxy_model(self):\n   723\t        \"\"\"\n   724\t        Tests the DeleteModel operation ignores proxy models.\n   725\t        \"\"\"\n   726\t        project_state = self.set_up_test_model(\"test_dlprmo\", proxy_model=True)\n   727\t        # Test the state alteration\n   728\t        operation = migrations.DeleteModel(\"ProxyPony\")\n   729\t        new_state = project_state.clone()\n   730\t        operation.state_forwards(\"test_dlprmo\", new_state)\n   731\t        self.assertIn((\"test_dlprmo\", \"proxypony\"), project_state.models)\n   732\t        self.assertNotIn((\"test_dlprmo\", \"proxypony\"), new_state.models)\n   733\t        # Test the database alteration\n   734\t        self.assertTableExists(\"test_dlprmo_pony\")\n   735\t        self.assertTableNotExists(\"test_dlprmo_proxypony\")\n   736\t        with connection.schema_editor() as editor:\n   737\t            operation.database_forwards(\"test_dlprmo\", editor, project_state, new_state)\n   738\t        self.assertTableExists(\"test_dlprmo_pony\")\n   739\t        self.assertTableNotExists(\"test_dlprmo_proxypony\")\n   740\t        # And test reversal\n   741\t        with connection.schema_editor() as editor:\n   742\t            operation.database_backwards(\n   743\t                \"test_dlprmo\", editor, new_state, project_state\n   744\t            )\n   745\t        self.assertTableExists(\"test_dlprmo_pony\")\n   746\t        self.assertTableNotExists(\"test_dlprmo_proxypony\")\n   747\t\n   748\t    def test_delete_mti_model(self):\n   749\t        project_state = self.set_up_test_model(\"test_dlmtimo\", mti_model=True)\n   750\t        # Test the state alteration\n   751\t        operation = migrations.DeleteModel(\"ShetlandPony\")\n   752\t        new_state = project_state.clone()\n   753\t        operation.state_forwards(\"test_dlmtimo\", new_state)\n   754\t        self.assertIn((\"test_dlmtimo\", \"shetlandpony\"), project_state.models)\n   755\t        self.assertNotIn((\"test_dlmtimo\", \"shetlandpony\"), new_state.models)\n   756\t        # Test the database alteration\n   757\t        self.assertTableExists(\"test_dlmtimo_pony\")\n   758\t        self.assertTableExists(\"test_dlmtimo_shetlandpony\")\n   759\t        self.assertColumnExists(\"test_dlmtimo_shetlandpony\", \"pony_ptr_id\")\n   760\t        with connection.schema_editor() as editor:\n   761\t            operation.database_forwards(\n   762\t                \"test_dlmtimo\", editor, project_state, new_state\n   763\t            )\n   764\t        self.assertTableExists(\"test_dlmtimo_pony\")\n   765\t        self.assertTableNotExists(\"test_dlmtimo_shetlandpony\")\n   766\t        # And test reversal\n   767\t        with connection.schema_editor() as editor:\n   768\t            operation.database_backwards(\n   769\t                \"test_dlmtimo\", editor, new_state, project_state\n   770\t            )\n   771\t        self.assertTableExists(\"test_dlmtimo_pony\")\n   772\t        self.assertTableExists(\"test_dlmtimo_shetlandpony\")\n   773\t        self.assertColumnExists(\"test_dlmtimo_shetlandpony\", \"pony_ptr_id\")\n   774\t\n   775\t    def test_rename_model(self):\n   776\t        \"\"\"\n   777\t        Tests the RenameModel operation.\n   778\t        \"\"\"\n   779\t        project_state = self.set_up_test_model(\"test_rnmo\", related_model=True)\n   780\t        # Test the state alteration\n   781\t        operation = migrations.RenameModel(\"Pony\", \"Horse\")\n   782\t        self.assertEqual(operation.describe(), \"Rename model Pony to Horse\")\n   783\t        self.assertEqual(operation.migration_name_fragment, \"rename_pony_horse\")\n   784\t        # Test initial state and database\n   785\t        self.assertIn((\"test_rnmo\", \"pony\"), project_state.models)\n   786\t        self.assertNotIn((\"test_rnmo\", \"horse\"), project_state.models)\n   787\t        self.assertTableExists(\"test_rnmo_pony\")\n   788\t        self.assertTableNotExists(\"test_rnmo_horse\")\n   789\t        if connection.features.supports_foreign_keys:\n   790\t            self.assertFKExists(\n   791\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_pony\", \"id\")\n   792\t            )\n   793\t            self.assertFKNotExists(\n   794\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_horse\", \"id\")\n   795\t            )\n   796\t        # Migrate forwards\n   797\t        new_state = project_state.clone()\n   798\t        atomic_rename = connection.features.supports_atomic_references_rename\n   799\t        new_state = self.apply_operations(\n   800\t            \"test_rnmo\", new_state, [operation], atomic=atomic_rename\n   801\t        )\n   802\t        # Test new state and database\n   803\t        self.assertNotIn((\"test_rnmo\", \"pony\"), new_state.models)\n   804\t        self.assertIn((\"test_rnmo\", \"horse\"), new_state.models)\n   805\t        # RenameModel also repoints all incoming FKs and M2Ms\n   806\t        self.assertEqual(\n   807\t            new_state.models[\"test_rnmo\", \"rider\"].fields[\"pony\"].remote_field.model,\n   808\t            \"test_rnmo.Horse\",\n   809\t        )\n   810\t        self.assertTableNotExists(\"test_rnmo_pony\")\n   811\t        self.assertTableExists(\"test_rnmo_horse\")\n   812\t        if connection.features.supports_foreign_keys:\n   813\t            self.assertFKNotExists(\n   814\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_pony\", \"id\")\n   815\t            )\n   816\t            self.assertFKExists(\n   817\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_horse\", \"id\")\n   818\t            )\n   819\t        # Migrate backwards\n   820\t        original_state = self.unapply_operations(\n   821\t            \"test_rnmo\", project_state, [operation], atomic=atomic_rename\n   822\t        )\n   823\t        # Test original state and database\n   824\t        self.assertIn((\"test_rnmo\", \"pony\"), original_state.models)\n   825\t        self.assertNotIn((\"test_rnmo\", \"horse\"), original_state.models)\n   826\t        self.assertEqual(\n   827\t            original_state.models[\"test_rnmo\", \"rider\"]\n   828\t            .fields[\"pony\"]\n   829\t            .remote_field.model,\n   830\t            \"Pony\",\n   831\t        )\n   832\t        self.assertTableExists(\"test_rnmo_pony\")\n   833\t        self.assertTableNotExists(\"test_rnmo_horse\")\n   834\t        if connection.features.supports_foreign_keys:\n   835\t            self.assertFKExists(\n   836\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_pony\", \"id\")\n   837\t            )\n   838\t            self.assertFKNotExists(\n   839\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_horse\", \"id\")\n   840\t            )\n   841\t        # And deconstruction\n   842\t        definition = operation.deconstruct()\n   843\t        self.assertEqual(definition[0], \"RenameModel\")\n   844\t        self.assertEqual(definition[1], [])\n   845\t        self.assertEqual(definition[2], {\"old_name\": \"Pony\", \"new_name\": \"Horse\"})\n   846\t\n   847\t    def test_rename_model_state_forwards(self):\n   848\t        \"\"\"\n   849\t        RenameModel operations shouldn't trigger the caching of rendered apps\n   850\t        on state without prior apps.\n   851\t        \"\"\"\n   852\t        state = ProjectState()\n   853\t        state.add_model(ModelState(\"migrations\", \"Foo\", []))\n   854\t        operation = migrations.RenameModel(\"Foo\", \"Bar\")\n   855\t        operation.state_forwards(\"migrations\", state)\n   856\t        self.assertNotIn(\"apps\", state.__dict__)\n   857\t        self.assertNotIn((\"migrations\", \"foo\"), state.models)\n   858\t        self.assertIn((\"migrations\", \"bar\"), state.models)\n   859\t        # Now with apps cached.\n   860\t        apps = state.apps\n   861\t        operation = migrations.RenameModel(\"Bar\", \"Foo\")\n   862\t        operation.state_forwards(\"migrations\", state)\n   863\t        self.assertIs(state.apps, apps)\n   864\t        self.assertNotIn((\"migrations\", \"bar\"), state.models)\n   865\t        self.assertIn((\"migrations\", \"foo\"), state.models)\n   866\t\n   867\t    def test_rename_model_with_self_referential_fk(self):\n   868\t        \"\"\"\n   869\t        Tests the RenameModel operation on model with self referential FK.\n   870\t        \"\"\"\n   871\t        project_state = self.set_up_test_model(\"test_rmwsrf\", related_model=True)\n   872\t        # Test the state alteration\n   873\t        operation = migrations.RenameModel(\"Rider\", \"HorseRider\")\n   874\t        self.assertEqual(operation.describe(), \"Rename model Rider to HorseRider\")\n   875\t        new_state = project_state.clone()\n   876\t        operation.state_forwards(\"test_rmwsrf\", new_state)\n   877\t        self.assertNotIn((\"test_rmwsrf\", \"rider\"), new_state.models)\n   878\t        self.assertIn((\"test_rmwsrf\", \"horserider\"), new_state.models)\n   879\t        # Remember, RenameModel also repoints all incoming FKs and M2Ms\n   880\t        self.assertEqual(\n   881\t            \"self\",\n   882\t            new_state.models[\"test_rmwsrf\", \"horserider\"]\n   883\t            .fields[\"friend\"]\n   884\t            .remote_field.model,\n   885\t        )\n   886\t        HorseRider = new_state.apps.get_model(\"test_rmwsrf\", \"horserider\")\n   887\t        self.assertIs(\n   888\t            HorseRider._meta.get_field(\"horserider\").remote_field.model, HorseRider\n   889\t        )\n   890\t        # Test the database alteration\n   891\t        self.assertTableExists(\"test_rmwsrf_rider\")\n   892\t        self.assertTableNotExists(\"test_rmwsrf_horserider\")\n   893\t        if connection.features.supports_foreign_keys:\n   894\t            self.assertFKExists(\n   895\t                \"test_rmwsrf_rider\", [\"friend_id\"], (\"test_rmwsrf_rider\", \"id\")\n   896\t            )\n   897\t            self.assertFKNotExists(\n   898\t                \"test_rmwsrf_rider\", [\"friend_id\"], (\"test_rmwsrf_horserider\", \"id\")\n   899\t            )\n   900\t        atomic_rename = connection.features.supports_atomic_references_rename\n   901\t        with connection.schema_editor(atomic=atomic_rename) as editor:\n   902\t            operation.database_forwards(\"test_rmwsrf\", editor, project_state, new_state)\n   903\t        self.assertTableNotExists(\"test_rmwsrf_rider\")\n   904\t        self.assertTableExists(\"test_rmwsrf_horserider\")\n   905\t        if connection.features.supports_foreign_keys:\n   906\t            self.assertFKNotExists(\n   907\t                \"test_rmwsrf_horserider\", [\"friend_id\"], (\"test_rmwsrf_rider\", \"id\")\n   908\t            )\n   909\t            self.assertFKExists(\n   910\t                \"test_rmwsrf_horserider\",\n   911\t                [\"friend_id\"],\n   912\t                (\"test_rmwsrf_horserider\", \"id\"),\n   913\t            )\n   914\t        # And test reversal\n   915\t        with connection.schema_editor(atomic=atomic_rename) as editor:\n   916\t            operation.database_backwards(\n   917\t                \"test_rmwsrf\", editor, new_state, project_state\n   918\t            )\n   919\t        self.assertTableExists(\"test_rmwsrf_rider\")\n   920\t        self.assertTableNotExists(\"test_rmwsrf_horserider\")\n   921\t        if connection.features.supports_foreign_keys:\n   922\t            self.assertFKExists(\n   923\t                \"test_rmwsrf_rider\", [\"friend_id\"], (\"test_rmwsrf_rider\", \"id\")\n   924\t            )\n   925\t            self.assertFKNotExists(\n   926\t                \"test_rmwsrf_rider\", [\"friend_id\"], (\"test_rmwsrf_horserider\", \"id\")\n   927\t            )\n   928\t\n   929\t    def test_rename_model_with_superclass_fk(self):\n   930\t        \"\"\"\n   931\t        Tests the RenameModel operation on a model which has a superclass that\n   932\t        has a foreign key.\n   933\t        \"\"\"\n   934\t        project_state = self.set_up_test_model(\n   935\t            \"test_rmwsc\", related_model=True, mti_model=True\n   936\t        )\n   937\t        # Test the state alteration\n   938\t        operation = migrations.RenameModel(\"ShetlandPony\", \"LittleHorse\")\n   939\t        self.assertEqual(\n   940\t            operation.describe(), \"Rename model ShetlandPony to LittleHorse\"\n   941\t        )\n   942\t        new_state = project_state.clone()\n   943\t        operation.state_forwards(\"test_rmwsc\", new_state)\n   944\t        self.assertNotIn((\"test_rmwsc\", \"shetlandpony\"), new_state.models)\n   945\t        self.assertIn((\"test_rmwsc\", \"littlehorse\"), new_state.models)\n   946\t        # RenameModel shouldn't repoint the superclass's relations, only local ones\n   947\t        self.assertEqual(\n   948\t            project_state.models[\"test_rmwsc\", \"rider\"]\n   949\t            .fields[\"pony\"]\n   950\t            .remote_field.model,\n   951\t            new_state.models[\"test_rmwsc\", \"rider\"].fields[\"pony\"].remote_field.model,\n   952\t        )\n   953\t        # Before running the migration we have a table for Shetland Pony, not\n   954\t        # Little Horse.\n   955\t        self.assertTableExists(\"test_rmwsc_shetlandpony\")\n   956\t        self.assertTableNotExists(\"test_rmwsc_littlehorse\")\n   957\t        if connection.features.supports_foreign_keys:\n   958\t            # and the foreign key on rider points to pony, not shetland pony\n   959\t            self.assertFKExists(\n   960\t                \"test_rmwsc_rider\", [\"pony_id\"], (\"test_rmwsc_pony\", \"id\")\n   961\t            )\n   962\t            self.assertFKNotExists(\n   963\t                \"test_rmwsc_rider\", [\"pony_id\"], (\"test_rmwsc_shetlandpony\", \"id\")\n   964\t            )\n   965\t        with connection.schema_editor(\n   966\t            atomic=connection.features.supports_atomic_references_rename\n   967\t        ) as editor:\n   968\t            operation.database_forwards(\"test_rmwsc\", editor, project_state, new_state)\n   969\t        # Now we have a little horse table, not shetland pony\n   970\t        self.assertTableNotExists(\"test_rmwsc_shetlandpony\")\n   971\t        self.assertTableExists(\"test_rmwsc_littlehorse\")\n   972\t        if connection.features.supports_foreign_keys:\n   973\t            # but the Foreign keys still point at pony, not little horse\n   974\t            self.assertFKExists(\n   975\t                \"test_rmwsc_rider\", [\"pony_id\"], (\"test_rmwsc_pony\", \"id\")\n   976\t            )\n   977\t            self.assertFKNotExists(\n   978\t                \"test_rmwsc_rider\", [\"pony_id\"], (\"test_rmwsc_littlehorse\", \"id\")\n   979\t            )\n   980\t\n   981\t    def test_rename_model_with_self_referential_m2m(self):\n   982\t        app_label = \"test_rename_model_with_self_referential_m2m\"\n   983\t\n   984\t        project_state = self.apply_operations(\n   985\t            app_label,\n   986\t            ProjectState(),\n   987\t            operations=[\n   988\t                migrations.CreateModel(\n   989\t                    \"ReflexivePony\",\n   990\t                    fields=[\n   991\t                        (\"id\", models.AutoField(primary_key=True)),\n   992\t                        (\"ponies\", models.ManyToManyField(\"self\")),\n   993\t                    ],\n   994\t                ),\n   995\t            ],\n   996\t        )\n   997\t        project_state = self.apply_operations(\n   998\t            app_label,\n   999\t            project_state,\n  1000\t            operations=[\n  1001\t                migrations.RenameModel(\"ReflexivePony\", \"ReflexivePony2\"),\n  1002\t            ],\n  1003\t            atomic=connection.features.supports_atomic_references_rename,\n  1004\t        )\n  1005\t        Pony = project_state.apps.get_model(app_label, \"ReflexivePony2\")\n  1006\t        pony = Pony.objects.create()\n  1007\t        pony.ponies.add(pony)\n  1008\t\n  1009\t    def test_rename_model_with_m2m(self):\n  1010\t        app_label = \"test_rename_model_with_m2m\"\n  1011\t        project_state = self.apply_operations(\n  1012\t            app_label,\n  1013\t            ProjectState(),\n  1014\t            operations=[\n  1015\t                migrations.CreateModel(\n  1016\t                    \"Rider\",\n  1017\t                    fields=[\n  1018\t                        (\"id\", models.AutoField(primary_key=True)),\n  1019\t                    ],\n  1020\t                ),\n  1021\t                migrations.CreateModel(\n  1022\t                    \"Pony\",\n  1023\t                    fields=[\n  1024\t                        (\"id\", models.AutoField(primary_key=True)),\n  1025\t                        (\"riders\", models.ManyToManyField(\"Rider\")),\n  1026\t                    ],\n  1027\t                ),\n  1028\t            ],\n  1029\t        )\n  1030\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1031\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1032\t        pony = Pony.objects.create()\n  1033\t        rider = Rider.objects.create()\n  1034\t        pony.riders.add(rider)\n  1035\t\n  1036\t        project_state = self.apply_operations(\n  1037\t            app_label,\n  1038\t            project_state,\n  1039\t            operations=[\n  1040\t                migrations.RenameModel(\"Pony\", \"Pony2\"),\n  1041\t            ],\n  1042\t            atomic=connection.features.supports_atomic_references_rename,\n  1043\t        )\n  1044\t        Pony = project_state.apps.get_model(app_label, \"Pony2\")\n  1045\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1046\t        pony = Pony.objects.create()\n  1047\t        rider = Rider.objects.create()\n  1048\t        pony.riders.add(rider)\n  1049\t        self.assertEqual(Pony.objects.count(), 2)\n  1050\t        self.assertEqual(Rider.objects.count(), 2)\n  1051\t        self.assertEqual(\n  1052\t            Pony._meta.get_field(\"riders\").remote_field.through.objects.count(), 2\n  1053\t        )\n  1054\t\n  1055\t    def test_rename_model_with_db_table_noop(self):\n  1056\t        app_label = \"test_rmwdbtn\"\n  1057\t        project_state = self.apply_operations(\n  1058\t            app_label,\n  1059\t            ProjectState(),\n  1060\t            operations=[\n  1061\t                migrations.CreateModel(\n  1062\t                    \"Rider\",\n  1063\t                    fields=[\n  1064\t                        (\"id\", models.AutoField(primary_key=True)),\n  1065\t                    ],\n  1066\t                    options={\"db_table\": \"rider\"},\n  1067\t                ),\n  1068\t                migrations.CreateModel(\n  1069\t                    \"Pony\",\n  1070\t                    fields=[\n  1071\t                        (\"id\", models.AutoField(primary_key=True)),\n  1072\t                        (\n  1073\t                            \"rider\",\n  1074\t                            models.ForeignKey(\"%s.Rider\" % app_label, models.CASCADE),\n  1075\t                        ),\n  1076\t                    ],\n  1077\t                ),\n  1078\t            ],\n  1079\t        )\n  1080\t        new_state = project_state.clone()\n  1081\t        operation = migrations.RenameModel(\"Rider\", \"Runner\")\n  1082\t        operation.state_forwards(app_label, new_state)\n  1083\t\n  1084\t        with connection.schema_editor() as editor:\n  1085\t            with self.assertNumQueries(0):\n  1086\t                operation.database_forwards(app_label, editor, project_state, new_state)\n  1087\t        with connection.schema_editor() as editor:\n  1088\t            with self.assertNumQueries(0):\n  1089\t                operation.database_backwards(\n  1090\t                    app_label, editor, new_state, project_state\n  1091\t                )\n  1092\t\n  1093\t    def test_rename_m2m_target_model(self):\n  1094\t        app_label = \"test_rename_m2m_target_model\"\n  1095\t        project_state = self.apply_operations(\n  1096\t            app_label,\n  1097\t            ProjectState(),\n  1098\t            operations=[\n  1099\t                migrations.CreateModel(\n  1100\t                    \"Rider\",\n  1101\t                    fields=[\n  1102\t                        (\"id\", models.AutoField(primary_key=True)),\n  1103\t                    ],\n  1104\t                ),\n  1105\t                migrations.CreateModel(\n  1106\t                    \"Pony\",\n  1107\t                    fields=[\n  1108\t                        (\"id\", models.AutoField(primary_key=True)),\n  1109\t                        (\"riders\", models.ManyToManyField(\"Rider\")),\n  1110\t                    ],\n  1111\t                ),\n  1112\t            ],\n  1113\t        )\n  1114\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1115\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1116\t        pony = Pony.objects.create()\n  1117\t        rider = Rider.objects.create()\n  1118\t        pony.riders.add(rider)\n  1119\t\n  1120\t        project_state = self.apply_operations(\n  1121\t            app_label,\n  1122\t            project_state,\n  1123\t            operations=[\n  1124\t                migrations.RenameModel(\"Rider\", \"Rider2\"),\n  1125\t            ],\n  1126\t            atomic=connection.features.supports_atomic_references_rename,\n  1127\t        )\n  1128\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1129\t        Rider = project_state.apps.get_model(app_label, \"Rider2\")\n  1130\t        pony = Pony.objects.create()\n  1131\t        rider = Rider.objects.create()\n  1132\t        pony.riders.add(rider)\n  1133\t        self.assertEqual(Pony.objects.count(), 2)\n  1134\t        self.assertEqual(Rider.objects.count(), 2)\n  1135\t        self.assertEqual(\n  1136\t            Pony._meta.get_field(\"riders\").remote_field.through.objects.count(), 2\n  1137\t        )\n  1138\t\n  1139\t    def test_rename_m2m_through_model(self):\n  1140\t        app_label = \"test_rename_through\"\n  1141\t        project_state = self.apply_operations(\n  1142\t            app_label,\n  1143\t            ProjectState(),\n  1144\t            operations=[\n  1145\t                migrations.CreateModel(\n  1146\t                    \"Rider\",\n  1147\t                    fields=[\n  1148\t                        (\"id\", models.AutoField(primary_key=True)),\n  1149\t                    ],\n  1150\t                ),\n  1151\t                migrations.CreateModel(\n  1152\t                    \"Pony\",\n  1153\t                    fields=[\n  1154\t                        (\"id\", models.AutoField(primary_key=True)),\n  1155\t                    ],\n  1156\t                ),\n  1157\t                migrations.CreateModel(\n  1158\t                    \"PonyRider\",\n  1159\t                    fields=[\n  1160\t                        (\"id\", models.AutoField(primary_key=True)),\n  1161\t                        (\n  1162\t                            \"rider\",\n  1163\t                            models.ForeignKey(\n  1164\t                                \"test_rename_through.Rider\", models.CASCADE\n  1165\t                            ),\n  1166\t                        ),\n  1167\t                        (\n  1168\t                            \"pony\",\n  1169\t                            models.ForeignKey(\n  1170\t                                \"test_rename_through.Pony\", models.CASCADE\n  1171\t                            ),\n  1172\t                        ),\n  1173\t                    ],\n  1174\t                ),\n  1175\t                migrations.AddField(\n  1176\t                    \"Pony\",\n  1177\t                    \"riders\",\n  1178\t                    models.ManyToManyField(\n  1179\t                        \"test_rename_through.Rider\",\n  1180\t                        through=\"test_rename_through.PonyRider\",\n  1181\t                    ),\n  1182\t                ),\n  1183\t            ],\n  1184\t        )\n  1185\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1186\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1187\t        PonyRider = project_state.apps.get_model(app_label, \"PonyRider\")\n  1188\t        pony = Pony.objects.create()\n  1189\t        rider = Rider.objects.create()\n  1190\t        PonyRider.objects.create(pony=pony, rider=rider)\n  1191\t\n  1192\t        project_state = self.apply_operations(\n  1193\t            app_label,\n  1194\t            project_state,\n  1195\t            operations=[\n  1196\t                migrations.RenameModel(\"PonyRider\", \"PonyRider2\"),\n  1197\t            ],\n  1198\t        )\n  1199\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1200\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1201\t        PonyRider = project_state.apps.get_model(app_label, \"PonyRider2\")\n  1202\t        pony = Pony.objects.first()\n  1203\t        rider = Rider.objects.create()\n  1204\t        PonyRider.objects.create(pony=pony, rider=rider)\n  1205\t        self.assertEqual(Pony.objects.count(), 1)\n  1206\t        self.assertEqual(Rider.objects.count(), 2)\n  1207\t        self.assertEqual(PonyRider.objects.count(), 2)\n  1208\t        self.assertEqual(pony.riders.count(), 2)\n  1209\t\n  1210\t    def test_rename_m2m_model_after_rename_field(self):\n  1211\t        \"\"\"RenameModel renames a many-to-many column after a RenameField.\"\"\"\n  1212\t        app_label = \"test_rename_multiple\"\n  1213\t        project_state = self.apply_operations(\n  1214\t            app_label,\n  1215\t            ProjectState(),\n  1216\t            operations=[\n  1217\t                migrations.CreateModel(\n  1218\t                    \"Pony\",\n  1219\t                    fields=[\n  1220\t                        (\"id\", models.AutoField(primary_key=True)),\n  1221\t                        (\"name\", models.CharField(max_length=20)),\n  1222\t                    ],\n  1223\t                ),\n  1224\t                migrations.CreateModel(\n  1225\t                    \"Rider\",\n  1226\t                    fields=[\n  1227\t                        (\"id\", models.AutoField(primary_key=True)),\n  1228\t                        (\n  1229\t                            \"pony\",\n  1230\t                            models.ForeignKey(\n  1231\t                                \"test_rename_multiple.Pony\", models.CASCADE\n  1232\t                            ),\n  1233\t                        ),\n  1234\t                    ],\n  1235\t                ),\n  1236\t                migrations.CreateModel(\n  1237\t                    \"PonyRider\",\n  1238\t                    fields=[\n  1239\t                        (\"id\", models.AutoField(primary_key=True)),\n  1240\t                        (\"riders\", models.ManyToManyField(\"Rider\")),\n  1241\t                    ],\n  1242\t                ),\n  1243\t                migrations.RenameField(\n  1244\t                    model_name=\"pony\", old_name=\"name\", new_name=\"fancy_name\"\n  1245\t                ),\n  1246\t                migrations.RenameModel(old_name=\"Rider\", new_name=\"Jockey\"),\n  1247\t            ],\n  1248\t            atomic=connection.features.supports_atomic_references_rename,\n  1249\t        )\n  1250\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1251\t        Jockey = project_state.apps.get_model(app_label, \"Jockey\")\n  1252\t        PonyRider = project_state.apps.get_model(app_label, \"PonyRider\")\n  1253\t        # No \"no such column\" error means the column was renamed correctly.\n  1254\t        pony = Pony.objects.create(fancy_name=\"a good name\")\n  1255\t        jockey = Jockey.objects.create(pony=pony)\n  1256\t        ponyrider = PonyRider.objects.create()\n  1257\t        ponyrider.riders.add(jockey)\n  1258\t\n  1259\t    def test_add_field(self):\n  1260\t        \"\"\"\n  1261\t        Tests the AddField operation.\n  1262\t        \"\"\"\n  1263\t        # Test the state alteration\n  1264\t        operation = migrations.AddField(\n  1265\t            \"Pony\",\n  1266\t            \"height\",\n  1267\t            models.FloatField(null=True, default=5),\n  1268\t        )\n  1269\t        self.assertEqual(operation.describe(), \"Add field height to Pony\")\n  1270\t        self.assertEqual(operation.migration_name_fragment, \"pony_height\")\n  1271\t        project_state, new_state = self.make_test_state(\"test_adfl\", operation)\n  1272\t        self.assertEqual(len(new_state.models[\"test_adfl\", \"pony\"].fields), 4)\n  1273\t        field = new_state.models[\"test_adfl\", \"pony\"].fields[\"height\"]\n  1274\t        self.assertEqual(field.default, 5)\n  1275\t        # Test the database alteration\n  1276\t        self.assertColumnNotExists(\"test_adfl_pony\", \"height\")\n  1277\t        with connection.schema_editor() as editor:\n  1278\t            operation.database_forwards(\"test_adfl\", editor, project_state, new_state)\n  1279\t        self.assertColumnExists(\"test_adfl_pony\", \"height\")\n  1280\t        # And test reversal\n  1281\t        with connection.schema_editor() as editor:\n  1282\t            operation.database_backwards(\"test_adfl\", editor, new_state, project_state)\n  1283\t        self.assertColumnNotExists(\"test_adfl_pony\", \"height\")\n  1284\t        # And deconstruction\n  1285\t        definition = operation.deconstruct()\n  1286\t        self.assertEqual(definition[0], \"AddField\")\n  1287\t        self.assertEqual(definition[1], [])\n  1288\t        self.assertEqual(sorted(definition[2]), [\"field\", \"model_name\", \"name\"])\n  1289\t\n  1290\t    def test_add_charfield(self):\n  1291\t        \"\"\"\n  1292\t        Tests the AddField operation on TextField.\n  1293\t        \"\"\"\n  1294\t        project_state = self.set_up_test_model(\"test_adchfl\")\n  1295\t\n  1296\t        Pony = project_state.apps.get_model(\"test_adchfl\", \"Pony\")\n  1297\t        pony = Pony.objects.create(weight=42)\n  1298\t\n  1299\t        new_state = self.apply_operations(\n  1300\t            \"test_adchfl\",\n  1301\t            project_state,\n  1302\t            [\n  1303\t                migrations.AddField(\n  1304\t                    \"Pony\",\n  1305\t                    \"text\",\n  1306\t                    models.CharField(max_length=10, default=\"some text\"),\n  1307\t                ),\n  1308\t                migrations.AddField(\n  1309\t                    \"Pony\",\n  1310\t                    \"empty\",\n  1311\t                    models.CharField(max_length=10, default=\"\"),\n  1312\t                ),\n  1313\t                # If not properly quoted digits would be interpreted as an int.\n  1314\t                migrations.AddField(\n  1315\t                    \"Pony\",\n  1316\t                    \"digits\",\n  1317\t                    models.CharField(max_length=10, default=\"42\"),\n  1318\t                ),\n  1319\t                # Manual quoting is fragile and could trip on quotes. Refs #xyz.\n  1320\t                migrations.AddField(\n  1321\t                    \"Pony\",\n  1322\t                    \"quotes\",\n  1323\t                    models.CharField(max_length=10, default='\"\\'\"'),\n  1324\t                ),\n  1325\t            ],\n  1326\t        )\n  1327\t\n  1328\t        Pony = new_state.apps.get_model(\"test_adchfl\", \"Pony\")\n  1329\t        pony = Pony.objects.get(pk=pony.pk)\n  1330\t        self.assertEqual(pony.text, \"some text\")\n  1331\t        self.assertEqual(pony.empty, \"\")\n  1332\t        self.assertEqual(pony.digits, \"42\")\n  1333\t        self.assertEqual(pony.quotes, '\"\\'\"')\n  1334\t\n  1335\t    def test_add_textfield(self):\n  1336\t        \"\"\"\n  1337\t        Tests the AddField operation on TextField.\n  1338\t        \"\"\"\n  1339\t        project_state = self.set_up_test_model(\"test_adtxtfl\")\n  1340\t\n  1341\t        Pony = project_state.apps.get_model(\"test_adtxtfl\", \"Pony\")\n  1342\t        pony = Pony.objects.create(weight=42)\n  1343\t\n  1344\t        new_state = self.apply_operations(\n  1345\t            \"test_adtxtfl\",\n  1346\t            project_state,\n  1347\t            [\n  1348\t                migrations.AddField(\n  1349\t                    \"Pony\",\n  1350\t                    \"text\",\n  1351\t                    models.TextField(default=\"some text\"),\n  1352\t                ),\n  1353\t                migrations.AddField(\n  1354\t                    \"Pony\",\n  1355\t                    \"empty\",\n  1356\t                    models.TextField(default=\"\"),\n  1357\t                ),\n  1358\t                # If not properly quoted digits would be interpreted as an int.\n  1359\t                migrations.AddField(\n  1360\t                    \"Pony\",\n  1361\t                    \"digits\",\n  1362\t                    models.TextField(default=\"42\"),\n  1363\t                ),\n  1364\t                # Manual quoting is fragile and could trip on quotes. Refs #xyz.\n  1365\t                migrations.AddField(\n  1366\t                    \"Pony\",\n  1367\t                    \"quotes\",\n  1368\t                    models.TextField(default='\"\\'\"'),\n  1369\t                ),\n  1370\t            ],\n  1371\t        )\n  1372\t\n  1373\t        Pony = new_state.apps.get_model(\"test_adtxtfl\", \"Pony\")\n  1374\t        pony = Pony.objects.get(pk=pony.pk)\n  1375\t        self.assertEqual(pony.text, \"some text\")\n  1376\t        self.assertEqual(pony.empty, \"\")\n  1377\t        self.assertEqual(pony.digits, \"42\")\n  1378\t        self.assertEqual(pony.quotes, '\"\\'\"')\n  1379\t\n  1380\t    def test_add_binaryfield(self):\n  1381\t        \"\"\"\n  1382\t        Tests the AddField operation on TextField/BinaryField.\n  1383\t        \"\"\"\n  1384\t        project_state = self.set_up_test_model(\"test_adbinfl\")\n  1385\t\n  1386\t        Pony = project_state.apps.get_model(\"test_adbinfl\", \"Pony\")\n  1387\t        pony = Pony.objects.create(weight=42)\n  1388\t\n  1389\t        new_state = self.apply_operations(\n  1390\t            \"test_adbinfl\",\n  1391\t            project_state,\n  1392\t            [\n  1393\t                migrations.AddField(\n  1394\t                    \"Pony\",\n  1395\t                    \"blob\",\n  1396\t                    models.BinaryField(default=b\"some text\"),\n  1397\t                ),\n  1398\t                migrations.AddField(\n  1399\t                    \"Pony\",\n  1400\t                    \"empty\",\n  1401\t                    models.BinaryField(default=b\"\"),\n  1402\t                ),\n  1403\t                # If not properly quoted digits would be interpreted as an int.\n  1404\t                migrations.AddField(\n  1405\t                    \"Pony\",\n  1406\t                    \"digits\",\n  1407\t                    models.BinaryField(default=b\"42\"),\n  1408\t                ),\n  1409\t                # Manual quoting is fragile and could trip on quotes. Refs #xyz.\n  1410\t                migrations.AddField(\n  1411\t                    \"Pony\",\n  1412\t                    \"quotes\",\n  1413\t                    models.BinaryField(default=b'\"\\'\"'),\n  1414\t                ),\n  1415\t            ],\n  1416\t        )\n  1417\t\n  1418\t        Pony = new_state.apps.get_model(\"test_adbinfl\", \"Pony\")\n  1419\t        pony = Pony.objects.get(pk=pony.pk)\n  1420\t        # SQLite returns buffer/memoryview, cast to bytes for checking.\n  1421\t        self.assertEqual(bytes(pony.blob), b\"some text\")\n  1422\t        self.assertEqual(bytes(pony.empty), b\"\")\n  1423\t        self.assertEqual(bytes(pony.digits), b\"42\")\n  1424\t        self.assertEqual(bytes(pony.quotes), b'\"\\'\"')\n  1425\t\n  1426\t    def test_column_name_quoting(self):\n  1427\t        \"\"\"\n  1428\t        Column names that are SQL keywords shouldn't cause problems when used\n  1429\t        in migrations (#22168).\n  1430\t        \"\"\"\n  1431\t        project_state = self.set_up_test_model(\"test_regr22168\")\n  1432\t        operation = migrations.AddField(\n  1433\t            \"Pony\",\n  1434\t            \"order\",\n  1435\t            models.IntegerField(default=0),\n  1436\t        )\n  1437\t        new_state = project_state.clone()\n  1438\t        operation.state_forwards(\"test_regr22168\", new_state)\n  1439\t        with connection.schema_editor() as editor:\n  1440\t            operation.database_forwards(\n  1441\t                \"test_regr22168\", editor, project_state, new_state\n  1442\t            )\n  1443\t        self.assertColumnExists(\"test_regr22168_pony\", \"order\")\n  1444\t\n  1445\t    def test_add_field_preserve_default(self):\n  1446\t        \"\"\"\n  1447\t        Tests the AddField operation's state alteration\n  1448\t        when preserve_default = False.\n  1449\t        \"\"\"\n  1450\t        project_state = self.set_up_test_model(\"test_adflpd\")\n  1451\t        # Test the state alteration\n  1452\t        operation = migrations.AddField(\n  1453\t            \"Pony\",\n  1454\t            \"height\",\n  1455\t            models.FloatField(null=True, default=4),\n  1456\t            preserve_default=False,\n  1457\t        )\n  1458\t        new_state = project_state.clone()\n  1459\t        operation.state_forwards(\"test_adflpd\", new_state)\n  1460\t        self.assertEqual(len(new_state.models[\"test_adflpd\", \"pony\"].fields), 4)\n  1461\t        field = new_state.models[\"test_adflpd\", \"pony\"].fields[\"height\"]\n  1462\t        self.assertEqual(field.default, models.NOT_PROVIDED)\n  1463\t        # Test the database alteration\n  1464\t        project_state.apps.get_model(\"test_adflpd\", \"pony\").objects.create(\n  1465\t            weight=4,\n  1466\t        )\n  1467\t        self.assertColumnNotExists(\"test_adflpd_pony\", \"height\")\n  1468\t        with connection.schema_editor() as editor:\n  1469\t            operation.database_forwards(\"test_adflpd\", editor, project_state, new_state)\n  1470\t        self.assertColumnExists(\"test_adflpd_pony\", \"height\")\n  1471\t        # And deconstruction\n  1472\t        definition = operation.deconstruct()\n  1473\t        self.assertEqual(definition[0], \"AddField\")\n  1474\t        self.assertEqual(definition[1], [])\n  1475\t        self.assertEqual(\n  1476\t            sorted(definition[2]), [\"field\", \"model_name\", \"name\", \"preserve_default\"]\n  1477\t        )\n  1478\t\n  1479\t    def test_add_field_m2m(self):\n  1480\t        \"\"\"\n  1481\t        Tests the AddField operation with a ManyToManyField.\n  1482\t        \"\"\"\n  1483\t        project_state = self.set_up_test_model(\"test_adflmm\", second_model=True)\n  1484\t        # Test the state alteration\n  1485\t        operation = migrations.AddField(\n  1486\t            \"Pony\", \"stables\", models.ManyToManyField(\"Stable\", related_name=\"ponies\")\n  1487\t        )\n  1488\t        new_state = project_state.clone()\n  1489\t        operation.state_forwards(\"test_adflmm\", new_state)\n  1490\t        self.assertEqual(len(new_state.models[\"test_adflmm\", \"pony\"].fields), 4)\n  1491\t        # Test the database alteration\n  1492\t        self.assertTableNotExists(\"test_adflmm_pony_stables\")\n  1493\t        with connection.schema_editor() as editor:\n  1494\t            operation.database_forwards(\"test_adflmm\", editor, project_state, new_state)\n  1495\t        self.assertTableExists(\"test_adflmm_pony_stables\")\n  1496\t        self.assertColumnNotExists(\"test_adflmm_pony\", \"stables\")\n  1497\t        # Make sure the M2M field actually works\n  1498\t        with atomic():\n  1499\t            Pony = new_state.apps.get_model(\"test_adflmm\", \"Pony\")\n  1500\t            p = Pony.objects.create(pink=False, weight=4.55)\n  1501\t            p.stables.create()\n  1502\t            self.assertEqual(p.stables.count(), 1)\n  1503\t            p.stables.all().delete()\n  1504\t        # And test reversal\n  1505\t        with connection.schema_editor() as editor:\n  1506\t            operation.database_backwards(\n  1507\t                \"test_adflmm\", editor, new_state, project_state\n  1508\t            )\n  1509\t        self.assertTableNotExists(\"test_adflmm_pony_stables\")\n  1510\t\n  1511\t    def test_alter_field_m2m(self):\n  1512\t        project_state = self.set_up_test_model(\"test_alflmm\", second_model=True)\n  1513\t\n  1514\t        project_state = self.apply_operations(\n  1515\t            \"test_alflmm\",\n  1516\t            project_state,\n  1517\t            operations=[\n  1518\t                migrations.AddField(\n  1519\t                    \"Pony\",\n  1520\t                    \"stables\",\n  1521\t                    models.ManyToManyField(\"Stable\", related_name=\"ponies\"),\n  1522\t                )\n  1523\t            ],\n  1524\t        )\n  1525\t        Pony = project_state.apps.get_model(\"test_alflmm\", \"Pony\")\n  1526\t        self.assertFalse(Pony._meta.get_field(\"stables\").blank)\n  1527\t\n  1528\t        project_state = self.apply_operations(\n  1529\t            \"test_alflmm\",\n  1530\t            project_state,\n  1531\t            operations=[\n  1532\t                migrations.AlterField(\n  1533\t                    \"Pony\",\n  1534\t                    \"stables\",\n  1535\t                    models.ManyToManyField(\n  1536\t                        to=\"Stable\", related_name=\"ponies\", blank=True\n  1537\t                    ),\n  1538\t                )\n  1539\t            ],\n  1540\t        )\n  1541\t        Pony = project_state.apps.get_model(\"test_alflmm\", \"Pony\")\n  1542\t        self.assertTrue(Pony._meta.get_field(\"stables\").blank)\n  1543\t\n  1544\t    def test_repoint_field_m2m(self):\n  1545\t        project_state = self.set_up_test_model(\n  1546\t            \"test_alflmm\", second_model=True, third_model=True\n  1547\t        )\n  1548\t\n  1549\t        project_state = self.apply_operations(\n  1550\t            \"test_alflmm\",\n  1551\t            project_state,\n  1552\t            operations=[\n  1553\t                migrations.AddField(\n  1554\t                    \"Pony\",\n  1555\t                    \"places\",\n  1556\t                    models.ManyToManyField(\"Stable\", related_name=\"ponies\"),\n  1557\t                )\n  1558\t            ],\n  1559\t        )\n  1560\t        Pony = project_state.apps.get_model(\"test_alflmm\", \"Pony\")\n  1561\t\n  1562\t        project_state = self.apply_operations(\n  1563\t            \"test_alflmm\",\n  1564\t            project_state,\n  1565\t            operations=[\n  1566\t                migrations.AlterField(\n  1567\t                    \"Pony\",\n  1568\t                    \"places\",\n  1569\t                    models.ManyToManyField(to=\"Van\", related_name=\"ponies\"),\n  1570\t                )\n  1571\t            ],\n  1572\t        )\n  1573\t\n  1574\t        # Ensure the new field actually works\n  1575\t        Pony = project_state.apps.get_model(\"test_alflmm\", \"Pony\")\n  1576\t        p = Pony.objects.create(pink=False, weight=4.55)\n  1577\t        p.places.create()\n  1578\t        self.assertEqual(p.places.count(), 1)\n  1579\t        p.places.all().delete()\n  1580\t\n  1581\t    def test_remove_field_m2m(self):\n  1582\t        project_state = self.set_up_test_model(\"test_rmflmm\", second_model=True)\n  1583\t\n  1584\t        project_state = self.apply_operations(\n  1585\t            \"test_rmflmm\",\n  1586\t            project_state,\n  1587\t            operations=[\n  1588\t                migrations.AddField(\n  1589\t                    \"Pony\",\n  1590\t                    \"stables\",\n  1591\t                    models.ManyToManyField(\"Stable\", related_name=\"ponies\"),\n  1592\t                )\n  1593\t            ],\n  1594\t        )\n  1595\t        self.assertTableExists(\"test_rmflmm_pony_stables\")\n  1596\t\n  1597\t        with_field_state = project_state.clone()\n  1598\t        operations = [migrations.RemoveField(\"Pony\", \"stables\")]\n  1599\t        project_state = self.apply_operations(\n  1600\t            \"test_rmflmm\", project_state, operations=operations\n  1601\t        )\n  1602\t        self.assertTableNotExists(\"test_rmflmm_pony_stables\")\n  1603\t\n  1604\t        # And test reversal\n  1605\t        self.unapply_operations(\"test_rmflmm\", with_field_state, operations=operations)\n  1606\t        self.assertTableExists(\"test_rmflmm_pony_stables\")\n  1607\t\n  1608\t    def test_remove_field_m2m_with_through(self):\n  1609\t        project_state = self.set_up_test_model(\"test_rmflmmwt\", second_model=True)\n  1610\t\n  1611\t        self.assertTableNotExists(\"test_rmflmmwt_ponystables\")\n  1612\t        project_state = self.apply_operations(\n  1613\t            \"test_rmflmmwt\",\n  1614\t            project_state,\n  1615\t            operations=[\n  1616\t                migrations.CreateModel(\n  1617\t                    \"PonyStables\",\n  1618\t                    fields=[\n  1619\t                        (\n  1620\t                            \"pony\",\n  1621\t                            models.ForeignKey(\"test_rmflmmwt.Pony\", models.CASCADE),\n  1622\t                        ),\n  1623\t                        (\n  1624\t                            \"stable\",\n  1625\t                            models.ForeignKey(\"test_rmflmmwt.Stable\", models.CASCADE),\n  1626\t                        ),\n  1627\t                    ],\n  1628\t                ),\n  1629\t                migrations.AddField(\n  1630\t                    \"Pony\",\n  1631\t                    \"stables\",\n  1632\t                    models.ManyToManyField(\n  1633\t                        \"Stable\",\n  1634\t                        related_name=\"ponies\",\n  1635\t                        through=\"test_rmflmmwt.PonyStables\",\n  1636\t                    ),\n  1637\t                ),\n  1638\t            ],\n  1639\t        )\n  1640\t        self.assertTableExists(\"test_rmflmmwt_ponystables\")\n  1641\t\n  1642\t        operations = [\n  1643\t            migrations.RemoveField(\"Pony\", \"stables\"),\n  1644\t            migrations.DeleteModel(\"PonyStables\"),\n  1645\t        ]\n  1646\t        self.apply_operations(\"test_rmflmmwt\", project_state, operations=operations)\n  1647\t\n  1648\t    def test_remove_field(self):\n  1649\t        \"\"\"\n  1650\t        Tests the RemoveField operation.\n  1651\t        \"\"\"\n  1652\t        project_state = self.set_up_test_model(\"test_rmfl\")\n  1653\t        # Test the state alteration\n  1654\t        operation = migrations.RemoveField(\"Pony\", \"pink\")\n  1655\t        self.assertEqual(operation.describe(), \"Remove field pink from Pony\")\n  1656\t        self.assertEqual(operation.migration_name_fragment, \"remove_pony_pink\")\n  1657\t        new_state = project_state.clone()\n  1658\t        operation.state_forwards(\"test_rmfl\", new_state)\n  1659\t        self.assertEqual(len(new_state.models[\"test_rmfl\", \"pony\"].fields), 2)\n  1660\t        # Test the database alteration\n  1661\t        self.assertColumnExists(\"test_rmfl_pony\", \"pink\")\n  1662\t        with connection.schema_editor() as editor:\n  1663\t            operation.database_forwards(\"test_rmfl\", editor, project_state, new_state)\n  1664\t        self.assertColumnNotExists(\"test_rmfl_pony\", \"pink\")\n  1665\t        # And test reversal\n  1666\t        with connection.schema_editor() as editor:\n  1667\t            operation.database_backwards(\"test_rmfl\", editor, new_state, project_state)\n  1668\t        self.assertColumnExists(\"test_rmfl_pony\", \"pink\")\n  1669\t        # And deconstruction\n  1670\t        definition = operation.deconstruct()\n  1671\t        self.assertEqual(definition[0], \"RemoveField\")\n  1672\t        self.assertEqual(definition[1], [])\n  1673\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"name\": \"pink\"})\n  1674\t\n  1675\t    def test_remove_fk(self):\n  1676\t        \"\"\"\n  1677\t        Tests the RemoveField operation on a foreign key.\n  1678\t        \"\"\"\n  1679\t        project_state = self.set_up_test_model(\"test_rfk\", related_model=True)\n  1680\t        self.assertColumnExists(\"test_rfk_rider\", \"pony_id\")\n  1681\t        operation = migrations.RemoveField(\"Rider\", \"pony\")\n  1682\t\n  1683\t        new_state = project_state.clone()\n  1684\t        operation.state_forwards(\"test_rfk\", new_state)\n  1685\t        with connection.schema_editor() as editor:\n  1686\t            operation.database_forwards(\"test_rfk\", editor, project_state, new_state)\n  1687\t        self.assertColumnNotExists(\"test_rfk_rider\", \"pony_id\")\n  1688\t        with connection.schema_editor() as editor:\n  1689\t            operation.database_backwards(\"test_rfk\", editor, new_state, project_state)\n  1690\t        self.assertColumnExists(\"test_rfk_rider\", \"pony_id\")\n  1691\t\n  1692\t    def test_alter_model_table(self):\n  1693\t        \"\"\"\n  1694\t        Tests the AlterModelTable operation.\n  1695\t        \"\"\"\n  1696\t        project_state = self.set_up_test_model(\"test_almota\")\n  1697\t        # Test the state alteration\n  1698\t        operation = migrations.AlterModelTable(\"Pony\", \"test_almota_pony_2\")\n  1699\t        self.assertEqual(\n  1700\t            operation.describe(), \"Rename table for Pony to test_almota_pony_2\"\n  1701\t        )\n  1702\t        self.assertEqual(operation.migration_name_fragment, \"alter_pony_table\")\n  1703\t        new_state = project_state.clone()\n  1704\t        operation.state_forwards(\"test_almota\", new_state)\n  1705\t        self.assertEqual(\n  1706\t            new_state.models[\"test_almota\", \"pony\"].options[\"db_table\"],\n  1707\t            \"test_almota_pony_2\",\n  1708\t        )\n  1709\t        # Test the database alteration\n  1710\t        self.assertTableExists(\"test_almota_pony\")\n  1711\t        self.assertTableNotExists(\"test_almota_pony_2\")\n  1712\t        with connection.schema_editor() as editor:\n  1713\t            operation.database_forwards(\"test_almota\", editor, project_state, new_state)\n  1714\t        self.assertTableNotExists(\"test_almota_pony\")\n  1715\t        self.assertTableExists(\"test_almota_pony_2\")\n  1716\t        # And test reversal\n  1717\t        with connection.schema_editor() as editor:\n  1718\t            operation.database_backwards(\n  1719\t                \"test_almota\", editor, new_state, project_state\n  1720\t            )\n  1721\t        self.assertTableExists(\"test_almota_pony\")\n  1722\t        self.assertTableNotExists(\"test_almota_pony_2\")\n  1723\t        # And deconstruction\n  1724\t        definition = operation.deconstruct()\n  1725\t        self.assertEqual(definition[0], \"AlterModelTable\")\n  1726\t        self.assertEqual(definition[1], [])\n  1727\t        self.assertEqual(definition[2], {\"name\": \"Pony\", \"table\": \"test_almota_pony_2\"})\n  1728\t\n  1729\t    def test_alter_model_table_none(self):\n  1730\t        \"\"\"\n  1731\t        Tests the AlterModelTable operation if the table name is set to None.\n  1732\t        \"\"\"\n  1733\t        operation = migrations.AlterModelTable(\"Pony\", None)\n  1734\t        self.assertEqual(operation.describe(), \"Rename table for Pony to (default)\")\n  1735\t\n  1736\t    def test_alter_model_table_noop(self):\n  1737\t        \"\"\"\n  1738\t        Tests the AlterModelTable operation if the table name is not changed.\n  1739\t        \"\"\"\n  1740\t        project_state = self.set_up_test_model(\"test_almota\")\n  1741\t        # Test the state alteration\n  1742\t        operation = migrations.AlterModelTable(\"Pony\", \"test_almota_pony\")\n  1743\t        new_state = project_state.clone()\n  1744\t        operation.state_forwards(\"test_almota\", new_state)\n  1745\t        self.assertEqual(\n  1746\t            new_state.models[\"test_almota\", \"pony\"].options[\"db_table\"],\n  1747\t            \"test_almota_pony\",\n  1748\t        )\n  1749\t        # Test the database alteration\n  1750\t        self.assertTableExists(\"test_almota_pony\")\n  1751\t        with connection.schema_editor() as editor:\n  1752\t            operation.database_forwards(\"test_almota\", editor, project_state, new_state)\n  1753\t        self.assertTableExists(\"test_almota_pony\")\n  1754\t        # And test reversal\n  1755\t        with connection.schema_editor() as editor:\n  1756\t            operation.database_backwards(\n  1757\t                \"test_almota\", editor, new_state, project_state\n  1758\t            )\n  1759\t        self.assertTableExists(\"test_almota_pony\")\n  1760\t\n  1761\t    def test_alter_model_table_m2m(self):\n  1762\t        \"\"\"\n  1763\t        AlterModelTable should rename auto-generated M2M tables.\n  1764\t        \"\"\"\n  1765\t        app_label = \"test_talflmltlm2m\"\n  1766\t        pony_db_table = \"pony_foo\"\n  1767\t        project_state = self.set_up_test_model(\n  1768\t            app_label, second_model=True, db_table=pony_db_table\n  1769\t        )\n  1770\t        # Add the M2M field\n  1771\t        first_state = project_state.clone()\n  1772\t        operation = migrations.AddField(\n  1773\t            \"Pony\", \"stables\", models.ManyToManyField(\"Stable\")\n  1774\t        )\n  1775\t        operation.state_forwards(app_label, first_state)\n  1776\t        with connection.schema_editor() as editor:\n  1777\t            operation.database_forwards(app_label, editor, project_state, first_state)\n  1778\t        original_m2m_table = \"%s_%s\" % (pony_db_table, \"stables\")\n  1779\t        new_m2m_table = \"%s_%s\" % (app_label, \"pony_stables\")\n  1780\t        self.assertTableExists(original_m2m_table)\n  1781\t        self.assertTableNotExists(new_m2m_table)\n  1782\t        # Rename the Pony db_table which should also rename the m2m table.\n  1783\t        second_state = first_state.clone()\n  1784\t        operation = migrations.AlterModelTable(name=\"pony\", table=None)\n  1785\t        operation.state_forwards(app_label, second_state)\n  1786\t        atomic_rename = connection.features.supports_atomic_references_rename\n  1787\t        with connection.schema_editor(atomic=atomic_rename) as editor:\n  1788\t            operation.database_forwards(app_label, editor, first_state, second_state)\n  1789\t        self.assertTableExists(new_m2m_table)\n  1790\t        self.assertTableNotExists(original_m2m_table)\n  1791\t        # And test reversal\n  1792\t        with connection.schema_editor(atomic=atomic_rename) as editor:\n  1793\t            operation.database_backwards(app_label, editor, second_state, first_state)\n  1794\t        self.assertTableExists(original_m2m_table)\n  1795\t        self.assertTableNotExists(new_m2m_table)\n  1796\t\n  1797\t    def test_alter_field(self):\n  1798\t        \"\"\"\n  1799\t        Tests the AlterField operation.\n  1800\t        \"\"\"\n  1801\t        project_state = self.set_up_test_model(\"test_alfl\")\n  1802\t        # Test the state alteration\n  1803\t        operation = migrations.AlterField(\n  1804\t            \"Pony\", \"pink\", models.IntegerField(null=True)\n  1805\t        )\n  1806\t        self.assertEqual(operation.describe(), \"Alter field pink on Pony\")\n  1807\t        self.assertEqual(operation.migration_name_fragment, \"alter_pony_pink\")\n  1808\t        new_state = project_state.clone()\n  1809\t        operation.state_forwards(\"test_alfl\", new_state)\n  1810\t        self.assertIs(\n  1811\t            project_state.models[\"test_alfl\", \"pony\"].fields[\"pink\"].null, False\n  1812\t        )\n  1813\t        self.assertIs(new_state.models[\"test_alfl\", \"pony\"].fields[\"pink\"].null, True)\n  1814\t        # Test the database alteration\n  1815\t        self.assertColumnNotNull(\"test_alfl_pony\", \"pink\")\n  1816\t        with connection.schema_editor() as editor:\n  1817\t            operation.database_forwards(\"test_alfl\", editor, project_state, new_state)\n  1818\t        self.assertColumnNull(\"test_alfl_pony\", \"pink\")\n  1819\t        # And test reversal\n  1820\t        with connection.schema_editor() as editor:\n  1821\t            operation.database_backwards(\"test_alfl\", editor, new_state, project_state)\n  1822\t        self.assertColumnNotNull(\"test_alfl_pony\", \"pink\")\n  1823\t        # And deconstruction\n  1824\t        definition = operation.deconstruct()\n  1825\t        self.assertEqual(definition[0], \"AlterField\")\n  1826\t        self.assertEqual(definition[1], [])\n  1827\t        self.assertEqual(sorted(definition[2]), [\"field\", \"model_name\", \"name\"])\n  1828\t\n  1829\t    def test_alter_field_add_db_column_noop(self):\n  1830\t        \"\"\"\n  1831\t        AlterField operation is a noop when adding only a db_column and the\n  1832\t        column name is not changed.\n  1833\t        \"\"\"\n  1834\t        app_label = \"test_afadbn\"\n  1835\t        project_state = self.set_up_test_model(app_label, related_model=True)\n  1836\t        pony_table = \"%s_pony\" % app_label\n  1837\t        new_state = project_state.clone()\n  1838\t        operation = migrations.AlterField(\n  1839\t            \"Pony\", \"weight\", models.FloatField(db_column=\"weight\")\n  1840\t        )\n  1841\t        operation.state_forwards(app_label, new_state)\n  1842\t        self.assertIsNone(\n  1843\t            project_state.models[app_label, \"pony\"].fields[\"weight\"].db_column,\n  1844\t        )\n  1845\t        self.assertEqual(\n  1846\t            new_state.models[app_label, \"pony\"].fields[\"weight\"].db_column,\n  1847\t            \"weight\",\n  1848\t        )\n  1849\t        self.assertColumnExists(pony_table, \"weight\")\n  1850\t        with connection.schema_editor() as editor:\n  1851\t            with self.assertNumQueries(0):\n  1852\t                operation.database_forwards(app_label, editor, project_state, new_state)\n  1853\t        self.assertColumnExists(pony_table, \"weight\")\n  1854\t        with connection.schema_editor() as editor:\n  1855\t            with self.assertNumQueries(0):\n  1856\t                operation.database_backwards(\n  1857\t                    app_label, editor, new_state, project_state\n  1858\t                )\n  1859\t        self.assertColumnExists(pony_table, \"weight\")\n  1860\t\n  1861\t        rider_table = \"%s_rider\" % app_label\n  1862\t        new_state = project_state.clone()\n  1863\t        operation = migrations.AlterField(\n  1864\t            \"Rider\",\n  1865\t            \"pony\",\n  1866\t            models.ForeignKey(\"Pony\", models.CASCADE, db_column=\"pony_id\"),\n  1867\t        )\n  1868\t        operation.state_forwards(app_label, new_state)\n  1869\t        self.assertIsNone(\n  1870\t            project_state.models[app_label, \"rider\"].fields[\"pony\"].db_column,\n  1871\t        )\n  1872\t        self.assertIs(\n  1873\t            new_state.models[app_label, \"rider\"].fields[\"pony\"].db_column,\n  1874\t            \"pony_id\",\n  1875\t        )\n  1876\t        self.assertColumnExists(rider_table, \"pony_id\")\n  1877\t        with connection.schema_editor() as editor:\n  1878\t            with self.assertNumQueries(0):\n  1879\t                operation.database_forwards(app_label, editor, project_state, new_state)\n  1880\t        self.assertColumnExists(rider_table, \"pony_id\")\n  1881\t        with connection.schema_editor() as editor:\n  1882\t            with self.assertNumQueries(0):\n  1883\t                operation.database_forwards(app_label, editor, new_state, project_state)\n  1884\t        self.assertColumnExists(rider_table, \"pony_id\")\n  1885\t\n  1886\t    def test_alter_field_pk(self):\n  1887\t        \"\"\"\n  1888\t        The AlterField operation on primary keys (things like PostgreSQL's\n  1889\t        SERIAL weirdness).\n  1890\t        \"\"\"\n  1891\t        project_state = self.set_up_test_model(\"test_alflpk\")\n  1892\t        # Test the state alteration\n  1893\t        operation = migrations.AlterField(\n  1894\t            \"Pony\", \"id\", models.IntegerField(primary_key=True)\n  1895\t        )\n  1896\t        new_state = project_state.clone()\n  1897\t        operation.state_forwards(\"test_alflpk\", new_state)\n  1898\t        self.assertIsInstance(\n  1899\t            project_state.models[\"test_alflpk\", \"pony\"].fields[\"id\"],\n  1900\t            models.AutoField,\n  1901\t        )\n  1902\t        self.assertIsInstance(\n  1903\t            new_state.models[\"test_alflpk\", \"pony\"].fields[\"id\"],\n  1904\t            models.IntegerField,\n  1905\t        )\n  1906\t        # Test the database alteration\n  1907\t        with connection.schema_editor() as editor:\n  1908\t            operation.database_forwards(\"test_alflpk\", editor, project_state, new_state)\n  1909\t        # And test reversal\n  1910\t        with connection.schema_editor() as editor:\n  1911\t            operation.database_backwards(\n  1912\t                \"test_alflpk\", editor, new_state, project_state\n  1913\t            )\n  1914\t\n  1915\t    @skipUnlessDBFeature(\"supports_foreign_keys\")\n  1916\t    def test_alter_field_pk_fk(self):\n  1917\t        \"\"\"\n  1918\t        Tests the AlterField operation on primary keys changes any FKs pointing to it.\n  1919\t        \"\"\"\n  1920\t        project_state = self.set_up_test_model(\"test_alflpkfk\", related_model=True)\n  1921\t        project_state = self.apply_operations(\n  1922\t            \"test_alflpkfk\",\n  1923\t            project_state,\n  1924\t            [\n  1925\t                migrations.CreateModel(\n  1926\t                    \"Stable\",\n  1927\t                    fields=[\n  1928\t                        (\"ponies\", models.ManyToManyField(\"Pony\")),\n  1929\t                    ],\n  1930\t                ),\n  1931\t                migrations.AddField(\n  1932\t                    \"Pony\",\n  1933\t                    \"stables\",\n  1934\t                    models.ManyToManyField(\"Stable\"),\n  1935\t                ),\n  1936\t            ],\n  1937\t        )\n  1938\t        # Test the state alteration\n  1939\t        operation = migrations.AlterField(\n  1940\t            \"Pony\", \"id\", models.FloatField(primary_key=True)\n  1941\t        )\n  1942\t        new_state = project_state.clone()\n  1943\t        operation.state_forwards(\"test_alflpkfk\", new_state)\n  1944\t        self.assertIsInstance(\n  1945\t            project_state.models[\"test_alflpkfk\", \"pony\"].fields[\"id\"],\n  1946\t            models.AutoField,\n  1947\t        )\n  1948\t        self.assertIsInstance(\n  1949\t            new_state.models[\"test_alflpkfk\", \"pony\"].fields[\"id\"],\n  1950\t            models.FloatField,\n  1951\t        )\n  1952\t\n  1953\t        def assertIdTypeEqualsFkType():\n  1954\t            with connection.cursor() as cursor:\n  1955\t                id_type, id_null = [\n  1956\t                    (c.type_code, c.null_ok)\n  1957\t                    for c in connection.introspection.get_table_description(\n  1958\t                        cursor, \"test_alflpkfk_pony\"\n  1959\t                    )\n  1960\t                    if c.name == \"id\"\n  1961\t                ][0]\n  1962\t                fk_type, fk_null = [\n  1963\t                    (c.type_code, c.null_ok)\n  1964\t                    for c in connection.introspection.get_table_description(\n  1965\t                        cursor, \"test_alflpkfk_rider\"\n  1966\t                    )\n  1967\t                    if c.name == \"pony_id\"\n  1968\t                ][0]\n  1969\t                m2m_fk_type, m2m_fk_null = [\n  1970\t                    (c.type_code, c.null_ok)\n  1971\t                    for c in connection.introspection.get_table_description(\n  1972\t                        cursor,\n  1973\t                        \"test_alflpkfk_pony_stables\",\n  1974\t                    )\n  1975\t                    if c.name == \"pony_id\"\n  1976\t                ][0]\n  1977\t                remote_m2m_fk_type, remote_m2m_fk_null = [\n  1978\t                    (c.type_code, c.null_ok)\n  1979\t                    for c in connection.introspection.get_table_description(\n  1980\t                        cursor,\n  1981\t                        \"test_alflpkfk_stable_ponies\",\n  1982\t                    )\n  1983\t                    if c.name == \"pony_id\"\n  1984\t                ][0]\n  1985\t            self.assertEqual(id_type, fk_type)\n  1986\t            self.assertEqual(id_type, m2m_fk_type)\n  1987\t            self.assertEqual(id_type, remote_m2m_fk_type)\n  1988\t            self.assertEqual(id_null, fk_null)\n  1989\t            self.assertEqual(id_null, m2m_fk_null)\n  1990\t            self.assertEqual(id_null, remote_m2m_fk_null)\n  1991\t\n  1992\t        assertIdTypeEqualsFkType()\n  1993\t        # Test the database alteration\n  1994\t        with connection.schema_editor() as editor:\n  1995\t            operation.database_forwards(\n  1996\t                \"test_alflpkfk\", editor, project_state, new_state\n  1997\t            )\n  1998\t        assertIdTypeEqualsFkType()\n  1999\t        if connection.features.supports_foreign_keys:\n  2000\t            self.assertFKExists(\n  2001\t                \"test_alflpkfk_pony_stables\",\n  2002\t                [\"pony_id\"],\n  2003\t                (\"test_alflpkfk_pony\", \"id\"),\n  2004\t            )\n  2005\t            self.assertFKExists(\n  2006\t                \"test_alflpkfk_stable_ponies\",\n  2007\t                [\"pony_id\"],\n  2008\t                (\"test_alflpkfk_pony\", \"id\"),\n  2009\t            )\n  2010\t        # And test reversal\n  2011\t        with connection.schema_editor() as editor:\n  2012\t            operation.database_backwards(\n  2013\t                \"test_alflpkfk\", editor, new_state, project_state\n  2014\t            )\n  2015\t        assertIdTypeEqualsFkType()\n  2016\t        if connection.features.supports_foreign_keys:\n  2017\t            self.assertFKExists(\n  2018\t                \"test_alflpkfk_pony_stables\",\n  2019\t                [\"pony_id\"],\n  2020\t                (\"test_alflpkfk_pony\", \"id\"),\n  2021\t            )\n  2022\t            self.assertFKExists(\n  2023\t                \"test_alflpkfk_stable_ponies\",\n  2024\t                [\"pony_id\"],\n  2025\t                (\"test_alflpkfk_pony\", \"id\"),\n  2026\t            )\n  2027\t\n  2028\t    @skipUnlessDBFeature(\"supports_collation_on_charfield\", \"supports_foreign_keys\")\n  2029\t    def test_alter_field_pk_fk_db_collation(self):\n  2030\t        \"\"\"\n  2031\t        AlterField operation of db_collation on primary keys changes any FKs\n  2032\t        pointing to it.\n  2033\t        \"\"\"\n  2034\t        collation = connection.features.test_collations.get(\"non_default\")\n  2035\t        if not collation:\n  2036\t            self.skipTest(\"Language collations are not supported.\")\n  2037\t\n  2038\t        app_label = \"test_alflpkfkdbc\"\n  2039\t        project_state = self.apply_operations(\n  2040\t            app_label,\n  2041\t            ProjectState(),\n  2042\t            [\n  2043\t                migrations.CreateModel(\n  2044\t                    \"Pony\",\n  2045\t                    [\n  2046\t                        (\"id\", models.CharField(primary_key=True, max_length=10)),\n  2047\t                    ],\n  2048\t                ),\n  2049\t                migrations.CreateModel(\n  2050\t                    \"Rider\",\n  2051\t                    [\n  2052\t                        (\"pony\", models.ForeignKey(\"Pony\", models.CASCADE)),\n  2053\t                    ],\n  2054\t                ),\n  2055\t                migrations.CreateModel(\n  2056\t                    \"Stable\",\n  2057\t                    [\n  2058\t                        (\"ponies\", models.ManyToManyField(\"Pony\")),\n  2059\t                    ],\n  2060\t                ),\n  2061\t            ],\n  2062\t        )\n  2063\t        # State alteration.\n  2064\t        operation = migrations.AlterField(\n  2065\t            \"Pony\",\n  2066\t            \"id\",\n  2067\t            models.CharField(\n  2068\t                primary_key=True,\n  2069\t                max_length=10,\n  2070\t                db_collation=collation,\n  2071\t            ),\n  2072\t        )\n  2073\t        new_state = project_state.clone()\n  2074\t        operation.state_forwards(app_label, new_state)\n  2075\t        # Database alteration.\n  2076\t        with connection.schema_editor() as editor:\n  2077\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2078\t        self.assertColumnCollation(f\"{app_label}_pony\", \"id\", collation)\n  2079\t        self.assertColumnCollation(f\"{app_label}_rider\", \"pony_id\", collation)\n  2080\t        self.assertColumnCollation(f\"{app_label}_stable_ponies\", \"pony_id\", collation)\n  2081\t        # Reversal.\n  2082\t        with connection.schema_editor() as editor:\n  2083\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2084\t\n  2085\t    def test_alter_field_pk_mti_fk(self):\n  2086\t        app_label = \"test_alflpkmtifk\"\n  2087\t        project_state = self.set_up_test_model(app_label, mti_model=True)\n  2088\t        project_state = self.apply_operations(\n  2089\t            app_label,\n  2090\t            project_state,\n  2091\t            [\n  2092\t                migrations.CreateModel(\n  2093\t                    \"ShetlandRider\",\n  2094\t                    fields=[\n  2095\t                        (\n  2096\t                            \"pony\",\n  2097\t                            models.ForeignKey(\n  2098\t                                f\"{app_label}.ShetlandPony\", models.CASCADE\n  2099\t                            ),\n  2100\t                        ),\n  2101\t                    ],\n  2102\t                ),\n  2103\t            ],\n  2104\t        )\n  2105\t        operation = migrations.AlterField(\n  2106\t            \"Pony\",\n  2107\t            \"id\",\n  2108\t            models.BigAutoField(primary_key=True),\n  2109\t        )\n  2110\t        new_state = project_state.clone()\n  2111\t        operation.state_forwards(app_label, new_state)\n  2112\t        self.assertIsInstance(\n  2113\t            new_state.models[app_label, \"pony\"].fields[\"id\"],\n  2114\t            models.BigAutoField,\n  2115\t        )\n  2116\t\n  2117\t        def _get_column_id_type(cursor, table, column):\n  2118\t            return [\n  2119\t                c.type_code\n  2120\t                for c in connection.introspection.get_table_description(\n  2121\t                    cursor,\n  2122\t                    f\"{app_label}_{table}\",\n  2123\t                )\n  2124\t                if c.name == column\n  2125\t            ][0]\n  2126\t\n  2127\t        def assertIdTypeEqualsMTIFkType():\n  2128\t            with connection.cursor() as cursor:\n  2129\t                parent_id_type = _get_column_id_type(cursor, \"pony\", \"id\")\n  2130\t                child_id_type = _get_column_id_type(\n  2131\t                    cursor, \"shetlandpony\", \"pony_ptr_id\"\n  2132\t                )\n  2133\t                mti_id_type = _get_column_id_type(cursor, \"shetlandrider\", \"pony_id\")\n  2134\t            self.assertEqual(parent_id_type, child_id_type)\n  2135\t            self.assertEqual(parent_id_type, mti_id_type)\n  2136\t\n  2137\t        assertIdTypeEqualsMTIFkType()\n  2138\t        # Alter primary key.\n  2139\t        with connection.schema_editor() as editor:\n  2140\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2141\t        assertIdTypeEqualsMTIFkType()\n  2142\t        if connection.features.supports_foreign_keys:\n  2143\t            self.assertFKExists(\n  2144\t                f\"{app_label}_shetlandpony\",\n  2145\t                [\"pony_ptr_id\"],\n  2146\t                (f\"{app_label}_pony\", \"id\"),\n  2147\t            )\n  2148\t            self.assertFKExists(\n  2149\t                f\"{app_label}_shetlandrider\",\n  2150\t                [\"pony_id\"],\n  2151\t                (f\"{app_label}_shetlandpony\", \"pony_ptr_id\"),\n  2152\t            )\n  2153\t        # Reversal.\n  2154\t        with connection.schema_editor() as editor:\n  2155\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2156\t        assertIdTypeEqualsMTIFkType()\n  2157\t        if connection.features.supports_foreign_keys:\n  2158\t            self.assertFKExists(\n  2159\t                f\"{app_label}_shetlandpony\",\n  2160\t                [\"pony_ptr_id\"],\n  2161\t                (f\"{app_label}_pony\", \"id\"),\n  2162\t            )\n  2163\t            self.assertFKExists(\n  2164\t                f\"{app_label}_shetlandrider\",\n  2165\t                [\"pony_id\"],\n  2166\t                (f\"{app_label}_shetlandpony\", \"pony_ptr_id\"),\n  2167\t            )\n  2168\t\n  2169\t    def test_alter_field_pk_mti_and_fk_to_base(self):\n  2170\t        app_label = \"test_alflpkmtiftb\"\n  2171\t        project_state = self.set_up_test_model(\n  2172\t            app_label,\n  2173\t            mti_model=True,\n  2174\t            related_model=True,\n  2175\t        )\n  2176\t        operation = migrations.AlterField(\n  2177\t            \"Pony\",\n  2178\t            \"id\",\n  2179\t            models.BigAutoField(primary_key=True),\n  2180\t        )\n  2181\t        new_state = project_state.clone()\n  2182\t        operation.state_forwards(app_label, new_state)\n  2183\t        self.assertIsInstance(\n  2184\t            new_state.models[app_label, \"pony\"].fields[\"id\"],\n  2185\t            models.BigAutoField,\n  2186\t        )\n  2187\t\n  2188\t        def _get_column_id_type(cursor, table, column):\n  2189\t            return [\n  2190\t                c.type_code\n  2191\t                for c in connection.introspection.get_table_description(\n  2192\t                    cursor,\n  2193\t                    f\"{app_label}_{table}\",\n  2194\t                )\n  2195\t                if c.name == column\n  2196\t            ][0]\n  2197\t\n  2198\t        def assertIdTypeEqualsMTIFkType():\n  2199\t            with connection.cursor() as cursor:\n  2200\t                parent_id_type = _get_column_id_type(cursor, \"pony\", \"id\")\n  2201\t                fk_id_type = _get_column_id_type(cursor, \"rider\", \"pony_id\")\n  2202\t                child_id_type = _get_column_id_type(\n  2203\t                    cursor, \"shetlandpony\", \"pony_ptr_id\"\n  2204\t                )\n  2205\t            self.assertEqual(parent_id_type, child_id_type)\n  2206\t            self.assertEqual(parent_id_type, fk_id_type)\n  2207\t\n  2208\t        assertIdTypeEqualsMTIFkType()\n  2209\t        # Alter primary key.\n  2210\t        with connection.schema_editor() as editor:\n  2211\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2212\t        assertIdTypeEqualsMTIFkType()\n  2213\t        if connection.features.supports_foreign_keys:\n  2214\t            self.assertFKExists(\n  2215\t                f\"{app_label}_shetlandpony\",\n  2216\t                [\"pony_ptr_id\"],\n  2217\t                (f\"{app_label}_pony\", \"id\"),\n  2218\t            )\n  2219\t            self.assertFKExists(\n  2220\t                f\"{app_label}_rider\",\n  2221\t                [\"pony_id\"],\n  2222\t                (f\"{app_label}_pony\", \"id\"),\n  2223\t            )\n  2224\t        # Reversal.\n  2225\t        with connection.schema_editor() as editor:\n  2226\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2227\t        assertIdTypeEqualsMTIFkType()\n  2228\t        if connection.features.supports_foreign_keys:\n  2229\t            self.assertFKExists(\n  2230\t                f\"{app_label}_shetlandpony\",\n  2231\t                [\"pony_ptr_id\"],\n  2232\t                (f\"{app_label}_pony\", \"id\"),\n  2233\t            )\n  2234\t            self.assertFKExists(\n  2235\t                f\"{app_label}_rider\",\n  2236\t                [\"pony_id\"],\n  2237\t                (f\"{app_label}_pony\", \"id\"),\n  2238\t            )\n  2239\t\n  2240\t    @skipUnlessDBFeature(\"supports_foreign_keys\")\n  2241\t    def test_alter_field_reloads_state_on_fk_with_to_field_target_type_change(self):\n  2242\t        app_label = \"test_alflrsfkwtflttc\"\n  2243\t        project_state = self.apply_operations(\n  2244\t            app_label,\n  2245\t            ProjectState(),\n  2246\t            operations=[\n  2247\t                migrations.CreateModel(\n  2248\t                    \"Rider\",\n  2249\t                    fields=[\n  2250\t                        (\"id\", models.AutoField(primary_key=True)),\n  2251\t                        (\"code\", models.IntegerField(unique=True)),\n  2252\t                    ],\n  2253\t                ),\n  2254\t                migrations.CreateModel(\n  2255\t                    \"Pony\",\n  2256\t                    fields=[\n  2257\t                        (\"id\", models.AutoField(primary_key=True)),\n  2258\t                        (\n  2259\t                            \"rider\",\n  2260\t                            models.ForeignKey(\n  2261\t                                \"%s.Rider\" % app_label, models.CASCADE, to_field=\"code\"\n  2262\t                            ),\n  2263\t                        ),\n  2264\t                    ],\n  2265\t                ),\n  2266\t            ],\n  2267\t        )\n  2268\t        operation = migrations.AlterField(\n  2269\t            \"Rider\",\n  2270\t            \"code\",\n  2271\t            models.CharField(max_length=100, unique=True),\n  2272\t        )\n  2273\t        self.apply_operations(app_label, project_state, operations=[operation])\n  2274\t        id_type, id_null = [\n  2275\t            (c.type_code, c.null_ok)\n  2276\t            for c in self.get_table_description(\"%s_rider\" % app_label)\n  2277\t            if c.name == \"code\"\n  2278\t        ][0]\n  2279\t        fk_type, fk_null = [\n  2280\t            (c.type_code, c.null_ok)\n  2281\t            for c in self.get_table_description(\"%s_pony\" % app_label)\n  2282\t            if c.name == \"rider_id\"\n  2283\t        ][0]\n  2284\t        self.assertEqual(id_type, fk_type)\n  2285\t        self.assertEqual(id_null, fk_null)\n  2286\t\n  2287\t    @skipUnlessDBFeature(\"supports_foreign_keys\")\n  2288\t    def test_alter_field_reloads_state_fk_with_to_field_related_name_target_type_change(\n  2289\t        self,\n  2290\t    ):\n  2291\t        app_label = \"test_alflrsfkwtflrnttc\"\n  2292\t        project_state = self.apply_operations(\n  2293\t            app_label,\n  2294\t            ProjectState(),\n  2295\t            operations=[\n  2296\t                migrations.CreateModel(\n  2297\t                    \"Rider\",\n  2298\t                    fields=[\n  2299\t                        (\"id\", models.AutoField(primary_key=True)),\n  2300\t                        (\"code\", models.PositiveIntegerField(unique=True)),\n  2301\t                    ],\n  2302\t                ),\n  2303\t                migrations.CreateModel(\n  2304\t                    \"Pony\",\n  2305\t                    fields=[\n  2306\t                        (\"id\", models.AutoField(primary_key=True)),\n  2307\t                        (\n  2308\t                            \"rider\",\n  2309\t                            models.ForeignKey(\n  2310\t                                \"%s.Rider\" % app_label,\n  2311\t                                models.CASCADE,\n  2312\t                                to_field=\"code\",\n  2313\t                                related_name=\"+\",\n  2314\t                            ),\n  2315\t                        ),\n  2316\t                    ],\n  2317\t                ),\n  2318\t            ],\n  2319\t        )\n  2320\t        operation = migrations.AlterField(\n  2321\t            \"Rider\",\n  2322\t            \"code\",\n  2323\t            models.CharField(max_length=100, unique=True),\n  2324\t        )\n  2325\t        self.apply_operations(app_label, project_state, operations=[operation])\n  2326\t\n  2327\t    def test_alter_field_reloads_state_on_fk_target_changes(self):\n  2328\t        \"\"\"\n  2329\t        If AlterField doesn't reload state appropriately, the second AlterField\n  2330\t        crashes on MySQL due to not dropping the PonyRider.pony foreign key\n  2331\t        constraint before modifying the column.\n  2332\t        \"\"\"\n  2333\t        app_label = \"alter_alter_field_reloads_state_on_fk_target_changes\"\n  2334\t        project_state = self.apply_operations(\n  2335\t            app_label,\n  2336\t            ProjectState(),\n  2337\t            operations=[\n  2338\t                migrations.CreateModel(\n  2339\t                    \"Rider\",\n  2340\t                    fields=[\n  2341\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2342\t                    ],\n  2343\t                ),\n  2344\t                migrations.CreateModel(\n  2345\t                    \"Pony\",\n  2346\t                    fields=[\n  2347\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2348\t                        (\n  2349\t                            \"rider\",\n  2350\t                            models.ForeignKey(\"%s.Rider\" % app_label, models.CASCADE),\n  2351\t                        ),\n  2352\t                    ],\n  2353\t                ),\n  2354\t                migrations.CreateModel(\n  2355\t                    \"PonyRider\",\n  2356\t                    fields=[\n  2357\t                        (\"id\", models.AutoField(primary_key=True)),\n  2358\t                        (\n  2359\t                            \"pony\",\n  2360\t                            models.ForeignKey(\"%s.Pony\" % app_label, models.CASCADE),\n  2361\t                        ),\n  2362\t                    ],\n  2363\t                ),\n  2364\t            ],\n  2365\t        )\n  2366\t        project_state = self.apply_operations(\n  2367\t            app_label,\n  2368\t            project_state,\n  2369\t            operations=[\n  2370\t                migrations.AlterField(\n  2371\t                    \"Rider\", \"id\", models.CharField(primary_key=True, max_length=99)\n  2372\t                ),\n  2373\t                migrations.AlterField(\n  2374\t                    \"Pony\", \"id\", models.CharField(primary_key=True, max_length=99)\n  2375\t                ),\n  2376\t            ],\n  2377\t        )\n  2378\t\n  2379\t    def test_alter_field_reloads_state_on_fk_with_to_field_target_changes(self):\n  2380\t        \"\"\"\n  2381\t        If AlterField doesn't reload state appropriately, the second AlterField\n  2382\t        crashes on MySQL due to not dropping the PonyRider.pony foreign key\n  2383\t        constraint before modifying the column.\n  2384\t        \"\"\"\n  2385\t        app_label = \"alter_alter_field_reloads_state_on_fk_with_to_field_target_changes\"\n  2386\t        project_state = self.apply_operations(\n  2387\t            app_label,\n  2388\t            ProjectState(),\n  2389\t            operations=[\n  2390\t                migrations.CreateModel(\n  2391\t                    \"Rider\",\n  2392\t                    fields=[\n  2393\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2394\t                        (\"slug\", models.CharField(unique=True, max_length=100)),\n  2395\t                    ],\n  2396\t                ),\n  2397\t                migrations.CreateModel(\n  2398\t                    \"Pony\",\n  2399\t                    fields=[\n  2400\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2401\t                        (\n  2402\t                            \"rider\",\n  2403\t                            models.ForeignKey(\n  2404\t                                \"%s.Rider\" % app_label, models.CASCADE, to_field=\"slug\"\n  2405\t                            ),\n  2406\t                        ),\n  2407\t                        (\"slug\", models.CharField(unique=True, max_length=100)),\n  2408\t                    ],\n  2409\t                ),\n  2410\t                migrations.CreateModel(\n  2411\t                    \"PonyRider\",\n  2412\t                    fields=[\n  2413\t                        (\"id\", models.AutoField(primary_key=True)),\n  2414\t                        (\n  2415\t                            \"pony\",\n  2416\t                            models.ForeignKey(\n  2417\t                                \"%s.Pony\" % app_label, models.CASCADE, to_field=\"slug\"\n  2418\t                            ),\n  2419\t                        ),\n  2420\t                    ],\n  2421\t                ),\n  2422\t            ],\n  2423\t        )\n  2424\t        project_state = self.apply_operations(\n  2425\t            app_label,\n  2426\t            project_state,\n  2427\t            operations=[\n  2428\t                migrations.AlterField(\n  2429\t                    \"Rider\", \"slug\", models.CharField(unique=True, max_length=99)\n  2430\t                ),\n  2431\t                migrations.AlterField(\n  2432\t                    \"Pony\", \"slug\", models.CharField(unique=True, max_length=99)\n  2433\t                ),\n  2434\t            ],\n  2435\t        )\n  2436\t\n  2437\t    def test_rename_field_reloads_state_on_fk_target_changes(self):\n  2438\t        \"\"\"\n  2439\t        If RenameField doesn't reload state appropriately, the AlterField\n  2440\t        crashes on MySQL due to not dropping the PonyRider.pony foreign key\n  2441\t        constraint before modifying the column.\n  2442\t        \"\"\"\n  2443\t        app_label = \"alter_rename_field_reloads_state_on_fk_target_changes\"\n  2444\t        project_state = self.apply_operations(\n  2445\t            app_label,\n  2446\t            ProjectState(),\n  2447\t            operations=[\n  2448\t                migrations.CreateModel(\n  2449\t                    \"Rider\",\n  2450\t                    fields=[\n  2451\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2452\t                    ],\n  2453\t                ),\n  2454\t                migrations.CreateModel(\n  2455\t                    \"Pony\",\n  2456\t                    fields=[\n  2457\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2458\t                        (\n  2459\t                            \"rider\",\n  2460\t                            models.ForeignKey(\"%s.Rider\" % app_label, models.CASCADE),\n  2461\t                        ),\n  2462\t                    ],\n  2463\t                ),\n  2464\t                migrations.CreateModel(\n  2465\t                    \"PonyRider\",\n  2466\t                    fields=[\n  2467\t                        (\"id\", models.AutoField(primary_key=True)),\n  2468\t                        (\n  2469\t                            \"pony\",\n  2470\t                            models.ForeignKey(\"%s.Pony\" % app_label, models.CASCADE),\n  2471\t                        ),\n  2472\t                    ],\n  2473\t                ),\n  2474\t            ],\n  2475\t        )\n  2476\t        project_state = self.apply_operations(\n  2477\t            app_label,\n  2478\t            project_state,\n  2479\t            operations=[\n  2480\t                migrations.RenameField(\"Rider\", \"id\", \"id2\"),\n  2481\t                migrations.AlterField(\n  2482\t                    \"Pony\", \"id\", models.CharField(primary_key=True, max_length=99)\n  2483\t                ),\n  2484\t            ],\n  2485\t            atomic=connection.features.supports_atomic_references_rename,\n  2486\t        )\n  2487\t\n  2488\t    def test_rename_field(self):\n  2489\t        \"\"\"\n  2490\t        Tests the RenameField operation.\n  2491\t        \"\"\"\n  2492\t        project_state = self.set_up_test_model(\n  2493\t            \"test_rnfl\", unique_together=True, index_together=True\n  2494\t        )\n  2495\t        # Test the state alteration\n  2496\t        operation = migrations.RenameField(\"Pony\", \"pink\", \"blue\")\n  2497\t        self.assertEqual(operation.describe(), \"Rename field pink on Pony to blue\")\n  2498\t        self.assertEqual(operation.migration_name_fragment, \"rename_pink_pony_blue\")\n  2499\t        new_state = project_state.clone()\n  2500\t        operation.state_forwards(\"test_rnfl\", new_state)\n  2501\t        self.assertIn(\"blue\", new_state.models[\"test_rnfl\", \"pony\"].fields)\n  2502\t        self.assertNotIn(\"pink\", new_state.models[\"test_rnfl\", \"pony\"].fields)\n  2503\t        # Make sure the unique_together has the renamed column too\n  2504\t        self.assertIn(\n  2505\t            \"blue\", new_state.models[\"test_rnfl\", \"pony\"].options[\"unique_together\"][0]\n  2506\t        )\n  2507\t        self.assertNotIn(\n  2508\t            \"pink\", new_state.models[\"test_rnfl\", \"pony\"].options[\"unique_together\"][0]\n  2509\t        )\n  2510\t        # Make sure the index_together has the renamed column too\n  2511\t        self.assertIn(\n  2512\t            \"blue\", new_state.models[\"test_rnfl\", \"pony\"].options[\"index_together\"][0]\n  2513\t        )\n  2514\t        self.assertNotIn(\n  2515\t            \"pink\", new_state.models[\"test_rnfl\", \"pony\"].options[\"index_together\"][0]\n  2516\t        )\n  2517\t        # Test the database alteration\n  2518\t        self.assertColumnExists(\"test_rnfl_pony\", \"pink\")\n  2519\t        self.assertColumnNotExists(\"test_rnfl_pony\", \"blue\")\n  2520\t        with connection.schema_editor() as editor:\n  2521\t            operation.database_forwards(\"test_rnfl\", editor, project_state, new_state)\n  2522\t        self.assertColumnExists(\"test_rnfl_pony\", \"blue\")\n  2523\t        self.assertColumnNotExists(\"test_rnfl_pony\", \"pink\")\n  2524\t        # Ensure the unique constraint has been ported over\n  2525\t        with connection.cursor() as cursor:\n  2526\t            cursor.execute(\"INSERT INTO test_rnfl_pony (blue, weight) VALUES (1, 1)\")\n  2527\t            with self.assertRaises(IntegrityError):\n  2528\t                with atomic():\n  2529\t                    cursor.execute(\n  2530\t                        \"INSERT INTO test_rnfl_pony (blue, weight) VALUES (1, 1)\"\n  2531\t                    )\n  2532\t            cursor.execute(\"DELETE FROM test_rnfl_pony\")\n  2533\t        # Ensure the index constraint has been ported over\n  2534\t        self.assertIndexExists(\"test_rnfl_pony\", [\"weight\", \"blue\"])\n  2535\t        # And test reversal\n  2536\t        with connection.schema_editor() as editor:\n  2537\t            operation.database_backwards(\"test_rnfl\", editor, new_state, project_state)\n  2538\t        self.assertColumnExists(\"test_rnfl_pony\", \"pink\")\n  2539\t        self.assertColumnNotExists(\"test_rnfl_pony\", \"blue\")\n  2540\t        # Ensure the index constraint has been reset\n  2541\t        self.assertIndexExists(\"test_rnfl_pony\", [\"weight\", \"pink\"])\n  2542\t        # And deconstruction\n  2543\t        definition = operation.deconstruct()\n  2544\t        self.assertEqual(definition[0], \"RenameField\")\n  2545\t        self.assertEqual(definition[1], [])\n  2546\t        self.assertEqual(\n  2547\t            definition[2],\n  2548\t            {\"model_name\": \"Pony\", \"old_name\": \"pink\", \"new_name\": \"blue\"},\n  2549\t        )\n  2550\t\n  2551\t    def test_rename_field_with_db_column(self):\n  2552\t        project_state = self.apply_operations(\n  2553\t            \"test_rfwdbc\",\n  2554\t            ProjectState(),\n  2555\t            operations=[\n  2556\t                migrations.CreateModel(\n  2557\t                    \"Pony\",\n  2558\t                    fields=[\n  2559\t                        (\"id\", models.AutoField(primary_key=True)),\n  2560\t                        (\"field\", models.IntegerField(db_column=\"db_field\")),\n  2561\t                        (\n  2562\t                            \"fk_field\",\n  2563\t                            models.ForeignKey(\n  2564\t                                \"Pony\",\n  2565\t                                models.CASCADE,\n  2566\t                                db_column=\"db_fk_field\",\n  2567\t                            ),\n  2568\t                        ),\n  2569\t                    ],\n  2570\t                ),\n  2571\t            ],\n  2572\t        )\n  2573\t        new_state = project_state.clone()\n  2574\t        operation = migrations.RenameField(\"Pony\", \"field\", \"renamed_field\")\n  2575\t        operation.state_forwards(\"test_rfwdbc\", new_state)\n  2576\t        self.assertIn(\"renamed_field\", new_state.models[\"test_rfwdbc\", \"pony\"].fields)\n  2577\t        self.assertNotIn(\"field\", new_state.models[\"test_rfwdbc\", \"pony\"].fields)\n  2578\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_field\")\n  2579\t        with connection.schema_editor() as editor:\n  2580\t            with self.assertNumQueries(0):\n  2581\t                operation.database_forwards(\n  2582\t                    \"test_rfwdbc\", editor, project_state, new_state\n  2583\t                )\n  2584\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_field\")\n  2585\t        with connection.schema_editor() as editor:\n  2586\t            with self.assertNumQueries(0):\n  2587\t                operation.database_backwards(\n  2588\t                    \"test_rfwdbc\", editor, new_state, project_state\n  2589\t                )\n  2590\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_field\")\n  2591\t\n  2592\t        new_state = project_state.clone()\n  2593\t        operation = migrations.RenameField(\"Pony\", \"fk_field\", \"renamed_fk_field\")\n  2594\t        operation.state_forwards(\"test_rfwdbc\", new_state)\n  2595\t        self.assertIn(\n  2596\t            \"renamed_fk_field\", new_state.models[\"test_rfwdbc\", \"pony\"].fields\n  2597\t        )\n  2598\t        self.assertNotIn(\"fk_field\", new_state.models[\"test_rfwdbc\", \"pony\"].fields)\n  2599\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_fk_field\")\n  2600\t        with connection.schema_editor() as editor:\n  2601\t            with self.assertNumQueries(0):\n  2602\t                operation.database_forwards(\n  2603\t                    \"test_rfwdbc\", editor, project_state, new_state\n  2604\t                )\n  2605\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_fk_field\")\n  2606\t        with connection.schema_editor() as editor:\n  2607\t            with self.assertNumQueries(0):\n  2608\t                operation.database_backwards(\n  2609\t                    \"test_rfwdbc\", editor, new_state, project_state\n  2610\t                )\n  2611\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_fk_field\")\n  2612\t\n  2613\t    def test_rename_field_case(self):\n  2614\t        project_state = self.apply_operations(\n  2615\t            \"test_rfmx\",\n  2616\t            ProjectState(),\n  2617\t            operations=[\n  2618\t                migrations.CreateModel(\n  2619\t                    \"Pony\",\n  2620\t                    fields=[\n  2621\t                        (\"id\", models.AutoField(primary_key=True)),\n  2622\t                        (\"field\", models.IntegerField()),\n  2623\t                    ],\n  2624\t                ),\n  2625\t            ],\n  2626\t        )\n  2627\t        new_state = project_state.clone()\n  2628\t        operation = migrations.RenameField(\"Pony\", \"field\", \"FiElD\")\n  2629\t        operation.state_forwards(\"test_rfmx\", new_state)\n  2630\t        self.assertIn(\"FiElD\", new_state.models[\"test_rfmx\", \"pony\"].fields)\n  2631\t        self.assertColumnExists(\"test_rfmx_pony\", \"field\")\n  2632\t        with connection.schema_editor() as editor:\n  2633\t            operation.database_forwards(\"test_rfmx\", editor, project_state, new_state)\n  2634\t        self.assertColumnExists(\n  2635\t            \"test_rfmx_pony\",\n  2636\t            connection.introspection.identifier_converter(\"FiElD\"),\n  2637\t        )\n  2638\t        with connection.schema_editor() as editor:\n  2639\t            operation.database_backwards(\"test_rfmx\", editor, new_state, project_state)\n  2640\t        self.assertColumnExists(\"test_rfmx_pony\", \"field\")\n  2641\t\n  2642\t    def test_rename_missing_field(self):\n  2643\t        state = ProjectState()\n  2644\t        state.add_model(ModelState(\"app\", \"model\", []))\n  2645\t        with self.assertRaisesMessage(\n  2646\t            FieldDoesNotExist, \"app.model has no field named 'field'\"\n  2647\t        ):\n  2648\t            migrations.RenameField(\"model\", \"field\", \"new_field\").state_forwards(\n  2649\t                \"app\", state\n  2650\t            )\n  2651\t\n  2652\t    def test_rename_referenced_field_state_forward(self):\n  2653\t        state = ProjectState()\n  2654\t        state.add_model(\n  2655\t            ModelState(\n  2656\t                \"app\",\n  2657\t                \"Model\",\n  2658\t                [\n  2659\t                    (\"id\", models.AutoField(primary_key=True)),\n  2660\t                    (\"field\", models.IntegerField(unique=True)),\n  2661\t                ],\n  2662\t            )\n  2663\t        )\n  2664\t        state.add_model(\n  2665\t            ModelState(\n  2666\t                \"app\",\n  2667\t                \"OtherModel\",\n  2668\t                [\n  2669\t                    (\"id\", models.AutoField(primary_key=True)),\n  2670\t                    (\n  2671\t                        \"fk\",\n  2672\t                        models.ForeignKey(\"Model\", models.CASCADE, to_field=\"field\"),\n  2673\t                    ),\n  2674\t                    (\n  2675\t                        \"fo\",\n  2676\t                        models.ForeignObject(\n  2677\t                            \"Model\",\n  2678\t                            models.CASCADE,\n  2679\t                            from_fields=(\"fk\",),\n  2680\t                            to_fields=(\"field\",),\n  2681\t                        ),\n  2682\t                    ),\n  2683\t                ],\n  2684\t            )\n  2685\t        )\n  2686\t        operation = migrations.RenameField(\"Model\", \"field\", \"renamed\")\n  2687\t        new_state = state.clone()\n  2688\t        operation.state_forwards(\"app\", new_state)\n  2689\t        self.assertEqual(\n  2690\t            new_state.models[\"app\", \"othermodel\"].fields[\"fk\"].remote_field.field_name,\n  2691\t            \"renamed\",\n  2692\t        )\n  2693\t        self.assertEqual(\n  2694\t            new_state.models[\"app\", \"othermodel\"].fields[\"fk\"].from_fields, [\"self\"]\n  2695\t        )\n  2696\t        self.assertEqual(\n  2697\t            new_state.models[\"app\", \"othermodel\"].fields[\"fk\"].to_fields, (\"renamed\",)\n  2698\t        )\n  2699\t        self.assertEqual(\n  2700\t            new_state.models[\"app\", \"othermodel\"].fields[\"fo\"].from_fields, (\"fk\",)\n  2701\t        )\n  2702\t        self.assertEqual(\n  2703\t            new_state.models[\"app\", \"othermodel\"].fields[\"fo\"].to_fields, (\"renamed\",)\n  2704\t        )\n  2705\t        operation = migrations.RenameField(\"OtherModel\", \"fk\", \"renamed_fk\")\n  2706\t        new_state = state.clone()\n  2707\t        operation.state_forwards(\"app\", new_state)\n  2708\t        self.assertEqual(\n  2709\t            new_state.models[\"app\", \"othermodel\"]\n  2710\t            .fields[\"renamed_fk\"]\n  2711\t            .remote_field.field_name,\n  2712\t            \"renamed\",\n  2713\t        )\n  2714\t        self.assertEqual(\n  2715\t            new_state.models[\"app\", \"othermodel\"].fields[\"renamed_fk\"].from_fields,\n  2716\t            (\"self\",),\n  2717\t        )\n  2718\t        self.assertEqual(\n  2719\t            new_state.models[\"app\", \"othermodel\"].fields[\"renamed_fk\"].to_fields,\n  2720\t            (\"renamed\",),\n  2721\t        )\n  2722\t        self.assertEqual(\n  2723\t            new_state.models[\"app\", \"othermodel\"].fields[\"fo\"].from_fields,\n  2724\t            (\"renamed_fk\",),\n  2725\t        )\n  2726\t        self.assertEqual(\n  2727\t            new_state.models[\"app\", \"othermodel\"].fields[\"fo\"].to_fields, (\"renamed\",)\n  2728\t        )\n  2729\t\n  2730\t    def test_alter_unique_together(self):\n  2731\t        \"\"\"\n  2732\t        Tests the AlterUniqueTogether operation.\n  2733\t        \"\"\"\n  2734\t        project_state = self.set_up_test_model(\"test_alunto\")\n  2735\t        # Test the state alteration\n  2736\t        operation = migrations.AlterUniqueTogether(\"Pony\", [(\"pink\", \"weight\")])\n  2737\t        self.assertEqual(\n  2738\t            operation.describe(), \"Alter unique_together for Pony (1 constraint(s))\"\n  2739\t        )\n  2740\t        self.assertEqual(\n  2741\t            operation.migration_name_fragment,\n  2742\t            \"alter_pony_unique_together\",\n  2743\t        )\n  2744\t        new_state = project_state.clone()\n  2745\t        operation.state_forwards(\"test_alunto\", new_state)\n  2746\t        self.assertEqual(\n  2747\t            len(\n  2748\t                project_state.models[\"test_alunto\", \"pony\"].options.get(\n  2749\t                    \"unique_together\", set()\n  2750\t                )\n  2751\t            ),\n  2752\t            0,\n  2753\t        )\n  2754\t        self.assertEqual(\n  2755\t            len(\n  2756\t                new_state.models[\"test_alunto\", \"pony\"].options.get(\n  2757\t                    \"unique_together\", set()\n  2758\t                )\n  2759\t            ),\n  2760\t            1,\n  2761\t        )\n  2762\t        # Make sure we can insert duplicate rows\n  2763\t        with connection.cursor() as cursor:\n  2764\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2765\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2766\t            cursor.execute(\"DELETE FROM test_alunto_pony\")\n  2767\t            # Test the database alteration\n  2768\t            with connection.schema_editor() as editor:\n  2769\t                operation.database_forwards(\n  2770\t                    \"test_alunto\", editor, project_state, new_state\n  2771\t                )\n  2772\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2773\t            with self.assertRaises(IntegrityError):\n  2774\t                with atomic():\n  2775\t                    cursor.execute(\n  2776\t                        \"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\"\n  2777\t                    )\n  2778\t            cursor.execute(\"DELETE FROM test_alunto_pony\")\n  2779\t            # And test reversal\n  2780\t            with connection.schema_editor() as editor:\n  2781\t                operation.database_backwards(\n  2782\t                    \"test_alunto\", editor, new_state, project_state\n  2783\t                )\n  2784\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2785\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2786\t            cursor.execute(\"DELETE FROM test_alunto_pony\")\n  2787\t        # Test flat unique_together\n  2788\t        operation = migrations.AlterUniqueTogether(\"Pony\", (\"pink\", \"weight\"))\n  2789\t        operation.state_forwards(\"test_alunto\", new_state)\n  2790\t        self.assertEqual(\n  2791\t            len(\n  2792\t                new_state.models[\"test_alunto\", \"pony\"].options.get(\n  2793\t                    \"unique_together\", set()\n  2794\t                )\n  2795\t            ),\n  2796\t            1,\n  2797\t        )\n  2798\t        # And deconstruction\n  2799\t        definition = operation.deconstruct()\n  2800\t        self.assertEqual(definition[0], \"AlterUniqueTogether\")\n  2801\t        self.assertEqual(definition[1], [])\n  2802\t        self.assertEqual(\n  2803\t            definition[2], {\"name\": \"Pony\", \"unique_together\": {(\"pink\", \"weight\")}}\n  2804\t        )\n  2805\t\n  2806\t    def test_alter_unique_together_remove(self):\n  2807\t        operation = migrations.AlterUniqueTogether(\"Pony\", None)\n  2808\t        self.assertEqual(\n  2809\t            operation.describe(), \"Alter unique_together for Pony (0 constraint(s))\"\n  2810\t        )\n  2811\t\n  2812\t    def test_add_index(self):\n  2813\t        \"\"\"\n  2814\t        Test the AddIndex operation.\n  2815\t        \"\"\"\n  2816\t        project_state = self.set_up_test_model(\"test_adin\")\n  2817\t        msg = (\n  2818\t            \"Indexes passed to AddIndex operations require a name argument. \"\n  2819\t            \"<Index: fields=['pink']> doesn't have one.\"\n  2820\t        )\n  2821\t        with self.assertRaisesMessage(ValueError, msg):\n  2822\t            migrations.AddIndex(\"Pony\", models.Index(fields=[\"pink\"]))\n  2823\t        index = models.Index(fields=[\"pink\"], name=\"test_adin_pony_pink_idx\")\n  2824\t        operation = migrations.AddIndex(\"Pony\", index)\n  2825\t        self.assertEqual(\n  2826\t            operation.describe(),\n  2827\t            \"Create index test_adin_pony_pink_idx on field(s) pink of model Pony\",\n  2828\t        )\n  2829\t        self.assertEqual(\n  2830\t            operation.migration_name_fragment,\n  2831\t            \"pony_test_adin_pony_pink_idx\",\n  2832\t        )\n  2833\t        new_state = project_state.clone()\n  2834\t        operation.state_forwards(\"test_adin\", new_state)\n  2835\t        # Test the database alteration\n  2836\t        self.assertEqual(\n  2837\t            len(new_state.models[\"test_adin\", \"pony\"].options[\"indexes\"]), 1\n  2838\t        )\n  2839\t        self.assertIndexNotExists(\"test_adin_pony\", [\"pink\"])\n  2840\t        with connection.schema_editor() as editor:\n  2841\t            operation.database_forwards(\"test_adin\", editor, project_state, new_state)\n  2842\t        self.assertIndexExists(\"test_adin_pony\", [\"pink\"])\n  2843\t        # And test reversal\n  2844\t        with connection.schema_editor() as editor:\n  2845\t            operation.database_backwards(\"test_adin\", editor, new_state, project_state)\n  2846\t        self.assertIndexNotExists(\"test_adin_pony\", [\"pink\"])\n  2847\t        # And deconstruction\n  2848\t        definition = operation.deconstruct()\n  2849\t        self.assertEqual(definition[0], \"AddIndex\")\n  2850\t        self.assertEqual(definition[1], [])\n  2851\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"index\": index})\n  2852\t\n  2853\t    def test_remove_index(self):\n  2854\t        \"\"\"\n  2855\t        Test the RemoveIndex operation.\n  2856\t        \"\"\"\n  2857\t        project_state = self.set_up_test_model(\"test_rmin\", multicol_index=True)\n  2858\t        self.assertTableExists(\"test_rmin_pony\")\n  2859\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2860\t        operation = migrations.RemoveIndex(\"Pony\", \"pony_test_idx\")\n  2861\t        self.assertEqual(operation.describe(), \"Remove index pony_test_idx from Pony\")\n  2862\t        self.assertEqual(\n  2863\t            operation.migration_name_fragment,\n  2864\t            \"remove_pony_pony_test_idx\",\n  2865\t        )\n  2866\t        new_state = project_state.clone()\n  2867\t        operation.state_forwards(\"test_rmin\", new_state)\n  2868\t        # Test the state alteration\n  2869\t        self.assertEqual(\n  2870\t            len(new_state.models[\"test_rmin\", \"pony\"].options[\"indexes\"]), 0\n  2871\t        )\n  2872\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2873\t        # Test the database alteration\n  2874\t        with connection.schema_editor() as editor:\n  2875\t            operation.database_forwards(\"test_rmin\", editor, project_state, new_state)\n  2876\t        self.assertIndexNotExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2877\t        # And test reversal\n  2878\t        with connection.schema_editor() as editor:\n  2879\t            operation.database_backwards(\"test_rmin\", editor, new_state, project_state)\n  2880\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2881\t        # And deconstruction\n  2882\t        definition = operation.deconstruct()\n  2883\t        self.assertEqual(definition[0], \"RemoveIndex\")\n  2884\t        self.assertEqual(definition[1], [])\n  2885\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"name\": \"pony_test_idx\"})\n  2886\t\n  2887\t        # Also test a field dropped with index - sqlite remake issue\n  2888\t        operations = [\n  2889\t            migrations.RemoveIndex(\"Pony\", \"pony_test_idx\"),\n  2890\t            migrations.RemoveField(\"Pony\", \"pink\"),\n  2891\t        ]\n  2892\t        self.assertColumnExists(\"test_rmin_pony\", \"pink\")\n  2893\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2894\t        # Test database alteration\n  2895\t        new_state = project_state.clone()\n  2896\t        self.apply_operations(\"test_rmin\", new_state, operations=operations)\n  2897\t        self.assertColumnNotExists(\"test_rmin_pony\", \"pink\")\n  2898\t        self.assertIndexNotExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2899\t        # And test reversal\n  2900\t        self.unapply_operations(\"test_rmin\", project_state, operations=operations)\n  2901\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2902\t\n  2903\t    def test_rename_index(self):\n  2904\t        app_label = \"test_rnin\"\n  2905\t        project_state = self.set_up_test_model(app_label, index=True)\n  2906\t        table_name = app_label + \"_pony\"\n  2907\t        self.assertIndexNameExists(table_name, \"pony_pink_idx\")\n  2908\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2909\t        operation = migrations.RenameIndex(\n  2910\t            \"Pony\", new_name=\"new_pony_test_idx\", old_name=\"pony_pink_idx\"\n  2911\t        )\n  2912\t        self.assertEqual(\n  2913\t            operation.describe(),\n  2914\t            \"Rename index pony_pink_idx on Pony to new_pony_test_idx\",\n  2915\t        )\n  2916\t        self.assertEqual(\n  2917\t            operation.migration_name_fragment,\n  2918\t            \"rename_pony_pink_idx_new_pony_test_idx\",\n  2919\t        )\n  2920\t\n  2921\t        new_state = project_state.clone()\n  2922\t        operation.state_forwards(app_label, new_state)\n  2923\t        # Rename index.\n  2924\t        expected_queries = 1 if connection.features.can_rename_index else 2\n  2925\t        with connection.schema_editor() as editor, self.assertNumQueries(\n  2926\t            expected_queries\n  2927\t        ):\n  2928\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2929\t        self.assertIndexNameNotExists(table_name, \"pony_pink_idx\")\n  2930\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2931\t        # Reversal.\n  2932\t        with connection.schema_editor() as editor, self.assertNumQueries(\n  2933\t            expected_queries\n  2934\t        ):\n  2935\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2936\t        self.assertIndexNameExists(table_name, \"pony_pink_idx\")\n  2937\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2938\t        # Deconstruction.\n  2939\t        definition = operation.deconstruct()\n  2940\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2941\t        self.assertEqual(definition[1], [])\n  2942\t        self.assertEqual(\n  2943\t            definition[2],\n  2944\t            {\n  2945\t                \"model_name\": \"Pony\",\n  2946\t                \"old_name\": \"pony_pink_idx\",\n  2947\t                \"new_name\": \"new_pony_test_idx\",\n  2948\t            },\n  2949\t        )\n  2950\t\n  2951\t    def test_rename_index_arguments(self):\n  2952\t        msg = \"RenameIndex.old_name and old_fields are mutually exclusive.\"\n  2953\t        with self.assertRaisesMessage(ValueError, msg):\n  2954\t            migrations.RenameIndex(\n  2955\t                \"Pony\",\n  2956\t                new_name=\"new_idx_name\",\n  2957\t                old_name=\"old_idx_name\",\n  2958\t                old_fields=(\"weight\", \"pink\"),\n  2959\t            )\n  2960\t        msg = \"RenameIndex requires one of old_name and old_fields arguments to be set.\"\n  2961\t        with self.assertRaisesMessage(ValueError, msg):\n  2962\t            migrations.RenameIndex(\"Pony\", new_name=\"new_idx_name\")\n  2963\t\n  2964\t    def test_rename_index_unnamed_index(self):\n  2965\t        app_label = \"test_rninui\"\n  2966\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  2967\t        table_name = app_label + \"_pony\"\n  2968\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2969\t        operation = migrations.RenameIndex(\n  2970\t            \"Pony\", new_name=\"new_pony_test_idx\", old_fields=(\"weight\", \"pink\")\n  2971\t        )\n  2972\t        self.assertEqual(\n  2973\t            operation.describe(),\n  2974\t            \"Rename unnamed index for ('weight', 'pink') on Pony to new_pony_test_idx\",\n  2975\t        )\n  2976\t        self.assertEqual(\n  2977\t            operation.migration_name_fragment,\n  2978\t            \"rename_pony_weight_pink_new_pony_test_idx\",\n  2979\t        )\n  2980\t\n  2981\t        new_state = project_state.clone()\n  2982\t        operation.state_forwards(app_label, new_state)\n  2983\t        # Rename index.\n  2984\t        with connection.schema_editor() as editor:\n  2985\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2986\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2987\t        # Reverse is a no-op.\n  2988\t        with connection.schema_editor() as editor, self.assertNumQueries(0):\n  2989\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2990\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2991\t        # Deconstruction.\n  2992\t        definition = operation.deconstruct()\n  2993\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2994\t        self.assertEqual(definition[1], [])\n  2995\t        self.assertEqual(\n  2996\t            definition[2],\n  2997\t            {\n  2998\t                \"model_name\": \"Pony\",\n  2999\t                \"new_name\": \"new_pony_test_idx\",\n  3000\t                \"old_fields\": (\"weight\", \"pink\"),\n  3001\t            },\n  3002\t        )\n  3003\t\n  3004\t    def test_rename_index_unknown_unnamed_index(self):\n  3005\t        app_label = \"test_rninuui\"\n  3006\t        project_state = self.set_up_test_model(app_label)\n  3007\t        operation = migrations.RenameIndex(\n  3008\t            \"Pony\", new_name=\"new_pony_test_idx\", old_fields=(\"weight\", \"pink\")\n  3009\t        )\n  3010\t        new_state = project_state.clone()\n  3011\t        operation.state_forwards(app_label, new_state)\n  3012\t        msg = \"Found wrong number (0) of indexes for test_rninuui_pony(weight, pink).\"\n  3013\t        with connection.schema_editor() as editor:\n  3014\t            with self.assertRaisesMessage(ValueError, msg):\n  3015\t                operation.database_forwards(app_label, editor, project_state, new_state)\n  3016\t\n  3017\t    def test_add_index_state_forwards(self):\n  3018\t        project_state = self.set_up_test_model(\"test_adinsf\")\n  3019\t        index = models.Index(fields=[\"pink\"], name=\"test_adinsf_pony_pink_idx\")\n  3020\t        old_model = project_state.apps.get_model(\"test_adinsf\", \"Pony\")\n  3021\t        new_state = project_state.clone()\n  3022\t\n  3023\t        operation = migrations.AddIndex(\"Pony\", index)\n  3024\t        operation.state_forwards(\"test_adinsf\", new_state)\n  3025\t        new_model = new_state.apps.get_model(\"test_adinsf\", \"Pony\")\n  3026\t        self.assertIsNot(old_model, new_model)\n  3027\t\n  3028\t    def test_remove_index_state_forwards(self):\n  3029\t        project_state = self.set_up_test_model(\"test_rminsf\")\n  3030\t        index = models.Index(fields=[\"pink\"], name=\"test_rminsf_pony_pink_idx\")\n  3031\t        migrations.AddIndex(\"Pony\", index).state_forwards(\"test_rminsf\", project_state)\n  3032\t        old_model = project_state.apps.get_model(\"test_rminsf\", \"Pony\")\n  3033\t        new_state = project_state.clone()\n  3034\t\n  3035\t        operation = migrations.RemoveIndex(\"Pony\", \"test_rminsf_pony_pink_idx\")\n  3036\t        operation.state_forwards(\"test_rminsf\", new_state)\n  3037\t        new_model = new_state.apps.get_model(\"test_rminsf\", \"Pony\")\n  3038\t        self.assertIsNot(old_model, new_model)\n  3039\t\n  3040\t    def test_rename_index_state_forwards(self):\n  3041\t        app_label = \"test_rnidsf\"\n  3042\t        project_state = self.set_up_test_model(app_label, index=True)\n  3043\t        old_model = project_state.apps.get_model(app_label, \"Pony\")\n  3044\t        new_state = project_state.clone()\n  3045\t\n  3046\t        operation = migrations.RenameIndex(\n  3047\t            \"Pony\", new_name=\"new_pony_pink_idx\", old_name=\"pony_pink_idx\"\n  3048\t        )\n  3049\t        operation.state_forwards(app_label, new_state)\n  3050\t        new_model = new_state.apps.get_model(app_label, \"Pony\")\n  3051\t        self.assertIsNot(old_model, new_model)\n  3052\t        self.assertEqual(new_model._meta.indexes[0].name, \"new_pony_pink_idx\")\n  3053\t\n  3054\t    def test_rename_index_state_forwards_unnamed_index(self):\n  3055\t        app_label = \"test_rnidsfui\"\n  3056\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  3057\t        old_model = project_state.apps.get_model(app_label, \"Pony\")\n  3058\t        new_state = project_state.clone()\n  3059\t\n  3060\t        operation = migrations.RenameIndex(\n  3061\t            \"Pony\", new_name=\"new_pony_pink_idx\", old_fields=(\"weight\", \"pink\")\n  3062\t        )\n  3063\t        operation.state_forwards(app_label, new_state)\n  3064\t        new_model = new_state.apps.get_model(app_label, \"Pony\")\n  3065\t        self.assertIsNot(old_model, new_model)\n  3066\t        self.assertEqual(new_model._meta.index_together, tuple())\n  3067\t        self.assertEqual(new_model._meta.indexes[0].name, \"new_pony_pink_idx\")\n  3068\t\n  3069\t    @skipUnlessDBFeature(\"supports_expression_indexes\")\n  3070\t    def test_add_func_index(self):\n  3071\t        app_label = \"test_addfuncin\"\n  3072\t        index_name = f\"{app_label}_pony_abs_idx\"\n  3073\t        table_name = f\"{app_label}_pony\"\n  3074\t        project_state = self.set_up_test_model(app_label)\n  3075\t        index = models.Index(Abs(\"weight\"), name=index_name)\n  3076\t        operation = migrations.AddIndex(\"Pony\", index)\n  3077\t        self.assertEqual(\n  3078\t            operation.describe(),\n  3079\t            \"Create index test_addfuncin_pony_abs_idx on Abs(F(weight)) on model Pony\",\n  3080\t        )\n  3081\t        self.assertEqual(\n  3082\t            operation.migration_name_fragment,\n  3083\t            \"pony_test_addfuncin_pony_abs_idx\",\n  3084\t        )\n  3085\t        new_state = project_state.clone()\n  3086\t        operation.state_forwards(app_label, new_state)\n  3087\t        self.assertEqual(len(new_state.models[app_label, \"pony\"].options[\"indexes\"]), 1)\n  3088\t        self.assertIndexNameNotExists(table_name, index_name)\n  3089\t        # Add index.\n  3090\t        with connection.schema_editor() as editor:\n  3091\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3092\t        self.assertIndexNameExists(table_name, index_name)\n  3093\t        # Reversal.\n  3094\t        with connection.schema_editor() as editor:\n  3095\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3096\t        self.assertIndexNameNotExists(table_name, index_name)\n  3097\t        # Deconstruction.\n  3098\t        definition = operation.deconstruct()\n  3099\t        self.assertEqual(definition[0], \"AddIndex\")\n  3100\t        self.assertEqual(definition[1], [])\n  3101\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"index\": index})\n  3102\t\n  3103\t    @skipUnlessDBFeature(\"supports_expression_indexes\")\n  3104\t    def test_remove_func_index(self):\n  3105\t        app_label = \"test_rmfuncin\"\n  3106\t        index_name = f\"{app_label}_pony_abs_idx\"\n  3107\t        table_name = f\"{app_label}_pony\"\n  3108\t        project_state = self.set_up_test_model(\n  3109\t            app_label,\n  3110\t            indexes=[\n  3111\t                models.Index(Abs(\"weight\"), name=index_name),\n  3112\t            ],\n  3113\t        )\n  3114\t        self.assertTableExists(table_name)\n  3115\t        self.assertIndexNameExists(table_name, index_name)\n  3116\t        operation = migrations.RemoveIndex(\"Pony\", index_name)\n  3117\t        self.assertEqual(\n  3118\t            operation.describe(),\n  3119\t            \"Remove index test_rmfuncin_pony_abs_idx from Pony\",\n  3120\t        )\n  3121\t        self.assertEqual(\n  3122\t            operation.migration_name_fragment,\n  3123\t            \"remove_pony_test_rmfuncin_pony_abs_idx\",\n  3124\t        )\n  3125\t        new_state = project_state.clone()\n  3126\t        operation.state_forwards(app_label, new_state)\n  3127\t        self.assertEqual(len(new_state.models[app_label, \"pony\"].options[\"indexes\"]), 0)\n  3128\t        # Remove index.\n  3129\t        with connection.schema_editor() as editor:\n  3130\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3131\t        self.assertIndexNameNotExists(table_name, index_name)\n  3132\t        # Reversal.\n  3133\t        with connection.schema_editor() as editor:\n  3134\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3135\t        self.assertIndexNameExists(table_name, index_name)\n  3136\t        # Deconstruction.\n  3137\t        definition = operation.deconstruct()\n  3138\t        self.assertEqual(definition[0], \"RemoveIndex\")\n  3139\t        self.assertEqual(definition[1], [])\n  3140\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"name\": index_name})\n  3141\t\n  3142\t    @skipUnlessDBFeature(\"supports_expression_indexes\")\n  3143\t    def test_alter_field_with_func_index(self):\n  3144\t        app_label = \"test_alfuncin\"\n  3145\t        index_name = f\"{app_label}_pony_idx\"\n  3146\t        table_name = f\"{app_label}_pony\"\n  3147\t        project_state = self.set_up_test_model(\n  3148\t            app_label,\n  3149\t            indexes=[models.Index(Abs(\"pink\"), name=index_name)],\n  3150\t        )\n  3151\t        operation = migrations.AlterField(\n  3152\t            \"Pony\", \"pink\", models.IntegerField(null=True)\n  3153\t        )\n  3154\t        new_state = project_state.clone()\n  3155\t        operation.state_forwards(app_label, new_state)\n  3156\t        with connection.schema_editor() as editor:\n  3157\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3158\t        self.assertIndexNameExists(table_name, index_name)\n  3159\t        with connection.schema_editor() as editor:\n  3160\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3161\t        self.assertIndexNameExists(table_name, index_name)\n  3162\t\n  3163\t    def test_alter_field_with_index(self):\n  3164\t        \"\"\"\n  3165\t        Test AlterField operation with an index to ensure indexes created via\n  3166\t        Meta.indexes don't get dropped with sqlite3 remake.\n  3167\t        \"\"\"\n  3168\t        project_state = self.set_up_test_model(\"test_alflin\", index=True)\n  3169\t        operation = migrations.AlterField(\n  3170\t            \"Pony\", \"pink\", models.IntegerField(null=True)\n  3171\t        )\n  3172\t        new_state = project_state.clone()\n  3173\t        operation.state_forwards(\"test_alflin\", new_state)\n  3174\t        # Test the database alteration\n  3175\t        self.assertColumnNotNull(\"test_alflin_pony\", \"pink\")\n  3176\t        with connection.schema_editor() as editor:\n  3177\t            operation.database_forwards(\"test_alflin\", editor, project_state, new_state)\n  3178\t        # Index hasn't been dropped\n  3179\t        self.assertIndexExists(\"test_alflin_pony\", [\"pink\"])\n  3180\t        # And test reversal\n  3181\t        with connection.schema_editor() as editor:\n  3182\t            operation.database_backwards(\n  3183\t                \"test_alflin\", editor, new_state, project_state\n  3184\t            )\n  3185\t        # Ensure the index is still there\n  3186\t        self.assertIndexExists(\"test_alflin_pony\", [\"pink\"])\n  3187\t\n  3188\t    def test_alter_index_together(self):\n  3189\t        \"\"\"\n  3190\t        Tests the AlterIndexTogether operation.\n  3191\t        \"\"\"\n  3192\t        project_state = self.set_up_test_model(\"test_alinto\")\n  3193\t        # Test the state alteration\n  3194\t        operation = migrations.AlterIndexTogether(\"Pony\", [(\"pink\", \"weight\")])\n  3195\t        self.assertEqual(\n  3196\t            operation.describe(), \"Alter index_together for Pony (1 constraint(s))\"\n  3197\t        )\n  3198\t        self.assertEqual(\n  3199\t            operation.migration_name_fragment,\n  3200\t            \"alter_pony_index_together\",\n  3201\t        )\n  3202\t        new_state = project_state.clone()\n  3203\t        operation.state_forwards(\"test_alinto\", new_state)\n  3204\t        self.assertEqual(\n  3205\t            len(\n  3206\t                project_state.models[\"test_alinto\", \"pony\"].options.get(\n  3207\t                    \"index_together\", set()\n  3208\t                )\n  3209\t            ),\n  3210\t            0,\n  3211\t        )\n  3212\t        self.assertEqual(\n  3213\t            len(\n  3214\t                new_state.models[\"test_alinto\", \"pony\"].options.get(\n  3215\t                    \"index_together\", set()\n  3216\t                )\n  3217\t            ),\n  3218\t            1,\n  3219\t        )\n  3220\t        # Make sure there's no matching index\n  3221\t        self.assertIndexNotExists(\"test_alinto_pony\", [\"pink\", \"weight\"])\n  3222\t        # Test the database alteration\n  3223\t        with connection.schema_editor() as editor:\n  3224\t            operation.database_forwards(\"test_alinto\", editor, project_state, new_state)\n  3225\t        self.assertIndexExists(\"test_alinto_pony\", [\"pink\", \"weight\"])\n  3226\t        # And test reversal\n  3227\t        with connection.schema_editor() as editor:\n  3228\t            operation.database_backwards(\n  3229\t                \"test_alinto\", editor, new_state, project_state\n  3230\t            )\n  3231\t        self.assertIndexNotExists(\"test_alinto_pony\", [\"pink\", \"weight\"])\n  3232\t        # And deconstruction\n  3233\t        definition = operation.deconstruct()\n  3234\t        self.assertEqual(definition[0], \"AlterIndexTogether\")\n  3235\t        self.assertEqual(definition[1], [])\n  3236\t        self.assertEqual(\n  3237\t            definition[2], {\"name\": \"Pony\", \"index_together\": {(\"pink\", \"weight\")}}\n  3238\t        )\n  3239\t\n  3240\t    def test_alter_index_together_remove(self):\n  3241\t        operation = migrations.AlterIndexTogether(\"Pony\", None)\n  3242\t        self.assertEqual(\n  3243\t            operation.describe(), \"Alter index_together for Pony (0 constraint(s))\"\n  3244\t        )\n  3245\t\n  3246\t    @skipUnlessDBFeature(\"allows_multiple_constraints_on_same_fields\")\n  3247\t    def test_alter_index_together_remove_with_unique_together(self):\n  3248\t        app_label = \"test_alintoremove_wunto\"\n  3249\t        table_name = \"%s_pony\" % app_label\n  3250\t        project_state = self.set_up_test_model(app_label, unique_together=True)\n  3251\t        self.assertUniqueConstraintExists(table_name, [\"pink\", \"weight\"])\n  3252\t        # Add index together.\n  3253\t        new_state = project_state.clone()\n  3254\t        operation = migrations.AlterIndexTogether(\"Pony\", [(\"pink\", \"weight\")])\n  3255\t        operation.state_forwards(app_label, new_state)\n  3256\t        with connection.schema_editor() as editor:\n  3257\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3258\t        self.assertIndexExists(table_name, [\"pink\", \"weight\"])\n  3259\t        # Remove index together.\n  3260\t        project_state = new_state\n  3261\t        new_state = project_state.clone()\n  3262\t        operation = migrations.AlterIndexTogether(\"Pony\", set())\n  3263\t        operation.state_forwards(app_label, new_state)\n  3264\t        with connection.schema_editor() as editor:\n  3265\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3266\t        self.assertIndexNotExists(table_name, [\"pink\", \"weight\"])\n  3267\t        self.assertUniqueConstraintExists(table_name, [\"pink\", \"weight\"])\n  3268\t\n  3269\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3270\t    def test_add_constraint(self):\n  3271\t        project_state = self.set_up_test_model(\"test_addconstraint\")\n  3272\t        gt_check = models.Q(pink__gt=2)\n  3273\t        gt_constraint = models.CheckConstraint(\n  3274\t            check=gt_check, name=\"test_add_constraint_pony_pink_gt_2\"\n  3275\t        )\n  3276\t        gt_operation = migrations.AddConstraint(\"Pony\", gt_constraint)\n  3277\t        self.assertEqual(\n  3278\t            gt_operation.describe(),\n  3279\t            \"Create constraint test_add_constraint_pony_pink_gt_2 on model Pony\",\n  3280\t        )\n  3281\t        self.assertEqual(\n  3282\t            gt_operation.migration_name_fragment,\n  3283\t            \"pony_test_add_constraint_pony_pink_gt_2\",\n  3284\t        )\n  3285\t        # Test the state alteration\n  3286\t        new_state = project_state.clone()\n  3287\t        gt_operation.state_forwards(\"test_addconstraint\", new_state)\n  3288\t        self.assertEqual(\n  3289\t            len(new_state.models[\"test_addconstraint\", \"pony\"].options[\"constraints\"]),\n  3290\t            1,\n  3291\t        )\n  3292\t        Pony = new_state.apps.get_model(\"test_addconstraint\", \"Pony\")\n  3293\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3294\t        # Test the database alteration\n  3295\t        with connection.schema_editor() as editor:\n  3296\t            gt_operation.database_forwards(\n  3297\t                \"test_addconstraint\", editor, project_state, new_state\n  3298\t            )\n  3299\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3300\t            Pony.objects.create(pink=1, weight=1.0)\n  3301\t        # Add another one.\n  3302\t        lt_check = models.Q(pink__lt=100)\n  3303\t        lt_constraint = models.CheckConstraint(\n  3304\t            check=lt_check, name=\"test_add_constraint_pony_pink_lt_100\"\n  3305\t        )\n  3306\t        lt_operation = migrations.AddConstraint(\"Pony\", lt_constraint)\n  3307\t        lt_operation.state_forwards(\"test_addconstraint\", new_state)\n  3308\t        self.assertEqual(\n  3309\t            len(new_state.models[\"test_addconstraint\", \"pony\"].options[\"constraints\"]),\n  3310\t            2,\n  3311\t        )\n  3312\t        Pony = new_state.apps.get_model(\"test_addconstraint\", \"Pony\")\n  3313\t        self.assertEqual(len(Pony._meta.constraints), 2)\n  3314\t        with connection.schema_editor() as editor:\n  3315\t            lt_operation.database_forwards(\n  3316\t                \"test_addconstraint\", editor, project_state, new_state\n  3317\t            )\n  3318\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3319\t            Pony.objects.create(pink=100, weight=1.0)\n  3320\t        # Test reversal\n  3321\t        with connection.schema_editor() as editor:\n  3322\t            gt_operation.database_backwards(\n  3323\t                \"test_addconstraint\", editor, new_state, project_state\n  3324\t            )\n  3325\t        Pony.objects.create(pink=1, weight=1.0)\n  3326\t        # Test deconstruction\n  3327\t        definition = gt_operation.deconstruct()\n  3328\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3329\t        self.assertEqual(definition[1], [])\n  3330\t        self.assertEqual(\n  3331\t            definition[2], {\"model_name\": \"Pony\", \"constraint\": gt_constraint}\n  3332\t        )\n  3333\t\n  3334\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3335\t    def test_add_constraint_percent_escaping(self):\n  3336\t        app_label = \"add_constraint_string_quoting\"\n  3337\t        operations = [\n  3338\t            migrations.CreateModel(\n  3339\t                \"Author\",\n  3340\t                fields=[\n  3341\t                    (\"id\", models.AutoField(primary_key=True)),\n  3342\t                    (\"name\", models.CharField(max_length=100)),\n  3343\t                    (\"surname\", models.CharField(max_length=100, default=\"\")),\n  3344\t                    (\"rebate\", models.CharField(max_length=100)),\n  3345\t                ],\n  3346\t            ),\n  3347\t        ]\n  3348\t        from_state = self.apply_operations(app_label, ProjectState(), operations)\n  3349\t        # \"%\" generated in startswith lookup should be escaped in a way that is\n  3350\t        # considered a leading wildcard.\n  3351\t        check = models.Q(name__startswith=\"Albert\")\n  3352\t        constraint = models.CheckConstraint(check=check, name=\"name_constraint\")\n  3353\t        operation = migrations.AddConstraint(\"Author\", constraint)\n  3354\t        to_state = from_state.clone()\n  3355\t        operation.state_forwards(app_label, to_state)\n  3356\t        with connection.schema_editor() as editor:\n  3357\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3358\t        Author = to_state.apps.get_model(app_label, \"Author\")\n  3359\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3360\t            Author.objects.create(name=\"Artur\")\n  3361\t        # Literal \"%\" should be escaped in a way that is not a considered a\n  3362\t        # wildcard.\n  3363\t        check = models.Q(rebate__endswith=\"%\")\n  3364\t        constraint = models.CheckConstraint(check=check, name=\"rebate_constraint\")\n  3365\t        operation = migrations.AddConstraint(\"Author\", constraint)\n  3366\t        from_state = to_state\n  3367\t        to_state = from_state.clone()\n  3368\t        operation.state_forwards(app_label, to_state)\n  3369\t        Author = to_state.apps.get_model(app_label, \"Author\")\n  3370\t        with connection.schema_editor() as editor:\n  3371\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3372\t        Author = to_state.apps.get_model(app_label, \"Author\")\n  3373\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3374\t            Author.objects.create(name=\"Albert\", rebate=\"10$\")\n  3375\t        author = Author.objects.create(name=\"Albert\", rebate=\"10%\")\n  3376\t        self.assertEqual(Author.objects.get(), author)\n  3377\t        # Right-hand-side baked \"%\" literals should not be used for parameters\n  3378\t        # interpolation.\n  3379\t        check = ~models.Q(surname__startswith=models.F(\"name\"))\n  3380\t        constraint = models.CheckConstraint(check=check, name=\"name_constraint_rhs\")\n  3381\t        operation = migrations.AddConstraint(\"Author\", constraint)\n  3382\t        from_state = to_state\n  3383\t        to_state = from_state.clone()\n  3384\t        operation.state_forwards(app_label, to_state)\n  3385\t        with connection.schema_editor() as editor:\n  3386\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3387\t        Author = to_state.apps.get_model(app_label, \"Author\")\n  3388\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3389\t            Author.objects.create(name=\"Albert\", surname=\"Alberto\")\n  3390\t\n  3391\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3392\t    def test_add_or_constraint(self):\n  3393\t        app_label = \"test_addorconstraint\"\n  3394\t        constraint_name = \"add_constraint_or\"\n  3395\t        from_state = self.set_up_test_model(app_label)\n  3396\t        check = models.Q(pink__gt=2, weight__gt=2) | models.Q(weight__lt=0)\n  3397\t        constraint = models.CheckConstraint(check=check, name=constraint_name)\n  3398\t        operation = migrations.AddConstraint(\"Pony\", constraint)\n  3399\t        to_state = from_state.clone()\n  3400\t        operation.state_forwards(app_label, to_state)\n  3401\t        with connection.schema_editor() as editor:\n  3402\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3403\t        Pony = to_state.apps.get_model(app_label, \"Pony\")\n  3404\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3405\t            Pony.objects.create(pink=2, weight=3.0)\n  3406\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3407\t            Pony.objects.create(pink=3, weight=1.0)\n  3408\t        Pony.objects.bulk_create(\n  3409\t            [\n  3410\t                Pony(pink=3, weight=-1.0),\n  3411\t                Pony(pink=1, weight=-1.0),\n  3412\t                Pony(pink=3, weight=3.0),\n  3413\t            ]\n  3414\t        )\n  3415\t\n  3416\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3417\t    def test_add_constraint_combinable(self):\n  3418\t        app_label = \"test_addconstraint_combinable\"\n  3419\t        operations = [\n  3420\t            migrations.CreateModel(\n  3421\t                \"Book\",\n  3422\t                fields=[\n  3423\t                    (\"id\", models.AutoField(primary_key=True)),\n  3424\t                    (\"read\", models.PositiveIntegerField()),\n  3425\t                    (\"unread\", models.PositiveIntegerField()),\n  3426\t                ],\n  3427\t            ),\n  3428\t        ]\n  3429\t        from_state = self.apply_operations(app_label, ProjectState(), operations)\n  3430\t        constraint = models.CheckConstraint(\n  3431\t            check=models.Q(read=(100 - models.F(\"unread\"))),\n  3432\t            name=\"test_addconstraint_combinable_sum_100\",\n  3433\t        )\n  3434\t        operation = migrations.AddConstraint(\"Book\", constraint)\n  3435\t        to_state = from_state.clone()\n  3436\t        operation.state_forwards(app_label, to_state)\n  3437\t        with connection.schema_editor() as editor:\n  3438\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3439\t        Book = to_state.apps.get_model(app_label, \"Book\")\n  3440\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3441\t            Book.objects.create(read=70, unread=10)\n  3442\t        Book.objects.create(read=70, unread=30)\n  3443\t\n  3444\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3445\t    def test_remove_constraint(self):\n  3446\t        project_state = self.set_up_test_model(\n  3447\t            \"test_removeconstraint\",\n  3448\t            constraints=[\n  3449\t                models.CheckConstraint(\n  3450\t                    check=models.Q(pink__gt=2),\n  3451\t                    name=\"test_remove_constraint_pony_pink_gt_2\",\n  3452\t                ),\n  3453\t                models.CheckConstraint(\n  3454\t                    check=models.Q(pink__lt=100),\n  3455\t                    name=\"test_remove_constraint_pony_pink_lt_100\",\n  3456\t                ),\n  3457\t            ],\n  3458\t        )\n  3459\t        gt_operation = migrations.RemoveConstraint(\n  3460\t            \"Pony\", \"test_remove_constraint_pony_pink_gt_2\"\n  3461\t        )\n  3462\t        self.assertEqual(\n  3463\t            gt_operation.describe(),\n  3464\t            \"Remove constraint test_remove_constraint_pony_pink_gt_2 from model Pony\",\n  3465\t        )\n  3466\t        self.assertEqual(\n  3467\t            gt_operation.migration_name_fragment,\n  3468\t            \"remove_pony_test_remove_constraint_pony_pink_gt_2\",\n  3469\t        )\n  3470\t        # Test state alteration\n  3471\t        new_state = project_state.clone()\n  3472\t        gt_operation.state_forwards(\"test_removeconstraint\", new_state)\n  3473\t        self.assertEqual(\n  3474\t            len(\n  3475\t                new_state.models[\"test_removeconstraint\", \"pony\"].options[\"constraints\"]\n  3476\t            ),\n  3477\t            1,\n  3478\t        )\n  3479\t        Pony = new_state.apps.get_model(\"test_removeconstraint\", \"Pony\")\n  3480\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3481\t        # Test database alteration\n  3482\t        with connection.schema_editor() as editor:\n  3483\t            gt_operation.database_forwards(\n  3484\t                \"test_removeconstraint\", editor, project_state, new_state\n  3485\t            )\n  3486\t        Pony.objects.create(pink=1, weight=1.0).delete()\n  3487\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3488\t            Pony.objects.create(pink=100, weight=1.0)\n  3489\t        # Remove the other one.\n  3490\t        lt_operation = migrations.RemoveConstraint(\n  3491\t            \"Pony\", \"test_remove_constraint_pony_pink_lt_100\"\n  3492\t        )\n  3493\t        lt_operation.state_forwards(\"test_removeconstraint\", new_state)\n  3494\t        self.assertEqual(\n  3495\t            len(\n  3496\t                new_state.models[\"test_removeconstraint\", \"pony\"].options[\"constraints\"]\n  3497\t            ),\n  3498\t            0,\n  3499\t        )\n  3500\t        Pony = new_state.apps.get_model(\"test_removeconstraint\", \"Pony\")\n  3501\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3502\t        with connection.schema_editor() as editor:\n  3503\t            lt_operation.database_forwards(\n  3504\t                \"test_removeconstraint\", editor, project_state, new_state\n  3505\t            )\n  3506\t        Pony.objects.create(pink=100, weight=1.0).delete()\n  3507\t        # Test reversal\n  3508\t        with connection.schema_editor() as editor:\n  3509\t            gt_operation.database_backwards(\n  3510\t                \"test_removeconstraint\", editor, new_state, project_state\n  3511\t            )\n  3512\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3513\t            Pony.objects.create(pink=1, weight=1.0)\n  3514\t        # Test deconstruction\n  3515\t        definition = gt_operation.deconstruct()\n  3516\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3517\t        self.assertEqual(definition[1], [])\n  3518\t        self.assertEqual(\n  3519\t            definition[2],\n  3520\t            {\"model_name\": \"Pony\", \"name\": \"test_remove_constraint_pony_pink_gt_2\"},\n  3521\t        )\n  3522\t\n  3523\t    def test_add_partial_unique_constraint(self):\n  3524\t        project_state = self.set_up_test_model(\"test_addpartialuniqueconstraint\")\n  3525\t        partial_unique_constraint = models.UniqueConstraint(\n  3526\t            fields=[\"pink\"],\n  3527\t            condition=models.Q(weight__gt=5),\n  3528\t            name=\"test_constraint_pony_pink_for_weight_gt_5_uniq\",\n  3529\t        )\n  3530\t        operation = migrations.AddConstraint(\"Pony\", partial_unique_constraint)\n  3531\t        self.assertEqual(\n  3532\t            operation.describe(),\n  3533\t            \"Create constraint test_constraint_pony_pink_for_weight_gt_5_uniq \"\n  3534\t            \"on model Pony\",\n  3535\t        )\n  3536\t        # Test the state alteration\n  3537\t        new_state = project_state.clone()\n  3538\t        operation.state_forwards(\"test_addpartialuniqueconstraint\", new_state)\n  3539\t        self.assertEqual(\n  3540\t            len(\n  3541\t                new_state.models[\"test_addpartialuniqueconstraint\", \"pony\"].options[\n  3542\t                    \"constraints\"\n  3543\t                ]\n  3544\t            ),\n  3545\t            1,\n  3546\t        )\n  3547\t        Pony = new_state.apps.get_model(\"test_addpartialuniqueconstraint\", \"Pony\")\n  3548\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3549\t        # Test the database alteration\n  3550\t        with connection.schema_editor() as editor:\n  3551\t            operation.database_forwards(\n  3552\t                \"test_addpartialuniqueconstraint\", editor, project_state, new_state\n  3553\t            )\n  3554\t        # Test constraint works\n  3555\t        Pony.objects.create(pink=1, weight=4.0)\n  3556\t        Pony.objects.create(pink=1, weight=4.0)\n  3557\t        Pony.objects.create(pink=1, weight=6.0)\n  3558\t        if connection.features.supports_partial_indexes:\n  3559\t            with self.assertRaises(IntegrityError), transaction.atomic():\n  3560\t                Pony.objects.create(pink=1, weight=7.0)\n  3561\t        else:\n  3562\t            Pony.objects.create(pink=1, weight=7.0)\n  3563\t        # Test reversal\n  3564\t        with connection.schema_editor() as editor:\n  3565\t            operation.database_backwards(\n  3566\t                \"test_addpartialuniqueconstraint\", editor, new_state, project_state\n  3567\t            )\n  3568\t        # Test constraint doesn't work\n  3569\t        Pony.objects.create(pink=1, weight=7.0)\n  3570\t        # Test deconstruction\n  3571\t        definition = operation.deconstruct()\n  3572\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3573\t        self.assertEqual(definition[1], [])\n  3574\t        self.assertEqual(\n  3575\t            definition[2],\n  3576\t            {\"model_name\": \"Pony\", \"constraint\": partial_unique_constraint},\n  3577\t        )\n  3578\t\n  3579\t    def test_remove_partial_unique_constraint(self):\n  3580\t        project_state = self.set_up_test_model(\n  3581\t            \"test_removepartialuniqueconstraint\",\n  3582\t            constraints=[\n  3583\t                models.UniqueConstraint(\n  3584\t                    fields=[\"pink\"],\n  3585\t                    condition=models.Q(weight__gt=5),\n  3586\t                    name=\"test_constraint_pony_pink_for_weight_gt_5_uniq\",\n  3587\t                ),\n  3588\t            ],\n  3589\t        )\n  3590\t        gt_operation = migrations.RemoveConstraint(\n  3591\t            \"Pony\", \"test_constraint_pony_pink_for_weight_gt_5_uniq\"\n  3592\t        )\n  3593\t        self.assertEqual(\n  3594\t            gt_operation.describe(),\n  3595\t            \"Remove constraint test_constraint_pony_pink_for_weight_gt_5_uniq from \"\n  3596\t            \"model Pony\",\n  3597\t        )\n  3598\t        # Test state alteration\n  3599\t        new_state = project_state.clone()\n  3600\t        gt_operation.state_forwards(\"test_removepartialuniqueconstraint\", new_state)\n  3601\t        self.assertEqual(\n  3602\t            len(\n  3603\t                new_state.models[\"test_removepartialuniqueconstraint\", \"pony\"].options[\n  3604\t                    \"constraints\"\n  3605\t                ]\n  3606\t            ),\n  3607\t            0,\n  3608\t        )\n  3609\t        Pony = new_state.apps.get_model(\"test_removepartialuniqueconstraint\", \"Pony\")\n  3610\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3611\t        # Test database alteration\n  3612\t        with connection.schema_editor() as editor:\n  3613\t            gt_operation.database_forwards(\n  3614\t                \"test_removepartialuniqueconstraint\", editor, project_state, new_state\n  3615\t            )\n  3616\t        # Test constraint doesn't work\n  3617\t        Pony.objects.create(pink=1, weight=4.0)\n  3618\t        Pony.objects.create(pink=1, weight=4.0)\n  3619\t        Pony.objects.create(pink=1, weight=6.0)\n  3620\t        Pony.objects.create(pink=1, weight=7.0).delete()\n  3621\t        # Test reversal\n  3622\t        with connection.schema_editor() as editor:\n  3623\t            gt_operation.database_backwards(\n  3624\t                \"test_removepartialuniqueconstraint\", editor, new_state, project_state\n  3625\t            )\n  3626\t        # Test constraint works\n  3627\t        if connection.features.supports_partial_indexes:\n  3628\t            with self.assertRaises(IntegrityError), transaction.atomic():\n  3629\t                Pony.objects.create(pink=1, weight=7.0)\n  3630\t        else:\n  3631\t            Pony.objects.create(pink=1, weight=7.0)\n  3632\t        # Test deconstruction\n  3633\t        definition = gt_operation.deconstruct()\n  3634\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3635\t        self.assertEqual(definition[1], [])\n  3636\t        self.assertEqual(\n  3637\t            definition[2],\n  3638\t            {\n  3639\t                \"model_name\": \"Pony\",\n  3640\t                \"name\": \"test_constraint_pony_pink_for_weight_gt_5_uniq\",\n  3641\t            },\n  3642\t        )\n  3643\t\n  3644\t    def test_add_deferred_unique_constraint(self):\n  3645\t        app_label = \"test_adddeferred_uc\"\n  3646\t        project_state = self.set_up_test_model(app_label)\n  3647\t        deferred_unique_constraint = models.UniqueConstraint(\n  3648\t            fields=[\"pink\"],\n  3649\t            name=\"deferred_pink_constraint_add\",\n  3650\t            deferrable=models.Deferrable.DEFERRED,\n  3651\t        )\n  3652\t        operation = migrations.AddConstraint(\"Pony\", deferred_unique_constraint)\n  3653\t        self.assertEqual(\n  3654\t            operation.describe(),\n  3655\t            \"Create constraint deferred_pink_constraint_add on model Pony\",\n  3656\t        )\n  3657\t        # Add constraint.\n  3658\t        new_state = project_state.clone()\n  3659\t        operation.state_forwards(app_label, new_state)\n  3660\t        self.assertEqual(\n  3661\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 1\n  3662\t        )\n  3663\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3664\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3665\t        with connection.schema_editor() as editor, CaptureQueriesContext(\n  3666\t            connection\n  3667\t        ) as ctx:\n  3668\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3669\t        Pony.objects.create(pink=1, weight=4.0)\n  3670\t        if connection.features.supports_deferrable_unique_constraints:\n  3671\t            # Unique constraint is deferred.\n  3672\t            with transaction.atomic():\n  3673\t                obj = Pony.objects.create(pink=1, weight=4.0)\n  3674\t                obj.pink = 2\n  3675\t                obj.save()\n  3676\t            # Constraint behavior can be changed with SET CONSTRAINTS.\n  3677\t            with self.assertRaises(IntegrityError):\n  3678\t                with transaction.atomic(), connection.cursor() as cursor:\n  3679\t                    quoted_name = connection.ops.quote_name(\n  3680\t                        deferred_unique_constraint.name\n  3681\t                    )\n  3682\t                    cursor.execute(\"SET CONSTRAINTS %s IMMEDIATE\" % quoted_name)\n  3683\t                    obj = Pony.objects.create(pink=1, weight=4.0)\n  3684\t                    obj.pink = 3\n  3685\t                    obj.save()\n  3686\t        else:\n  3687\t            self.assertEqual(len(ctx), 0)\n  3688\t            Pony.objects.create(pink=1, weight=4.0)\n  3689\t        # Reversal.\n  3690\t        with connection.schema_editor() as editor:\n  3691\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3692\t        # Constraint doesn't work.\n  3693\t        Pony.objects.create(pink=1, weight=4.0)\n  3694\t        # Deconstruction.\n  3695\t        definition = operation.deconstruct()\n  3696\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3697\t        self.assertEqual(definition[1], [])\n  3698\t        self.assertEqual(\n  3699\t            definition[2],\n  3700\t            {\"model_name\": \"Pony\", \"constraint\": deferred_unique_constraint},\n  3701\t        )\n  3702\t\n  3703\t    def test_remove_deferred_unique_constraint(self):\n  3704\t        app_label = \"test_removedeferred_uc\"\n  3705\t        deferred_unique_constraint = models.UniqueConstraint(\n  3706\t            fields=[\"pink\"],\n  3707\t            name=\"deferred_pink_constraint_rm\",\n  3708\t            deferrable=models.Deferrable.DEFERRED,\n  3709\t        )\n  3710\t        project_state = self.set_up_test_model(\n  3711\t            app_label, constraints=[deferred_unique_constraint]\n  3712\t        )\n  3713\t        operation = migrations.RemoveConstraint(\"Pony\", deferred_unique_constraint.name)\n  3714\t        self.assertEqual(\n  3715\t            operation.describe(),\n  3716\t            \"Remove constraint deferred_pink_constraint_rm from model Pony\",\n  3717\t        )\n  3718\t        # Remove constraint.\n  3719\t        new_state = project_state.clone()\n  3720\t        operation.state_forwards(app_label, new_state)\n  3721\t        self.assertEqual(\n  3722\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 0\n  3723\t        )\n  3724\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3725\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3726\t        with connection.schema_editor() as editor, CaptureQueriesContext(\n  3727\t            connection\n  3728\t        ) as ctx:\n  3729\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3730\t        # Constraint doesn't work.\n  3731\t        Pony.objects.create(pink=1, weight=4.0)\n  3732\t        Pony.objects.create(pink=1, weight=4.0).delete()\n  3733\t        if not connection.features.supports_deferrable_unique_constraints:\n  3734\t            self.assertEqual(len(ctx), 0)\n  3735\t        # Reversal.\n  3736\t        with connection.schema_editor() as editor:\n  3737\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3738\t        if connection.features.supports_deferrable_unique_constraints:\n  3739\t            # Unique constraint is deferred.\n  3740\t            with transaction.atomic():\n  3741\t                obj = Pony.objects.create(pink=1, weight=4.0)\n  3742\t                obj.pink = 2\n  3743\t                obj.save()\n  3744\t            # Constraint behavior can be changed with SET CONSTRAINTS.\n  3745\t            with self.assertRaises(IntegrityError):\n  3746\t                with transaction.atomic(), connection.cursor() as cursor:\n  3747\t                    quoted_name = connection.ops.quote_name(\n  3748\t                        deferred_unique_constraint.name\n  3749\t                    )\n  3750\t                    cursor.execute(\"SET CONSTRAINTS %s IMMEDIATE\" % quoted_name)\n  3751\t                    obj = Pony.objects.create(pink=1, weight=4.0)\n  3752\t                    obj.pink = 3\n  3753\t                    obj.save()\n  3754\t        else:\n  3755\t            Pony.objects.create(pink=1, weight=4.0)\n  3756\t        # Deconstruction.\n  3757\t        definition = operation.deconstruct()\n  3758\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3759\t        self.assertEqual(definition[1], [])\n  3760\t        self.assertEqual(\n  3761\t            definition[2],\n  3762\t            {\n  3763\t                \"model_name\": \"Pony\",\n  3764\t                \"name\": \"deferred_pink_constraint_rm\",\n  3765\t            },\n  3766\t        )\n  3767\t\n  3768\t    def test_add_covering_unique_constraint(self):\n  3769\t        app_label = \"test_addcovering_uc\"\n  3770\t        project_state = self.set_up_test_model(app_label)\n  3771\t        covering_unique_constraint = models.UniqueConstraint(\n  3772\t            fields=[\"pink\"],\n  3773\t            name=\"covering_pink_constraint_add\",\n  3774\t            include=[\"weight\"],\n  3775\t        )\n  3776\t        operation = migrations.AddConstraint(\"Pony\", covering_unique_constraint)\n  3777\t        self.assertEqual(\n  3778\t            operation.describe(),\n  3779\t            \"Create constraint covering_pink_constraint_add on model Pony\",\n  3780\t        )\n  3781\t        # Add constraint.\n  3782\t        new_state = project_state.clone()\n  3783\t        operation.state_forwards(app_label, new_state)\n  3784\t        self.assertEqual(\n  3785\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 1\n  3786\t        )\n  3787\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3788\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3789\t        with connection.schema_editor() as editor, CaptureQueriesContext(\n  3790\t            connection\n  3791\t        ) as ctx:\n  3792\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3793\t        Pony.objects.create(pink=1, weight=4.0)\n  3794\t        if connection.features.supports_covering_indexes:\n  3795\t            with self.assertRaises(IntegrityError):\n  3796\t                Pony.objects.create(pink=1, weight=4.0)\n  3797\t        else:\n  3798\t            self.assertEqual(len(ctx), 0)\n  3799\t            Pony.objects.create(pink=1, weight=4.0)\n  3800\t        # Reversal.\n  3801\t        with connection.schema_editor() as editor:\n  3802\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3803\t        # Constraint doesn't work.\n  3804\t        Pony.objects.create(pink=1, weight=4.0)\n  3805\t        # Deconstruction.\n  3806\t        definition = operation.deconstruct()\n  3807\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3808\t        self.assertEqual(definition[1], [])\n  3809\t        self.assertEqual(\n  3810\t            definition[2],\n  3811\t            {\"model_name\": \"Pony\", \"constraint\": covering_unique_constraint},\n  3812\t        )\n  3813\t\n  3814\t    def test_remove_covering_unique_constraint(self):\n  3815\t        app_label = \"test_removecovering_uc\"\n  3816\t        covering_unique_constraint = models.UniqueConstraint(\n  3817\t            fields=[\"pink\"],\n  3818\t            name=\"covering_pink_constraint_rm\",\n  3819\t            include=[\"weight\"],\n  3820\t        )\n  3821\t        project_state = self.set_up_test_model(\n  3822\t            app_label, constraints=[covering_unique_constraint]\n  3823\t        )\n  3824\t        operation = migrations.RemoveConstraint(\"Pony\", covering_unique_constraint.name)\n  3825\t        self.assertEqual(\n  3826\t            operation.describe(),\n  3827\t            \"Remove constraint covering_pink_constraint_rm from model Pony\",\n  3828\t        )\n  3829\t        # Remove constraint.\n  3830\t        new_state = project_state.clone()\n  3831\t        operation.state_forwards(app_label, new_state)\n  3832\t        self.assertEqual(\n  3833\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 0\n  3834\t        )\n  3835\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3836\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3837\t        with connection.schema_editor() as editor, CaptureQueriesContext(\n  3838\t            connection\n  3839\t        ) as ctx:\n  3840\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3841\t        # Constraint doesn't work.\n  3842\t        Pony.objects.create(pink=1, weight=4.0)\n  3843\t        Pony.objects.create(pink=1, weight=4.0).delete()\n  3844\t        if not connection.features.supports_covering_indexes:\n  3845\t            self.assertEqual(len(ctx), 0)\n  3846\t        # Reversal.\n  3847\t        with connection.schema_editor() as editor:\n  3848\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3849\t        if connection.features.supports_covering_indexes:\n  3850\t            with self.assertRaises(IntegrityError):\n  3851\t                Pony.objects.create(pink=1, weight=4.0)\n  3852\t        else:\n  3853\t            Pony.objects.create(pink=1, weight=4.0)\n  3854\t        # Deconstruction.\n  3855\t        definition = operation.deconstruct()\n  3856\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3857\t        self.assertEqual(definition[1], [])\n  3858\t        self.assertEqual(\n  3859\t            definition[2],\n  3860\t            {\n  3861\t                \"model_name\": \"Pony\",\n  3862\t                \"name\": \"covering_pink_constraint_rm\",\n  3863\t            },\n  3864\t        )\n  3865\t\n  3866\t    def test_alter_field_with_func_unique_constraint(self):\n  3867\t        app_label = \"test_alfuncuc\"\n  3868\t        constraint_name = f\"{app_label}_pony_uq\"\n  3869\t        table_name = f\"{app_label}_pony\"\n  3870\t        project_state = self.set_up_test_model(\n  3871\t            app_label,\n  3872\t            constraints=[\n  3873\t                models.UniqueConstraint(\"pink\", \"weight\", name=constraint_name)\n  3874\t            ],\n  3875\t        )\n  3876\t        operation = migrations.AlterField(\n  3877\t            \"Pony\", \"pink\", models.IntegerField(null=True)\n  3878\t        )\n  3879\t        new_state = project_state.clone()\n  3880\t        operation.state_forwards(app_label, new_state)\n  3881\t        with connection.schema_editor() as editor:\n  3882\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3883\t        if connection.features.supports_expression_indexes:\n  3884\t            self.assertIndexNameExists(table_name, constraint_name)\n  3885\t        with connection.schema_editor() as editor:\n  3886\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3887\t        if connection.features.supports_expression_indexes:\n  3888\t            self.assertIndexNameExists(table_name, constraint_name)\n  3889\t\n  3890\t    def test_add_func_unique_constraint(self):\n  3891\t        app_label = \"test_adfuncuc\"\n  3892\t        constraint_name = f\"{app_label}_pony_abs_uq\"\n  3893\t        table_name = f\"{app_label}_pony\"\n  3894\t        project_state = self.set_up_test_model(app_label)\n  3895\t        constraint = models.UniqueConstraint(Abs(\"weight\"), name=constraint_name)\n  3896\t        operation = migrations.AddConstraint(\"Pony\", constraint)\n  3897\t        self.assertEqual(\n  3898\t            operation.describe(),\n  3899\t            \"Create constraint test_adfuncuc_pony_abs_uq on model Pony\",\n  3900\t        )\n  3901\t        self.assertEqual(\n  3902\t            operation.migration_name_fragment,\n  3903\t            \"pony_test_adfuncuc_pony_abs_uq\",\n  3904\t        )\n  3905\t        new_state = project_state.clone()\n  3906\t        operation.state_forwards(app_label, new_state)\n  3907\t        self.assertEqual(\n  3908\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 1\n  3909\t        )\n  3910\t        self.assertIndexNameNotExists(table_name, constraint_name)\n  3911\t        # Add constraint.\n  3912\t        with connection.schema_editor() as editor:\n  3913\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3914\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3915\t        Pony.objects.create(weight=4.0)\n  3916\t        if connection.features.supports_expression_indexes:\n  3917\t            self.assertIndexNameExists(table_name, constraint_name)\n  3918\t            with self.assertRaises(IntegrityError):\n  3919\t                Pony.objects.create(weight=-4.0)\n  3920\t        else:\n  3921\t            self.assertIndexNameNotExists(table_name, constraint_name)\n  3922\t            Pony.objects.create(weight=-4.0)\n  3923\t        # Reversal.\n  3924\t        with connection.schema_editor() as editor:\n  3925\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3926\t        self.assertIndexNameNotExists(table_name, constraint_name)\n  3927\t        # Constraint doesn't work.\n  3928\t        Pony.objects.create(weight=-4.0)\n  3929\t        # Deconstruction.\n  3930\t        definition = operation.deconstruct()\n  3931\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3932\t        self.assertEqual(definition[1], [])\n  3933\t        self.assertEqual(\n  3934\t            definition[2],\n  3935\t            {\"model_name\": \"Pony\", \"constraint\": constraint},\n  3936\t        )\n  3937\t\n  3938\t    def test_remove_func_unique_constraint(self):\n  3939\t        app_label = \"test_rmfuncuc\"\n  3940\t        constraint_name = f\"{app_label}_pony_abs_uq\"\n  3941\t        table_name = f\"{app_label}_pony\"\n  3942\t        project_state = self.set_up_test_model(\n  3943\t            app_label,\n  3944\t            constraints=[\n  3945\t                models.UniqueConstraint(Abs(\"weight\"), name=constraint_name),\n  3946\t            ],\n  3947\t        )\n  3948\t        self.assertTableExists(table_name)\n  3949\t        if connection.features.supports_expression_indexes:\n  3950\t            self.assertIndexNameExists(table_name, constraint_name)\n  3951\t        operation = migrations.RemoveConstraint(\"Pony\", constraint_name)\n  3952\t        self.assertEqual(\n  3953\t            operation.describe(),\n  3954\t            \"Remove constraint test_rmfuncuc_pony_abs_uq from model Pony\",\n  3955\t        )\n  3956\t        self.assertEqual(\n  3957\t            operation.migration_name_fragment,\n  3958\t            \"remove_pony_test_rmfuncuc_pony_abs_uq\",\n  3959\t        )\n  3960\t        new_state = project_state.clone()\n  3961\t        operation.state_forwards(app_label, new_state)\n  3962\t        self.assertEqual(\n  3963\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 0\n  3964\t        )\n  3965\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3966\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3967\t        # Remove constraint.\n  3968\t        with connection.schema_editor() as editor:\n  3969\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3970\t        self.assertIndexNameNotExists(table_name, constraint_name)\n  3971\t        # Constraint doesn't work.\n  3972\t        Pony.objects.create(pink=1, weight=4.0)\n  3973\t        Pony.objects.create(pink=1, weight=-4.0).delete()\n  3974\t        # Reversal.\n  3975\t        with connection.schema_editor() as editor:\n  3976\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3977\t        if connection.features.supports_expression_indexes:\n  3978\t            self.assertIndexNameExists(table_name, constraint_name)\n  3979\t            with self.assertRaises(IntegrityError):\n  3980\t                Pony.objects.create(weight=-4.0)\n  3981\t        else:\n  3982\t            self.assertIndexNameNotExists(table_name, constraint_name)\n  3983\t            Pony.objects.create(weight=-4.0)\n  3984\t        # Deconstruction.\n  3985\t        definition = operation.deconstruct()\n  3986\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3987\t        self.assertEqual(definition[1], [])\n  3988\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"name\": constraint_name})\n  3989\t\n  3990\t    def test_alter_model_options(self):\n  3991\t        \"\"\"\n  3992\t        Tests the AlterModelOptions operation.\n  3993\t        \"\"\"\n  3994\t        project_state = self.set_up_test_model(\"test_almoop\")\n  3995\t        # Test the state alteration (no DB alteration to test)\n  3996\t        operation = migrations.AlterModelOptions(\n  3997\t            \"Pony\", {\"permissions\": [(\"can_groom\", \"Can groom\")]}\n  3998\t        )\n  3999\t        self.assertEqual(operation.describe(), \"Change Meta options on Pony\")\n  4000\t        self.assertEqual(operation.migration_name_fragment, \"alter_pony_options\")\n  4001\t        new_state = project_state.clone()\n  4002\t        operation.state_forwards(\"test_almoop\", new_state)\n  4003\t        self.assertEqual(\n  4004\t            len(\n  4005\t                project_state.models[\"test_almoop\", \"pony\"].options.get(\n  4006\t                    \"permissions\", []\n  4007\t                )\n  4008\t            ),\n  4009\t            0,\n  4010\t        )\n  4011\t        self.assertEqual(\n  4012\t            len(new_state.models[\"test_almoop\", \"pony\"].options.get(\"permissions\", [])),\n  4013\t            1,\n  4014\t        )\n  4015\t        self.assertEqual(\n  4016\t            new_state.models[\"test_almoop\", \"pony\"].options[\"permissions\"][0][0],\n  4017\t            \"can_groom\",\n  4018\t        )\n  4019\t        # And deconstruction\n  4020\t        definition = operation.deconstruct()\n  4021\t        self.assertEqual(definition[0], \"AlterModelOptions\")\n  4022\t        self.assertEqual(definition[1], [])\n  4023\t        self.assertEqual(\n  4024\t            definition[2],\n  4025\t            {\"name\": \"Pony\", \"options\": {\"permissions\": [(\"can_groom\", \"Can groom\")]}},\n  4026\t        )\n  4027\t\n  4028\t    def test_alter_model_options_emptying(self):\n  4029\t        \"\"\"\n  4030\t        The AlterModelOptions operation removes keys from the dict (#23121)\n  4031\t        \"\"\"\n  4032\t        project_state = self.set_up_test_model(\"test_almoop\", options=True)\n  4033\t        # Test the state alteration (no DB alteration to test)\n  4034\t        operation = migrations.AlterModelOptions(\"Pony\", {})\n  4035\t        self.assertEqual(operation.describe(), \"Change Meta options on Pony\")\n  4036\t        new_state = project_state.clone()\n  4037\t        operation.state_forwards(\"test_almoop\", new_state)\n  4038\t        self.assertEqual(\n  4039\t            len(\n  4040\t                project_state.models[\"test_almoop\", \"pony\"].options.get(\n  4041\t                    \"permissions\", []\n  4042\t                )\n  4043\t            ),\n  4044\t            1,\n  4045\t        )\n  4046\t        self.assertEqual(\n  4047\t            len(new_state.models[\"test_almoop\", \"pony\"].options.get(\"permissions\", [])),\n  4048\t            0,\n  4049\t        )\n  4050\t        # And deconstruction\n  4051\t        definition = operation.deconstruct()\n  4052\t        self.assertEqual(definition[0], \"AlterModelOptions\")\n  4053\t        self.assertEqual(definition[1], [])\n  4054\t        self.assertEqual(definition[2], {\"name\": \"Pony\", \"options\": {}})\n  4055\t\n  4056\t    def test_alter_order_with_respect_to(self):\n  4057\t        \"\"\"\n  4058\t        Tests the AlterOrderWithRespectTo operation.\n  4059\t        \"\"\"\n  4060\t        project_state = self.set_up_test_model(\"test_alorwrtto\", related_model=True)\n  4061\t        # Test the state alteration\n  4062\t        operation = migrations.AlterOrderWithRespectTo(\"Rider\", \"pony\")\n  4063\t        self.assertEqual(\n  4064\t            operation.describe(), \"Set order_with_respect_to on Rider to pony\"\n  4065\t        )\n  4066\t        self.assertEqual(\n  4067\t            operation.migration_name_fragment,\n  4068\t            \"alter_rider_order_with_respect_to\",\n  4069\t        )\n  4070\t        new_state = project_state.clone()\n  4071\t        operation.state_forwards(\"test_alorwrtto\", new_state)\n  4072\t        self.assertIsNone(\n  4073\t            project_state.models[\"test_alorwrtto\", \"rider\"].options.get(\n  4074\t                \"order_with_respect_to\", None\n  4075\t            )\n  4076\t        )\n  4077\t        self.assertEqual(\n  4078\t            new_state.models[\"test_alorwrtto\", \"rider\"].options.get(\n  4079\t                \"order_with_respect_to\", None\n  4080\t            ),\n  4081\t            \"pony\",\n  4082\t        )\n  4083\t        # Make sure there's no matching index\n  4084\t        self.assertColumnNotExists(\"test_alorwrtto_rider\", \"_order\")\n  4085\t        # Create some rows before alteration\n  4086\t        rendered_state = project_state.apps\n  4087\t        pony = rendered_state.get_model(\"test_alorwrtto\", \"Pony\").objects.create(\n  4088\t            weight=50\n  4089\t        )\n  4090\t        rider1 = rendered_state.get_model(\"test_alorwrtto\", \"Rider\").objects.create(\n  4091\t            pony=pony\n  4092\t        )\n  4093\t        rider1.friend = rider1\n  4094\t        rider1.save()\n  4095\t        rider2 = rendered_state.get_model(\"test_alorwrtto\", \"Rider\").objects.create(\n  4096\t            pony=pony\n  4097\t        )\n  4098\t        rider2.friend = rider2\n  4099\t        rider2.save()\n  4100\t        # Test the database alteration\n  4101\t        with connection.schema_editor() as editor:\n  4102\t            operation.database_forwards(\n  4103\t                \"test_alorwrtto\", editor, project_state, new_state\n  4104\t            )\n  4105\t        self.assertColumnExists(\"test_alorwrtto_rider\", \"_order\")\n  4106\t        # Check for correct value in rows\n  4107\t        updated_riders = new_state.apps.get_model(\n  4108\t            \"test_alorwrtto\", \"Rider\"\n  4109\t        ).objects.all()\n  4110\t        self.assertEqual(updated_riders[0]._order, 0)\n  4111\t        self.assertEqual(updated_riders[1]._order, 0)\n  4112\t        # And test reversal\n  4113\t        with connection.schema_editor() as editor:\n  4114\t            operation.database_backwards(\n  4115\t                \"test_alorwrtto\", editor, new_state, project_state\n  4116\t            )\n  4117\t        self.assertColumnNotExists(\"test_alorwrtto_rider\", \"_order\")\n  4118\t        # And deconstruction\n  4119\t        definition = operation.deconstruct()\n  4120\t        self.assertEqual(definition[0], \"AlterOrderWithRespectTo\")\n  4121\t        self.assertEqual(definition[1], [])\n  4122\t        self.assertEqual(\n  4123\t            definition[2], {\"name\": \"Rider\", \"order_with_respect_to\": \"pony\"}\n  4124\t        )\n  4125\t\n  4126\t    def test_alter_model_managers(self):\n  4127\t        \"\"\"\n  4128\t        The managers on a model are set.\n  4129\t        \"\"\"\n  4130\t        project_state = self.set_up_test_model(\"test_almoma\")\n  4131\t        # Test the state alteration\n  4132\t        operation = migrations.AlterModelManagers(\n  4133\t            \"Pony\",\n  4134\t            managers=[\n  4135\t                (\"food_qs\", FoodQuerySet.as_manager()),\n  4136\t                (\"food_mgr\", FoodManager(\"a\", \"b\")),\n  4137\t                (\"food_mgr_kwargs\", FoodManager(\"x\", \"y\", 3, 4)),\n  4138\t            ],\n  4139\t        )\n  4140\t        self.assertEqual(operation.describe(), \"Change managers on Pony\")\n  4141\t        self.assertEqual(operation.migration_name_fragment, \"alter_pony_managers\")\n  4142\t        managers = project_state.models[\"test_almoma\", \"pony\"].managers\n  4143\t        self.assertEqual(managers, [])\n  4144\t\n  4145\t        new_state = project_state.clone()\n  4146\t        operation.state_forwards(\"test_almoma\", new_state)\n  4147\t        self.assertIn((\"test_almoma\", \"pony\"), new_state.models)\n  4148\t        managers = new_state.models[\"test_almoma\", \"pony\"].managers\n  4149\t        self.assertEqual(managers[0][0], \"food_qs\")\n  4150\t        self.assertIsInstance(managers[0][1], models.Manager)\n  4151\t        self.assertEqual(managers[1][0], \"food_mgr\")\n  4152\t        self.assertIsInstance(managers[1][1], FoodManager)\n  4153\t        self.assertEqual(managers[1][1].args, (\"a\", \"b\", 1, 2))\n  4154\t        self.assertEqual(managers[2][0], \"food_mgr_kwargs\")\n  4155\t        self.assertIsInstance(managers[2][1], FoodManager)\n  4156\t        self.assertEqual(managers[2][1].args, (\"x\", \"y\", 3, 4))\n  4157\t        rendered_state = new_state.apps\n  4158\t        model = rendered_state.get_model(\"test_almoma\", \"pony\")\n  4159\t        self.assertIsInstance(model.food_qs, models.Manager)\n  4160\t        self.assertIsInstance(model.food_mgr, FoodManager)\n  4161\t        self.assertIsInstance(model.food_mgr_kwargs, FoodManager)\n  4162\t\n  4163\t    def test_alter_model_managers_emptying(self):\n  4164\t        \"\"\"\n  4165\t        The managers on a model are set.\n  4166\t        \"\"\"\n  4167\t        project_state = self.set_up_test_model(\"test_almomae\", manager_model=True)\n  4168\t        # Test the state alteration\n  4169\t        operation = migrations.AlterModelManagers(\"Food\", managers=[])\n  4170\t        self.assertEqual(operation.describe(), \"Change managers on Food\")\n  4171\t        self.assertIn((\"test_almomae\", \"food\"), project_state.models)\n  4172\t        managers = project_state.models[\"test_almomae\", \"food\"].managers\n  4173\t        self.assertEqual(managers[0][0], \"food_qs\")\n  4174\t        self.assertIsInstance(managers[0][1], models.Manager)\n  4175\t        self.assertEqual(managers[1][0], \"food_mgr\")\n  4176\t        self.assertIsInstance(managers[1][1], FoodManager)\n  4177\t        self.assertEqual(managers[1][1].args, (\"a\", \"b\", 1, 2))\n  4178\t        self.assertEqual(managers[2][0], \"food_mgr_kwargs\")\n  4179\t        self.assertIsInstance(managers[2][1], FoodManager)\n  4180\t        self.assertEqual(managers[2][1].args, (\"x\", \"y\", 3, 4))\n  4181\t\n  4182\t        new_state = project_state.clone()\n  4183\t        operation.state_forwards(\"test_almomae\", new_state)\n  4184\t        managers = new_state.models[\"test_almomae\", \"food\"].managers\n  4185\t        self.assertEqual(managers, [])\n  4186\t\n  4187\t    def test_alter_fk(self):\n  4188\t        \"\"\"\n  4189\t        Creating and then altering an FK works correctly\n  4190\t        and deals with the pending SQL (#23091)\n  4191\t        \"\"\"\n  4192\t        project_state = self.set_up_test_model(\"test_alfk\")\n  4193\t        # Test adding and then altering the FK in one go\n  4194\t        create_operation = migrations.CreateModel(\n  4195\t            name=\"Rider\",\n  4196\t            fields=[\n  4197\t                (\"id\", models.AutoField(primary_key=True)),\n  4198\t                (\"pony\", models.ForeignKey(\"Pony\", models.CASCADE)),\n  4199\t            ],\n  4200\t        )\n  4201\t        create_state = project_state.clone()\n  4202\t        create_operation.state_forwards(\"test_alfk\", create_state)\n  4203\t        alter_operation = migrations.AlterField(\n  4204\t            model_name=\"Rider\",\n  4205\t            name=\"pony\",\n  4206\t            field=models.ForeignKey(\"Pony\", models.CASCADE, editable=False),\n  4207\t        )\n  4208\t        alter_state = create_state.clone()\n  4209\t        alter_operation.state_forwards(\"test_alfk\", alter_state)\n  4210\t        with connection.schema_editor() as editor:\n  4211\t            create_operation.database_forwards(\n  4212\t                \"test_alfk\", editor, project_state, create_state\n  4213\t            )\n  4214\t            alter_operation.database_forwards(\n  4215\t                \"test_alfk\", editor, create_state, alter_state\n  4216\t            )\n  4217\t\n  4218\t    def test_alter_fk_non_fk(self):\n  4219\t        \"\"\"\n  4220\t        Altering an FK to a non-FK works (#23244)\n  4221\t        \"\"\"\n  4222\t        # Test the state alteration\n  4223\t        operation = migrations.AlterField(\n  4224\t            model_name=\"Rider\",\n  4225\t            name=\"pony\",\n  4226\t            field=models.FloatField(),\n  4227\t        )\n  4228\t        project_state, new_state = self.make_test_state(\n  4229\t            \"test_afknfk\", operation, related_model=True\n  4230\t        )\n  4231\t        # Test the database alteration\n  4232\t        self.assertColumnExists(\"test_afknfk_rider\", \"pony_id\")\n  4233\t        self.assertColumnNotExists(\"test_afknfk_rider\", \"pony\")\n  4234\t        with connection.schema_editor() as editor:\n  4235\t            operation.database_forwards(\"test_afknfk\", editor, project_state, new_state)\n  4236\t        self.assertColumnExists(\"test_afknfk_rider\", \"pony\")\n  4237\t        self.assertColumnNotExists(\"test_afknfk_rider\", \"pony_id\")\n  4238\t        # And test reversal\n  4239\t        with connection.schema_editor() as editor:\n  4240\t            operation.database_backwards(\n  4241\t                \"test_afknfk\", editor, new_state, project_state\n  4242\t            )\n  4243\t        self.assertColumnExists(\"test_afknfk_rider\", \"pony_id\")\n  4244\t        self.assertColumnNotExists(\"test_afknfk_rider\", \"pony\")\n  4245\t\n  4246\t    def test_run_sql(self):\n  4247\t        \"\"\"\n  4248\t        Tests the RunSQL operation.\n  4249\t        \"\"\"\n  4250\t        project_state = self.set_up_test_model(\"test_runsql\")\n  4251\t        # Create the operation\n  4252\t        operation = migrations.RunSQL(\n  4253\t            # Use a multi-line string with a comment to test splitting on\n  4254\t            # SQLite and MySQL respectively.\n  4255\t            \"CREATE TABLE i_love_ponies (id int, special_thing varchar(15));\\n\"\n  4256\t            \"INSERT INTO i_love_ponies (id, special_thing) \"\n  4257\t            \"VALUES (1, 'i love ponies'); -- this is magic!\\n\"\n  4258\t            \"INSERT INTO i_love_ponies (id, special_thing) \"\n  4259\t            \"VALUES (2, 'i love django');\\n\"\n  4260\t            \"UPDATE i_love_ponies SET special_thing = 'Ponies' \"\n  4261\t            \"WHERE special_thing LIKE '%%ponies';\"\n  4262\t            \"UPDATE i_love_ponies SET special_thing = 'Django' \"\n  4263\t            \"WHERE special_thing LIKE '%django';\",\n  4264\t            # Run delete queries to test for parameter substitution failure\n  4265\t            # reported in #23426\n  4266\t            \"DELETE FROM i_love_ponies WHERE special_thing LIKE '%Django%';\"\n  4267\t            \"DELETE FROM i_love_ponies WHERE special_thing LIKE '%%Ponies%%';\"\n  4268\t            \"DROP TABLE i_love_ponies\",\n  4269\t            state_operations=[\n  4270\t                migrations.CreateModel(\n  4271\t                    \"SomethingElse\", [(\"id\", models.AutoField(primary_key=True))]\n  4272\t                )\n  4273\t            ],\n  4274\t        )\n  4275\t        self.assertEqual(operation.describe(), \"Raw SQL operation\")\n  4276\t        # Test the state alteration\n  4277\t        new_state = project_state.clone()\n  4278\t        operation.state_forwards(\"test_runsql\", new_state)\n  4279\t        self.assertEqual(\n  4280\t            len(new_state.models[\"test_runsql\", \"somethingelse\"].fields), 1\n  4281\t        )\n  4282\t        # Make sure there's no table\n  4283\t        self.assertTableNotExists(\"i_love_ponies\")\n  4284\t        # Test SQL collection\n  4285\t        with connection.schema_editor(collect_sql=True) as editor:\n  4286\t            operation.database_forwards(\"test_runsql\", editor, project_state, new_state)\n  4287\t            self.assertIn(\"LIKE '%%ponies';\", \"\\n\".join(editor.collected_sql))\n  4288\t            operation.database_backwards(\n  4289\t                \"test_runsql\", editor, project_state, new_state\n  4290\t            )\n  4291\t            self.assertIn(\"LIKE '%%Ponies%%';\", \"\\n\".join(editor.collected_sql))\n  4292\t        # Test the database alteration\n  4293\t        with connection.schema_editor() as editor:\n  4294\t            operation.database_forwards(\"test_runsql\", editor, project_state, new_state)\n  4295\t        self.assertTableExists(\"i_love_ponies\")\n  4296\t        # Make sure all the SQL was processed\n  4297\t        with connection.cursor() as cursor:\n  4298\t            cursor.execute(\"SELECT COUNT(*) FROM i_love_ponies\")\n  4299\t            self.assertEqual(cursor.fetchall()[0][0], 2)\n  4300\t            cursor.execute(\n  4301\t                \"SELECT COUNT(*) FROM i_love_ponies WHERE special_thing = 'Django'\"\n  4302\t            )\n  4303\t            self.assertEqual(cursor.fetchall()[0][0], 1)\n  4304\t            cursor.execute(\n  4305\t                \"SELECT COUNT(*) FROM i_love_ponies WHERE special_thing = 'Ponies'\"\n  4306\t            )\n  4307\t            self.assertEqual(cursor.fetchall()[0][0], 1)\n  4308\t        # And test reversal\n  4309\t        self.assertTrue(operation.reversible)\n  4310\t        with connection.schema_editor() as editor:\n  4311\t            operation.database_backwards(\n  4312\t                \"test_runsql\", editor, new_state, project_state\n  4313\t            )\n  4314\t        self.assertTableNotExists(\"i_love_ponies\")\n  4315\t        # And deconstruction\n  4316\t        definition = operation.deconstruct()\n  4317\t        self.assertEqual(definition[0], \"RunSQL\")\n  4318\t        self.assertEqual(definition[1], [])\n  4319\t        self.assertEqual(\n  4320\t            sorted(definition[2]), [\"reverse_sql\", \"sql\", \"state_operations\"]\n  4321\t        )\n  4322\t        # And elidable reduction\n  4323\t        self.assertIs(False, operation.reduce(operation, []))\n  4324\t        elidable_operation = migrations.RunSQL(\"SELECT 1 FROM void;\", elidable=True)\n  4325\t        self.assertEqual(elidable_operation.reduce(operation, []), [operation])\n  4326\t\n  4327\t    def test_run_sql_params(self):\n  4328\t        \"\"\"\n  4329\t        #23426 - RunSQL should accept parameters.\n  4330\t        \"\"\"\n  4331\t        project_state = self.set_up_test_model(\"test_runsql\")\n  4332\t        # Create the operation\n  4333\t        operation = migrations.RunSQL(\n  4334\t            [\"CREATE TABLE i_love_ponies (id int, special_thing varchar(15));\"],\n  4335\t            [\"DROP TABLE i_love_ponies\"],\n  4336\t        )\n  4337\t        param_operation = migrations.RunSQL(\n  4338\t            # forwards\n  4339\t            (\n  4340\t                \"INSERT INTO i_love_ponies (id, special_thing) VALUES (1, 'Django');\",\n  4341\t                [\n  4342\t                    \"INSERT INTO i_love_ponies (id, special_thing) VALUES (2, %s);\",\n  4343\t                    [\"Ponies\"],\n  4344\t                ],\n  4345\t                (\n  4346\t                    \"INSERT INTO i_love_ponies (id, special_thing) VALUES (%s, %s);\",\n  4347\t                    (\n  4348\t                        3,\n  4349\t                        \"Python\",\n  4350\t                    ),\n  4351\t                ),\n  4352\t            ),\n  4353\t            # backwards\n  4354\t            [\n  4355\t                \"DELETE FROM i_love_ponies WHERE special_thing = 'Django';\",\n  4356\t                [\"DELETE FROM i_love_ponies WHERE special_thing = 'Ponies';\", None],\n  4357\t                (\n  4358\t                    \"DELETE FROM i_love_ponies WHERE id = %s OR special_thing = %s;\",\n  4359\t                    [3, \"Python\"],\n  4360\t                ),\n  4361\t            ],\n  4362\t        )\n  4363\t\n  4364\t        # Make sure there's no table\n  4365\t        self.assertTableNotExists(\"i_love_ponies\")\n  4366\t        new_state = project_state.clone()\n  4367\t        # Test the database alteration\n  4368\t        with connection.schema_editor() as editor:\n  4369\t            operation.database_forwards(\"test_runsql\", editor, project_state, new_state)\n  4370\t\n  4371\t        # Test parameter passing\n  4372\t        with connection.schema_editor() as editor:\n  4373\t            param_operation.database_forwards(\n  4374\t                \"test_runsql\", editor, project_state, new_state\n  4375\t            )\n  4376\t        # Make sure all the SQL was processed\n  4377\t        with connection.cursor() as cursor:\n  4378\t            cursor.execute(\"SELECT COUNT(*) FROM i_love_ponies\")\n  4379\t            self.assertEqual(cursor.fetchall()[0][0], 3)\n  4380\t\n  4381\t        with connection.schema_editor() as editor:\n  4382\t            param_operation.database_backwards(\n  4383\t                \"test_runsql\", editor, new_state, project_state\n  4384\t            )\n  4385\t        with connection.cursor() as cursor:\n  4386\t            cursor.execute(\"SELECT COUNT(*) FROM i_love_ponies\")\n  4387\t            self.assertEqual(cursor.fetchall()[0][0], 0)\n  4388\t\n  4389\t        # And test reversal\n  4390\t        with connection.schema_editor() as editor:\n  4391\t            operation.database_backwards(\n  4392\t                \"test_runsql\", editor, new_state, project_state\n  4393\t            )\n  4394\t        self.assertTableNotExists(\"i_love_ponies\")\n  4395\t\n  4396\t    def test_run_sql_params_invalid(self):\n  4397\t        \"\"\"\n  4398\t        #23426 - RunSQL should fail when a list of statements with an incorrect\n  4399\t        number of tuples is given.\n  4400\t        \"\"\"\n  4401\t        project_state = self.set_up_test_model(\"test_runsql\")\n  4402\t        new_state = project_state.clone()\n  4403\t        operation = migrations.RunSQL(\n  4404\t            # forwards\n  4405\t            [[\"INSERT INTO foo (bar) VALUES ('buz');\"]],\n  4406\t            # backwards\n  4407\t            ((\"DELETE FROM foo WHERE bar = 'buz';\", \"invalid\", \"parameter count\"),),\n  4408\t        )\n  4409\t\n  4410\t        with connection.schema_editor() as editor:\n  4411\t            with self.assertRaisesMessage(ValueError, \"Expected a 2-tuple but got 1\"):\n  4412\t                operation.database_forwards(\n  4413\t                    \"test_runsql\", editor, project_state, new_state\n  4414\t                )\n  4415\t\n  4416\t        with connection.schema_editor() as editor:\n  4417\t            with self.assertRaisesMessage(ValueError, \"Expected a 2-tuple but got 3\"):\n  4418\t                operation.database_backwards(\n  4419\t                    \"test_runsql\", editor, new_state, project_state\n  4420\t                )\n  4421\t\n  4422\t    def test_run_sql_noop(self):\n  4423\t        \"\"\"\n  4424\t        #24098 - Tests no-op RunSQL operations.\n  4425\t        \"\"\"\n  4426\t        operation = migrations.RunSQL(migrations.RunSQL.noop, migrations.RunSQL.noop)\n  4427\t        with connection.schema_editor() as editor:\n  4428\t            operation.database_forwards(\"test_runsql\", editor, None, None)\n  4429\t            operation.database_backwards(\"test_runsql\", editor, None, None)\n  4430\t\n  4431\t    def test_run_sql_add_missing_semicolon_on_collect_sql(self):\n  4432\t        project_state = self.set_up_test_model(\"test_runsql\")\n  4433\t        new_state = project_state.clone()\n  4434\t        tests = [\n  4435\t            \"INSERT INTO test_runsql_pony (pink, weight) VALUES (1, 1);\\n\",\n  4436\t            \"INSERT INTO test_runsql_pony (pink, weight) VALUES (1, 1)\\n\",\n  4437\t        ]\n  4438\t        for sql in tests:\n  4439\t            with self.subTest(sql=sql):\n  4440\t                operation = migrations.RunSQL(sql, migrations.RunPython.noop)\n  4441\t                with connection.schema_editor(collect_sql=True) as editor:\n  4442\t                    operation.database_forwards(\n  4443\t                        \"test_runsql\", editor, project_state, new_state\n  4444\t                    )\n  4445\t                    collected_sql = \"\\n\".join(editor.collected_sql)\n  4446\t                    self.assertEqual(collected_sql.count(\";\"), 1)\n  4447\t\n  4448\t    def test_run_python(self):\n  4449\t        \"\"\"\n  4450\t        Tests the RunPython operation\n  4451\t        \"\"\"\n  4452\t\n  4453\t        project_state = self.set_up_test_model(\"test_runpython\", mti_model=True)\n  4454\t\n  4455\t        # Create the operation\n  4456\t        def inner_method(models, schema_editor):\n  4457\t            Pony = models.get_model(\"test_runpython\", \"Pony\")\n  4458\t            Pony.objects.create(pink=1, weight=3.55)\n  4459\t            Pony.objects.create(weight=5)\n  4460\t\n  4461\t        def inner_method_reverse(models, schema_editor):\n  4462\t            Pony = models.get_model(\"test_runpython\", \"Pony\")\n  4463\t            Pony.objects.filter(pink=1, weight=3.55).delete()\n  4464\t            Pony.objects.filter(weight=5).delete()\n  4465\t\n  4466\t        operation = migrations.RunPython(\n  4467\t            inner_method, reverse_code=inner_method_reverse\n  4468\t        )\n  4469\t        self.assertEqual(operation.describe(), \"Raw Python operation\")\n  4470\t        # Test the state alteration does nothing\n  4471\t        new_state = project_state.clone()\n  4472\t        operation.state_forwards(\"test_runpython\", new_state)\n  4473\t        self.assertEqual(new_state, project_state)\n  4474\t        # Test the database alteration\n  4475\t        self.assertEqual(\n  4476\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 0\n  4477\t        )\n  4478\t        with connection.schema_editor() as editor:\n  4479\t            operation.database_forwards(\n  4480\t                \"test_runpython\", editor, project_state, new_state\n  4481\t            )\n  4482\t        self.assertEqual(\n  4483\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 2\n  4484\t        )\n  4485\t        # Now test reversal\n  4486\t        self.assertTrue(operation.reversible)\n  4487\t        with connection.schema_editor() as editor:\n  4488\t            operation.database_backwards(\n  4489\t                \"test_runpython\", editor, project_state, new_state\n  4490\t            )\n  4491\t        self.assertEqual(\n  4492\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 0\n  4493\t        )\n  4494\t        # Now test we can't use a string\n  4495\t        with self.assertRaisesMessage(\n  4496\t            ValueError, \"RunPython must be supplied with a callable\"\n  4497\t        ):\n  4498\t            migrations.RunPython(\"print 'ahahaha'\")\n  4499\t        # And deconstruction\n  4500\t        definition = operation.deconstruct()\n  4501\t        self.assertEqual(definition[0], \"RunPython\")\n  4502\t        self.assertEqual(definition[1], [])\n  4503\t        self.assertEqual(sorted(definition[2]), [\"code\", \"reverse_code\"])\n  4504\t\n  4505\t        # Also test reversal fails, with an operation identical to above but\n  4506\t        # without reverse_code set.\n  4507\t        no_reverse_operation = migrations.RunPython(inner_method)\n  4508\t        self.assertFalse(no_reverse_operation.reversible)\n  4509\t        with connection.schema_editor() as editor:\n  4510\t            no_reverse_operation.database_forwards(\n  4511\t                \"test_runpython\", editor, project_state, new_state\n  4512\t            )\n  4513\t            with self.assertRaises(NotImplementedError):\n  4514\t                no_reverse_operation.database_backwards(\n  4515\t                    \"test_runpython\", editor, new_state, project_state\n  4516\t                )\n  4517\t        self.assertEqual(\n  4518\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 2\n  4519\t        )\n  4520\t\n  4521\t        def create_ponies(models, schema_editor):\n  4522\t            Pony = models.get_model(\"test_runpython\", \"Pony\")\n  4523\t            pony1 = Pony.objects.create(pink=1, weight=3.55)\n  4524\t            self.assertIsNot(pony1.pk, None)\n  4525\t            pony2 = Pony.objects.create(weight=5)\n  4526\t            self.assertIsNot(pony2.pk, None)\n  4527\t            self.assertNotEqual(pony1.pk, pony2.pk)\n  4528\t\n  4529\t        operation = migrations.RunPython(create_ponies)\n  4530\t        with connection.schema_editor() as editor:\n  4531\t            operation.database_forwards(\n  4532\t                \"test_runpython\", editor, project_state, new_state\n  4533\t            )\n  4534\t        self.assertEqual(\n  4535\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 4\n  4536\t        )\n  4537\t        # And deconstruction\n  4538\t        definition = operation.deconstruct()\n  4539\t        self.assertEqual(definition[0], \"RunPython\")\n  4540\t        self.assertEqual(definition[1], [])\n  4541\t        self.assertEqual(sorted(definition[2]), [\"code\"])\n  4542\t\n  4543\t        def create_shetlandponies(models, schema_editor):\n  4544\t            ShetlandPony = models.get_model(\"test_runpython\", \"ShetlandPony\")\n  4545\t            pony1 = ShetlandPony.objects.create(weight=4.0)\n  4546\t            self.assertIsNot(pony1.pk, None)\n  4547\t            pony2 = ShetlandPony.objects.create(weight=5.0)\n  4548\t            self.assertIsNot(pony2.pk, None)\n  4549\t            self.assertNotEqual(pony1.pk, pony2.pk)\n  4550\t\n  4551\t        operation = migrations.RunPython(create_shetlandponies)\n  4552\t        with connection.schema_editor() as editor:\n  4553\t            operation.database_forwards(\n  4554\t                \"test_runpython\", editor, project_state, new_state\n  4555\t            )\n  4556\t        self.assertEqual(\n  4557\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 6\n  4558\t        )\n  4559\t        self.assertEqual(\n  4560\t            project_state.apps.get_model(\n  4561\t                \"test_runpython\", \"ShetlandPony\"\n  4562\t            ).objects.count(),\n  4563\t            2,\n  4564\t        )\n  4565\t        # And elidable reduction\n  4566\t        self.assertIs(False, operation.reduce(operation, []))\n  4567\t        elidable_operation = migrations.RunPython(inner_method, elidable=True)\n  4568\t        self.assertEqual(elidable_operation.reduce(operation, []), [operation])\n  4569\t\n  4570\t    def test_run_python_atomic(self):\n  4571\t        \"\"\"\n  4572\t        Tests the RunPython operation correctly handles the \"atomic\" keyword\n  4573\t        \"\"\"\n  4574\t        project_state = self.set_up_test_model(\"test_runpythonatomic\", mti_model=True)\n  4575\t\n  4576\t        def inner_method(models, schema_editor):\n  4577\t            Pony = models.get_model(\"test_runpythonatomic\", \"Pony\")\n  4578\t            Pony.objects.create(pink=1, weight=3.55)\n  4579\t            raise ValueError(\"Adrian hates ponies.\")\n  4580\t\n  4581\t        # Verify atomicity when applying.\n  4582\t        atomic_migration = Migration(\"test\", \"test_runpythonatomic\")\n  4583\t        atomic_migration.operations = [\n  4584\t            migrations.RunPython(inner_method, reverse_code=inner_method)\n  4585\t        ]\n  4586\t        non_atomic_migration = Migration(\"test\", \"test_runpythonatomic\")\n  4587\t        non_atomic_migration.operations = [\n  4588\t            migrations.RunPython(inner_method, reverse_code=inner_method, atomic=False)\n  4589\t        ]\n  4590\t        # If we're a fully-transactional database, both versions should rollback\n  4591\t        if connection.features.can_rollback_ddl:\n  4592\t            self.assertEqual(\n  4593\t                project_state.apps.get_model(\n  4594\t                    \"test_runpythonatomic\", \"Pony\"\n  4595\t                ).objects.count(),\n  4596\t                0,\n  4597\t            )\n  4598\t            with self.assertRaises(ValueError):\n  4599\t                with connection.schema_editor() as editor:\n  4600\t                    atomic_migration.apply(project_state, editor)\n  4601\t            self.assertEqual(\n  4602\t                project_state.apps.get_model(\n  4603\t                    \"test_runpythonatomic\", \"Pony\"\n  4604\t                ).objects.count(),\n  4605\t                0,\n  4606\t            )\n  4607\t            with self.assertRaises(ValueError):\n  4608\t                with connection.schema_editor() as editor:\n  4609\t                    non_atomic_migration.apply(project_state, editor)\n  4610\t            self.assertEqual(\n  4611\t                project_state.apps.get_model(\n  4612\t                    \"test_runpythonatomic\", \"Pony\"\n  4613\t                ).objects.count(),\n  4614\t                0,\n  4615\t            )\n  4616\t        # Otherwise, the non-atomic operation should leave a row there\n  4617\t        else:\n  4618\t            self.assertEqual(\n  4619\t                project_state.apps.get_model(\n  4620\t                    \"test_runpythonatomic\", \"Pony\"\n  4621\t                ).objects.count(),\n  4622\t                0,\n  4623\t            )\n  4624\t            with self.assertRaises(ValueError):\n  4625\t                with connection.schema_editor() as editor:\n  4626\t                    atomic_migration.apply(project_state, editor)\n  4627\t            self.assertEqual(\n  4628\t                project_state.apps.get_model(\n  4629\t                    \"test_runpythonatomic\", \"Pony\"\n  4630\t                ).objects.count(),\n  4631\t                0,\n  4632\t            )\n  4633\t            with self.assertRaises(ValueError):\n  4634\t                with connection.schema_editor() as editor:\n  4635\t                    non_atomic_migration.apply(project_state, editor)\n  4636\t            self.assertEqual(\n  4637\t                project_state.apps.get_model(\n  4638\t                    \"test_runpythonatomic\", \"Pony\"\n  4639\t                ).objects.count(),\n  4640\t                1,\n  4641\t            )\n  4642\t        # Reset object count to zero and verify atomicity when unapplying.\n  4643\t        project_state.apps.get_model(\n  4644\t            \"test_runpythonatomic\", \"Pony\"\n  4645\t        ).objects.all().delete()\n  4646\t        # On a fully-transactional database, both versions rollback.\n  4647\t        if connection.features.can_rollback_ddl:\n  4648\t            self.assertEqual(\n  4649\t                project_state.apps.get_model(\n  4650\t                    \"test_runpythonatomic\", \"Pony\"\n  4651\t                ).objects.count(),\n  4652\t                0,\n  4653\t            )\n  4654\t            with self.assertRaises(ValueError):\n  4655\t                with connection.schema_editor() as editor:\n  4656\t                    atomic_migration.unapply(project_state, editor)\n  4657\t            self.assertEqual(\n  4658\t                project_state.apps.get_model(\n  4659\t                    \"test_runpythonatomic\", \"Pony\"\n  4660\t                ).objects.count(),\n  4661\t                0,\n  4662\t            )\n  4663\t            with self.assertRaises(ValueError):\n  4664\t                with connection.schema_editor() as editor:\n  4665\t                    non_atomic_migration.unapply(project_state, editor)\n  4666\t            self.assertEqual(\n  4667\t                project_state.apps.get_model(\n  4668\t                    \"test_runpythonatomic\", \"Pony\"\n  4669\t                ).objects.count(),\n  4670\t                0,\n  4671\t            )\n  4672\t        # Otherwise, the non-atomic operation leaves a row there.\n  4673\t        else:\n  4674\t            self.assertEqual(\n  4675\t                project_state.apps.get_model(\n  4676\t                    \"test_runpythonatomic\", \"Pony\"\n  4677\t                ).objects.count(),\n  4678\t                0,\n  4679\t            )\n  4680\t            with self.assertRaises(ValueError):\n  4681\t                with connection.schema_editor() as editor:\n  4682\t                    atomic_migration.unapply(project_state, editor)\n  4683\t            self.assertEqual(\n  4684\t                project_state.apps.get_model(\n  4685\t                    \"test_runpythonatomic\", \"Pony\"\n  4686\t                ).objects.count(),\n  4687\t                0,\n  4688\t            )\n  4689\t            with self.assertRaises(ValueError):\n  4690\t                with connection.schema_editor() as editor:\n  4691\t                    non_atomic_migration.unapply(project_state, editor)\n  4692\t            self.assertEqual(\n  4693\t                project_state.apps.get_model(\n  4694\t                    \"test_runpythonatomic\", \"Pony\"\n  4695\t                ).objects.count(),\n  4696\t                1,\n  4697\t            )\n  4698\t        # Verify deconstruction.\n  4699\t        definition = non_atomic_migration.operations[0].deconstruct()\n  4700\t        self.assertEqual(definition[0], \"RunPython\")\n  4701\t        self.assertEqual(definition[1], [])\n  4702\t        self.assertEqual(sorted(definition[2]), [\"atomic\", \"code\", \"reverse_code\"])\n  4703\t\n  4704\t    def test_run_python_related_assignment(self):\n  4705\t        \"\"\"\n  4706\t        #24282 - Model changes to a FK reverse side update the model\n  4707\t        on the FK side as well.\n  4708\t        \"\"\"\n  4709\t\n  4710\t        def inner_method(models, schema_editor):\n  4711\t            Author = models.get_model(\"test_authors\", \"Author\")\n  4712\t            Book = models.get_model(\"test_books\", \"Book\")\n  4713\t            author = Author.objects.create(name=\"Hemingway\")\n  4714\t            Book.objects.create(title=\"Old Man and The Sea\", author=author)\n  4715\t\n  4716\t        create_author = migrations.CreateModel(\n  4717\t            \"Author\",\n  4718\t            [\n  4719\t                (\"id\", models.AutoField(primary_key=True)),\n  4720\t                (\"name\", models.CharField(max_length=100)),\n  4721\t            ],\n  4722\t            options={},\n  4723\t        )\n  4724\t        create_book = migrations.CreateModel(\n  4725\t            \"Book\",\n  4726\t            [\n  4727\t                (\"id\", models.AutoField(primary_key=True)),\n  4728\t                (\"title\", models.CharField(max_length=100)),\n  4729\t                (\"author\", models.ForeignKey(\"test_authors.Author\", models.CASCADE)),\n  4730\t            ],\n  4731\t            options={},\n  4732\t        )\n  4733\t        add_hometown = migrations.AddField(\n  4734\t            \"Author\",\n  4735\t            \"hometown\",\n  4736\t            models.CharField(max_length=100),\n  4737\t        )\n  4738\t        create_old_man = migrations.RunPython(inner_method, inner_method)\n  4739\t\n  4740\t        project_state = ProjectState()\n  4741\t        new_state = project_state.clone()\n  4742\t        with connection.schema_editor() as editor:\n  4743\t            create_author.state_forwards(\"test_authors\", new_state)\n  4744\t            create_author.database_forwards(\n  4745\t                \"test_authors\", editor, project_state, new_state\n  4746\t            )\n  4747\t        project_state = new_state\n  4748\t        new_state = new_state.clone()\n  4749\t        with connection.schema_editor() as editor:\n  4750\t            create_book.state_forwards(\"test_books\", new_state)\n  4751\t            create_book.database_forwards(\n  4752\t                \"test_books\", editor, project_state, new_state\n  4753\t            )\n  4754\t        project_state = new_state\n  4755\t        new_state = new_state.clone()\n  4756\t        with connection.schema_editor() as editor:\n  4757\t            add_hometown.state_forwards(\"test_authors\", new_state)\n  4758\t            add_hometown.database_forwards(\n  4759\t                \"test_authors\", editor, project_state, new_state\n  4760\t            )\n  4761\t        project_state = new_state\n  4762\t        new_state = new_state.clone()\n  4763\t        with connection.schema_editor() as editor:\n  4764\t            create_old_man.state_forwards(\"test_books\", new_state)\n  4765\t            create_old_man.database_forwards(\n  4766\t                \"test_books\", editor, project_state, new_state\n  4767\t            )\n  4768\t\n  4769\t    def test_model_with_bigautofield(self):\n  4770\t        \"\"\"\n  4771\t        A model with BigAutoField can be created.\n  4772\t        \"\"\"\n  4773\t\n  4774\t        def create_data(models, schema_editor):\n  4775\t            Author = models.get_model(\"test_author\", \"Author\")\n  4776\t            Book = models.get_model(\"test_book\", \"Book\")\n  4777\t            author1 = Author.objects.create(name=\"Hemingway\")\n  4778\t            Book.objects.create(title=\"Old Man and The Sea\", author=author1)\n  4779\t            Book.objects.create(id=2**33, title=\"A farewell to arms\", author=author1)\n  4780\t\n  4781\t            author2 = Author.objects.create(id=2**33, name=\"Remarque\")\n  4782\t            Book.objects.create(title=\"All quiet on the western front\", author=author2)\n  4783\t            Book.objects.create(title=\"Arc de Triomphe\", author=author2)\n  4784\t\n  4785\t        create_author = migrations.CreateModel(\n  4786\t            \"Author\",\n  4787\t            [\n  4788\t                (\"id\", models.BigAutoField(primary_key=True)),\n  4789\t                (\"name\", models.CharField(max_length=100)),\n  4790\t            ],\n  4791\t            options={},\n  4792\t        )\n  4793\t        create_book = migrations.CreateModel(\n  4794\t            \"Book\",\n  4795\t            [\n  4796\t                (\"id\", models.BigAutoField(primary_key=True)),\n  4797\t                (\"title\", models.CharField(max_length=100)),\n  4798\t                (\n  4799\t                    \"author\",\n  4800\t                    models.ForeignKey(\n  4801\t                        to=\"test_author.Author\", on_delete=models.CASCADE\n  4802\t                    ),\n  4803\t                ),\n  4804\t            ],\n  4805\t            options={},\n  4806\t        )\n  4807\t        fill_data = migrations.RunPython(create_data)\n  4808\t\n  4809\t        project_state = ProjectState()\n  4810\t        new_state = project_state.clone()\n  4811\t        with connection.schema_editor() as editor:\n  4812\t            create_author.state_forwards(\"test_author\", new_state)\n  4813\t            create_author.database_forwards(\n  4814\t                \"test_author\", editor, project_state, new_state\n  4815\t            )\n  4816\t\n  4817\t        project_state = new_state\n  4818\t        new_state = new_state.clone()\n  4819\t        with connection.schema_editor() as editor:\n  4820\t            create_book.state_forwards(\"test_book\", new_state)\n  4821\t            create_book.database_forwards(\"test_book\", editor, project_state, new_state)\n  4822\t\n  4823\t        project_state = new_state\n  4824\t        new_state = new_state.clone()\n  4825\t        with connection.schema_editor() as editor:\n  4826\t            fill_data.state_forwards(\"fill_data\", new_state)\n  4827\t            fill_data.database_forwards(\"fill_data\", editor, project_state, new_state)\n  4828\t\n  4829\t    def _test_autofield_foreignfield_growth(\n  4830\t        self, source_field, target_field, target_value\n  4831\t    ):\n  4832\t        \"\"\"\n  4833\t        A field may be migrated in the following ways:\n  4834\t\n  4835\t        - AutoField to BigAutoField\n  4836\t        - SmallAutoField to AutoField\n  4837\t        - SmallAutoField to BigAutoField\n  4838\t        \"\"\"\n  4839\t\n  4840\t        def create_initial_data(models, schema_editor):\n  4841\t            Article = models.get_model(\"test_article\", \"Article\")\n  4842\t            Blog = models.get_model(\"test_blog\", \"Blog\")\n  4843\t            blog = Blog.objects.create(name=\"web development done right\")\n  4844\t            Article.objects.create(name=\"Frameworks\", blog=blog)\n  4845\t            Article.objects.create(name=\"Programming Languages\", blog=blog)\n  4846\t\n  4847\t        def create_big_data(models, schema_editor):\n  4848\t            Article = models.get_model(\"test_article\", \"Article\")\n  4849\t            Blog = models.get_model(\"test_blog\", \"Blog\")\n  4850\t            blog2 = Blog.objects.create(name=\"Frameworks\", id=target_value)\n  4851\t            Article.objects.create(name=\"Django\", blog=blog2)\n  4852\t            Article.objects.create(id=target_value, name=\"Django2\", blog=blog2)\n  4853\t\n  4854\t        create_blog = migrations.CreateModel(\n  4855\t            \"Blog\",\n  4856\t            [\n  4857\t                (\"id\", source_field(primary_key=True)),\n  4858\t                (\"name\", models.CharField(max_length=100)),\n  4859\t            ],\n  4860\t            options={},\n  4861\t        )\n  4862\t        create_article = migrations.CreateModel(\n  4863\t            \"Article\",\n  4864\t            [\n  4865\t                (\"id\", source_field(primary_key=True)),\n  4866\t                (\n  4867\t                    \"blog\",\n  4868\t                    models.ForeignKey(to=\"test_blog.Blog\", on_delete=models.CASCADE),\n  4869\t                ),\n  4870\t                (\"name\", models.CharField(max_length=100)),\n  4871\t                (\"data\", models.TextField(default=\"\")),\n  4872\t            ],\n  4873\t            options={},\n  4874\t        )\n  4875\t        fill_initial_data = migrations.RunPython(\n  4876\t            create_initial_data, create_initial_data\n  4877\t        )\n  4878\t        fill_big_data = migrations.RunPython(create_big_data, create_big_data)\n  4879\t\n  4880\t        grow_article_id = migrations.AlterField(\n  4881\t            \"Article\", \"id\", target_field(primary_key=True)\n  4882\t        )\n  4883\t        grow_blog_id = migrations.AlterField(\n  4884\t            \"Blog\", \"id\", target_field(primary_key=True)\n  4885\t        )\n  4886\t\n  4887\t        project_state = ProjectState()\n  4888\t        new_state = project_state.clone()\n  4889\t        with connection.schema_editor() as editor:\n  4890\t            create_blog.state_forwards(\"test_blog\", new_state)\n  4891\t            create_blog.database_forwards(\"test_blog\", editor, project_state, new_state)\n  4892\t\n  4893\t        project_state = new_state\n  4894\t        new_state = new_state.clone()\n  4895\t        with connection.schema_editor() as editor:\n  4896\t            create_article.state_forwards(\"test_article\", new_state)\n  4897\t            create_article.database_forwards(\n  4898\t                \"test_article\", editor, project_state, new_state\n  4899\t            )\n  4900\t\n  4901\t        project_state = new_state\n  4902\t        new_state = new_state.clone()\n  4903\t        with connection.schema_editor() as editor:\n  4904\t            fill_initial_data.state_forwards(\"fill_initial_data\", new_state)\n  4905\t            fill_initial_data.database_forwards(\n  4906\t                \"fill_initial_data\", editor, project_state, new_state\n  4907\t            )\n  4908\t\n  4909\t        project_state = new_state\n  4910\t        new_state = new_state.clone()\n  4911\t        with connection.schema_editor() as editor:\n  4912\t            grow_article_id.state_forwards(\"test_article\", new_state)\n  4913\t            grow_article_id.database_forwards(\n  4914\t                \"test_article\", editor, project_state, new_state\n  4915\t            )\n  4916\t\n  4917\t        state = new_state.clone()\n  4918\t        article = state.apps.get_model(\"test_article.Article\")\n  4919\t        self.assertIsInstance(article._meta.pk, target_field)\n  4920\t\n  4921\t        project_state = new_state\n  4922\t        new_state = new_state.clone()\n  4923\t        with connection.schema_editor() as editor:\n  4924\t            grow_blog_id.state_forwards(\"test_blog\", new_state)\n  4925\t            grow_blog_id.database_forwards(\n  4926\t                \"test_blog\", editor, project_state, new_state\n  4927\t            )\n  4928\t\n  4929\t        state = new_state.clone()\n  4930\t        blog = state.apps.get_model(\"test_blog.Blog\")\n  4931\t        self.assertIsInstance(blog._meta.pk, target_field)\n  4932\t\n  4933\t        project_state = new_state\n  4934\t        new_state = new_state.clone()\n  4935\t        with connection.schema_editor() as editor:\n  4936\t            fill_big_data.state_forwards(\"fill_big_data\", new_state)\n  4937\t            fill_big_data.database_forwards(\n  4938\t                \"fill_big_data\", editor, project_state, new_state\n  4939\t            )\n  4940\t\n  4941\t    def test_autofield__bigautofield_foreignfield_growth(self):\n  4942\t        \"\"\"A field may be migrated from AutoField to BigAutoField.\"\"\"\n  4943\t        self._test_autofield_foreignfield_growth(\n  4944\t            models.AutoField,\n  4945\t            models.BigAutoField,\n  4946\t            2**33,\n  4947\t        )\n  4948\t\n  4949\t    def test_smallfield_autofield_foreignfield_growth(self):\n  4950\t        \"\"\"A field may be migrated from SmallAutoField to AutoField.\"\"\"\n  4951\t        self._test_autofield_foreignfield_growth(\n  4952\t            models.SmallAutoField,\n  4953\t            models.AutoField,\n  4954\t            2**22,\n  4955\t        )\n  4956\t\n  4957\t    def test_smallfield_bigautofield_foreignfield_growth(self):\n  4958\t        \"\"\"A field may be migrated from SmallAutoField to BigAutoField.\"\"\"\n  4959\t        self._test_autofield_foreignfield_growth(\n  4960\t            models.SmallAutoField,\n  4961\t            models.BigAutoField,\n  4962\t            2**33,\n  4963\t        )\n  4964\t\n  4965\t    def test_run_python_noop(self):\n  4966\t        \"\"\"\n  4967\t        #24098 - Tests no-op RunPython operations.\n  4968\t        \"\"\"\n  4969\t        project_state = ProjectState()\n  4970\t        new_state = project_state.clone()\n  4971\t        operation = migrations.RunPython(\n  4972\t            migrations.RunPython.noop, migrations.RunPython.noop\n  4973\t        )\n  4974\t        with connection.schema_editor() as editor:\n  4975\t            operation.database_forwards(\n  4976\t                \"test_runpython\", editor, project_state, new_state\n  4977\t            )\n  4978\t            operation.database_backwards(\n  4979\t                \"test_runpython\", editor, new_state, project_state\n  4980\t            )\n  4981\t\n  4982\t    def test_separate_database_and_state(self):\n  4983\t        \"\"\"\n  4984\t        Tests the SeparateDatabaseAndState operation.\n  4985\t        \"\"\"\n  4986\t        project_state = self.set_up_test_model(\"test_separatedatabaseandstate\")\n  4987\t        # Create the operation\n  4988\t        database_operation = migrations.RunSQL(\n  4989\t            \"CREATE TABLE i_love_ponies (id int, special_thing int);\",\n  4990\t            \"DROP TABLE i_love_ponies;\",\n  4991\t        )\n  4992\t        state_operation = migrations.CreateModel(\n  4993\t            \"SomethingElse\", [(\"id\", models.AutoField(primary_key=True))]\n  4994\t        )\n  4995\t        operation = migrations.SeparateDatabaseAndState(\n  4996\t            state_operations=[state_operation], database_operations=[database_operation]\n  4997\t        )\n  4998\t        self.assertEqual(\n  4999\t            operation.describe(), \"Custom state/database change combination\"\n  5000\t        )\n  5001\t        # Test the state alteration\n  5002\t        new_state = project_state.clone()\n  5003\t        operation.state_forwards(\"test_separatedatabaseandstate\", new_state)\n  5004\t        self.assertEqual(\n  5005\t            len(\n  5006\t                new_state.models[\n  5007\t                    \"test_separatedatabaseandstate\", \"somethingelse\"\n  5008\t                ].fields\n  5009\t            ),\n  5010\t            1,\n  5011\t        )\n  5012\t        # Make sure there's no table\n  5013\t        self.assertTableNotExists(\"i_love_ponies\")\n  5014\t        # Test the database alteration\n  5015\t        with connection.schema_editor() as editor:\n  5016\t            operation.database_forwards(\n  5017\t                \"test_separatedatabaseandstate\", editor, project_state, new_state\n  5018\t            )\n  5019\t        self.assertTableExists(\"i_love_ponies\")\n  5020\t        # And test reversal\n  5021\t        self.assertTrue(operation.reversible)\n  5022\t        with connection.schema_editor() as editor:\n  5023\t            operation.database_backwards(\n  5024\t                \"test_separatedatabaseandstate\", editor, new_state, project_state\n  5025\t            )\n  5026\t        self.assertTableNotExists(\"i_love_ponies\")\n  5027\t        # And deconstruction\n  5028\t        definition = operation.deconstruct()\n  5029\t        self.assertEqual(definition[0], \"SeparateDatabaseAndState\")\n  5030\t        self.assertEqual(definition[1], [])\n  5031\t        self.assertEqual(\n  5032\t            sorted(definition[2]), [\"database_operations\", \"state_operations\"]\n  5033\t        )\n  5034\t\n  5035\t    def test_separate_database_and_state2(self):\n  5036\t        \"\"\"\n  5037\t        A complex SeparateDatabaseAndState operation: Multiple operations both\n  5038\t        for state and database. Verify the state dependencies within each list\n  5039\t        and that state ops don't affect the database.\n  5040\t        \"\"\"\n  5041\t        app_label = \"test_separatedatabaseandstate2\"\n  5042\t        project_state = self.set_up_test_model(app_label)\n  5043\t        # Create the operation\n  5044\t        database_operations = [\n  5045\t            migrations.CreateModel(\n  5046\t                \"ILovePonies\",\n  5047\t                [(\"id\", models.AutoField(primary_key=True))],\n  5048\t                options={\"db_table\": \"iloveponies\"},\n  5049\t            ),\n  5050\t            migrations.CreateModel(\n  5051\t                \"ILoveMorePonies\",\n  5052\t                # We use IntegerField and not AutoField because\n  5053\t                # the model is going to be deleted immediately\n  5054\t                # and with an AutoField this fails on Oracle\n  5055\t                [(\"id\", models.IntegerField(primary_key=True))],\n  5056\t                options={\"db_table\": \"ilovemoreponies\"},\n  5057\t            ),\n  5058\t            migrations.DeleteModel(\"ILoveMorePonies\"),\n  5059\t            migrations.CreateModel(\n  5060\t                \"ILoveEvenMorePonies\",\n  5061\t                [(\"id\", models.AutoField(primary_key=True))],\n  5062\t                options={\"db_table\": \"iloveevenmoreponies\"},\n  5063\t            ),\n  5064\t        ]\n  5065\t        state_operations = [\n  5066\t            migrations.CreateModel(\n  5067\t                \"SomethingElse\",\n  5068\t                [(\"id\", models.AutoField(primary_key=True))],\n  5069\t                options={\"db_table\": \"somethingelse\"},\n  5070\t            ),\n  5071\t            migrations.DeleteModel(\"SomethingElse\"),\n  5072\t            migrations.CreateModel(\n  5073\t                \"SomethingCompletelyDifferent\",\n  5074\t                [(\"id\", models.AutoField(primary_key=True))],\n  5075\t                options={\"db_table\": \"somethingcompletelydifferent\"},\n  5076\t            ),\n  5077\t        ]\n  5078\t        operation = migrations.SeparateDatabaseAndState(\n  5079\t            state_operations=state_operations,\n  5080\t            database_operations=database_operations,\n  5081\t        )\n  5082\t        # Test the state alteration\n  5083\t        new_state = project_state.clone()\n  5084\t        operation.state_forwards(app_label, new_state)\n  5085\t\n  5086\t        def assertModelsAndTables(after_db):\n  5087\t            # Tables and models exist, or don't, as they should:\n  5088\t            self.assertNotIn((app_label, \"somethingelse\"), new_state.models)\n  5089\t            self.assertEqual(\n  5090\t                len(new_state.models[app_label, \"somethingcompletelydifferent\"].fields),\n  5091\t                1,\n  5092\t            )\n  5093\t            self.assertNotIn((app_label, \"iloveponiesonies\"), new_state.models)\n  5094\t            self.assertNotIn((app_label, \"ilovemoreponies\"), new_state.models)\n  5095\t            self.assertNotIn((app_label, \"iloveevenmoreponies\"), new_state.models)\n  5096\t            self.assertTableNotExists(\"somethingelse\")\n  5097\t            self.assertTableNotExists(\"somethingcompletelydifferent\")\n  5098\t            self.assertTableNotExists(\"ilovemoreponies\")\n  5099\t            if after_db:\n  5100\t                self.assertTableExists(\"iloveponies\")\n  5101\t                self.assertTableExists(\"iloveevenmoreponies\")\n  5102\t            else:\n  5103\t                self.assertTableNotExists(\"iloveponies\")\n  5104\t                self.assertTableNotExists(\"iloveevenmoreponies\")\n  5105\t\n  5106\t        assertModelsAndTables(after_db=False)\n  5107\t        # Test the database alteration\n  5108\t        with connection.schema_editor() as editor:\n  5109\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  5110\t        assertModelsAndTables(after_db=True)\n  5111\t        # And test reversal\n  5112\t        self.assertTrue(operation.reversible)\n  5113\t        with connection.schema_editor() as editor:\n  5114\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  5115\t        assertModelsAndTables(after_db=False)\n  5116\t\n  5117\t\n  5118\tclass SwappableOperationTests(OperationTestBase):\n  5119\t    \"\"\"\n  5120\t    Key operations ignore swappable models\n  5121\t    (we don't want to replicate all of them here, as the functionality\n  5122\t    is in a common base class anyway)\n  5123\t    \"\"\"\n  5124\t\n  5125\t    available_apps = [\"migrations\"]\n  5126\t\n  5127\t    @override_settings(TEST_SWAP_MODEL=\"migrations.SomeFakeModel\")\n  5128\t    def test_create_ignore_swapped(self):\n  5129\t        \"\"\"\n  5130\t        The CreateTable operation ignores swapped models.\n  5131\t        \"\"\"\n  5132\t        operation = migrations.CreateModel(\n  5133\t            \"Pony\",\n  5134\t            [\n  5135\t                (\"id\", models.AutoField(primary_key=True)),\n  5136\t                (\"pink\", models.IntegerField(default=1)),\n  5137\t            ],\n  5138\t            options={\n  5139\t                \"swappable\": \"TEST_SWAP_MODEL\",\n  5140\t            },\n  5141\t        )\n  5142\t        # Test the state alteration (it should still be there!)\n  5143\t        project_state = ProjectState()\n  5144\t        new_state = project_state.clone()\n  5145\t        operation.state_forwards(\"test_crigsw\", new_state)\n  5146\t        self.assertEqual(new_state.models[\"test_crigsw\", \"pony\"].name, \"Pony\")\n  5147\t        self.assertEqual(len(new_state.models[\"test_crigsw\", \"pony\"].fields), 2)\n  5148\t        # Test the database alteration\n  5149\t        self.assertTableNotExists(\"test_crigsw_pony\")\n  5150\t        with connection.schema_editor() as editor:\n  5151\t            operation.database_forwards(\"test_crigsw\", editor, project_state, new_state)\n  5152\t        self.assertTableNotExists(\"test_crigsw_pony\")\n  5153\t        # And test reversal\n  5154\t        with connection.schema_editor() as editor:\n  5155\t            operation.database_backwards(\n  5156\t                \"test_crigsw\", editor, new_state, project_state\n  5157\t            )\n  5158\t        self.assertTableNotExists(\"test_crigsw_pony\")\n  5159\t\n  5160\t    @override_settings(TEST_SWAP_MODEL=\"migrations.SomeFakeModel\")\n  5161\t    def test_delete_ignore_swapped(self):\n  5162\t        \"\"\"\n  5163\t        Tests the DeleteModel operation ignores swapped models.\n  5164\t        \"\"\"\n  5165\t        operation = migrations.DeleteModel(\"Pony\")\n  5166\t        project_state, new_state = self.make_test_state(\"test_dligsw\", operation)\n  5167\t        # Test the database alteration\n  5168\t        self.assertTableNotExists(\"test_dligsw_pony\")\n  5169\t        with connection.schema_editor() as editor:\n  5170\t            operation.database_forwards(\"test_dligsw\", editor, project_state, new_state)\n  5171\t        self.assertTableNotExists(\"test_dligsw_pony\")\n  5172\t        # And test reversal\n  5173\t        with connection.schema_editor() as editor:\n  5174\t            operation.database_backwards(\n  5175\t                \"test_dligsw\", editor, new_state, project_state\n  5176\t            )\n  5177\t        self.assertTableNotExists(\"test_dligsw_pony\")\n  5178\t\n  5179\t    @override_settings(TEST_SWAP_MODEL=\"migrations.SomeFakeModel\")\n  5180\t    def test_add_field_ignore_swapped(self):\n  5181\t        \"\"\"\n  5182\t        Tests the AddField operation.\n  5183\t        \"\"\"\n  5184\t        # Test the state alteration\n  5185\t        operation = migrations.AddField(\n  5186\t            \"Pony\",\n  5187\t            \"height\",\n  5188\t            models.FloatField(null=True, default=5),\n  5189\t        )\n  5190\t        project_state, new_state = self.make_test_state(\"test_adfligsw\", operation)\n  5191\t        # Test the database alteration\n  5192\t        self.assertTableNotExists(\"test_adfligsw_pony\")\n  5193\t        with connection.schema_editor() as editor:\n  5194\t            operation.database_forwards(\n  5195\t                \"test_adfligsw\", editor, project_state, new_state\n  5196\t            )\n  5197\t        self.assertTableNotExists(\"test_adfligsw_pony\")\n  5198\t        # And test reversal\n  5199\t        with connection.schema_editor() as editor:\n  5200\t            operation.database_backwards(\n  5201\t                \"test_adfligsw\", editor, new_state, project_state\n  5202\t            )\n  5203\t        self.assertTableNotExists(\"test_adfligsw_pony\")\n  5204\t\n  5205\t    @override_settings(TEST_SWAP_MODEL=\"migrations.SomeFakeModel\")\n  5206\t    def test_indexes_ignore_swapped(self):\n  5207\t        \"\"\"\n  5208\t        Add/RemoveIndex operations ignore swapped models.\n  5209\t        \"\"\"\n  5210\t        operation = migrations.AddIndex(\n  5211\t            \"Pony\", models.Index(fields=[\"pink\"], name=\"my_name_idx\")\n  5212\t        )\n  5213\t        project_state, new_state = self.make_test_state(\"test_adinigsw\", operation)\n  5214\t        with connection.schema_editor() as editor:\n  5215\t            # No database queries should be run for swapped models\n  5216\t            operation.database_forwards(\n  5217\t                \"test_adinigsw\", editor, project_state, new_state\n  5218\t            )\n  5219\t            operation.database_backwards(\n  5220\t                \"test_adinigsw\", editor, new_state, project_state\n  5221\t            )\n  5222\t\n  5223\t        operation = migrations.RemoveIndex(\n  5224\t            \"Pony\", models.Index(fields=[\"pink\"], name=\"my_name_idx\")\n  5225\t        )\n  5226\t        project_state, new_state = self.make_test_state(\"test_rminigsw\", operation)\n  5227\t        with connection.schema_editor() as editor:\n  5228\t            operation.database_forwards(\n  5229\t                \"test_rminigsw\", editor, project_state, new_state\n  5230\t            )\n  5231\t            operation.database_backwards(\n  5232\t                \"test_rminigsw\", editor, new_state, project_state\n  5233\t            )\n  5234\t\n  5235\t\n  5236\tclass TestCreateModel(SimpleTestCase):\n  5237\t    def test_references_model_mixin(self):\n  5238\t        migrations.CreateModel(\n  5239\t            \"name\",\n  5240\t            fields=[],\n  5241\t            bases=(Mixin, models.Model),\n  5242\t        ).references_model(\"other_model\", \"migrations\")\n  5243\t\n  5244\t\n  5245\tclass FieldOperationTests(SimpleTestCase):\n  5246\t    def test_references_model(self):\n  5247\t        operation = FieldOperation(\n  5248\t            \"MoDel\", \"field\", models.ForeignKey(\"Other\", models.CASCADE)\n  5249\t        )\n  5250\t        # Model name match.\n  5251\t        self.assertIs(operation.references_model(\"mOdEl\", \"migrations\"), True)\n  5252\t        # Referenced field.\n  5253\t        self.assertIs(operation.references_model(\"oTher\", \"migrations\"), True)\n  5254\t        # Doesn't reference.\n  5255\t        self.assertIs(operation.references_model(\"Whatever\", \"migrations\"), False)\n  5256\t\n  5257\t    def test_references_field_by_name(self):\n  5258\t        operation = FieldOperation(\"MoDel\", \"field\", models.BooleanField(default=False))\n  5259\t        self.assertIs(operation.references_field(\"model\", \"field\", \"migrations\"), True)\n  5260\t\n  5261\t    def test_references_field_by_remote_field_model(self):\n  5262\t        operation = FieldOperation(\n  5263\t            \"Model\", \"field\", models.ForeignKey(\"Other\", models.CASCADE)\n  5264\t        )\n  5265\t        self.assertIs(\n  5266\t            operation.references_field(\"Other\", \"whatever\", \"migrations\"), True\n  5267\t        )\n  5268\t        self.assertIs(\n  5269\t            operation.references_field(\"Missing\", \"whatever\", \"migrations\"), False\n  5270\t        )\n  5271\t\n  5272\t    def test_references_field_by_from_fields(self):\n  5273\t        operation = FieldOperation(\n  5274\t            \"Model\",\n  5275\t            \"field\",\n  5276\t            models.fields.related.ForeignObject(\n  5277\t                \"Other\", models.CASCADE, [\"from\"], [\"to\"]\n  5278\t            ),\n  5279\t        )\n  5280\t        self.assertIs(operation.references_field(\"Model\", \"from\", \"migrations\"), True)\n  5281\t        self.assertIs(operation.references_field(\"Model\", \"to\", \"migrations\"), False)\n  5282\t        self.assertIs(operation.references_field(\"Other\", \"from\", \"migrations\"), False)\n  5283\t        self.assertIs(operation.references_field(\"Model\", \"to\", \"migrations\"), False)\n  5284\t\n  5285\t    def test_references_field_by_to_fields(self):\n  5286\t        operation = FieldOperation(\n  5287\t            \"Model\",\n  5288\t            \"field\",\n  5289\t            models.ForeignKey(\"Other\", models.CASCADE, to_field=\"field\"),\n  5290\t        )\n  5291\t        self.assertIs(operation.references_field(\"Other\", \"field\", \"migrations\"), True)\n  5292\t        self.assertIs(\n  5293\t            operation.references_field(\"Other\", \"whatever\", \"migrations\"), False\n  5294\t        )\n  5295\t        self.assertIs(\n  5296\t            operation.references_field(\"Missing\", \"whatever\", \"migrations\"), False\n  5297\t        )\n  5298\t\n  5299\t    def test_references_field_by_through(self):\n  5300\t        operation = FieldOperation(\n  5301\t            \"Model\", \"field\", models.ManyToManyField(\"Other\", through=\"Through\")\n  5302\t        )\n  5303\t        self.assertIs(\n  5304\t            operation.references_field(\"Other\", \"whatever\", \"migrations\"), True\n  5305\t        )\n  5306\t        self.assertIs(\n  5307\t            operation.references_field(\"Through\", \"whatever\", \"migrations\"), True\n  5308\t        )\n  5309\t        self.assertIs(\n  5310\t            operation.references_field(\"Missing\", \"whatever\", \"migrations\"), False\n  5311\t        )\n  5312\t\n  5313\t    def test_reference_field_by_through_fields(self):\n  5314\t        operation = FieldOperation(\n  5315\t            \"Model\",\n  5316\t            \"field\",\n  5317\t            models.ManyToManyField(\n  5318\t                \"Other\", through=\"Through\", through_fields=(\"first\", \"second\")\n  5319\t            ),\n  5320\t        )\n  5321\t        self.assertIs(\n  5322\t            operation.references_field(\"Other\", \"whatever\", \"migrations\"), True\n  5323\t        )\n  5324\t        self.assertIs(\n  5325\t            operation.references_field(\"Through\", \"whatever\", \"migrations\"), False\n  5326\t        )\n  5327\t        self.assertIs(\n  5328\t            operation.references_field(\"Through\", \"first\", \"migrations\"), True\n  5329\t        )\n  5330\t        self.assertIs(\n  5331\t            operation.references_field(\"Through\", \"second\", \"migrations\"), True\n  5332\t        )\n  5333\t\n```\n\n</observation>",
                  "type": "tool_result"
                }
              ]
            },
            {
              "role": "assistant",
              "content": [
                {
                  "type": "text",
                  "text": "<thoughts>\n1. From the test file, I can see this is related to the RenameIndex operation and how it handles unnamed indexes when moving backward and forward.\n\n2. Let me search for the RenameIndex operation implementation to understand how it currently works.\n</thoughts>"
                },
                {
                  "id": "call_459acff2",
                  "input": {
                    "file_pattern": null,
                    "query": "RenameIndex operation implementation",
                    "category": "implementation"
                  },
                  "type": "tool_use",
                  "name": "SemanticSearch"
                }
              ]
            },
            {
              "role": "user",
              "content": [
                {
                  "tool_use_id": "call_459acff2",
                  "content": "<observation>\nFound 15 code sections.\n\nViewed relevant code:\ndjango/db/migrations/operations/models.py\n```\n     1\tfrom django.db import models\n     2\tfrom django.db.migrations.operations.base import Operation\n     3\tfrom django.db.migrations.state import ModelState\n     4\tfrom django.db.migrations.utils import field_references, resolve_relation\n     5\tfrom django.db.models.options import normalize_together\n     6\tfrom django.utils.functional import cached_property\n     7\t\n     8\tfrom .fields import AddField, AlterField, FieldOperation, RemoveField, RenameField\n      # ...\n   877\t\n   878\t\n   879\tclass RenameIndex(IndexOperation):\n   880\t    \"\"\"Rename an index.\"\"\"\n   881\t\n   882\t    def __init__(self, model_name, new_name, old_name=None, old_fields=None):\n   883\t        if not old_name and not old_fields:\n   884\t            raise ValueError(\n   885\t                \"RenameIndex requires one of old_name and old_fields arguments to be \"\n   886\t                \"set.\"\n   887\t            )\n   888\t        if old_name and old_fields:\n   889\t            raise ValueError(\n   890\t                \"RenameIndex.old_name and old_fields are mutually exclusive.\"\n   891\t            )\n   892\t        self.model_name = model_name\n   893\t        self.new_name = new_name\n   894\t        self.old_name = old_name\n   895\t        self.old_fields = old_fields\n   896\t\n   897\t    @cached_property\n   898\t    def old_name_lower(self):\n   899\t        return self.old_name.lower()\n   900\t\n   901\t    @cached_property\n   902\t    def new_name_lower(self):\n   903\t        return self.new_name.lower()\n   904\t\n   905\t    def deconstruct(self):\n   906\t        kwargs = {\n   907\t            \"model_name\": self.model_name,\n   908\t            \"new_name\": self.new_name,\n   909\t        }\n   910\t        if self.old_name:\n   911\t            kwargs[\"old_name\"] = self.old_name\n   912\t        if self.old_fields:\n   913\t            kwargs[\"old_fields\"] = self.old_fields\n   914\t        return (self.__class__.__qualname__, [], kwargs)\n   915\t\n   916\t    def state_forwards(self, app_label, state):\n   917\t        if self.old_fields:\n   918\t            state.add_index(\n   919\t                app_label,\n   920\t                self.model_name_lower,\n   921\t                models.Index(fields=self.old_fields, name=self.new_name),\n   922\t            )\n   923\t            state.remove_model_options(\n   924\t                app_label,\n   925\t                self.model_name_lower,\n   926\t                AlterIndexTogether.option_name,\n   927\t                self.old_fields,\n   928\t            )\n   929\t        else:\n   930\t            state.rename_index(\n   931\t                app_label, self.model_name_lower, self.old_name, self.new_name\n   932\t            )\n   933\t\n   934\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n   935\t        model = to_state.apps.get_model(app_label, self.model_name)\n   936\t        if not self.allow_migrate_model(schema_editor.connection.alias, model):\n   937\t            return\n   938\t\n   939\t        if self.old_fields:\n   940\t            from_model = from_state.apps.get_model(app_label, self.model_name)\n   941\t            columns = [\n   942\t                from_model._meta.get_field(field).column for field in self.old_fields\n   943\t            ]\n   944\t            matching_index_name = schema_editor._constraint_names(\n   945\t                from_model, column_names=columns, index=True\n   946\t            )\n   947\t            if len(matching_index_name) != 1:\n   948\t                raise ValueError(\n   949\t                    \"Found wrong number (%s) of indexes for %s(%s).\"\n   950\t                    % (\n   951\t                        len(matching_index_name),\n   952\t                        from_model._meta.db_table,\n   953\t                        \", \".join(columns),\n   954\t                    )\n   955\t                )\n   956\t            old_index = models.Index(\n   957\t                fields=self.old_fields,\n   958\t                name=matching_index_name[0],\n   959\t            )\n   960\t        else:\n   961\t            from_model_state = from_state.models[app_label, self.model_name_lower]\n   962\t            old_index = from_model_state.get_index_by_name(self.old_name)\n   963\t\n   964\t        to_model_state = to_state.models[app_label, self.model_name_lower]\n   965\t        new_index = to_model_state.get_index_by_name(self.new_name)\n   966\t        schema_editor.rename_index(model, old_index, new_index)\n   967\t\n   968\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n   969\t        if self.old_fields:\n   970\t            # Backward operation with unnamed index is a no-op.\n   971\t            return\n   972\t\n   973\t        self.new_name_lower, self.old_name_lower = (\n   974\t            self.old_name_lower,\n   975\t            self.new_name_lower,\n   976\t        )\n   977\t        self.new_name, self.old_name = self.old_name, self.new_name\n   978\t\n   979\t        self.database_forwards(app_label, schema_editor, from_state, to_state)\n   980\t\n   981\t        self.new_name_lower, self.old_name_lower = (\n   982\t            self.old_name_lower,\n   983\t            self.new_name_lower,\n   984\t        )\n   985\t        self.new_name, self.old_name = self.old_name, self.new_name\n   986\t\n   987\t    def describe(self):\n   988\t        if self.old_name:\n   989\t            return (\n   990\t                f\"Rename index {self.old_name} on {self.model_name} to {self.new_name}\"\n   991\t            )\n   992\t        return (\n   993\t            f\"Rename unnamed index for {self.old_fields} on {self.model_name} to \"\n   994\t            f\"{self.new_name}\"\n   995\t        )\n   996\t\n   997\t    @property\n   998\t    def migration_name_fragment(self):\n   999\t        if self.old_name:\n  1000\t            return \"rename_%s_%s\" % (self.old_name_lower, self.new_name_lower)\n  1001\t        return \"rename_%s_%s_%s\" % (\n  1002\t            self.model_name_lower,\n  1003\t            \"_\".join(self.old_fields),\n  1004\t            self.new_name_lower,\n  1005\t        )\n  1006\t\n  1007\t    def reduce(self, operation, app_label):\n  1008\t        if (\n  1009\t            isinstance(operation, RenameIndex)\n  1010\t            and self.model_name_lower == operation.model_name_lower\n  1011\t            and operation.old_name\n  1012\t            and self.new_name_lower == operation.old_name_lower\n  1013\t        ):\n  1014\t            return [\n  1015\t                RenameIndex(\n  1016\t                    self.model_name,\n  1017\t                    new_name=operation.new_name,\n  1018\t                    old_name=self.old_name,\n  1019\t                    old_fields=self.old_fields,\n  1020\t                )\n  1021\t            ]\n  1022\t        return super().reduce(operation, app_label)\n      # ...\n```\n\n\ndjango/db/backends/base/schema.py\n```\n     1\timport logging\n     2\timport operator\n     3\tfrom datetime import datetime\n     4\t\n     5\tfrom django.db.backends.ddl_references import (\n     6\t    Columns,\n     7\t    Expressions,\n     8\t    ForeignKeyName,\n     9\t    IndexName,\n    10\t    Statement,\n    11\t    Table,\n    12\t)\n    13\tfrom django.db.backends.utils import names_digest, split_identifier\n    14\tfrom django.db.models import Deferrable, Index\n    15\tfrom django.db.models.sql import Query\n    16\tfrom django.db.transaction import TransactionManagementError, atomic\n    17\tfrom django.utils import timezone\n    18\t\n    19\tlogger = logging.getLogger(\"django.db.backends.schema\")\n      # ...\n    72\t\n    73\t\n    74\tclass BaseDatabaseSchemaEditor:\n    75\t    \"\"\"\n    76\t    This class and its subclasses are responsible for emitting schema-changing\n    77\t    statements to the databases - model creation/removal/alteration, field\n    78\t    renaming, index fiddling, and so on.\n    79\t    \"\"\"\n    80\t\n    81\t    # Overrideable SQL templates\n    82\t    sql_create_table = \"CREATE TABLE %(table)s (%(definition)s)\"\n    83\t    sql_rename_table = \"ALTER TABLE %(old_table)s RENAME TO %(new_table)s\"\n    84\t    sql_retablespace_table = \"ALTER TABLE %(table)s SET TABLESPACE %(new_tablespace)s\"\n    85\t    sql_delete_table = \"DROP TABLE %(table)s CASCADE\"\n    86\t\n    87\t    sql_create_column = \"ALTER TABLE %(table)s ADD COLUMN %(column)s %(definition)s\"\n    88\t    sql_alter_column = \"ALTER TABLE %(table)s %(changes)s\"\n    89\t    sql_alter_column_type = \"ALTER COLUMN %(column)s TYPE %(type)s\"\n    90\t    sql_alter_column_null = \"ALTER COLUMN %(column)s DROP NOT NULL\"\n    91\t    sql_alter_column_not_null = \"ALTER COLUMN %(column)s SET NOT NULL\"\n    92\t    sql_alter_column_default = \"ALTER COLUMN %(column)s SET DEFAULT %(default)s\"\n    93\t    sql_alter_column_no_default = \"ALTER COLUMN %(column)s DROP DEFAULT\"\n    94\t    sql_alter_column_no_default_null = sql_alter_column_no_default\n    95\t    sql_alter_column_collate = \"ALTER COLUMN %(column)s TYPE %(type)s%(collation)s\"\n    96\t    sql_delete_column = \"ALTER TABLE %(table)s DROP COLUMN %(column)s CASCADE\"\n    97\t    sql_rename_column = (\n    98\t        \"ALTER TABLE %(table)s RENAME COLUMN %(old_column)s TO %(new_column)s\"\n    99\t    )\n   100\t    sql_update_with_default = (\n   101\t        \"UPDATE %(table)s SET %(column)s = %(default)s WHERE %(column)s IS NULL\"\n   102\t    )\n   103\t\n   104\t    sql_unique_constraint = \"UNIQUE (%(columns)s)%(deferrable)s\"\n   105\t    sql_check_constraint = \"CHECK (%(check)s)\"\n   106\t    sql_delete_constraint = \"ALTER TABLE %(table)s DROP CONSTRAINT %(name)s\"\n   107\t    sql_constraint = \"CONSTRAINT %(name)s %(constraint)s\"\n   108\t\n   109\t    sql_create_check = \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s CHECK (%(check)s)\"\n   110\t    sql_delete_check = sql_delete_constraint\n   111\t\n   112\t    sql_create_unique = (\n   113\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s \"\n   114\t        \"UNIQUE (%(columns)s)%(deferrable)s\"\n   115\t    )\n   116\t    sql_delete_unique = sql_delete_constraint\n   117\t\n   118\t    sql_create_fk = (\n   119\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s FOREIGN KEY (%(column)s) \"\n   120\t        \"REFERENCES %(to_table)s (%(to_column)s)%(deferrable)s\"\n   121\t    )\n   122\t    sql_create_inline_fk = None\n   123\t    sql_create_column_inline_fk = None\n   124\t    sql_delete_fk = sql_delete_constraint\n   125\t\n   126\t    sql_create_index = (\n   127\t        \"CREATE INDEX %(name)s ON %(table)s \"\n   128\t        \"(%(columns)s)%(include)s%(extra)s%(condition)s\"\n   129\t    )\n   130\t    sql_create_unique_index = (\n   131\t        \"CREATE UNIQUE INDEX %(name)s ON %(table)s \"\n   132\t        \"(%(columns)s)%(include)s%(condition)s\"\n   133\t    )\n   134\t    sql_rename_index = \"ALTER INDEX %(old_name)s RENAME TO %(new_name)s\"\n   135\t    sql_delete_index = \"DROP INDEX %(name)s\"\n   136\t\n   137\t    sql_create_pk = (\n   138\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s PRIMARY KEY (%(columns)s)\"\n   139\t    )\n   140\t    sql_delete_pk = sql_delete_constraint\n   141\t\n   142\t    sql_delete_procedure = \"DROP PROCEDURE %(procedure)s\"\n          # ...\n  1374\t\n  1375\t    def _rename_index_sql(self, model, old_name, new_name):\n  1376\t        return Statement(\n  1377\t            self.sql_rename_index,\n  1378\t            table=Table(model._meta.db_table, self.quote_name),\n  1379\t            old_name=self.quote_name(old_name),\n  1380\t            new_name=self.quote_name(new_name),\n  1381\t        )\n          # ...\n```\n\n</observation>",
                  "type": "tool_result"
                }
              ]
            },
            {
              "role": "assistant",
              "content": [
                {
                  "type": "text",
                  "text": "<thoughts>\n1. Looking at the code, I can see that RenameIndex has two modes:\n   - Renaming an index by old_name \n   - Renaming an unnamed index by old_fields\n\n2. The issue appears to be in the database_backwards() method when dealing with unnamed indexes. The method has a comment \"Backward operation with unnamed index is a no-op\" and just returns without doing anything.\n\n3. This means that when trying to revert an unnamed index rename operation, it doesn't properly restore the old auto-generated name.\n\n4. The fix should be to:\n   - Remove the early return for unnamed indexes in database_backwards()\n   - Handle the reversal properly by swapping names and letting database_forwards() handle it\n\nLet me look at the test file again to understand the exact test case that's failing.\n</thoughts>"
                },
                {
                  "id": "call_a879f7cc",
                  "input": {
                    "files": [
                      {
                        "file_path": "tests/migrations/test_operations.py",
                        "start_line": 2980,
                        "end_line": 3000,
                        "span_ids": []
                      }
                    ]
                  },
                  "type": "tool_use",
                  "name": "ViewCode"
                }
              ]
            },
            {
              "role": "user",
              "content": [
                {
                  "tool_use_id": "call_a879f7cc",
                  "content": "<observation>\nHere's the contents of the requested code spans:\ntests/migrations/test_operations.py\n```\n     1\tfrom django.core.exceptions import FieldDoesNotExist\n     2\tfrom django.db import IntegrityError, connection, migrations, models, transaction\n     3\tfrom django.db.migrations.migration import Migration\n     4\tfrom django.db.migrations.operations.fields import FieldOperation\n     5\tfrom django.db.migrations.state import ModelState, ProjectState\n     6\tfrom django.db.models.functions import Abs\n     7\tfrom django.db.transaction import atomic\n     8\tfrom django.test import SimpleTestCase, override_settings, skipUnlessDBFeature\n     9\tfrom django.test.utils import CaptureQueriesContext\n    10\t\n    11\tfrom .models import FoodManager, FoodQuerySet, UnicodeModel\n    12\tfrom .test_base import OperationTestBase\n      # ...\n    17\t\n    18\t\n    19\tclass OperationTests(OperationTestBase):\n    20\t    \"\"\"\n    21\t    Tests running the operations and making sure they do what they say they do.\n    22\t    Each test looks at their state changing, and then their database operation -\n    23\t    both forwards and backwards.\n    24\t    \"\"\"\n          # ...\n  2963\t\n  2964\t    def test_rename_index_unnamed_index(self):\n  2965\t        app_label = \"test_rninui\"\n  2966\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  2967\t        table_name = app_label + \"_pony\"\n  2968\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2969\t        operation = migrations.RenameIndex(\n  2970\t            \"Pony\", new_name=\"new_pony_test_idx\", old_fields=(\"weight\", \"pink\")\n  2971\t        )\n  2972\t        self.assertEqual(\n  2973\t            operation.describe(),\n  2974\t            \"Rename unnamed index for ('weight', 'pink') on Pony to new_pony_test_idx\",\n  2975\t        )\n  2976\t        self.assertEqual(\n  2977\t            operation.migration_name_fragment,\n  2978\t            \"rename_pony_weight_pink_new_pony_test_idx\",\n  2979\t        )\n  2980\t\n  2981\t        new_state = project_state.clone()\n  2982\t        operation.state_forwards(app_label, new_state)\n  2983\t        # Rename index.\n  2984\t        with connection.schema_editor() as editor:\n  2985\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2986\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2987\t        # Reverse is a no-op.\n  2988\t        with connection.schema_editor() as editor, self.assertNumQueries(0):\n  2989\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2990\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2991\t        # Deconstruction.\n  2992\t        definition = operation.deconstruct()\n  2993\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2994\t        self.assertEqual(definition[1], [])\n  2995\t        self.assertEqual(\n  2996\t            definition[2],\n  2997\t            {\n  2998\t                \"model_name\": \"Pony\",\n  2999\t                \"new_name\": \"new_pony_test_idx\",\n  3000\t                \"old_fields\": (\"weight\", \"pink\"),\n  3001\t            },\n  3002\t        )\n          # ...\n      # ...\n```\n\n</observation>",
                  "type": "tool_result"
                }
              ]
            },
            {
              "role": "assistant",
              "content": [
                {
                  "type": "text",
                  "text": "<thoughts>\nLooking at the test case, I can see that:\n\n1. The test is specifically checking that RenameIndex works with unnamed indexes (created via index_together)\n\n2. The test expects that:\n   - Forward operation renames the unnamed index to \"new_pony_test_idx\"\n   - Backward operation is currently a no-op and keeps \"new_pony_test_idx\"\n\n3. The issue is that this behavior is incorrect - the backward operation should restore the original auto-generated name for the index.\n\n4. The fix needs to:\n   - Remove the early return in database_backwards() for unnamed indexes\n   - Let the normal name swapping and database_forwards() handle restoring the original name\n\nLet me look at the ProjectState code to understand how it handles index names.\n</thoughts>"
                },
                {
                  "id": "call_5a4e16aa",
                  "input": {
                    "file_pattern": null,
                    "query": "ProjectState index_together handling",
                    "category": "implementation"
                  },
                  "type": "tool_use",
                  "name": "SemanticSearch"
                }
              ]
            },
            {
              "role": "user",
              "content": [
                {
                  "tool_use_id": "call_5a4e16aa",
                  "content": "<observation>\nFound 14 code sections.\n\nViewed relevant code:\ndjango/db/migrations/state.py\n```\n     1\timport copy\n     2\tfrom collections import defaultdict\n     3\tfrom contextlib import contextmanager\n     4\tfrom functools import partial\n     5\t\n     6\tfrom django.apps import AppConfig\n     7\tfrom django.apps.registry import Apps\n     8\tfrom django.apps.registry import apps as global_apps\n     9\tfrom django.conf import settings\n    10\tfrom django.core.exceptions import FieldDoesNotExist\n    11\tfrom django.db import models\n    12\tfrom django.db.migrations.utils import field_is_referenced, get_references\n    13\tfrom django.db.models import NOT_PROVIDED\n    14\tfrom django.db.models.fields.related import RECURSIVE_RELATIONSHIP_CONSTANT\n    15\tfrom django.db.models.options import DEFAULT_NAMES, normalize_together\n    16\tfrom django.db.models.utils import make_model_tuple\n    17\tfrom django.utils.functional import cached_property\n    18\tfrom django.utils.module_loading import import_string\n    19\tfrom django.utils.version import get_docs_version\n    20\t\n    21\tfrom .exceptions import InvalidBasesError\n    22\tfrom .utils import resolve_relation\n      # ...\n    91\t\n    92\t\n    93\tclass ProjectState:\n    94\t    \"\"\"\n    95\t    Represent the entire project's overall state. This is the item that is\n    96\t    passed around - do it here rather than at the app level so that cross-app\n    97\t    FKs/etc. resolve properly.\n    98\t    \"\"\"\n          # ...\n   180\t\n   181\t    def alter_model_options(self, app_label, model_name, options, option_keys=None):\n   182\t        model_state = self.models[app_label, model_name]\n   183\t        model_state.options = {**model_state.options, **options}\n   184\t        if option_keys:\n   185\t            for key in option_keys:\n   186\t                if key not in options:\n   187\t                    model_state.options.pop(key, False)\n   188\t        self.reload_model(app_label, model_name, delay=True)\n   189\t\n   190\t    def remove_model_options(self, app_label, model_name, option_name, value_to_remove):\n   191\t        model_state = self.models[app_label, model_name]\n   192\t        if objs := model_state.options.get(option_name):\n   193\t            model_state.options[option_name] = [\n   194\t                obj for obj in objs if tuple(obj) != tuple(value_to_remove)\n   195\t            ]\n   196\t        self.reload_model(app_label, model_name, delay=True)\n          # ...\n      # ...\n```\n\n</observation>",
                  "type": "tool_result",
                  "cache_control": {
                    "type": "ephemeral"
                  }
                }
              ]
            },
            {
              "role": "assistant",
              "content": [
                {
                  "type": "text",
                  "text": "<thoughts>\nAfter reviewing the code, I understand that:\n\n1. The issue is that when an unnamed index (from index_together) is renamed, the backward operation should:\n   - Remove the named index\n   - Restore the original index_together option which will recreate the unnamed index\n\n2. The current implementation in RenameIndex.database_backwards() just returns early for unnamed indexes, which is incorrect.\n\n3. The fix should be to:\n   - Remove the early return for unnamed indexes\n   - Let the normal name swapping and database_forwards() handle the reversal\n   - This will properly restore the original index_together state and recreate the unnamed index\n\nLet me prepare a patch to fix this issue.\n</thoughts>"
                },
                {
                  "id": "call_71495245",
                  "input": {
                    "command": "view",
                    "path": "django/db/migrations/operations/models.py",
                    "file_text": null,
                    "view_range": null,
                    "old_str": null,
                    "new_str": null,
                    "insert_line": null
                  },
                  "type": "tool_use",
                  "name": "str_replace_editor",
                  "cache_control": {
                    "type": "ephemeral"
                  }
                }
              ]
            },
            {
              "role": "user",
              "content": [
                {
                  "tool_use_id": "call_71495245",
                  "content": "<observation>\nFile django/db/migrations/operations/models.py is too large (7725 tokens) to view in its entirety. Maximum allowed is 2000 tokens. Please specify a line range using view_range or spans with ViewCode to view specific parts of the file.\nHere's a structure of the file django/db/migrations/operations/models.py\n```\n\n      # ...\n     9\t\n    10\t\n    11\tdef _check_for_duplicates(arg_name, objs):\n          # ...\n    19\t\n    20\t\n    21\tclass ModelOperation(Operation):\n    22\t    def __init__(self, name):\n              # ...\n    24\t\n    25\t    @cached_property\n    26\t    def name_lower(self):\n              # ...\n    28\t\n    29\t    def references_model(self, name, app_label):\n              # ...\n    31\t\n    32\t    def reduce(self, operation, app_label):\n              # ...\n    36\t\n    37\t    def can_reduce_through(self, operation, app_label):\n              # ...\n    39\t\n    40\t\n    41\tclass CreateModel(ModelOperation):\n          # ...\n    45\t\n    46\t    def __init__(self, name, fields, options=None, bases=None, managers=None):\n              # ...\n    67\t\n    68\t    def deconstruct(self):\n              # ...\n    80\t\n    81\t    def state_forwards(self, app_label, state):\n              # ...\n    92\t\n    93\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n    97\t\n    98\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   102\t\n   103\t    def describe(self):\n              # ...\n   108\t\n   109\t    @property\n   110\t    def migration_name_fragment(self):\n              # ...\n   112\t\n   113\t    def references_model(self, name, app_label):\n              # ...\n   135\t\n   136\t    def reduce(self, operation, app_label):\n              # ...\n   307\t\n   308\t\n   309\tclass DeleteModel(ModelOperation):\n   311\t\n   312\t    def deconstruct(self):\n              # ...\n   317\t\n   318\t    def state_forwards(self, app_label, state):\n              # ...\n   320\t\n   321\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   325\t\n   326\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   330\t\n   331\t    def references_model(self, name, app_label):\n              # ...\n   335\t\n   336\t    def describe(self):\n              # ...\n   338\t\n   339\t    @property\n   340\t    def migration_name_fragment(self):\n              # ...\n   342\t\n   343\t\n   344\tclass RenameModel(ModelOperation):\n   346\t\n   347\t    def __init__(self, old_name, new_name):\n              # ...\n   351\t\n   352\t    @cached_property\n   353\t    def old_name_lower(self):\n              # ...\n   355\t\n   356\t    @cached_property\n   357\t    def new_name_lower(self):\n              # ...\n   359\t\n   360\t    def deconstruct(self):\n              # ...\n   366\t\n   367\t    def state_forwards(self, app_label, state):\n              # ...\n   369\t\n   370\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   426\t\n   427\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   441\t\n   442\t    def references_model(self, name, app_label):\n              # ...\n   446\t\n   447\t    def describe(self):\n              # ...\n   449\t\n   450\t    @property\n   451\t    def migration_name_fragment(self):\n              # ...\n   453\t\n   454\t    def reduce(self, operation, app_label):\n              # ...\n   470\t\n   471\t\n   472\tclass ModelOptionOperation(ModelOperation):\n   473\t    def reduce(self, operation, app_label):\n              # ...\n   480\t\n   481\t\n   482\tclass AlterModelTable(ModelOptionOperation):\n   484\t\n   485\t    def __init__(self, name, table):\n              # ...\n   488\t\n   489\t    def deconstruct(self):\n              # ...\n   495\t\n   496\t    def state_forwards(self, app_label, state):\n              # ...\n   498\t\n   499\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   518\t\n   519\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   521\t\n   522\t    def describe(self):\n              # ...\n   527\t\n   528\t    @property\n   529\t    def migration_name_fragment(self):\n              # ...\n   531\t\n   532\t\n   533\tclass AlterTogetherOptionOperation(ModelOptionOperation):\n          # ...\n   535\t\n   536\t    def __init__(self, name, option_value):\n              # ...\n   541\t\n   542\t    @cached_property\n   543\t    def option_value(self):\n              # ...\n   545\t\n   546\t    def deconstruct(self):\n              # ...\n   552\t\n   553\t    def state_forwards(self, app_label, state):\n              # ...\n   559\t\n   560\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   570\t\n   571\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   573\t\n   574\t    def references_field(self, model_name, name, app_label):\n              # ...\n   579\t\n   580\t    def describe(self):\n              # ...\n   586\t\n   587\t    @property\n   588\t    def migration_name_fragment(self):\n              # ...\n   590\t\n   591\t    def can_reduce_through(self, operation, app_label):\n              # ...\n   596\t\n   597\t\n   598\tclass AlterUniqueTogether(AlterTogetherOptionOperation):\n          # ...\n   605\t\n   606\t    def __init__(self, name, unique_together):\n              # ...\n   608\t\n   609\t\n   610\tclass AlterIndexTogether(AlterTogetherOptionOperation):\n          # ...\n   617\t\n   618\t    def __init__(self, name, index_together):\n              # ...\n   620\t\n   621\t\n   622\tclass AlterOrderWithRespectTo(ModelOptionOperation):\n          # ...\n   626\t\n   627\t    def __init__(self, name, order_with_respect_to):\n              # ...\n   630\t\n   631\t    def deconstruct(self):\n              # ...\n   637\t\n   638\t    def state_forwards(self, app_label, state):\n              # ...\n   644\t\n   645\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   670\t\n   671\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   673\t\n   674\t    def references_field(self, model_name, name, app_label):\n              # ...\n   678\t\n   679\t    def describe(self):\n              # ...\n   684\t\n   685\t    @property\n   686\t    def migration_name_fragment(self):\n              # ...\n   688\t\n   689\t\n   690\tclass AlterModelOptions(ModelOptionOperation):\n          # ...\n   711\t\n   712\t    def __init__(self, name, options):\n              # ...\n   715\t\n   716\t    def deconstruct(self):\n              # ...\n   722\t\n   723\t    def state_forwards(self, app_label, state):\n              # ...\n   730\t\n   731\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   733\t\n   734\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   736\t\n   737\t    def describe(self):\n              # ...\n   739\t\n   740\t    @property\n   741\t    def migration_name_fragment(self):\n              # ...\n   743\t\n   744\t\n   745\tclass AlterModelManagers(ModelOptionOperation):\n          # ...\n   749\t\n   750\t    def __init__(self, name, managers):\n              # ...\n   753\t\n   754\t    def deconstruct(self):\n              # ...\n   756\t\n   757\t    def state_forwards(self, app_label, state):\n              # ...\n   759\t\n   760\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   762\t\n   763\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   765\t\n   766\t    def describe(self):\n              # ...\n   768\t\n   769\t    @property\n   770\t    def migration_name_fragment(self):\n              # ...\n   772\t\n   773\t\n   774\tclass IndexOperation(Operation):\n          # ...\n   776\t\n   777\t    @cached_property\n   778\t    def model_name_lower(self):\n              # ...\n   780\t\n   781\t\n   782\tclass AddIndex(IndexOperation):\n   784\t\n   785\t    def __init__(self, model_name, index):\n              # ...\n   793\t\n   794\t    def state_forwards(self, app_label, state):\n              # ...\n   796\t\n   797\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   801\t\n   802\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   806\t\n   807\t    def deconstruct(self):\n              # ...\n   817\t\n   818\t    def describe(self):\n              # ...\n   830\t\n   831\t    @property\n   832\t    def migration_name_fragment(self):\n              # ...\n   834\t\n   835\t\n   836\tclass RemoveIndex(IndexOperation):\n   838\t\n   839\t    def __init__(self, model_name, name):\n              # ...\n   842\t\n   843\t    def state_forwards(self, app_label, state):\n              # ...\n   845\t\n   846\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   852\t\n   853\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   859\t\n   860\t    def deconstruct(self):\n              # ...\n   870\t\n   871\t    def describe(self):\n              # ...\n   873\t\n   874\t    @property\n   875\t    def migration_name_fragment(self):\n              # ...\n   877\t\n   878\t\n   879\tclass RenameIndex(IndexOperation):\n   881\t\n   882\t    def __init__(self, model_name, new_name, old_name=None, old_fields=None):\n              # ...\n   896\t\n   897\t    @cached_property\n   898\t    def old_name_lower(self):\n              # ...\n   900\t\n   901\t    @cached_property\n   902\t    def new_name_lower(self):\n              # ...\n   904\t\n   905\t    def deconstruct(self):\n              # ...\n   915\t\n   916\t    def state_forwards(self, app_label, state):\n              # ...\n   933\t\n   934\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   967\t\n   968\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   986\t\n   987\t    def describe(self):\n              # ...\n   996\t\n   997\t    @property\n   998\t    def migration_name_fragment(self):\n              # ...\n  1006\t\n  1007\t    def reduce(self, operation, app_label):\n              # ...\n  1023\t\n  1024\t\n  1025\tclass AddConstraint(IndexOperation):\n          # ...\n  1027\t\n  1028\t    def __init__(self, model_name, constraint):\n              # ...\n  1031\t\n  1032\t    def state_forwards(self, app_label, state):\n              # ...\n  1034\t\n  1035\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n  1039\t\n  1040\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n  1044\t\n  1045\t    def deconstruct(self):\n              # ...\n  1054\t\n  1055\t    def describe(self):\n              # ...\n  1060\t\n  1061\t    @property\n  1062\t    def migration_name_fragment(self):\n              # ...\n  1064\t\n  1065\t\n  1066\tclass RemoveConstraint(IndexOperation):\n          # ...\n  1068\t\n  1069\t    def __init__(self, model_name, name):\n              # ...\n  1072\t\n  1073\t    def state_forwards(self, app_label, state):\n              # ...\n  1075\t\n  1076\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n  1082\t\n  1083\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n  1089\t\n  1090\t    def deconstruct(self):\n              # ...\n  1099\t\n  1100\t    def describe(self):\n              # ...\n  1102\t\n  1103\t    @property\n  1104\t    def migration_name_fragment(self):\n              # ...\n```\n\n</observation>",
                  "type": "tool_result",
                  "cache_control": {
                    "type": "ephemeral"
                  }
                }
              ]
            }
          ],
          "response": {
            "id": "msg_01JGSJQHzJjJiLCT57BVjSr8",
            "content": [
              {
                "text": "<thoughts>\nLet me view the specific RenameIndex operation code to make the changes.\n</thoughts>",
                "type": "text"
              },
              {
                "id": "toolu_01LR2snrDHh4paU6gudT8BLY",
                "input": {
                  "files": [
                    {
                      "file_path": "django/db/migrations/operations/models.py",
                      "start_line": 879,
                      "end_line": 986,
                      "span_ids": []
                    }
                  ]
                },
                "name": "ViewCode",
                "type": "tool_use"
              }
            ],
            "model": "claude-3-5-sonnet-20241022",
            "role": "assistant",
            "stop_reason": "tool_use",
            "stop_sequence": null,
            "type": "message",
            "usage": {
              "cache_creation_input_tokens": 4028,
              "cache_read_input_tokens": 93448,
              "input_tokens": 1,
              "output_tokens": 120
            }
          },
          "usage": {
            "completion_cost": 0.013887,
            "completion_tokens": 120,
            "prompt_tokens": 4029,
            "cached_tokens": 93448
          }
        }
      },
      "possible_actions": [
        "SemanticSearch",
        "FindClass",
        "FindFunction",
        "FindCodeSnippet",
        "ViewCode",
        "ClaudeEditTool"
      ],
      "output": {
        "message": "Here's the contents of the requested code spans:\ndjango/db/migrations/operations/models.py\n```\n     1\tfrom django.db import models\n     2\tfrom django.db.migrations.operations.base import Operation\n     3\tfrom django.db.migrations.state import ModelState\n     4\tfrom django.db.migrations.utils import field_references, resolve_relation\n     5\tfrom django.db.models.options import normalize_together\n     6\tfrom django.utils.functional import cached_property\n     7\t\n     8\tfrom .fields import AddField, AlterField, FieldOperation, RemoveField, RenameField\n      # ...\n   877\t\n   878\t\n   879\tclass RenameIndex(IndexOperation):\n   880\t    \"\"\"Rename an index.\"\"\"\n   881\t\n   882\t    def __init__(self, model_name, new_name, old_name=None, old_fields=None):\n   883\t        if not old_name and not old_fields:\n   884\t            raise ValueError(\n   885\t                \"RenameIndex requires one of old_name and old_fields arguments to be \"\n   886\t                \"set.\"\n   887\t            )\n   888\t        if old_name and old_fields:\n   889\t            raise ValueError(\n   890\t                \"RenameIndex.old_name and old_fields are mutually exclusive.\"\n   891\t            )\n   892\t        self.model_name = model_name\n   893\t        self.new_name = new_name\n   894\t        self.old_name = old_name\n   895\t        self.old_fields = old_fields\n   896\t\n   897\t    @cached_property\n   898\t    def old_name_lower(self):\n   899\t        return self.old_name.lower()\n   900\t\n   901\t    @cached_property\n   902\t    def new_name_lower(self):\n   903\t        return self.new_name.lower()\n   904\t\n   905\t    def deconstruct(self):\n   906\t        kwargs = {\n   907\t            \"model_name\": self.model_name,\n   908\t            \"new_name\": self.new_name,\n   909\t        }\n   910\t        if self.old_name:\n   911\t            kwargs[\"old_name\"] = self.old_name\n   912\t        if self.old_fields:\n   913\t            kwargs[\"old_fields\"] = self.old_fields\n   914\t        return (self.__class__.__qualname__, [], kwargs)\n   915\t\n   916\t    def state_forwards(self, app_label, state):\n   917\t        if self.old_fields:\n   918\t            state.add_index(\n   919\t                app_label,\n   920\t                self.model_name_lower,\n   921\t                models.Index(fields=self.old_fields, name=self.new_name),\n   922\t            )\n   923\t            state.remove_model_options(\n   924\t                app_label,\n   925\t                self.model_name_lower,\n   926\t                AlterIndexTogether.option_name,\n   927\t                self.old_fields,\n   928\t            )\n   929\t        else:\n   930\t            state.rename_index(\n   931\t                app_label, self.model_name_lower, self.old_name, self.new_name\n   932\t            )\n   933\t\n   934\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n   935\t        model = to_state.apps.get_model(app_label, self.model_name)\n   936\t        if not self.allow_migrate_model(schema_editor.connection.alias, model):\n   937\t            return\n   938\t\n   939\t        if self.old_fields:\n   940\t            from_model = from_state.apps.get_model(app_label, self.model_name)\n   941\t            columns = [\n   942\t                from_model._meta.get_field(field).column for field in self.old_fields\n   943\t            ]\n   944\t            matching_index_name = schema_editor._constraint_names(\n   945\t                from_model, column_names=columns, index=True\n   946\t            )\n   947\t            if len(matching_index_name) != 1:\n   948\t                raise ValueError(\n   949\t                    \"Found wrong number (%s) of indexes for %s(%s).\"\n   950\t                    % (\n   951\t                        len(matching_index_name),\n   952\t                        from_model._meta.db_table,\n   953\t                        \", \".join(columns),\n   954\t                    )\n   955\t                )\n   956\t            old_index = models.Index(\n   957\t                fields=self.old_fields,\n   958\t                name=matching_index_name[0],\n   959\t            )\n   960\t        else:\n   961\t            from_model_state = from_state.models[app_label, self.model_name_lower]\n   962\t            old_index = from_model_state.get_index_by_name(self.old_name)\n   963\t\n   964\t        to_model_state = to_state.models[app_label, self.model_name_lower]\n   965\t        new_index = to_model_state.get_index_by_name(self.new_name)\n   966\t        schema_editor.rename_index(model, old_index, new_index)\n   967\t\n   968\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n   969\t        if self.old_fields:\n   970\t            # Backward operation with unnamed index is a no-op.\n   971\t            return\n   972\t\n   973\t        self.new_name_lower, self.old_name_lower = (\n   974\t            self.old_name_lower,\n   975\t            self.new_name_lower,\n   976\t        )\n   977\t        self.new_name, self.old_name = self.old_name, self.new_name\n   978\t\n   979\t        self.database_forwards(app_label, schema_editor, from_state, to_state)\n   980\t\n   981\t        self.new_name_lower, self.old_name_lower = (\n   982\t            self.old_name_lower,\n   983\t            self.new_name_lower,\n   984\t        )\n   985\t        self.new_name, self.old_name = self.old_name, self.new_name\n          # ...\n      # ...\n```\n",
        "summary": "Showed the following code spans:\n\nFile: tests/migrations/test_operations.py\n- Showing all code in file\n\nFile: django/db/migrations/operations/models.py\n- imports\n- RenameIndex\n- RenameIndex.__init__\n- RenameIndex.old_name_lower\n- RenameIndex.new_name_lower\n- RenameIndex.deconstruct\n- RenameIndex.state_forwards\n- RenameIndex.database_forwards\n- RenameIndex.database_backwards\n- RenameIndex.describe\n- RenameIndex.migration_name_fragment\n- RenameIndex.reduce\n\nFile: django/db/backends/base/schema.py\n- imports\n- BaseDatabaseSchemaEditor\n- BaseDatabaseSchemaEditor._rename_index_sql\n\nFile: django/db/migrations/state.py\n- imports\n- ProjectState\n- ProjectState.alter_model_options\n- ProjectState.remove_model_options\n",
        "terminal": false,
        "expect_correction": false,
        "properties": {
          "files": {
            "django/db/migrations/operations/models.py": {
              "new_span_ids": []
            }
          },
          "fail_reason": "no_spans_added",
          "retries": 1
        }
      },
      "parent_id": 4
    },
    {
      "node_id": 6,
      "action": {
        "scratch_pad": "Let me view the specific RenameIndex database_backwards method to make the changes.",
        "files": [
          {
            "file_path": "django/db/migrations/operations/models.py",
            "start_line": 968,
            "end_line": 986,
            "span_ids": []
          }
        ],
        "action_args_class": "moatless.actions.view_code.ViewCodeArgs"
      },
      "observation": {
        "message": "Here's the contents of the requested code spans:\ndjango/db/migrations/operations/models.py\n```\n     1\tfrom django.db import models\n     2\tfrom django.db.migrations.operations.base import Operation\n     3\tfrom django.db.migrations.state import ModelState\n     4\tfrom django.db.migrations.utils import field_references, resolve_relation\n     5\tfrom django.db.models.options import normalize_together\n     6\tfrom django.utils.functional import cached_property\n     7\t\n     8\tfrom .fields import AddField, AlterField, FieldOperation, RemoveField, RenameField\n      # ...\n   877\t\n   878\t\n   879\tclass RenameIndex(IndexOperation):\n   880\t    \"\"\"Rename an index.\"\"\"\n          # ...\n   967\t\n   968\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n   969\t        if self.old_fields:\n   970\t            # Backward operation with unnamed index is a no-op.\n   971\t            return\n   972\t\n   973\t        self.new_name_lower, self.old_name_lower = (\n   974\t            self.old_name_lower,\n   975\t            self.new_name_lower,\n   976\t        )\n   977\t        self.new_name, self.old_name = self.old_name, self.new_name\n   978\t\n   979\t        self.database_forwards(app_label, schema_editor, from_state, to_state)\n   980\t\n   981\t        self.new_name_lower, self.old_name_lower = (\n   982\t            self.old_name_lower,\n   983\t            self.new_name_lower,\n   984\t        )\n   985\t        self.new_name, self.old_name = self.old_name, self.new_name\n          # ...\n      # ...\n```\n",
        "summary": "Showed the following code spans:\n\nFile: tests/migrations/test_operations.py\n- Showing all code in file\n\nFile: django/db/migrations/operations/models.py\n- imports\n- RenameIndex\n- RenameIndex.__init__\n- RenameIndex.old_name_lower\n- RenameIndex.new_name_lower\n- RenameIndex.deconstruct\n- RenameIndex.state_forwards\n- RenameIndex.database_forwards\n- RenameIndex.database_backwards\n- RenameIndex.describe\n- RenameIndex.migration_name_fragment\n- RenameIndex.reduce\n\nFile: django/db/backends/base/schema.py\n- imports\n- BaseDatabaseSchemaEditor\n- BaseDatabaseSchemaEditor._rename_index_sql\n\nFile: django/db/migrations/state.py\n- imports\n- ProjectState\n- ProjectState.alter_model_options\n- ProjectState.remove_model_options\n",
        "terminal": false,
        "expect_correction": false,
        "properties": {
          "files": {
            "django/db/migrations/operations/models.py": {
              "new_span_ids": []
            }
          },
          "fail_reason": "no_spans_added",
          "retries": 1
        }
      },
      "file_context": {
        "max_tokens": 8000,
        "files": [
          {
            "file_path": "tests/migrations/test_operations.py",
            "spans": [
              {
                "span_id": "imports",
                "pinned": false
              },
              {
                "span_id": "OperationTests",
                "pinned": false
              },
              {
                "span_id": "OperationTests.test_rename_index_unnamed_index",
                "pinned": false
              }
            ],
            "show_all_spans": true,
            "patch": null
          },
          {
            "file_path": "django/db/migrations/operations/models.py",
            "spans": [
              {
                "span_id": "imports",
                "pinned": false
              },
              {
                "span_id": "RenameIndex",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.__init__",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.old_name_lower",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.new_name_lower",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.deconstruct",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.state_forwards",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.database_forwards",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.database_backwards",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.describe",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.migration_name_fragment",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.reduce",
                "pinned": false
              }
            ],
            "show_all_spans": false,
            "patch": null
          },
          {
            "file_path": "django/db/backends/base/schema.py",
            "spans": [
              {
                "span_id": "imports",
                "pinned": false
              },
              {
                "span_id": "BaseDatabaseSchemaEditor",
                "pinned": false
              },
              {
                "span_id": "BaseDatabaseSchemaEditor._rename_index_sql",
                "pinned": false
              }
            ],
            "show_all_spans": false,
            "patch": null
          },
          {
            "file_path": "django/db/migrations/state.py",
            "spans": [
              {
                "span_id": "imports",
                "pinned": false
              },
              {
                "span_id": "ProjectState",
                "pinned": false
              },
              {
                "span_id": "ProjectState.alter_model_options",
                "pinned": false
              },
              {
                "span_id": "ProjectState.remove_model_options",
                "pinned": false
              }
            ],
            "show_all_spans": false,
            "patch": null
          }
        ]
      },
      "completions": {
        "build_action": {
          "model": "claude-3-5-sonnet-20241022",
          "input": [
            {
              "role": "user",
              "content": "<task>\nRenameIndex() crashes when unnamed index is moving backward and forward.\nDescription\n\t\nRenameIndex() should restore the old auto-generated name when an unnamed index for unique_together is moving backward. Now re-applying RenameIndex() crashes. For example:\ntests/migrations/test_operations.py\ndiff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex cfd28b1b39..c0a55023bb 100644\n\t\t\t\t\t\n\t\t\t\t\t a\n\t\t\t\t \n\t\t\t\t\t\n\t\t\t\t\t b\n\t\t\t\t \n class OperationTests(OperationTestBase):\u00a0\n29882988\u00a0 \u00a0 \u00a0 \u00a0 with connection.schema_editor() as editor, self.assertNumQueries(0):\n29892989\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 operation.database_backwards(app_label, editor, new_state, project_state)\n29902990\u00a0 \u00a0 \u00a0 \u00a0 self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n\u00a02991\u00a0 \u00a0 \u00a0 \u00a0 # Re-apply renaming.\n\u00a02992\u00a0 \u00a0 \u00a0 \u00a0 with connection.schema_editor() as editor:\n\u00a02993\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 operation.database_forwards(app_label, editor, project_state, new_state)\n\u00a02994\u00a0 \u00a0 \u00a0 \u00a0 self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n29912995\u00a0 \u00a0 \u00a0 \u00a0 # Deconstruction.\n29922996\u00a0 \u00a0 \u00a0 \u00a0 definition = operation.deconstruct()\n29932997\u00a0 \u00a0 \u00a0 \u00a0 self.assertEqual(definition[0], \"RenameIndex\")\ncrashes on PostgreSQL:\ndjango.db.utils.ProgrammingError: relation \"new_pony_test_idx\" already exists\n\n</task>"
            },
            {
              "role": "assistant",
              "content": [
                {
                  "type": "text",
                  "text": "<thoughts>\n1. First, I need to understand the context better by:\n   - Looking at the test file to see the full test case\n   - Finding the RenameIndex operation implementation\n   - Understanding how index naming works in this context\n\n2. Let's start by viewing the test file to see the full test case context.\n</thoughts>"
                },
                {
                  "id": "call_8635dcc7",
                  "input": {
                    "files": [
                      {
                        "file_path": "tests/migrations/test_operations.py",
                        "start_line": null,
                        "end_line": null,
                        "span_ids": []
                      }
                    ]
                  },
                  "type": "tool_use",
                  "name": "ViewCode"
                }
              ]
            },
            {
              "role": "user",
              "content": [
                {
                  "tool_use_id": "call_8635dcc7",
                  "content": "<observation>\nHere's the contents of the requested code spans:\ntests/migrations/test_operations.py\n```\n     1\tfrom django.core.exceptions import FieldDoesNotExist\n     2\tfrom django.db import IntegrityError, connection, migrations, models, transaction\n     3\tfrom django.db.migrations.migration import Migration\n     4\tfrom django.db.migrations.operations.fields import FieldOperation\n     5\tfrom django.db.migrations.state import ModelState, ProjectState\n     6\tfrom django.db.models.functions import Abs\n     7\tfrom django.db.transaction import atomic\n     8\tfrom django.test import SimpleTestCase, override_settings, skipUnlessDBFeature\n     9\tfrom django.test.utils import CaptureQueriesContext\n    10\t\n    11\tfrom .models import FoodManager, FoodQuerySet, UnicodeModel\n    12\tfrom .test_base import OperationTestBase\n    13\t\n    14\t\n    15\tclass Mixin:\n    16\t    pass\n    17\t\n    18\t\n    19\tclass OperationTests(OperationTestBase):\n    20\t    \"\"\"\n    21\t    Tests running the operations and making sure they do what they say they do.\n    22\t    Each test looks at their state changing, and then their database operation -\n    23\t    both forwards and backwards.\n    24\t    \"\"\"\n    25\t\n    26\t    def test_create_model(self):\n    27\t        \"\"\"\n    28\t        Tests the CreateModel operation.\n    29\t        Most other tests use this operation as part of setup, so check failures\n    30\t        here first.\n    31\t        \"\"\"\n    32\t        operation = migrations.CreateModel(\n    33\t            \"Pony\",\n    34\t            [\n    35\t                (\"id\", models.AutoField(primary_key=True)),\n    36\t                (\"pink\", models.IntegerField(default=1)),\n    37\t            ],\n    38\t        )\n    39\t        self.assertEqual(operation.describe(), \"Create model Pony\")\n    40\t        self.assertEqual(operation.migration_name_fragment, \"pony\")\n    41\t        # Test the state alteration\n    42\t        project_state = ProjectState()\n    43\t        new_state = project_state.clone()\n    44\t        operation.state_forwards(\"test_crmo\", new_state)\n    45\t        self.assertEqual(new_state.models[\"test_crmo\", \"pony\"].name, \"Pony\")\n    46\t        self.assertEqual(len(new_state.models[\"test_crmo\", \"pony\"].fields), 2)\n    47\t        # Test the database alteration\n    48\t        self.assertTableNotExists(\"test_crmo_pony\")\n    49\t        with connection.schema_editor() as editor:\n    50\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n    51\t        self.assertTableExists(\"test_crmo_pony\")\n    52\t        # And test reversal\n    53\t        with connection.schema_editor() as editor:\n    54\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n    55\t        self.assertTableNotExists(\"test_crmo_pony\")\n    56\t        # And deconstruction\n    57\t        definition = operation.deconstruct()\n    58\t        self.assertEqual(definition[0], \"CreateModel\")\n    59\t        self.assertEqual(definition[1], [])\n    60\t        self.assertEqual(sorted(definition[2]), [\"fields\", \"name\"])\n    61\t        # And default manager not in set\n    62\t        operation = migrations.CreateModel(\n    63\t            \"Foo\", fields=[], managers=[(\"objects\", models.Manager())]\n    64\t        )\n    65\t        definition = operation.deconstruct()\n    66\t        self.assertNotIn(\"managers\", definition[2])\n    67\t\n    68\t    def test_create_model_with_duplicate_field_name(self):\n    69\t        with self.assertRaisesMessage(\n    70\t            ValueError, \"Found duplicate value pink in CreateModel fields argument.\"\n    71\t        ):\n    72\t            migrations.CreateModel(\n    73\t                \"Pony\",\n    74\t                [\n    75\t                    (\"id\", models.AutoField(primary_key=True)),\n    76\t                    (\"pink\", models.TextField()),\n    77\t                    (\"pink\", models.IntegerField(default=1)),\n    78\t                ],\n    79\t            )\n    80\t\n    81\t    def test_create_model_with_duplicate_base(self):\n    82\t        message = \"Found duplicate value test_crmo.pony in CreateModel bases argument.\"\n    83\t        with self.assertRaisesMessage(ValueError, message):\n    84\t            migrations.CreateModel(\n    85\t                \"Pony\",\n    86\t                fields=[],\n    87\t                bases=(\n    88\t                    \"test_crmo.Pony\",\n    89\t                    \"test_crmo.Pony\",\n    90\t                ),\n    91\t            )\n    92\t        with self.assertRaisesMessage(ValueError, message):\n    93\t            migrations.CreateModel(\n    94\t                \"Pony\",\n    95\t                fields=[],\n    96\t                bases=(\n    97\t                    \"test_crmo.Pony\",\n    98\t                    \"test_crmo.pony\",\n    99\t                ),\n   100\t            )\n   101\t        message = (\n   102\t            \"Found duplicate value migrations.unicodemodel in CreateModel bases \"\n   103\t            \"argument.\"\n   104\t        )\n   105\t        with self.assertRaisesMessage(ValueError, message):\n   106\t            migrations.CreateModel(\n   107\t                \"Pony\",\n   108\t                fields=[],\n   109\t                bases=(\n   110\t                    UnicodeModel,\n   111\t                    UnicodeModel,\n   112\t                ),\n   113\t            )\n   114\t        with self.assertRaisesMessage(ValueError, message):\n   115\t            migrations.CreateModel(\n   116\t                \"Pony\",\n   117\t                fields=[],\n   118\t                bases=(\n   119\t                    UnicodeModel,\n   120\t                    \"migrations.unicodemodel\",\n   121\t                ),\n   122\t            )\n   123\t        with self.assertRaisesMessage(ValueError, message):\n   124\t            migrations.CreateModel(\n   125\t                \"Pony\",\n   126\t                fields=[],\n   127\t                bases=(\n   128\t                    UnicodeModel,\n   129\t                    \"migrations.UnicodeModel\",\n   130\t                ),\n   131\t            )\n   132\t        message = (\n   133\t            \"Found duplicate value <class 'django.db.models.base.Model'> in \"\n   134\t            \"CreateModel bases argument.\"\n   135\t        )\n   136\t        with self.assertRaisesMessage(ValueError, message):\n   137\t            migrations.CreateModel(\n   138\t                \"Pony\",\n   139\t                fields=[],\n   140\t                bases=(\n   141\t                    models.Model,\n   142\t                    models.Model,\n   143\t                ),\n   144\t            )\n   145\t        message = (\n   146\t            \"Found duplicate value <class 'migrations.test_operations.Mixin'> in \"\n   147\t            \"CreateModel bases argument.\"\n   148\t        )\n   149\t        with self.assertRaisesMessage(ValueError, message):\n   150\t            migrations.CreateModel(\n   151\t                \"Pony\",\n   152\t                fields=[],\n   153\t                bases=(\n   154\t                    Mixin,\n   155\t                    Mixin,\n   156\t                ),\n   157\t            )\n   158\t\n   159\t    def test_create_model_with_duplicate_manager_name(self):\n   160\t        with self.assertRaisesMessage(\n   161\t            ValueError,\n   162\t            \"Found duplicate value objects in CreateModel managers argument.\",\n   163\t        ):\n   164\t            migrations.CreateModel(\n   165\t                \"Pony\",\n   166\t                fields=[],\n   167\t                managers=[\n   168\t                    (\"objects\", models.Manager()),\n   169\t                    (\"objects\", models.Manager()),\n   170\t                ],\n   171\t            )\n   172\t\n   173\t    def test_create_model_with_unique_after(self):\n   174\t        \"\"\"\n   175\t        Tests the CreateModel operation directly followed by an\n   176\t        AlterUniqueTogether (bug #22844 - sqlite remake issues)\n   177\t        \"\"\"\n   178\t        operation1 = migrations.CreateModel(\n   179\t            \"Pony\",\n   180\t            [\n   181\t                (\"id\", models.AutoField(primary_key=True)),\n   182\t                (\"pink\", models.IntegerField(default=1)),\n   183\t            ],\n   184\t        )\n   185\t        operation2 = migrations.CreateModel(\n   186\t            \"Rider\",\n   187\t            [\n   188\t                (\"id\", models.AutoField(primary_key=True)),\n   189\t                (\"number\", models.IntegerField(default=1)),\n   190\t                (\"pony\", models.ForeignKey(\"test_crmoua.Pony\", models.CASCADE)),\n   191\t            ],\n   192\t        )\n   193\t        operation3 = migrations.AlterUniqueTogether(\n   194\t            \"Rider\",\n   195\t            [\n   196\t                (\"number\", \"pony\"),\n   197\t            ],\n   198\t        )\n   199\t        # Test the database alteration\n   200\t        project_state = ProjectState()\n   201\t        self.assertTableNotExists(\"test_crmoua_pony\")\n   202\t        self.assertTableNotExists(\"test_crmoua_rider\")\n   203\t        with connection.schema_editor() as editor:\n   204\t            new_state = project_state.clone()\n   205\t            operation1.state_forwards(\"test_crmoua\", new_state)\n   206\t            operation1.database_forwards(\n   207\t                \"test_crmoua\", editor, project_state, new_state\n   208\t            )\n   209\t            project_state, new_state = new_state, new_state.clone()\n   210\t            operation2.state_forwards(\"test_crmoua\", new_state)\n   211\t            operation2.database_forwards(\n   212\t                \"test_crmoua\", editor, project_state, new_state\n   213\t            )\n   214\t            project_state, new_state = new_state, new_state.clone()\n   215\t            operation3.state_forwards(\"test_crmoua\", new_state)\n   216\t            operation3.database_forwards(\n   217\t                \"test_crmoua\", editor, project_state, new_state\n   218\t            )\n   219\t        self.assertTableExists(\"test_crmoua_pony\")\n   220\t        self.assertTableExists(\"test_crmoua_rider\")\n   221\t\n   222\t    def test_create_model_m2m(self):\n   223\t        \"\"\"\n   224\t        Test the creation of a model with a ManyToMany field and the\n   225\t        auto-created \"through\" model.\n   226\t        \"\"\"\n   227\t        project_state = self.set_up_test_model(\"test_crmomm\")\n   228\t        operation = migrations.CreateModel(\n   229\t            \"Stable\",\n   230\t            [\n   231\t                (\"id\", models.AutoField(primary_key=True)),\n   232\t                (\"ponies\", models.ManyToManyField(\"Pony\", related_name=\"stables\")),\n   233\t            ],\n   234\t        )\n   235\t        # Test the state alteration\n   236\t        new_state = project_state.clone()\n   237\t        operation.state_forwards(\"test_crmomm\", new_state)\n   238\t        # Test the database alteration\n   239\t        self.assertTableNotExists(\"test_crmomm_stable_ponies\")\n   240\t        with connection.schema_editor() as editor:\n   241\t            operation.database_forwards(\"test_crmomm\", editor, project_state, new_state)\n   242\t        self.assertTableExists(\"test_crmomm_stable\")\n   243\t        self.assertTableExists(\"test_crmomm_stable_ponies\")\n   244\t        self.assertColumnNotExists(\"test_crmomm_stable\", \"ponies\")\n   245\t        # Make sure the M2M field actually works\n   246\t        with atomic():\n   247\t            Pony = new_state.apps.get_model(\"test_crmomm\", \"Pony\")\n   248\t            Stable = new_state.apps.get_model(\"test_crmomm\", \"Stable\")\n   249\t            stable = Stable.objects.create()\n   250\t            p1 = Pony.objects.create(pink=False, weight=4.55)\n   251\t            p2 = Pony.objects.create(pink=True, weight=5.43)\n   252\t            stable.ponies.add(p1, p2)\n   253\t            self.assertEqual(stable.ponies.count(), 2)\n   254\t            stable.ponies.all().delete()\n   255\t        # And test reversal\n   256\t        with connection.schema_editor() as editor:\n   257\t            operation.database_backwards(\n   258\t                \"test_crmomm\", editor, new_state, project_state\n   259\t            )\n   260\t        self.assertTableNotExists(\"test_crmomm_stable\")\n   261\t        self.assertTableNotExists(\"test_crmomm_stable_ponies\")\n   262\t\n   263\t    @skipUnlessDBFeature(\"supports_collation_on_charfield\", \"supports_foreign_keys\")\n   264\t    def test_create_fk_models_to_pk_field_db_collation(self):\n   265\t        \"\"\"Creation of models with a FK to a PK with db_collation.\"\"\"\n   266\t        collation = connection.features.test_collations.get(\"non_default\")\n   267\t        if not collation:\n   268\t            self.skipTest(\"Language collations are not supported.\")\n   269\t\n   270\t        app_label = \"test_cfkmtopkfdbc\"\n   271\t        operations = [\n   272\t            migrations.CreateModel(\n   273\t                \"Pony\",\n   274\t                [\n   275\t                    (\n   276\t                        \"id\",\n   277\t                        models.CharField(\n   278\t                            primary_key=True,\n   279\t                            max_length=10,\n   280\t                            db_collation=collation,\n   281\t                        ),\n   282\t                    ),\n   283\t                ],\n   284\t            )\n   285\t        ]\n   286\t        project_state = self.apply_operations(app_label, ProjectState(), operations)\n   287\t        # ForeignKey.\n   288\t        new_state = project_state.clone()\n   289\t        operation = migrations.CreateModel(\n   290\t            \"Rider\",\n   291\t            [\n   292\t                (\"id\", models.AutoField(primary_key=True)),\n   293\t                (\"pony\", models.ForeignKey(\"Pony\", models.CASCADE)),\n   294\t            ],\n   295\t        )\n   296\t        operation.state_forwards(app_label, new_state)\n   297\t        with connection.schema_editor() as editor:\n   298\t            operation.database_forwards(app_label, editor, project_state, new_state)\n   299\t        self.assertColumnCollation(f\"{app_label}_rider\", \"pony_id\", collation)\n   300\t        # Reversal.\n   301\t        with connection.schema_editor() as editor:\n   302\t            operation.database_backwards(app_label, editor, new_state, project_state)\n   303\t        # OneToOneField.\n   304\t        new_state = project_state.clone()\n   305\t        operation = migrations.CreateModel(\n   306\t            \"ShetlandPony\",\n   307\t            [\n   308\t                (\n   309\t                    \"pony\",\n   310\t                    models.OneToOneField(\"Pony\", models.CASCADE, primary_key=True),\n   311\t                ),\n   312\t                (\"cuteness\", models.IntegerField(default=1)),\n   313\t            ],\n   314\t        )\n   315\t        operation.state_forwards(app_label, new_state)\n   316\t        with connection.schema_editor() as editor:\n   317\t            operation.database_forwards(app_label, editor, project_state, new_state)\n   318\t        self.assertColumnCollation(f\"{app_label}_shetlandpony\", \"pony_id\", collation)\n   319\t        # Reversal.\n   320\t        with connection.schema_editor() as editor:\n   321\t            operation.database_backwards(app_label, editor, new_state, project_state)\n   322\t\n   323\t    def test_create_model_inheritance(self):\n   324\t        \"\"\"\n   325\t        Tests the CreateModel operation on a multi-table inheritance setup.\n   326\t        \"\"\"\n   327\t        project_state = self.set_up_test_model(\"test_crmoih\")\n   328\t        # Test the state alteration\n   329\t        operation = migrations.CreateModel(\n   330\t            \"ShetlandPony\",\n   331\t            [\n   332\t                (\n   333\t                    \"pony_ptr\",\n   334\t                    models.OneToOneField(\n   335\t                        \"test_crmoih.Pony\",\n   336\t                        models.CASCADE,\n   337\t                        auto_created=True,\n   338\t                        primary_key=True,\n   339\t                        to_field=\"id\",\n   340\t                        serialize=False,\n   341\t                    ),\n   342\t                ),\n   343\t                (\"cuteness\", models.IntegerField(default=1)),\n   344\t            ],\n   345\t        )\n   346\t        new_state = project_state.clone()\n   347\t        operation.state_forwards(\"test_crmoih\", new_state)\n   348\t        self.assertIn((\"test_crmoih\", \"shetlandpony\"), new_state.models)\n   349\t        # Test the database alteration\n   350\t        self.assertTableNotExists(\"test_crmoih_shetlandpony\")\n   351\t        with connection.schema_editor() as editor:\n   352\t            operation.database_forwards(\"test_crmoih\", editor, project_state, new_state)\n   353\t        self.assertTableExists(\"test_crmoih_shetlandpony\")\n   354\t        # And test reversal\n   355\t        with connection.schema_editor() as editor:\n   356\t            operation.database_backwards(\n   357\t                \"test_crmoih\", editor, new_state, project_state\n   358\t            )\n   359\t        self.assertTableNotExists(\"test_crmoih_shetlandpony\")\n   360\t\n   361\t    def test_create_proxy_model(self):\n   362\t        \"\"\"\n   363\t        CreateModel ignores proxy models.\n   364\t        \"\"\"\n   365\t        project_state = self.set_up_test_model(\"test_crprmo\")\n   366\t        # Test the state alteration\n   367\t        operation = migrations.CreateModel(\n   368\t            \"ProxyPony\",\n   369\t            [],\n   370\t            options={\"proxy\": True},\n   371\t            bases=(\"test_crprmo.Pony\",),\n   372\t        )\n   373\t        self.assertEqual(operation.describe(), \"Create proxy model ProxyPony\")\n   374\t        new_state = project_state.clone()\n   375\t        operation.state_forwards(\"test_crprmo\", new_state)\n   376\t        self.assertIn((\"test_crprmo\", \"proxypony\"), new_state.models)\n   377\t        # Test the database alteration\n   378\t        self.assertTableNotExists(\"test_crprmo_proxypony\")\n   379\t        self.assertTableExists(\"test_crprmo_pony\")\n   380\t        with connection.schema_editor() as editor:\n   381\t            operation.database_forwards(\"test_crprmo\", editor, project_state, new_state)\n   382\t        self.assertTableNotExists(\"test_crprmo_proxypony\")\n   383\t        self.assertTableExists(\"test_crprmo_pony\")\n   384\t        # And test reversal\n   385\t        with connection.schema_editor() as editor:\n   386\t            operation.database_backwards(\n   387\t                \"test_crprmo\", editor, new_state, project_state\n   388\t            )\n   389\t        self.assertTableNotExists(\"test_crprmo_proxypony\")\n   390\t        self.assertTableExists(\"test_crprmo_pony\")\n   391\t        # And deconstruction\n   392\t        definition = operation.deconstruct()\n   393\t        self.assertEqual(definition[0], \"CreateModel\")\n   394\t        self.assertEqual(definition[1], [])\n   395\t        self.assertEqual(sorted(definition[2]), [\"bases\", \"fields\", \"name\", \"options\"])\n   396\t\n   397\t    def test_create_unmanaged_model(self):\n   398\t        \"\"\"\n   399\t        CreateModel ignores unmanaged models.\n   400\t        \"\"\"\n   401\t        project_state = self.set_up_test_model(\"test_crummo\")\n   402\t        # Test the state alteration\n   403\t        operation = migrations.CreateModel(\n   404\t            \"UnmanagedPony\",\n   405\t            [],\n   406\t            options={\"proxy\": True},\n   407\t            bases=(\"test_crummo.Pony\",),\n   408\t        )\n   409\t        self.assertEqual(operation.describe(), \"Create proxy model UnmanagedPony\")\n   410\t        new_state = project_state.clone()\n   411\t        operation.state_forwards(\"test_crummo\", new_state)\n   412\t        self.assertIn((\"test_crummo\", \"unmanagedpony\"), new_state.models)\n   413\t        # Test the database alteration\n   414\t        self.assertTableNotExists(\"test_crummo_unmanagedpony\")\n   415\t        self.assertTableExists(\"test_crummo_pony\")\n   416\t        with connection.schema_editor() as editor:\n   417\t            operation.database_forwards(\"test_crummo\", editor, project_state, new_state)\n   418\t        self.assertTableNotExists(\"test_crummo_unmanagedpony\")\n   419\t        self.assertTableExists(\"test_crummo_pony\")\n   420\t        # And test reversal\n   421\t        with connection.schema_editor() as editor:\n   422\t            operation.database_backwards(\n   423\t                \"test_crummo\", editor, new_state, project_state\n   424\t            )\n   425\t        self.assertTableNotExists(\"test_crummo_unmanagedpony\")\n   426\t        self.assertTableExists(\"test_crummo_pony\")\n   427\t\n   428\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n   429\t    def test_create_model_with_constraint(self):\n   430\t        where = models.Q(pink__gt=2)\n   431\t        check_constraint = models.CheckConstraint(\n   432\t            check=where, name=\"test_constraint_pony_pink_gt_2\"\n   433\t        )\n   434\t        operation = migrations.CreateModel(\n   435\t            \"Pony\",\n   436\t            [\n   437\t                (\"id\", models.AutoField(primary_key=True)),\n   438\t                (\"pink\", models.IntegerField(default=3)),\n   439\t            ],\n   440\t            options={\"constraints\": [check_constraint]},\n   441\t        )\n   442\t\n   443\t        # Test the state alteration\n   444\t        project_state = ProjectState()\n   445\t        new_state = project_state.clone()\n   446\t        operation.state_forwards(\"test_crmo\", new_state)\n   447\t        self.assertEqual(\n   448\t            len(new_state.models[\"test_crmo\", \"pony\"].options[\"constraints\"]), 1\n   449\t        )\n   450\t\n   451\t        # Test database alteration\n   452\t        self.assertTableNotExists(\"test_crmo_pony\")\n   453\t        with connection.schema_editor() as editor:\n   454\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n   455\t        self.assertTableExists(\"test_crmo_pony\")\n   456\t        with connection.cursor() as cursor:\n   457\t            with self.assertRaises(IntegrityError):\n   458\t                cursor.execute(\"INSERT INTO test_crmo_pony (id, pink) VALUES (1, 1)\")\n   459\t\n   460\t        # Test reversal\n   461\t        with connection.schema_editor() as editor:\n   462\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n   463\t        self.assertTableNotExists(\"test_crmo_pony\")\n   464\t\n   465\t        # Test deconstruction\n   466\t        definition = operation.deconstruct()\n   467\t        self.assertEqual(definition[0], \"CreateModel\")\n   468\t        self.assertEqual(definition[1], [])\n   469\t        self.assertEqual(definition[2][\"options\"][\"constraints\"], [check_constraint])\n   470\t\n   471\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n   472\t    def test_create_model_with_boolean_expression_in_check_constraint(self):\n   473\t        app_label = \"test_crmobechc\"\n   474\t        rawsql_constraint = models.CheckConstraint(\n   475\t            check=models.expressions.RawSQL(\n   476\t                \"price < %s\", (1000,), output_field=models.BooleanField()\n   477\t            ),\n   478\t            name=f\"{app_label}_price_lt_1000_raw\",\n   479\t        )\n   480\t        wrapper_constraint = models.CheckConstraint(\n   481\t            check=models.expressions.ExpressionWrapper(\n   482\t                models.Q(price__gt=500) | models.Q(price__lt=500),\n   483\t                output_field=models.BooleanField(),\n   484\t            ),\n   485\t            name=f\"{app_label}_price_neq_500_wrap\",\n   486\t        )\n   487\t        operation = migrations.CreateModel(\n   488\t            \"Product\",\n   489\t            [\n   490\t                (\"id\", models.AutoField(primary_key=True)),\n   491\t                (\"price\", models.IntegerField(null=True)),\n   492\t            ],\n   493\t            options={\"constraints\": [rawsql_constraint, wrapper_constraint]},\n   494\t        )\n   495\t\n   496\t        project_state = ProjectState()\n   497\t        new_state = project_state.clone()\n   498\t        operation.state_forwards(app_label, new_state)\n   499\t        # Add table.\n   500\t        self.assertTableNotExists(app_label)\n   501\t        with connection.schema_editor() as editor:\n   502\t            operation.database_forwards(app_label, editor, project_state, new_state)\n   503\t        self.assertTableExists(f\"{app_label}_product\")\n   504\t        insert_sql = f\"INSERT INTO {app_label}_product (id, price) VALUES (%d, %d)\"\n   505\t        with connection.cursor() as cursor:\n   506\t            with self.assertRaises(IntegrityError):\n   507\t                cursor.execute(insert_sql % (1, 1000))\n   508\t            cursor.execute(insert_sql % (1, 999))\n   509\t            with self.assertRaises(IntegrityError):\n   510\t                cursor.execute(insert_sql % (2, 500))\n   511\t            cursor.execute(insert_sql % (2, 499))\n   512\t\n   513\t    def test_create_model_with_partial_unique_constraint(self):\n   514\t        partial_unique_constraint = models.UniqueConstraint(\n   515\t            fields=[\"pink\"],\n   516\t            condition=models.Q(weight__gt=5),\n   517\t            name=\"test_constraint_pony_pink_for_weight_gt_5_uniq\",\n   518\t        )\n   519\t        operation = migrations.CreateModel(\n   520\t            \"Pony\",\n   521\t            [\n   522\t                (\"id\", models.AutoField(primary_key=True)),\n   523\t                (\"pink\", models.IntegerField(default=3)),\n   524\t                (\"weight\", models.FloatField()),\n   525\t            ],\n   526\t            options={\"constraints\": [partial_unique_constraint]},\n   527\t        )\n   528\t        # Test the state alteration\n   529\t        project_state = ProjectState()\n   530\t        new_state = project_state.clone()\n   531\t        operation.state_forwards(\"test_crmo\", new_state)\n   532\t        self.assertEqual(\n   533\t            len(new_state.models[\"test_crmo\", \"pony\"].options[\"constraints\"]), 1\n   534\t        )\n   535\t        # Test database alteration\n   536\t        self.assertTableNotExists(\"test_crmo_pony\")\n   537\t        with connection.schema_editor() as editor:\n   538\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n   539\t        self.assertTableExists(\"test_crmo_pony\")\n   540\t        # Test constraint works\n   541\t        Pony = new_state.apps.get_model(\"test_crmo\", \"Pony\")\n   542\t        Pony.objects.create(pink=1, weight=4.0)\n   543\t        Pony.objects.create(pink=1, weight=4.0)\n   544\t        Pony.objects.create(pink=1, weight=6.0)\n   545\t        if connection.features.supports_partial_indexes:\n   546\t            with self.assertRaises(IntegrityError):\n   547\t                Pony.objects.create(pink=1, weight=7.0)\n   548\t        else:\n   549\t            Pony.objects.create(pink=1, weight=7.0)\n   550\t        # Test reversal\n   551\t        with connection.schema_editor() as editor:\n   552\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n   553\t        self.assertTableNotExists(\"test_crmo_pony\")\n   554\t        # Test deconstruction\n   555\t        definition = operation.deconstruct()\n   556\t        self.assertEqual(definition[0], \"CreateModel\")\n   557\t        self.assertEqual(definition[1], [])\n   558\t        self.assertEqual(\n   559\t            definition[2][\"options\"][\"constraints\"], [partial_unique_constraint]\n   560\t        )\n   561\t\n   562\t    def test_create_model_with_deferred_unique_constraint(self):\n   563\t        deferred_unique_constraint = models.UniqueConstraint(\n   564\t            fields=[\"pink\"],\n   565\t            name=\"deferrable_pink_constraint\",\n   566\t            deferrable=models.Deferrable.DEFERRED,\n   567\t        )\n   568\t        operation = migrations.CreateModel(\n   569\t            \"Pony\",\n   570\t            [\n   571\t                (\"id\", models.AutoField(primary_key=True)),\n   572\t                (\"pink\", models.IntegerField(default=3)),\n   573\t            ],\n   574\t            options={\"constraints\": [deferred_unique_constraint]},\n   575\t        )\n   576\t        project_state = ProjectState()\n   577\t        new_state = project_state.clone()\n   578\t        operation.state_forwards(\"test_crmo\", new_state)\n   579\t        self.assertEqual(\n   580\t            len(new_state.models[\"test_crmo\", \"pony\"].options[\"constraints\"]), 1\n   581\t        )\n   582\t        self.assertTableNotExists(\"test_crmo_pony\")\n   583\t        # Create table.\n   584\t        with connection.schema_editor() as editor:\n   585\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n   586\t        self.assertTableExists(\"test_crmo_pony\")\n   587\t        Pony = new_state.apps.get_model(\"test_crmo\", \"Pony\")\n   588\t        Pony.objects.create(pink=1)\n   589\t        if connection.features.supports_deferrable_unique_constraints:\n   590\t            # Unique constraint is deferred.\n   591\t            with transaction.atomic():\n   592\t                obj = Pony.objects.create(pink=1)\n   593\t                obj.pink = 2\n   594\t                obj.save()\n   595\t            # Constraint behavior can be changed with SET CONSTRAINTS.\n   596\t            with self.assertRaises(IntegrityError):\n   597\t                with transaction.atomic(), connection.cursor() as cursor:\n   598\t                    quoted_name = connection.ops.quote_name(\n   599\t                        deferred_unique_constraint.name\n   600\t                    )\n   601\t                    cursor.execute(\"SET CONSTRAINTS %s IMMEDIATE\" % quoted_name)\n   602\t                    obj = Pony.objects.create(pink=1)\n   603\t                    obj.pink = 3\n   604\t                    obj.save()\n   605\t        else:\n   606\t            Pony.objects.create(pink=1)\n   607\t        # Reversal.\n   608\t        with connection.schema_editor() as editor:\n   609\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n   610\t        self.assertTableNotExists(\"test_crmo_pony\")\n   611\t        # Deconstruction.\n   612\t        definition = operation.deconstruct()\n   613\t        self.assertEqual(definition[0], \"CreateModel\")\n   614\t        self.assertEqual(definition[1], [])\n   615\t        self.assertEqual(\n   616\t            definition[2][\"options\"][\"constraints\"],\n   617\t            [deferred_unique_constraint],\n   618\t        )\n   619\t\n   620\t    @skipUnlessDBFeature(\"supports_covering_indexes\")\n   621\t    def test_create_model_with_covering_unique_constraint(self):\n   622\t        covering_unique_constraint = models.UniqueConstraint(\n   623\t            fields=[\"pink\"],\n   624\t            include=[\"weight\"],\n   625\t            name=\"test_constraint_pony_pink_covering_weight\",\n   626\t        )\n   627\t        operation = migrations.CreateModel(\n   628\t            \"Pony\",\n   629\t            [\n   630\t                (\"id\", models.AutoField(primary_key=True)),\n   631\t                (\"pink\", models.IntegerField(default=3)),\n   632\t                (\"weight\", models.FloatField()),\n   633\t            ],\n   634\t            options={\"constraints\": [covering_unique_constraint]},\n   635\t        )\n   636\t        project_state = ProjectState()\n   637\t        new_state = project_state.clone()\n   638\t        operation.state_forwards(\"test_crmo\", new_state)\n   639\t        self.assertEqual(\n   640\t            len(new_state.models[\"test_crmo\", \"pony\"].options[\"constraints\"]), 1\n   641\t        )\n   642\t        self.assertTableNotExists(\"test_crmo_pony\")\n   643\t        # Create table.\n   644\t        with connection.schema_editor() as editor:\n   645\t            operation.database_forwards(\"test_crmo\", editor, project_state, new_state)\n   646\t        self.assertTableExists(\"test_crmo_pony\")\n   647\t        Pony = new_state.apps.get_model(\"test_crmo\", \"Pony\")\n   648\t        Pony.objects.create(pink=1, weight=4.0)\n   649\t        with self.assertRaises(IntegrityError):\n   650\t            Pony.objects.create(pink=1, weight=7.0)\n   651\t        # Reversal.\n   652\t        with connection.schema_editor() as editor:\n   653\t            operation.database_backwards(\"test_crmo\", editor, new_state, project_state)\n   654\t        self.assertTableNotExists(\"test_crmo_pony\")\n   655\t        # Deconstruction.\n   656\t        definition = operation.deconstruct()\n   657\t        self.assertEqual(definition[0], \"CreateModel\")\n   658\t        self.assertEqual(definition[1], [])\n   659\t        self.assertEqual(\n   660\t            definition[2][\"options\"][\"constraints\"],\n   661\t            [covering_unique_constraint],\n   662\t        )\n   663\t\n   664\t    def test_create_model_managers(self):\n   665\t        \"\"\"\n   666\t        The managers on a model are set.\n   667\t        \"\"\"\n   668\t        project_state = self.set_up_test_model(\"test_cmoma\")\n   669\t        # Test the state alteration\n   670\t        operation = migrations.CreateModel(\n   671\t            \"Food\",\n   672\t            fields=[\n   673\t                (\"id\", models.AutoField(primary_key=True)),\n   674\t            ],\n   675\t            managers=[\n   676\t                (\"food_qs\", FoodQuerySet.as_manager()),\n   677\t                (\"food_mgr\", FoodManager(\"a\", \"b\")),\n   678\t                (\"food_mgr_kwargs\", FoodManager(\"x\", \"y\", 3, 4)),\n   679\t            ],\n   680\t        )\n   681\t        self.assertEqual(operation.describe(), \"Create model Food\")\n   682\t        new_state = project_state.clone()\n   683\t        operation.state_forwards(\"test_cmoma\", new_state)\n   684\t        self.assertIn((\"test_cmoma\", \"food\"), new_state.models)\n   685\t        managers = new_state.models[\"test_cmoma\", \"food\"].managers\n   686\t        self.assertEqual(managers[0][0], \"food_qs\")\n   687\t        self.assertIsInstance(managers[0][1], models.Manager)\n   688\t        self.assertEqual(managers[1][0], \"food_mgr\")\n   689\t        self.assertIsInstance(managers[1][1], FoodManager)\n   690\t        self.assertEqual(managers[1][1].args, (\"a\", \"b\", 1, 2))\n   691\t        self.assertEqual(managers[2][0], \"food_mgr_kwargs\")\n   692\t        self.assertIsInstance(managers[2][1], FoodManager)\n   693\t        self.assertEqual(managers[2][1].args, (\"x\", \"y\", 3, 4))\n   694\t\n   695\t    def test_delete_model(self):\n   696\t        \"\"\"\n   697\t        Tests the DeleteModel operation.\n   698\t        \"\"\"\n   699\t        project_state = self.set_up_test_model(\"test_dlmo\")\n   700\t        # Test the state alteration\n   701\t        operation = migrations.DeleteModel(\"Pony\")\n   702\t        self.assertEqual(operation.describe(), \"Delete model Pony\")\n   703\t        self.assertEqual(operation.migration_name_fragment, \"delete_pony\")\n   704\t        new_state = project_state.clone()\n   705\t        operation.state_forwards(\"test_dlmo\", new_state)\n   706\t        self.assertNotIn((\"test_dlmo\", \"pony\"), new_state.models)\n   707\t        # Test the database alteration\n   708\t        self.assertTableExists(\"test_dlmo_pony\")\n   709\t        with connection.schema_editor() as editor:\n   710\t            operation.database_forwards(\"test_dlmo\", editor, project_state, new_state)\n   711\t        self.assertTableNotExists(\"test_dlmo_pony\")\n   712\t        # And test reversal\n   713\t        with connection.schema_editor() as editor:\n   714\t            operation.database_backwards(\"test_dlmo\", editor, new_state, project_state)\n   715\t        self.assertTableExists(\"test_dlmo_pony\")\n   716\t        # And deconstruction\n   717\t        definition = operation.deconstruct()\n   718\t        self.assertEqual(definition[0], \"DeleteModel\")\n   719\t        self.assertEqual(definition[1], [])\n   720\t        self.assertEqual(list(definition[2]), [\"name\"])\n   721\t\n   722\t    def test_delete_proxy_model(self):\n   723\t        \"\"\"\n   724\t        Tests the DeleteModel operation ignores proxy models.\n   725\t        \"\"\"\n   726\t        project_state = self.set_up_test_model(\"test_dlprmo\", proxy_model=True)\n   727\t        # Test the state alteration\n   728\t        operation = migrations.DeleteModel(\"ProxyPony\")\n   729\t        new_state = project_state.clone()\n   730\t        operation.state_forwards(\"test_dlprmo\", new_state)\n   731\t        self.assertIn((\"test_dlprmo\", \"proxypony\"), project_state.models)\n   732\t        self.assertNotIn((\"test_dlprmo\", \"proxypony\"), new_state.models)\n   733\t        # Test the database alteration\n   734\t        self.assertTableExists(\"test_dlprmo_pony\")\n   735\t        self.assertTableNotExists(\"test_dlprmo_proxypony\")\n   736\t        with connection.schema_editor() as editor:\n   737\t            operation.database_forwards(\"test_dlprmo\", editor, project_state, new_state)\n   738\t        self.assertTableExists(\"test_dlprmo_pony\")\n   739\t        self.assertTableNotExists(\"test_dlprmo_proxypony\")\n   740\t        # And test reversal\n   741\t        with connection.schema_editor() as editor:\n   742\t            operation.database_backwards(\n   743\t                \"test_dlprmo\", editor, new_state, project_state\n   744\t            )\n   745\t        self.assertTableExists(\"test_dlprmo_pony\")\n   746\t        self.assertTableNotExists(\"test_dlprmo_proxypony\")\n   747\t\n   748\t    def test_delete_mti_model(self):\n   749\t        project_state = self.set_up_test_model(\"test_dlmtimo\", mti_model=True)\n   750\t        # Test the state alteration\n   751\t        operation = migrations.DeleteModel(\"ShetlandPony\")\n   752\t        new_state = project_state.clone()\n   753\t        operation.state_forwards(\"test_dlmtimo\", new_state)\n   754\t        self.assertIn((\"test_dlmtimo\", \"shetlandpony\"), project_state.models)\n   755\t        self.assertNotIn((\"test_dlmtimo\", \"shetlandpony\"), new_state.models)\n   756\t        # Test the database alteration\n   757\t        self.assertTableExists(\"test_dlmtimo_pony\")\n   758\t        self.assertTableExists(\"test_dlmtimo_shetlandpony\")\n   759\t        self.assertColumnExists(\"test_dlmtimo_shetlandpony\", \"pony_ptr_id\")\n   760\t        with connection.schema_editor() as editor:\n   761\t            operation.database_forwards(\n   762\t                \"test_dlmtimo\", editor, project_state, new_state\n   763\t            )\n   764\t        self.assertTableExists(\"test_dlmtimo_pony\")\n   765\t        self.assertTableNotExists(\"test_dlmtimo_shetlandpony\")\n   766\t        # And test reversal\n   767\t        with connection.schema_editor() as editor:\n   768\t            operation.database_backwards(\n   769\t                \"test_dlmtimo\", editor, new_state, project_state\n   770\t            )\n   771\t        self.assertTableExists(\"test_dlmtimo_pony\")\n   772\t        self.assertTableExists(\"test_dlmtimo_shetlandpony\")\n   773\t        self.assertColumnExists(\"test_dlmtimo_shetlandpony\", \"pony_ptr_id\")\n   774\t\n   775\t    def test_rename_model(self):\n   776\t        \"\"\"\n   777\t        Tests the RenameModel operation.\n   778\t        \"\"\"\n   779\t        project_state = self.set_up_test_model(\"test_rnmo\", related_model=True)\n   780\t        # Test the state alteration\n   781\t        operation = migrations.RenameModel(\"Pony\", \"Horse\")\n   782\t        self.assertEqual(operation.describe(), \"Rename model Pony to Horse\")\n   783\t        self.assertEqual(operation.migration_name_fragment, \"rename_pony_horse\")\n   784\t        # Test initial state and database\n   785\t        self.assertIn((\"test_rnmo\", \"pony\"), project_state.models)\n   786\t        self.assertNotIn((\"test_rnmo\", \"horse\"), project_state.models)\n   787\t        self.assertTableExists(\"test_rnmo_pony\")\n   788\t        self.assertTableNotExists(\"test_rnmo_horse\")\n   789\t        if connection.features.supports_foreign_keys:\n   790\t            self.assertFKExists(\n   791\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_pony\", \"id\")\n   792\t            )\n   793\t            self.assertFKNotExists(\n   794\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_horse\", \"id\")\n   795\t            )\n   796\t        # Migrate forwards\n   797\t        new_state = project_state.clone()\n   798\t        atomic_rename = connection.features.supports_atomic_references_rename\n   799\t        new_state = self.apply_operations(\n   800\t            \"test_rnmo\", new_state, [operation], atomic=atomic_rename\n   801\t        )\n   802\t        # Test new state and database\n   803\t        self.assertNotIn((\"test_rnmo\", \"pony\"), new_state.models)\n   804\t        self.assertIn((\"test_rnmo\", \"horse\"), new_state.models)\n   805\t        # RenameModel also repoints all incoming FKs and M2Ms\n   806\t        self.assertEqual(\n   807\t            new_state.models[\"test_rnmo\", \"rider\"].fields[\"pony\"].remote_field.model,\n   808\t            \"test_rnmo.Horse\",\n   809\t        )\n   810\t        self.assertTableNotExists(\"test_rnmo_pony\")\n   811\t        self.assertTableExists(\"test_rnmo_horse\")\n   812\t        if connection.features.supports_foreign_keys:\n   813\t            self.assertFKNotExists(\n   814\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_pony\", \"id\")\n   815\t            )\n   816\t            self.assertFKExists(\n   817\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_horse\", \"id\")\n   818\t            )\n   819\t        # Migrate backwards\n   820\t        original_state = self.unapply_operations(\n   821\t            \"test_rnmo\", project_state, [operation], atomic=atomic_rename\n   822\t        )\n   823\t        # Test original state and database\n   824\t        self.assertIn((\"test_rnmo\", \"pony\"), original_state.models)\n   825\t        self.assertNotIn((\"test_rnmo\", \"horse\"), original_state.models)\n   826\t        self.assertEqual(\n   827\t            original_state.models[\"test_rnmo\", \"rider\"]\n   828\t            .fields[\"pony\"]\n   829\t            .remote_field.model,\n   830\t            \"Pony\",\n   831\t        )\n   832\t        self.assertTableExists(\"test_rnmo_pony\")\n   833\t        self.assertTableNotExists(\"test_rnmo_horse\")\n   834\t        if connection.features.supports_foreign_keys:\n   835\t            self.assertFKExists(\n   836\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_pony\", \"id\")\n   837\t            )\n   838\t            self.assertFKNotExists(\n   839\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_horse\", \"id\")\n   840\t            )\n   841\t        # And deconstruction\n   842\t        definition = operation.deconstruct()\n   843\t        self.assertEqual(definition[0], \"RenameModel\")\n   844\t        self.assertEqual(definition[1], [])\n   845\t        self.assertEqual(definition[2], {\"old_name\": \"Pony\", \"new_name\": \"Horse\"})\n   846\t\n   847\t    def test_rename_model_state_forwards(self):\n   848\t        \"\"\"\n   849\t        RenameModel operations shouldn't trigger the caching of rendered apps\n   850\t        on state without prior apps.\n   851\t        \"\"\"\n   852\t        state = ProjectState()\n   853\t        state.add_model(ModelState(\"migrations\", \"Foo\", []))\n   854\t        operation = migrations.RenameModel(\"Foo\", \"Bar\")\n   855\t        operation.state_forwards(\"migrations\", state)\n   856\t        self.assertNotIn(\"apps\", state.__dict__)\n   857\t        self.assertNotIn((\"migrations\", \"foo\"), state.models)\n   858\t        self.assertIn((\"migrations\", \"bar\"), state.models)\n   859\t        # Now with apps cached.\n   860\t        apps = state.apps\n   861\t        operation = migrations.RenameModel(\"Bar\", \"Foo\")\n   862\t        operation.state_forwards(\"migrations\", state)\n   863\t        self.assertIs(state.apps, apps)\n   864\t        self.assertNotIn((\"migrations\", \"bar\"), state.models)\n   865\t        self.assertIn((\"migrations\", \"foo\"), state.models)\n   866\t\n   867\t    def test_rename_model_with_self_referential_fk(self):\n   868\t        \"\"\"\n   869\t        Tests the RenameModel operation on model with self referential FK.\n   870\t        \"\"\"\n   871\t        project_state = self.set_up_test_model(\"test_rmwsrf\", related_model=True)\n   872\t        # Test the state alteration\n   873\t        operation = migrations.RenameModel(\"Rider\", \"HorseRider\")\n   874\t        self.assertEqual(operation.describe(), \"Rename model Rider to HorseRider\")\n   875\t        new_state = project_state.clone()\n   876\t        operation.state_forwards(\"test_rmwsrf\", new_state)\n   877\t        self.assertNotIn((\"test_rmwsrf\", \"rider\"), new_state.models)\n   878\t        self.assertIn((\"test_rmwsrf\", \"horserider\"), new_state.models)\n   879\t        # Remember, RenameModel also repoints all incoming FKs and M2Ms\n   880\t        self.assertEqual(\n   881\t            \"self\",\n   882\t            new_state.models[\"test_rmwsrf\", \"horserider\"]\n   883\t            .fields[\"friend\"]\n   884\t            .remote_field.model,\n   885\t        )\n   886\t        HorseRider = new_state.apps.get_model(\"test_rmwsrf\", \"horserider\")\n   887\t        self.assertIs(\n   888\t            HorseRider._meta.get_field(\"horserider\").remote_field.model, HorseRider\n   889\t        )\n   890\t        # Test the database alteration\n   891\t        self.assertTableExists(\"test_rmwsrf_rider\")\n   892\t        self.assertTableNotExists(\"test_rmwsrf_horserider\")\n   893\t        if connection.features.supports_foreign_keys:\n   894\t            self.assertFKExists(\n   895\t                \"test_rmwsrf_rider\", [\"friend_id\"], (\"test_rmwsrf_rider\", \"id\")\n   896\t            )\n   897\t            self.assertFKNotExists(\n   898\t                \"test_rmwsrf_rider\", [\"friend_id\"], (\"test_rmwsrf_horserider\", \"id\")\n   899\t            )\n   900\t        atomic_rename = connection.features.supports_atomic_references_rename\n   901\t        with connection.schema_editor(atomic=atomic_rename) as editor:\n   902\t            operation.database_forwards(\"test_rmwsrf\", editor, project_state, new_state)\n   903\t        self.assertTableNotExists(\"test_rmwsrf_rider\")\n   904\t        self.assertTableExists(\"test_rmwsrf_horserider\")\n   905\t        if connection.features.supports_foreign_keys:\n   906\t            self.assertFKNotExists(\n   907\t                \"test_rmwsrf_horserider\", [\"friend_id\"], (\"test_rmwsrf_rider\", \"id\")\n   908\t            )\n   909\t            self.assertFKExists(\n   910\t                \"test_rmwsrf_horserider\",\n   911\t                [\"friend_id\"],\n   912\t                (\"test_rmwsrf_horserider\", \"id\"),\n   913\t            )\n   914\t        # And test reversal\n   915\t        with connection.schema_editor(atomic=atomic_rename) as editor:\n   916\t            operation.database_backwards(\n   917\t                \"test_rmwsrf\", editor, new_state, project_state\n   918\t            )\n   919\t        self.assertTableExists(\"test_rmwsrf_rider\")\n   920\t        self.assertTableNotExists(\"test_rmwsrf_horserider\")\n   921\t        if connection.features.supports_foreign_keys:\n   922\t            self.assertFKExists(\n   923\t                \"test_rmwsrf_rider\", [\"friend_id\"], (\"test_rmwsrf_rider\", \"id\")\n   924\t            )\n   925\t            self.assertFKNotExists(\n   926\t                \"test_rmwsrf_rider\", [\"friend_id\"], (\"test_rmwsrf_horserider\", \"id\")\n   927\t            )\n   928\t\n   929\t    def test_rename_model_with_superclass_fk(self):\n   930\t        \"\"\"\n   931\t        Tests the RenameModel operation on a model which has a superclass that\n   932\t        has a foreign key.\n   933\t        \"\"\"\n   934\t        project_state = self.set_up_test_model(\n   935\t            \"test_rmwsc\", related_model=True, mti_model=True\n   936\t        )\n   937\t        # Test the state alteration\n   938\t        operation = migrations.RenameModel(\"ShetlandPony\", \"LittleHorse\")\n   939\t        self.assertEqual(\n   940\t            operation.describe(), \"Rename model ShetlandPony to LittleHorse\"\n   941\t        )\n   942\t        new_state = project_state.clone()\n   943\t        operation.state_forwards(\"test_rmwsc\", new_state)\n   944\t        self.assertNotIn((\"test_rmwsc\", \"shetlandpony\"), new_state.models)\n   945\t        self.assertIn((\"test_rmwsc\", \"littlehorse\"), new_state.models)\n   946\t        # RenameModel shouldn't repoint the superclass's relations, only local ones\n   947\t        self.assertEqual(\n   948\t            project_state.models[\"test_rmwsc\", \"rider\"]\n   949\t            .fields[\"pony\"]\n   950\t            .remote_field.model,\n   951\t            new_state.models[\"test_rmwsc\", \"rider\"].fields[\"pony\"].remote_field.model,\n   952\t        )\n   953\t        # Before running the migration we have a table for Shetland Pony, not\n   954\t        # Little Horse.\n   955\t        self.assertTableExists(\"test_rmwsc_shetlandpony\")\n   956\t        self.assertTableNotExists(\"test_rmwsc_littlehorse\")\n   957\t        if connection.features.supports_foreign_keys:\n   958\t            # and the foreign key on rider points to pony, not shetland pony\n   959\t            self.assertFKExists(\n   960\t                \"test_rmwsc_rider\", [\"pony_id\"], (\"test_rmwsc_pony\", \"id\")\n   961\t            )\n   962\t            self.assertFKNotExists(\n   963\t                \"test_rmwsc_rider\", [\"pony_id\"], (\"test_rmwsc_shetlandpony\", \"id\")\n   964\t            )\n   965\t        with connection.schema_editor(\n   966\t            atomic=connection.features.supports_atomic_references_rename\n   967\t        ) as editor:\n   968\t            operation.database_forwards(\"test_rmwsc\", editor, project_state, new_state)\n   969\t        # Now we have a little horse table, not shetland pony\n   970\t        self.assertTableNotExists(\"test_rmwsc_shetlandpony\")\n   971\t        self.assertTableExists(\"test_rmwsc_littlehorse\")\n   972\t        if connection.features.supports_foreign_keys:\n   973\t            # but the Foreign keys still point at pony, not little horse\n   974\t            self.assertFKExists(\n   975\t                \"test_rmwsc_rider\", [\"pony_id\"], (\"test_rmwsc_pony\", \"id\")\n   976\t            )\n   977\t            self.assertFKNotExists(\n   978\t                \"test_rmwsc_rider\", [\"pony_id\"], (\"test_rmwsc_littlehorse\", \"id\")\n   979\t            )\n   980\t\n   981\t    def test_rename_model_with_self_referential_m2m(self):\n   982\t        app_label = \"test_rename_model_with_self_referential_m2m\"\n   983\t\n   984\t        project_state = self.apply_operations(\n   985\t            app_label,\n   986\t            ProjectState(),\n   987\t            operations=[\n   988\t                migrations.CreateModel(\n   989\t                    \"ReflexivePony\",\n   990\t                    fields=[\n   991\t                        (\"id\", models.AutoField(primary_key=True)),\n   992\t                        (\"ponies\", models.ManyToManyField(\"self\")),\n   993\t                    ],\n   994\t                ),\n   995\t            ],\n   996\t        )\n   997\t        project_state = self.apply_operations(\n   998\t            app_label,\n   999\t            project_state,\n  1000\t            operations=[\n  1001\t                migrations.RenameModel(\"ReflexivePony\", \"ReflexivePony2\"),\n  1002\t            ],\n  1003\t            atomic=connection.features.supports_atomic_references_rename,\n  1004\t        )\n  1005\t        Pony = project_state.apps.get_model(app_label, \"ReflexivePony2\")\n  1006\t        pony = Pony.objects.create()\n  1007\t        pony.ponies.add(pony)\n  1008\t\n  1009\t    def test_rename_model_with_m2m(self):\n  1010\t        app_label = \"test_rename_model_with_m2m\"\n  1011\t        project_state = self.apply_operations(\n  1012\t            app_label,\n  1013\t            ProjectState(),\n  1014\t            operations=[\n  1015\t                migrations.CreateModel(\n  1016\t                    \"Rider\",\n  1017\t                    fields=[\n  1018\t                        (\"id\", models.AutoField(primary_key=True)),\n  1019\t                    ],\n  1020\t                ),\n  1021\t                migrations.CreateModel(\n  1022\t                    \"Pony\",\n  1023\t                    fields=[\n  1024\t                        (\"id\", models.AutoField(primary_key=True)),\n  1025\t                        (\"riders\", models.ManyToManyField(\"Rider\")),\n  1026\t                    ],\n  1027\t                ),\n  1028\t            ],\n  1029\t        )\n  1030\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1031\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1032\t        pony = Pony.objects.create()\n  1033\t        rider = Rider.objects.create()\n  1034\t        pony.riders.add(rider)\n  1035\t\n  1036\t        project_state = self.apply_operations(\n  1037\t            app_label,\n  1038\t            project_state,\n  1039\t            operations=[\n  1040\t                migrations.RenameModel(\"Pony\", \"Pony2\"),\n  1041\t            ],\n  1042\t            atomic=connection.features.supports_atomic_references_rename,\n  1043\t        )\n  1044\t        Pony = project_state.apps.get_model(app_label, \"Pony2\")\n  1045\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1046\t        pony = Pony.objects.create()\n  1047\t        rider = Rider.objects.create()\n  1048\t        pony.riders.add(rider)\n  1049\t        self.assertEqual(Pony.objects.count(), 2)\n  1050\t        self.assertEqual(Rider.objects.count(), 2)\n  1051\t        self.assertEqual(\n  1052\t            Pony._meta.get_field(\"riders\").remote_field.through.objects.count(), 2\n  1053\t        )\n  1054\t\n  1055\t    def test_rename_model_with_db_table_noop(self):\n  1056\t        app_label = \"test_rmwdbtn\"\n  1057\t        project_state = self.apply_operations(\n  1058\t            app_label,\n  1059\t            ProjectState(),\n  1060\t            operations=[\n  1061\t                migrations.CreateModel(\n  1062\t                    \"Rider\",\n  1063\t                    fields=[\n  1064\t                        (\"id\", models.AutoField(primary_key=True)),\n  1065\t                    ],\n  1066\t                    options={\"db_table\": \"rider\"},\n  1067\t                ),\n  1068\t                migrations.CreateModel(\n  1069\t                    \"Pony\",\n  1070\t                    fields=[\n  1071\t                        (\"id\", models.AutoField(primary_key=True)),\n  1072\t                        (\n  1073\t                            \"rider\",\n  1074\t                            models.ForeignKey(\"%s.Rider\" % app_label, models.CASCADE),\n  1075\t                        ),\n  1076\t                    ],\n  1077\t                ),\n  1078\t            ],\n  1079\t        )\n  1080\t        new_state = project_state.clone()\n  1081\t        operation = migrations.RenameModel(\"Rider\", \"Runner\")\n  1082\t        operation.state_forwards(app_label, new_state)\n  1083\t\n  1084\t        with connection.schema_editor() as editor:\n  1085\t            with self.assertNumQueries(0):\n  1086\t                operation.database_forwards(app_label, editor, project_state, new_state)\n  1087\t        with connection.schema_editor() as editor:\n  1088\t            with self.assertNumQueries(0):\n  1089\t                operation.database_backwards(\n  1090\t                    app_label, editor, new_state, project_state\n  1091\t                )\n  1092\t\n  1093\t    def test_rename_m2m_target_model(self):\n  1094\t        app_label = \"test_rename_m2m_target_model\"\n  1095\t        project_state = self.apply_operations(\n  1096\t            app_label,\n  1097\t            ProjectState(),\n  1098\t            operations=[\n  1099\t                migrations.CreateModel(\n  1100\t                    \"Rider\",\n  1101\t                    fields=[\n  1102\t                        (\"id\", models.AutoField(primary_key=True)),\n  1103\t                    ],\n  1104\t                ),\n  1105\t                migrations.CreateModel(\n  1106\t                    \"Pony\",\n  1107\t                    fields=[\n  1108\t                        (\"id\", models.AutoField(primary_key=True)),\n  1109\t                        (\"riders\", models.ManyToManyField(\"Rider\")),\n  1110\t                    ],\n  1111\t                ),\n  1112\t            ],\n  1113\t        )\n  1114\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1115\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1116\t        pony = Pony.objects.create()\n  1117\t        rider = Rider.objects.create()\n  1118\t        pony.riders.add(rider)\n  1119\t\n  1120\t        project_state = self.apply_operations(\n  1121\t            app_label,\n  1122\t            project_state,\n  1123\t            operations=[\n  1124\t                migrations.RenameModel(\"Rider\", \"Rider2\"),\n  1125\t            ],\n  1126\t            atomic=connection.features.supports_atomic_references_rename,\n  1127\t        )\n  1128\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1129\t        Rider = project_state.apps.get_model(app_label, \"Rider2\")\n  1130\t        pony = Pony.objects.create()\n  1131\t        rider = Rider.objects.create()\n  1132\t        pony.riders.add(rider)\n  1133\t        self.assertEqual(Pony.objects.count(), 2)\n  1134\t        self.assertEqual(Rider.objects.count(), 2)\n  1135\t        self.assertEqual(\n  1136\t            Pony._meta.get_field(\"riders\").remote_field.through.objects.count(), 2\n  1137\t        )\n  1138\t\n  1139\t    def test_rename_m2m_through_model(self):\n  1140\t        app_label = \"test_rename_through\"\n  1141\t        project_state = self.apply_operations(\n  1142\t            app_label,\n  1143\t            ProjectState(),\n  1144\t            operations=[\n  1145\t                migrations.CreateModel(\n  1146\t                    \"Rider\",\n  1147\t                    fields=[\n  1148\t                        (\"id\", models.AutoField(primary_key=True)),\n  1149\t                    ],\n  1150\t                ),\n  1151\t                migrations.CreateModel(\n  1152\t                    \"Pony\",\n  1153\t                    fields=[\n  1154\t                        (\"id\", models.AutoField(primary_key=True)),\n  1155\t                    ],\n  1156\t                ),\n  1157\t                migrations.CreateModel(\n  1158\t                    \"PonyRider\",\n  1159\t                    fields=[\n  1160\t                        (\"id\", models.AutoField(primary_key=True)),\n  1161\t                        (\n  1162\t                            \"rider\",\n  1163\t                            models.ForeignKey(\n  1164\t                                \"test_rename_through.Rider\", models.CASCADE\n  1165\t                            ),\n  1166\t                        ),\n  1167\t                        (\n  1168\t                            \"pony\",\n  1169\t                            models.ForeignKey(\n  1170\t                                \"test_rename_through.Pony\", models.CASCADE\n  1171\t                            ),\n  1172\t                        ),\n  1173\t                    ],\n  1174\t                ),\n  1175\t                migrations.AddField(\n  1176\t                    \"Pony\",\n  1177\t                    \"riders\",\n  1178\t                    models.ManyToManyField(\n  1179\t                        \"test_rename_through.Rider\",\n  1180\t                        through=\"test_rename_through.PonyRider\",\n  1181\t                    ),\n  1182\t                ),\n  1183\t            ],\n  1184\t        )\n  1185\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1186\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1187\t        PonyRider = project_state.apps.get_model(app_label, \"PonyRider\")\n  1188\t        pony = Pony.objects.create()\n  1189\t        rider = Rider.objects.create()\n  1190\t        PonyRider.objects.create(pony=pony, rider=rider)\n  1191\t\n  1192\t        project_state = self.apply_operations(\n  1193\t            app_label,\n  1194\t            project_state,\n  1195\t            operations=[\n  1196\t                migrations.RenameModel(\"PonyRider\", \"PonyRider2\"),\n  1197\t            ],\n  1198\t        )\n  1199\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1200\t        Rider = project_state.apps.get_model(app_label, \"Rider\")\n  1201\t        PonyRider = project_state.apps.get_model(app_label, \"PonyRider2\")\n  1202\t        pony = Pony.objects.first()\n  1203\t        rider = Rider.objects.create()\n  1204\t        PonyRider.objects.create(pony=pony, rider=rider)\n  1205\t        self.assertEqual(Pony.objects.count(), 1)\n  1206\t        self.assertEqual(Rider.objects.count(), 2)\n  1207\t        self.assertEqual(PonyRider.objects.count(), 2)\n  1208\t        self.assertEqual(pony.riders.count(), 2)\n  1209\t\n  1210\t    def test_rename_m2m_model_after_rename_field(self):\n  1211\t        \"\"\"RenameModel renames a many-to-many column after a RenameField.\"\"\"\n  1212\t        app_label = \"test_rename_multiple\"\n  1213\t        project_state = self.apply_operations(\n  1214\t            app_label,\n  1215\t            ProjectState(),\n  1216\t            operations=[\n  1217\t                migrations.CreateModel(\n  1218\t                    \"Pony\",\n  1219\t                    fields=[\n  1220\t                        (\"id\", models.AutoField(primary_key=True)),\n  1221\t                        (\"name\", models.CharField(max_length=20)),\n  1222\t                    ],\n  1223\t                ),\n  1224\t                migrations.CreateModel(\n  1225\t                    \"Rider\",\n  1226\t                    fields=[\n  1227\t                        (\"id\", models.AutoField(primary_key=True)),\n  1228\t                        (\n  1229\t                            \"pony\",\n  1230\t                            models.ForeignKey(\n  1231\t                                \"test_rename_multiple.Pony\", models.CASCADE\n  1232\t                            ),\n  1233\t                        ),\n  1234\t                    ],\n  1235\t                ),\n  1236\t                migrations.CreateModel(\n  1237\t                    \"PonyRider\",\n  1238\t                    fields=[\n  1239\t                        (\"id\", models.AutoField(primary_key=True)),\n  1240\t                        (\"riders\", models.ManyToManyField(\"Rider\")),\n  1241\t                    ],\n  1242\t                ),\n  1243\t                migrations.RenameField(\n  1244\t                    model_name=\"pony\", old_name=\"name\", new_name=\"fancy_name\"\n  1245\t                ),\n  1246\t                migrations.RenameModel(old_name=\"Rider\", new_name=\"Jockey\"),\n  1247\t            ],\n  1248\t            atomic=connection.features.supports_atomic_references_rename,\n  1249\t        )\n  1250\t        Pony = project_state.apps.get_model(app_label, \"Pony\")\n  1251\t        Jockey = project_state.apps.get_model(app_label, \"Jockey\")\n  1252\t        PonyRider = project_state.apps.get_model(app_label, \"PonyRider\")\n  1253\t        # No \"no such column\" error means the column was renamed correctly.\n  1254\t        pony = Pony.objects.create(fancy_name=\"a good name\")\n  1255\t        jockey = Jockey.objects.create(pony=pony)\n  1256\t        ponyrider = PonyRider.objects.create()\n  1257\t        ponyrider.riders.add(jockey)\n  1258\t\n  1259\t    def test_add_field(self):\n  1260\t        \"\"\"\n  1261\t        Tests the AddField operation.\n  1262\t        \"\"\"\n  1263\t        # Test the state alteration\n  1264\t        operation = migrations.AddField(\n  1265\t            \"Pony\",\n  1266\t            \"height\",\n  1267\t            models.FloatField(null=True, default=5),\n  1268\t        )\n  1269\t        self.assertEqual(operation.describe(), \"Add field height to Pony\")\n  1270\t        self.assertEqual(operation.migration_name_fragment, \"pony_height\")\n  1271\t        project_state, new_state = self.make_test_state(\"test_adfl\", operation)\n  1272\t        self.assertEqual(len(new_state.models[\"test_adfl\", \"pony\"].fields), 4)\n  1273\t        field = new_state.models[\"test_adfl\", \"pony\"].fields[\"height\"]\n  1274\t        self.assertEqual(field.default, 5)\n  1275\t        # Test the database alteration\n  1276\t        self.assertColumnNotExists(\"test_adfl_pony\", \"height\")\n  1277\t        with connection.schema_editor() as editor:\n  1278\t            operation.database_forwards(\"test_adfl\", editor, project_state, new_state)\n  1279\t        self.assertColumnExists(\"test_adfl_pony\", \"height\")\n  1280\t        # And test reversal\n  1281\t        with connection.schema_editor() as editor:\n  1282\t            operation.database_backwards(\"test_adfl\", editor, new_state, project_state)\n  1283\t        self.assertColumnNotExists(\"test_adfl_pony\", \"height\")\n  1284\t        # And deconstruction\n  1285\t        definition = operation.deconstruct()\n  1286\t        self.assertEqual(definition[0], \"AddField\")\n  1287\t        self.assertEqual(definition[1], [])\n  1288\t        self.assertEqual(sorted(definition[2]), [\"field\", \"model_name\", \"name\"])\n  1289\t\n  1290\t    def test_add_charfield(self):\n  1291\t        \"\"\"\n  1292\t        Tests the AddField operation on TextField.\n  1293\t        \"\"\"\n  1294\t        project_state = self.set_up_test_model(\"test_adchfl\")\n  1295\t\n  1296\t        Pony = project_state.apps.get_model(\"test_adchfl\", \"Pony\")\n  1297\t        pony = Pony.objects.create(weight=42)\n  1298\t\n  1299\t        new_state = self.apply_operations(\n  1300\t            \"test_adchfl\",\n  1301\t            project_state,\n  1302\t            [\n  1303\t                migrations.AddField(\n  1304\t                    \"Pony\",\n  1305\t                    \"text\",\n  1306\t                    models.CharField(max_length=10, default=\"some text\"),\n  1307\t                ),\n  1308\t                migrations.AddField(\n  1309\t                    \"Pony\",\n  1310\t                    \"empty\",\n  1311\t                    models.CharField(max_length=10, default=\"\"),\n  1312\t                ),\n  1313\t                # If not properly quoted digits would be interpreted as an int.\n  1314\t                migrations.AddField(\n  1315\t                    \"Pony\",\n  1316\t                    \"digits\",\n  1317\t                    models.CharField(max_length=10, default=\"42\"),\n  1318\t                ),\n  1319\t                # Manual quoting is fragile and could trip on quotes. Refs #xyz.\n  1320\t                migrations.AddField(\n  1321\t                    \"Pony\",\n  1322\t                    \"quotes\",\n  1323\t                    models.CharField(max_length=10, default='\"\\'\"'),\n  1324\t                ),\n  1325\t            ],\n  1326\t        )\n  1327\t\n  1328\t        Pony = new_state.apps.get_model(\"test_adchfl\", \"Pony\")\n  1329\t        pony = Pony.objects.get(pk=pony.pk)\n  1330\t        self.assertEqual(pony.text, \"some text\")\n  1331\t        self.assertEqual(pony.empty, \"\")\n  1332\t        self.assertEqual(pony.digits, \"42\")\n  1333\t        self.assertEqual(pony.quotes, '\"\\'\"')\n  1334\t\n  1335\t    def test_add_textfield(self):\n  1336\t        \"\"\"\n  1337\t        Tests the AddField operation on TextField.\n  1338\t        \"\"\"\n  1339\t        project_state = self.set_up_test_model(\"test_adtxtfl\")\n  1340\t\n  1341\t        Pony = project_state.apps.get_model(\"test_adtxtfl\", \"Pony\")\n  1342\t        pony = Pony.objects.create(weight=42)\n  1343\t\n  1344\t        new_state = self.apply_operations(\n  1345\t            \"test_adtxtfl\",\n  1346\t            project_state,\n  1347\t            [\n  1348\t                migrations.AddField(\n  1349\t                    \"Pony\",\n  1350\t                    \"text\",\n  1351\t                    models.TextField(default=\"some text\"),\n  1352\t                ),\n  1353\t                migrations.AddField(\n  1354\t                    \"Pony\",\n  1355\t                    \"empty\",\n  1356\t                    models.TextField(default=\"\"),\n  1357\t                ),\n  1358\t                # If not properly quoted digits would be interpreted as an int.\n  1359\t                migrations.AddField(\n  1360\t                    \"Pony\",\n  1361\t                    \"digits\",\n  1362\t                    models.TextField(default=\"42\"),\n  1363\t                ),\n  1364\t                # Manual quoting is fragile and could trip on quotes. Refs #xyz.\n  1365\t                migrations.AddField(\n  1366\t                    \"Pony\",\n  1367\t                    \"quotes\",\n  1368\t                    models.TextField(default='\"\\'\"'),\n  1369\t                ),\n  1370\t            ],\n  1371\t        )\n  1372\t\n  1373\t        Pony = new_state.apps.get_model(\"test_adtxtfl\", \"Pony\")\n  1374\t        pony = Pony.objects.get(pk=pony.pk)\n  1375\t        self.assertEqual(pony.text, \"some text\")\n  1376\t        self.assertEqual(pony.empty, \"\")\n  1377\t        self.assertEqual(pony.digits, \"42\")\n  1378\t        self.assertEqual(pony.quotes, '\"\\'\"')\n  1379\t\n  1380\t    def test_add_binaryfield(self):\n  1381\t        \"\"\"\n  1382\t        Tests the AddField operation on TextField/BinaryField.\n  1383\t        \"\"\"\n  1384\t        project_state = self.set_up_test_model(\"test_adbinfl\")\n  1385\t\n  1386\t        Pony = project_state.apps.get_model(\"test_adbinfl\", \"Pony\")\n  1387\t        pony = Pony.objects.create(weight=42)\n  1388\t\n  1389\t        new_state = self.apply_operations(\n  1390\t            \"test_adbinfl\",\n  1391\t            project_state,\n  1392\t            [\n  1393\t                migrations.AddField(\n  1394\t                    \"Pony\",\n  1395\t                    \"blob\",\n  1396\t                    models.BinaryField(default=b\"some text\"),\n  1397\t                ),\n  1398\t                migrations.AddField(\n  1399\t                    \"Pony\",\n  1400\t                    \"empty\",\n  1401\t                    models.BinaryField(default=b\"\"),\n  1402\t                ),\n  1403\t                # If not properly quoted digits would be interpreted as an int.\n  1404\t                migrations.AddField(\n  1405\t                    \"Pony\",\n  1406\t                    \"digits\",\n  1407\t                    models.BinaryField(default=b\"42\"),\n  1408\t                ),\n  1409\t                # Manual quoting is fragile and could trip on quotes. Refs #xyz.\n  1410\t                migrations.AddField(\n  1411\t                    \"Pony\",\n  1412\t                    \"quotes\",\n  1413\t                    models.BinaryField(default=b'\"\\'\"'),\n  1414\t                ),\n  1415\t            ],\n  1416\t        )\n  1417\t\n  1418\t        Pony = new_state.apps.get_model(\"test_adbinfl\", \"Pony\")\n  1419\t        pony = Pony.objects.get(pk=pony.pk)\n  1420\t        # SQLite returns buffer/memoryview, cast to bytes for checking.\n  1421\t        self.assertEqual(bytes(pony.blob), b\"some text\")\n  1422\t        self.assertEqual(bytes(pony.empty), b\"\")\n  1423\t        self.assertEqual(bytes(pony.digits), b\"42\")\n  1424\t        self.assertEqual(bytes(pony.quotes), b'\"\\'\"')\n  1425\t\n  1426\t    def test_column_name_quoting(self):\n  1427\t        \"\"\"\n  1428\t        Column names that are SQL keywords shouldn't cause problems when used\n  1429\t        in migrations (#22168).\n  1430\t        \"\"\"\n  1431\t        project_state = self.set_up_test_model(\"test_regr22168\")\n  1432\t        operation = migrations.AddField(\n  1433\t            \"Pony\",\n  1434\t            \"order\",\n  1435\t            models.IntegerField(default=0),\n  1436\t        )\n  1437\t        new_state = project_state.clone()\n  1438\t        operation.state_forwards(\"test_regr22168\", new_state)\n  1439\t        with connection.schema_editor() as editor:\n  1440\t            operation.database_forwards(\n  1441\t                \"test_regr22168\", editor, project_state, new_state\n  1442\t            )\n  1443\t        self.assertColumnExists(\"test_regr22168_pony\", \"order\")\n  1444\t\n  1445\t    def test_add_field_preserve_default(self):\n  1446\t        \"\"\"\n  1447\t        Tests the AddField operation's state alteration\n  1448\t        when preserve_default = False.\n  1449\t        \"\"\"\n  1450\t        project_state = self.set_up_test_model(\"test_adflpd\")\n  1451\t        # Test the state alteration\n  1452\t        operation = migrations.AddField(\n  1453\t            \"Pony\",\n  1454\t            \"height\",\n  1455\t            models.FloatField(null=True, default=4),\n  1456\t            preserve_default=False,\n  1457\t        )\n  1458\t        new_state = project_state.clone()\n  1459\t        operation.state_forwards(\"test_adflpd\", new_state)\n  1460\t        self.assertEqual(len(new_state.models[\"test_adflpd\", \"pony\"].fields), 4)\n  1461\t        field = new_state.models[\"test_adflpd\", \"pony\"].fields[\"height\"]\n  1462\t        self.assertEqual(field.default, models.NOT_PROVIDED)\n  1463\t        # Test the database alteration\n  1464\t        project_state.apps.get_model(\"test_adflpd\", \"pony\").objects.create(\n  1465\t            weight=4,\n  1466\t        )\n  1467\t        self.assertColumnNotExists(\"test_adflpd_pony\", \"height\")\n  1468\t        with connection.schema_editor() as editor:\n  1469\t            operation.database_forwards(\"test_adflpd\", editor, project_state, new_state)\n  1470\t        self.assertColumnExists(\"test_adflpd_pony\", \"height\")\n  1471\t        # And deconstruction\n  1472\t        definition = operation.deconstruct()\n  1473\t        self.assertEqual(definition[0], \"AddField\")\n  1474\t        self.assertEqual(definition[1], [])\n  1475\t        self.assertEqual(\n  1476\t            sorted(definition[2]), [\"field\", \"model_name\", \"name\", \"preserve_default\"]\n  1477\t        )\n  1478\t\n  1479\t    def test_add_field_m2m(self):\n  1480\t        \"\"\"\n  1481\t        Tests the AddField operation with a ManyToManyField.\n  1482\t        \"\"\"\n  1483\t        project_state = self.set_up_test_model(\"test_adflmm\", second_model=True)\n  1484\t        # Test the state alteration\n  1485\t        operation = migrations.AddField(\n  1486\t            \"Pony\", \"stables\", models.ManyToManyField(\"Stable\", related_name=\"ponies\")\n  1487\t        )\n  1488\t        new_state = project_state.clone()\n  1489\t        operation.state_forwards(\"test_adflmm\", new_state)\n  1490\t        self.assertEqual(len(new_state.models[\"test_adflmm\", \"pony\"].fields), 4)\n  1491\t        # Test the database alteration\n  1492\t        self.assertTableNotExists(\"test_adflmm_pony_stables\")\n  1493\t        with connection.schema_editor() as editor:\n  1494\t            operation.database_forwards(\"test_adflmm\", editor, project_state, new_state)\n  1495\t        self.assertTableExists(\"test_adflmm_pony_stables\")\n  1496\t        self.assertColumnNotExists(\"test_adflmm_pony\", \"stables\")\n  1497\t        # Make sure the M2M field actually works\n  1498\t        with atomic():\n  1499\t            Pony = new_state.apps.get_model(\"test_adflmm\", \"Pony\")\n  1500\t            p = Pony.objects.create(pink=False, weight=4.55)\n  1501\t            p.stables.create()\n  1502\t            self.assertEqual(p.stables.count(), 1)\n  1503\t            p.stables.all().delete()\n  1504\t        # And test reversal\n  1505\t        with connection.schema_editor() as editor:\n  1506\t            operation.database_backwards(\n  1507\t                \"test_adflmm\", editor, new_state, project_state\n  1508\t            )\n  1509\t        self.assertTableNotExists(\"test_adflmm_pony_stables\")\n  1510\t\n  1511\t    def test_alter_field_m2m(self):\n  1512\t        project_state = self.set_up_test_model(\"test_alflmm\", second_model=True)\n  1513\t\n  1514\t        project_state = self.apply_operations(\n  1515\t            \"test_alflmm\",\n  1516\t            project_state,\n  1517\t            operations=[\n  1518\t                migrations.AddField(\n  1519\t                    \"Pony\",\n  1520\t                    \"stables\",\n  1521\t                    models.ManyToManyField(\"Stable\", related_name=\"ponies\"),\n  1522\t                )\n  1523\t            ],\n  1524\t        )\n  1525\t        Pony = project_state.apps.get_model(\"test_alflmm\", \"Pony\")\n  1526\t        self.assertFalse(Pony._meta.get_field(\"stables\").blank)\n  1527\t\n  1528\t        project_state = self.apply_operations(\n  1529\t            \"test_alflmm\",\n  1530\t            project_state,\n  1531\t            operations=[\n  1532\t                migrations.AlterField(\n  1533\t                    \"Pony\",\n  1534\t                    \"stables\",\n  1535\t                    models.ManyToManyField(\n  1536\t                        to=\"Stable\", related_name=\"ponies\", blank=True\n  1537\t                    ),\n  1538\t                )\n  1539\t            ],\n  1540\t        )\n  1541\t        Pony = project_state.apps.get_model(\"test_alflmm\", \"Pony\")\n  1542\t        self.assertTrue(Pony._meta.get_field(\"stables\").blank)\n  1543\t\n  1544\t    def test_repoint_field_m2m(self):\n  1545\t        project_state = self.set_up_test_model(\n  1546\t            \"test_alflmm\", second_model=True, third_model=True\n  1547\t        )\n  1548\t\n  1549\t        project_state = self.apply_operations(\n  1550\t            \"test_alflmm\",\n  1551\t            project_state,\n  1552\t            operations=[\n  1553\t                migrations.AddField(\n  1554\t                    \"Pony\",\n  1555\t                    \"places\",\n  1556\t                    models.ManyToManyField(\"Stable\", related_name=\"ponies\"),\n  1557\t                )\n  1558\t            ],\n  1559\t        )\n  1560\t        Pony = project_state.apps.get_model(\"test_alflmm\", \"Pony\")\n  1561\t\n  1562\t        project_state = self.apply_operations(\n  1563\t            \"test_alflmm\",\n  1564\t            project_state,\n  1565\t            operations=[\n  1566\t                migrations.AlterField(\n  1567\t                    \"Pony\",\n  1568\t                    \"places\",\n  1569\t                    models.ManyToManyField(to=\"Van\", related_name=\"ponies\"),\n  1570\t                )\n  1571\t            ],\n  1572\t        )\n  1573\t\n  1574\t        # Ensure the new field actually works\n  1575\t        Pony = project_state.apps.get_model(\"test_alflmm\", \"Pony\")\n  1576\t        p = Pony.objects.create(pink=False, weight=4.55)\n  1577\t        p.places.create()\n  1578\t        self.assertEqual(p.places.count(), 1)\n  1579\t        p.places.all().delete()\n  1580\t\n  1581\t    def test_remove_field_m2m(self):\n  1582\t        project_state = self.set_up_test_model(\"test_rmflmm\", second_model=True)\n  1583\t\n  1584\t        project_state = self.apply_operations(\n  1585\t            \"test_rmflmm\",\n  1586\t            project_state,\n  1587\t            operations=[\n  1588\t                migrations.AddField(\n  1589\t                    \"Pony\",\n  1590\t                    \"stables\",\n  1591\t                    models.ManyToManyField(\"Stable\", related_name=\"ponies\"),\n  1592\t                )\n  1593\t            ],\n  1594\t        )\n  1595\t        self.assertTableExists(\"test_rmflmm_pony_stables\")\n  1596\t\n  1597\t        with_field_state = project_state.clone()\n  1598\t        operations = [migrations.RemoveField(\"Pony\", \"stables\")]\n  1599\t        project_state = self.apply_operations(\n  1600\t            \"test_rmflmm\", project_state, operations=operations\n  1601\t        )\n  1602\t        self.assertTableNotExists(\"test_rmflmm_pony_stables\")\n  1603\t\n  1604\t        # And test reversal\n  1605\t        self.unapply_operations(\"test_rmflmm\", with_field_state, operations=operations)\n  1606\t        self.assertTableExists(\"test_rmflmm_pony_stables\")\n  1607\t\n  1608\t    def test_remove_field_m2m_with_through(self):\n  1609\t        project_state = self.set_up_test_model(\"test_rmflmmwt\", second_model=True)\n  1610\t\n  1611\t        self.assertTableNotExists(\"test_rmflmmwt_ponystables\")\n  1612\t        project_state = self.apply_operations(\n  1613\t            \"test_rmflmmwt\",\n  1614\t            project_state,\n  1615\t            operations=[\n  1616\t                migrations.CreateModel(\n  1617\t                    \"PonyStables\",\n  1618\t                    fields=[\n  1619\t                        (\n  1620\t                            \"pony\",\n  1621\t                            models.ForeignKey(\"test_rmflmmwt.Pony\", models.CASCADE),\n  1622\t                        ),\n  1623\t                        (\n  1624\t                            \"stable\",\n  1625\t                            models.ForeignKey(\"test_rmflmmwt.Stable\", models.CASCADE),\n  1626\t                        ),\n  1627\t                    ],\n  1628\t                ),\n  1629\t                migrations.AddField(\n  1630\t                    \"Pony\",\n  1631\t                    \"stables\",\n  1632\t                    models.ManyToManyField(\n  1633\t                        \"Stable\",\n  1634\t                        related_name=\"ponies\",\n  1635\t                        through=\"test_rmflmmwt.PonyStables\",\n  1636\t                    ),\n  1637\t                ),\n  1638\t            ],\n  1639\t        )\n  1640\t        self.assertTableExists(\"test_rmflmmwt_ponystables\")\n  1641\t\n  1642\t        operations = [\n  1643\t            migrations.RemoveField(\"Pony\", \"stables\"),\n  1644\t            migrations.DeleteModel(\"PonyStables\"),\n  1645\t        ]\n  1646\t        self.apply_operations(\"test_rmflmmwt\", project_state, operations=operations)\n  1647\t\n  1648\t    def test_remove_field(self):\n  1649\t        \"\"\"\n  1650\t        Tests the RemoveField operation.\n  1651\t        \"\"\"\n  1652\t        project_state = self.set_up_test_model(\"test_rmfl\")\n  1653\t        # Test the state alteration\n  1654\t        operation = migrations.RemoveField(\"Pony\", \"pink\")\n  1655\t        self.assertEqual(operation.describe(), \"Remove field pink from Pony\")\n  1656\t        self.assertEqual(operation.migration_name_fragment, \"remove_pony_pink\")\n  1657\t        new_state = project_state.clone()\n  1658\t        operation.state_forwards(\"test_rmfl\", new_state)\n  1659\t        self.assertEqual(len(new_state.models[\"test_rmfl\", \"pony\"].fields), 2)\n  1660\t        # Test the database alteration\n  1661\t        self.assertColumnExists(\"test_rmfl_pony\", \"pink\")\n  1662\t        with connection.schema_editor() as editor:\n  1663\t            operation.database_forwards(\"test_rmfl\", editor, project_state, new_state)\n  1664\t        self.assertColumnNotExists(\"test_rmfl_pony\", \"pink\")\n  1665\t        # And test reversal\n  1666\t        with connection.schema_editor() as editor:\n  1667\t            operation.database_backwards(\"test_rmfl\", editor, new_state, project_state)\n  1668\t        self.assertColumnExists(\"test_rmfl_pony\", \"pink\")\n  1669\t        # And deconstruction\n  1670\t        definition = operation.deconstruct()\n  1671\t        self.assertEqual(definition[0], \"RemoveField\")\n  1672\t        self.assertEqual(definition[1], [])\n  1673\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"name\": \"pink\"})\n  1674\t\n  1675\t    def test_remove_fk(self):\n  1676\t        \"\"\"\n  1677\t        Tests the RemoveField operation on a foreign key.\n  1678\t        \"\"\"\n  1679\t        project_state = self.set_up_test_model(\"test_rfk\", related_model=True)\n  1680\t        self.assertColumnExists(\"test_rfk_rider\", \"pony_id\")\n  1681\t        operation = migrations.RemoveField(\"Rider\", \"pony\")\n  1682\t\n  1683\t        new_state = project_state.clone()\n  1684\t        operation.state_forwards(\"test_rfk\", new_state)\n  1685\t        with connection.schema_editor() as editor:\n  1686\t            operation.database_forwards(\"test_rfk\", editor, project_state, new_state)\n  1687\t        self.assertColumnNotExists(\"test_rfk_rider\", \"pony_id\")\n  1688\t        with connection.schema_editor() as editor:\n  1689\t            operation.database_backwards(\"test_rfk\", editor, new_state, project_state)\n  1690\t        self.assertColumnExists(\"test_rfk_rider\", \"pony_id\")\n  1691\t\n  1692\t    def test_alter_model_table(self):\n  1693\t        \"\"\"\n  1694\t        Tests the AlterModelTable operation.\n  1695\t        \"\"\"\n  1696\t        project_state = self.set_up_test_model(\"test_almota\")\n  1697\t        # Test the state alteration\n  1698\t        operation = migrations.AlterModelTable(\"Pony\", \"test_almota_pony_2\")\n  1699\t        self.assertEqual(\n  1700\t            operation.describe(), \"Rename table for Pony to test_almota_pony_2\"\n  1701\t        )\n  1702\t        self.assertEqual(operation.migration_name_fragment, \"alter_pony_table\")\n  1703\t        new_state = project_state.clone()\n  1704\t        operation.state_forwards(\"test_almota\", new_state)\n  1705\t        self.assertEqual(\n  1706\t            new_state.models[\"test_almota\", \"pony\"].options[\"db_table\"],\n  1707\t            \"test_almota_pony_2\",\n  1708\t        )\n  1709\t        # Test the database alteration\n  1710\t        self.assertTableExists(\"test_almota_pony\")\n  1711\t        self.assertTableNotExists(\"test_almota_pony_2\")\n  1712\t        with connection.schema_editor() as editor:\n  1713\t            operation.database_forwards(\"test_almota\", editor, project_state, new_state)\n  1714\t        self.assertTableNotExists(\"test_almota_pony\")\n  1715\t        self.assertTableExists(\"test_almota_pony_2\")\n  1716\t        # And test reversal\n  1717\t        with connection.schema_editor() as editor:\n  1718\t            operation.database_backwards(\n  1719\t                \"test_almota\", editor, new_state, project_state\n  1720\t            )\n  1721\t        self.assertTableExists(\"test_almota_pony\")\n  1722\t        self.assertTableNotExists(\"test_almota_pony_2\")\n  1723\t        # And deconstruction\n  1724\t        definition = operation.deconstruct()\n  1725\t        self.assertEqual(definition[0], \"AlterModelTable\")\n  1726\t        self.assertEqual(definition[1], [])\n  1727\t        self.assertEqual(definition[2], {\"name\": \"Pony\", \"table\": \"test_almota_pony_2\"})\n  1728\t\n  1729\t    def test_alter_model_table_none(self):\n  1730\t        \"\"\"\n  1731\t        Tests the AlterModelTable operation if the table name is set to None.\n  1732\t        \"\"\"\n  1733\t        operation = migrations.AlterModelTable(\"Pony\", None)\n  1734\t        self.assertEqual(operation.describe(), \"Rename table for Pony to (default)\")\n  1735\t\n  1736\t    def test_alter_model_table_noop(self):\n  1737\t        \"\"\"\n  1738\t        Tests the AlterModelTable operation if the table name is not changed.\n  1739\t        \"\"\"\n  1740\t        project_state = self.set_up_test_model(\"test_almota\")\n  1741\t        # Test the state alteration\n  1742\t        operation = migrations.AlterModelTable(\"Pony\", \"test_almota_pony\")\n  1743\t        new_state = project_state.clone()\n  1744\t        operation.state_forwards(\"test_almota\", new_state)\n  1745\t        self.assertEqual(\n  1746\t            new_state.models[\"test_almota\", \"pony\"].options[\"db_table\"],\n  1747\t            \"test_almota_pony\",\n  1748\t        )\n  1749\t        # Test the database alteration\n  1750\t        self.assertTableExists(\"test_almota_pony\")\n  1751\t        with connection.schema_editor() as editor:\n  1752\t            operation.database_forwards(\"test_almota\", editor, project_state, new_state)\n  1753\t        self.assertTableExists(\"test_almota_pony\")\n  1754\t        # And test reversal\n  1755\t        with connection.schema_editor() as editor:\n  1756\t            operation.database_backwards(\n  1757\t                \"test_almota\", editor, new_state, project_state\n  1758\t            )\n  1759\t        self.assertTableExists(\"test_almota_pony\")\n  1760\t\n  1761\t    def test_alter_model_table_m2m(self):\n  1762\t        \"\"\"\n  1763\t        AlterModelTable should rename auto-generated M2M tables.\n  1764\t        \"\"\"\n  1765\t        app_label = \"test_talflmltlm2m\"\n  1766\t        pony_db_table = \"pony_foo\"\n  1767\t        project_state = self.set_up_test_model(\n  1768\t            app_label, second_model=True, db_table=pony_db_table\n  1769\t        )\n  1770\t        # Add the M2M field\n  1771\t        first_state = project_state.clone()\n  1772\t        operation = migrations.AddField(\n  1773\t            \"Pony\", \"stables\", models.ManyToManyField(\"Stable\")\n  1774\t        )\n  1775\t        operation.state_forwards(app_label, first_state)\n  1776\t        with connection.schema_editor() as editor:\n  1777\t            operation.database_forwards(app_label, editor, project_state, first_state)\n  1778\t        original_m2m_table = \"%s_%s\" % (pony_db_table, \"stables\")\n  1779\t        new_m2m_table = \"%s_%s\" % (app_label, \"pony_stables\")\n  1780\t        self.assertTableExists(original_m2m_table)\n  1781\t        self.assertTableNotExists(new_m2m_table)\n  1782\t        # Rename the Pony db_table which should also rename the m2m table.\n  1783\t        second_state = first_state.clone()\n  1784\t        operation = migrations.AlterModelTable(name=\"pony\", table=None)\n  1785\t        operation.state_forwards(app_label, second_state)\n  1786\t        atomic_rename = connection.features.supports_atomic_references_rename\n  1787\t        with connection.schema_editor(atomic=atomic_rename) as editor:\n  1788\t            operation.database_forwards(app_label, editor, first_state, second_state)\n  1789\t        self.assertTableExists(new_m2m_table)\n  1790\t        self.assertTableNotExists(original_m2m_table)\n  1791\t        # And test reversal\n  1792\t        with connection.schema_editor(atomic=atomic_rename) as editor:\n  1793\t            operation.database_backwards(app_label, editor, second_state, first_state)\n  1794\t        self.assertTableExists(original_m2m_table)\n  1795\t        self.assertTableNotExists(new_m2m_table)\n  1796\t\n  1797\t    def test_alter_field(self):\n  1798\t        \"\"\"\n  1799\t        Tests the AlterField operation.\n  1800\t        \"\"\"\n  1801\t        project_state = self.set_up_test_model(\"test_alfl\")\n  1802\t        # Test the state alteration\n  1803\t        operation = migrations.AlterField(\n  1804\t            \"Pony\", \"pink\", models.IntegerField(null=True)\n  1805\t        )\n  1806\t        self.assertEqual(operation.describe(), \"Alter field pink on Pony\")\n  1807\t        self.assertEqual(operation.migration_name_fragment, \"alter_pony_pink\")\n  1808\t        new_state = project_state.clone()\n  1809\t        operation.state_forwards(\"test_alfl\", new_state)\n  1810\t        self.assertIs(\n  1811\t            project_state.models[\"test_alfl\", \"pony\"].fields[\"pink\"].null, False\n  1812\t        )\n  1813\t        self.assertIs(new_state.models[\"test_alfl\", \"pony\"].fields[\"pink\"].null, True)\n  1814\t        # Test the database alteration\n  1815\t        self.assertColumnNotNull(\"test_alfl_pony\", \"pink\")\n  1816\t        with connection.schema_editor() as editor:\n  1817\t            operation.database_forwards(\"test_alfl\", editor, project_state, new_state)\n  1818\t        self.assertColumnNull(\"test_alfl_pony\", \"pink\")\n  1819\t        # And test reversal\n  1820\t        with connection.schema_editor() as editor:\n  1821\t            operation.database_backwards(\"test_alfl\", editor, new_state, project_state)\n  1822\t        self.assertColumnNotNull(\"test_alfl_pony\", \"pink\")\n  1823\t        # And deconstruction\n  1824\t        definition = operation.deconstruct()\n  1825\t        self.assertEqual(definition[0], \"AlterField\")\n  1826\t        self.assertEqual(definition[1], [])\n  1827\t        self.assertEqual(sorted(definition[2]), [\"field\", \"model_name\", \"name\"])\n  1828\t\n  1829\t    def test_alter_field_add_db_column_noop(self):\n  1830\t        \"\"\"\n  1831\t        AlterField operation is a noop when adding only a db_column and the\n  1832\t        column name is not changed.\n  1833\t        \"\"\"\n  1834\t        app_label = \"test_afadbn\"\n  1835\t        project_state = self.set_up_test_model(app_label, related_model=True)\n  1836\t        pony_table = \"%s_pony\" % app_label\n  1837\t        new_state = project_state.clone()\n  1838\t        operation = migrations.AlterField(\n  1839\t            \"Pony\", \"weight\", models.FloatField(db_column=\"weight\")\n  1840\t        )\n  1841\t        operation.state_forwards(app_label, new_state)\n  1842\t        self.assertIsNone(\n  1843\t            project_state.models[app_label, \"pony\"].fields[\"weight\"].db_column,\n  1844\t        )\n  1845\t        self.assertEqual(\n  1846\t            new_state.models[app_label, \"pony\"].fields[\"weight\"].db_column,\n  1847\t            \"weight\",\n  1848\t        )\n  1849\t        self.assertColumnExists(pony_table, \"weight\")\n  1850\t        with connection.schema_editor() as editor:\n  1851\t            with self.assertNumQueries(0):\n  1852\t                operation.database_forwards(app_label, editor, project_state, new_state)\n  1853\t        self.assertColumnExists(pony_table, \"weight\")\n  1854\t        with connection.schema_editor() as editor:\n  1855\t            with self.assertNumQueries(0):\n  1856\t                operation.database_backwards(\n  1857\t                    app_label, editor, new_state, project_state\n  1858\t                )\n  1859\t        self.assertColumnExists(pony_table, \"weight\")\n  1860\t\n  1861\t        rider_table = \"%s_rider\" % app_label\n  1862\t        new_state = project_state.clone()\n  1863\t        operation = migrations.AlterField(\n  1864\t            \"Rider\",\n  1865\t            \"pony\",\n  1866\t            models.ForeignKey(\"Pony\", models.CASCADE, db_column=\"pony_id\"),\n  1867\t        )\n  1868\t        operation.state_forwards(app_label, new_state)\n  1869\t        self.assertIsNone(\n  1870\t            project_state.models[app_label, \"rider\"].fields[\"pony\"].db_column,\n  1871\t        )\n  1872\t        self.assertIs(\n  1873\t            new_state.models[app_label, \"rider\"].fields[\"pony\"].db_column,\n  1874\t            \"pony_id\",\n  1875\t        )\n  1876\t        self.assertColumnExists(rider_table, \"pony_id\")\n  1877\t        with connection.schema_editor() as editor:\n  1878\t            with self.assertNumQueries(0):\n  1879\t                operation.database_forwards(app_label, editor, project_state, new_state)\n  1880\t        self.assertColumnExists(rider_table, \"pony_id\")\n  1881\t        with connection.schema_editor() as editor:\n  1882\t            with self.assertNumQueries(0):\n  1883\t                operation.database_forwards(app_label, editor, new_state, project_state)\n  1884\t        self.assertColumnExists(rider_table, \"pony_id\")\n  1885\t\n  1886\t    def test_alter_field_pk(self):\n  1887\t        \"\"\"\n  1888\t        The AlterField operation on primary keys (things like PostgreSQL's\n  1889\t        SERIAL weirdness).\n  1890\t        \"\"\"\n  1891\t        project_state = self.set_up_test_model(\"test_alflpk\")\n  1892\t        # Test the state alteration\n  1893\t        operation = migrations.AlterField(\n  1894\t            \"Pony\", \"id\", models.IntegerField(primary_key=True)\n  1895\t        )\n  1896\t        new_state = project_state.clone()\n  1897\t        operation.state_forwards(\"test_alflpk\", new_state)\n  1898\t        self.assertIsInstance(\n  1899\t            project_state.models[\"test_alflpk\", \"pony\"].fields[\"id\"],\n  1900\t            models.AutoField,\n  1901\t        )\n  1902\t        self.assertIsInstance(\n  1903\t            new_state.models[\"test_alflpk\", \"pony\"].fields[\"id\"],\n  1904\t            models.IntegerField,\n  1905\t        )\n  1906\t        # Test the database alteration\n  1907\t        with connection.schema_editor() as editor:\n  1908\t            operation.database_forwards(\"test_alflpk\", editor, project_state, new_state)\n  1909\t        # And test reversal\n  1910\t        with connection.schema_editor() as editor:\n  1911\t            operation.database_backwards(\n  1912\t                \"test_alflpk\", editor, new_state, project_state\n  1913\t            )\n  1914\t\n  1915\t    @skipUnlessDBFeature(\"supports_foreign_keys\")\n  1916\t    def test_alter_field_pk_fk(self):\n  1917\t        \"\"\"\n  1918\t        Tests the AlterField operation on primary keys changes any FKs pointing to it.\n  1919\t        \"\"\"\n  1920\t        project_state = self.set_up_test_model(\"test_alflpkfk\", related_model=True)\n  1921\t        project_state = self.apply_operations(\n  1922\t            \"test_alflpkfk\",\n  1923\t            project_state,\n  1924\t            [\n  1925\t                migrations.CreateModel(\n  1926\t                    \"Stable\",\n  1927\t                    fields=[\n  1928\t                        (\"ponies\", models.ManyToManyField(\"Pony\")),\n  1929\t                    ],\n  1930\t                ),\n  1931\t                migrations.AddField(\n  1932\t                    \"Pony\",\n  1933\t                    \"stables\",\n  1934\t                    models.ManyToManyField(\"Stable\"),\n  1935\t                ),\n  1936\t            ],\n  1937\t        )\n  1938\t        # Test the state alteration\n  1939\t        operation = migrations.AlterField(\n  1940\t            \"Pony\", \"id\", models.FloatField(primary_key=True)\n  1941\t        )\n  1942\t        new_state = project_state.clone()\n  1943\t        operation.state_forwards(\"test_alflpkfk\", new_state)\n  1944\t        self.assertIsInstance(\n  1945\t            project_state.models[\"test_alflpkfk\", \"pony\"].fields[\"id\"],\n  1946\t            models.AutoField,\n  1947\t        )\n  1948\t        self.assertIsInstance(\n  1949\t            new_state.models[\"test_alflpkfk\", \"pony\"].fields[\"id\"],\n  1950\t            models.FloatField,\n  1951\t        )\n  1952\t\n  1953\t        def assertIdTypeEqualsFkType():\n  1954\t            with connection.cursor() as cursor:\n  1955\t                id_type, id_null = [\n  1956\t                    (c.type_code, c.null_ok)\n  1957\t                    for c in connection.introspection.get_table_description(\n  1958\t                        cursor, \"test_alflpkfk_pony\"\n  1959\t                    )\n  1960\t                    if c.name == \"id\"\n  1961\t                ][0]\n  1962\t                fk_type, fk_null = [\n  1963\t                    (c.type_code, c.null_ok)\n  1964\t                    for c in connection.introspection.get_table_description(\n  1965\t                        cursor, \"test_alflpkfk_rider\"\n  1966\t                    )\n  1967\t                    if c.name == \"pony_id\"\n  1968\t                ][0]\n  1969\t                m2m_fk_type, m2m_fk_null = [\n  1970\t                    (c.type_code, c.null_ok)\n  1971\t                    for c in connection.introspection.get_table_description(\n  1972\t                        cursor,\n  1973\t                        \"test_alflpkfk_pony_stables\",\n  1974\t                    )\n  1975\t                    if c.name == \"pony_id\"\n  1976\t                ][0]\n  1977\t                remote_m2m_fk_type, remote_m2m_fk_null = [\n  1978\t                    (c.type_code, c.null_ok)\n  1979\t                    for c in connection.introspection.get_table_description(\n  1980\t                        cursor,\n  1981\t                        \"test_alflpkfk_stable_ponies\",\n  1982\t                    )\n  1983\t                    if c.name == \"pony_id\"\n  1984\t                ][0]\n  1985\t            self.assertEqual(id_type, fk_type)\n  1986\t            self.assertEqual(id_type, m2m_fk_type)\n  1987\t            self.assertEqual(id_type, remote_m2m_fk_type)\n  1988\t            self.assertEqual(id_null, fk_null)\n  1989\t            self.assertEqual(id_null, m2m_fk_null)\n  1990\t            self.assertEqual(id_null, remote_m2m_fk_null)\n  1991\t\n  1992\t        assertIdTypeEqualsFkType()\n  1993\t        # Test the database alteration\n  1994\t        with connection.schema_editor() as editor:\n  1995\t            operation.database_forwards(\n  1996\t                \"test_alflpkfk\", editor, project_state, new_state\n  1997\t            )\n  1998\t        assertIdTypeEqualsFkType()\n  1999\t        if connection.features.supports_foreign_keys:\n  2000\t            self.assertFKExists(\n  2001\t                \"test_alflpkfk_pony_stables\",\n  2002\t                [\"pony_id\"],\n  2003\t                (\"test_alflpkfk_pony\", \"id\"),\n  2004\t            )\n  2005\t            self.assertFKExists(\n  2006\t                \"test_alflpkfk_stable_ponies\",\n  2007\t                [\"pony_id\"],\n  2008\t                (\"test_alflpkfk_pony\", \"id\"),\n  2009\t            )\n  2010\t        # And test reversal\n  2011\t        with connection.schema_editor() as editor:\n  2012\t            operation.database_backwards(\n  2013\t                \"test_alflpkfk\", editor, new_state, project_state\n  2014\t            )\n  2015\t        assertIdTypeEqualsFkType()\n  2016\t        if connection.features.supports_foreign_keys:\n  2017\t            self.assertFKExists(\n  2018\t                \"test_alflpkfk_pony_stables\",\n  2019\t                [\"pony_id\"],\n  2020\t                (\"test_alflpkfk_pony\", \"id\"),\n  2021\t            )\n  2022\t            self.assertFKExists(\n  2023\t                \"test_alflpkfk_stable_ponies\",\n  2024\t                [\"pony_id\"],\n  2025\t                (\"test_alflpkfk_pony\", \"id\"),\n  2026\t            )\n  2027\t\n  2028\t    @skipUnlessDBFeature(\"supports_collation_on_charfield\", \"supports_foreign_keys\")\n  2029\t    def test_alter_field_pk_fk_db_collation(self):\n  2030\t        \"\"\"\n  2031\t        AlterField operation of db_collation on primary keys changes any FKs\n  2032\t        pointing to it.\n  2033\t        \"\"\"\n  2034\t        collation = connection.features.test_collations.get(\"non_default\")\n  2035\t        if not collation:\n  2036\t            self.skipTest(\"Language collations are not supported.\")\n  2037\t\n  2038\t        app_label = \"test_alflpkfkdbc\"\n  2039\t        project_state = self.apply_operations(\n  2040\t            app_label,\n  2041\t            ProjectState(),\n  2042\t            [\n  2043\t                migrations.CreateModel(\n  2044\t                    \"Pony\",\n  2045\t                    [\n  2046\t                        (\"id\", models.CharField(primary_key=True, max_length=10)),\n  2047\t                    ],\n  2048\t                ),\n  2049\t                migrations.CreateModel(\n  2050\t                    \"Rider\",\n  2051\t                    [\n  2052\t                        (\"pony\", models.ForeignKey(\"Pony\", models.CASCADE)),\n  2053\t                    ],\n  2054\t                ),\n  2055\t                migrations.CreateModel(\n  2056\t                    \"Stable\",\n  2057\t                    [\n  2058\t                        (\"ponies\", models.ManyToManyField(\"Pony\")),\n  2059\t                    ],\n  2060\t                ),\n  2061\t            ],\n  2062\t        )\n  2063\t        # State alteration.\n  2064\t        operation = migrations.AlterField(\n  2065\t            \"Pony\",\n  2066\t            \"id\",\n  2067\t            models.CharField(\n  2068\t                primary_key=True,\n  2069\t                max_length=10,\n  2070\t                db_collation=collation,\n  2071\t            ),\n  2072\t        )\n  2073\t        new_state = project_state.clone()\n  2074\t        operation.state_forwards(app_label, new_state)\n  2075\t        # Database alteration.\n  2076\t        with connection.schema_editor() as editor:\n  2077\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2078\t        self.assertColumnCollation(f\"{app_label}_pony\", \"id\", collation)\n  2079\t        self.assertColumnCollation(f\"{app_label}_rider\", \"pony_id\", collation)\n  2080\t        self.assertColumnCollation(f\"{app_label}_stable_ponies\", \"pony_id\", collation)\n  2081\t        # Reversal.\n  2082\t        with connection.schema_editor() as editor:\n  2083\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2084\t\n  2085\t    def test_alter_field_pk_mti_fk(self):\n  2086\t        app_label = \"test_alflpkmtifk\"\n  2087\t        project_state = self.set_up_test_model(app_label, mti_model=True)\n  2088\t        project_state = self.apply_operations(\n  2089\t            app_label,\n  2090\t            project_state,\n  2091\t            [\n  2092\t                migrations.CreateModel(\n  2093\t                    \"ShetlandRider\",\n  2094\t                    fields=[\n  2095\t                        (\n  2096\t                            \"pony\",\n  2097\t                            models.ForeignKey(\n  2098\t                                f\"{app_label}.ShetlandPony\", models.CASCADE\n  2099\t                            ),\n  2100\t                        ),\n  2101\t                    ],\n  2102\t                ),\n  2103\t            ],\n  2104\t        )\n  2105\t        operation = migrations.AlterField(\n  2106\t            \"Pony\",\n  2107\t            \"id\",\n  2108\t            models.BigAutoField(primary_key=True),\n  2109\t        )\n  2110\t        new_state = project_state.clone()\n  2111\t        operation.state_forwards(app_label, new_state)\n  2112\t        self.assertIsInstance(\n  2113\t            new_state.models[app_label, \"pony\"].fields[\"id\"],\n  2114\t            models.BigAutoField,\n  2115\t        )\n  2116\t\n  2117\t        def _get_column_id_type(cursor, table, column):\n  2118\t            return [\n  2119\t                c.type_code\n  2120\t                for c in connection.introspection.get_table_description(\n  2121\t                    cursor,\n  2122\t                    f\"{app_label}_{table}\",\n  2123\t                )\n  2124\t                if c.name == column\n  2125\t            ][0]\n  2126\t\n  2127\t        def assertIdTypeEqualsMTIFkType():\n  2128\t            with connection.cursor() as cursor:\n  2129\t                parent_id_type = _get_column_id_type(cursor, \"pony\", \"id\")\n  2130\t                child_id_type = _get_column_id_type(\n  2131\t                    cursor, \"shetlandpony\", \"pony_ptr_id\"\n  2132\t                )\n  2133\t                mti_id_type = _get_column_id_type(cursor, \"shetlandrider\", \"pony_id\")\n  2134\t            self.assertEqual(parent_id_type, child_id_type)\n  2135\t            self.assertEqual(parent_id_type, mti_id_type)\n  2136\t\n  2137\t        assertIdTypeEqualsMTIFkType()\n  2138\t        # Alter primary key.\n  2139\t        with connection.schema_editor() as editor:\n  2140\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2141\t        assertIdTypeEqualsMTIFkType()\n  2142\t        if connection.features.supports_foreign_keys:\n  2143\t            self.assertFKExists(\n  2144\t                f\"{app_label}_shetlandpony\",\n  2145\t                [\"pony_ptr_id\"],\n  2146\t                (f\"{app_label}_pony\", \"id\"),\n  2147\t            )\n  2148\t            self.assertFKExists(\n  2149\t                f\"{app_label}_shetlandrider\",\n  2150\t                [\"pony_id\"],\n  2151\t                (f\"{app_label}_shetlandpony\", \"pony_ptr_id\"),\n  2152\t            )\n  2153\t        # Reversal.\n  2154\t        with connection.schema_editor() as editor:\n  2155\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2156\t        assertIdTypeEqualsMTIFkType()\n  2157\t        if connection.features.supports_foreign_keys:\n  2158\t            self.assertFKExists(\n  2159\t                f\"{app_label}_shetlandpony\",\n  2160\t                [\"pony_ptr_id\"],\n  2161\t                (f\"{app_label}_pony\", \"id\"),\n  2162\t            )\n  2163\t            self.assertFKExists(\n  2164\t                f\"{app_label}_shetlandrider\",\n  2165\t                [\"pony_id\"],\n  2166\t                (f\"{app_label}_shetlandpony\", \"pony_ptr_id\"),\n  2167\t            )\n  2168\t\n  2169\t    def test_alter_field_pk_mti_and_fk_to_base(self):\n  2170\t        app_label = \"test_alflpkmtiftb\"\n  2171\t        project_state = self.set_up_test_model(\n  2172\t            app_label,\n  2173\t            mti_model=True,\n  2174\t            related_model=True,\n  2175\t        )\n  2176\t        operation = migrations.AlterField(\n  2177\t            \"Pony\",\n  2178\t            \"id\",\n  2179\t            models.BigAutoField(primary_key=True),\n  2180\t        )\n  2181\t        new_state = project_state.clone()\n  2182\t        operation.state_forwards(app_label, new_state)\n  2183\t        self.assertIsInstance(\n  2184\t            new_state.models[app_label, \"pony\"].fields[\"id\"],\n  2185\t            models.BigAutoField,\n  2186\t        )\n  2187\t\n  2188\t        def _get_column_id_type(cursor, table, column):\n  2189\t            return [\n  2190\t                c.type_code\n  2191\t                for c in connection.introspection.get_table_description(\n  2192\t                    cursor,\n  2193\t                    f\"{app_label}_{table}\",\n  2194\t                )\n  2195\t                if c.name == column\n  2196\t            ][0]\n  2197\t\n  2198\t        def assertIdTypeEqualsMTIFkType():\n  2199\t            with connection.cursor() as cursor:\n  2200\t                parent_id_type = _get_column_id_type(cursor, \"pony\", \"id\")\n  2201\t                fk_id_type = _get_column_id_type(cursor, \"rider\", \"pony_id\")\n  2202\t                child_id_type = _get_column_id_type(\n  2203\t                    cursor, \"shetlandpony\", \"pony_ptr_id\"\n  2204\t                )\n  2205\t            self.assertEqual(parent_id_type, child_id_type)\n  2206\t            self.assertEqual(parent_id_type, fk_id_type)\n  2207\t\n  2208\t        assertIdTypeEqualsMTIFkType()\n  2209\t        # Alter primary key.\n  2210\t        with connection.schema_editor() as editor:\n  2211\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2212\t        assertIdTypeEqualsMTIFkType()\n  2213\t        if connection.features.supports_foreign_keys:\n  2214\t            self.assertFKExists(\n  2215\t                f\"{app_label}_shetlandpony\",\n  2216\t                [\"pony_ptr_id\"],\n  2217\t                (f\"{app_label}_pony\", \"id\"),\n  2218\t            )\n  2219\t            self.assertFKExists(\n  2220\t                f\"{app_label}_rider\",\n  2221\t                [\"pony_id\"],\n  2222\t                (f\"{app_label}_pony\", \"id\"),\n  2223\t            )\n  2224\t        # Reversal.\n  2225\t        with connection.schema_editor() as editor:\n  2226\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2227\t        assertIdTypeEqualsMTIFkType()\n  2228\t        if connection.features.supports_foreign_keys:\n  2229\t            self.assertFKExists(\n  2230\t                f\"{app_label}_shetlandpony\",\n  2231\t                [\"pony_ptr_id\"],\n  2232\t                (f\"{app_label}_pony\", \"id\"),\n  2233\t            )\n  2234\t            self.assertFKExists(\n  2235\t                f\"{app_label}_rider\",\n  2236\t                [\"pony_id\"],\n  2237\t                (f\"{app_label}_pony\", \"id\"),\n  2238\t            )\n  2239\t\n  2240\t    @skipUnlessDBFeature(\"supports_foreign_keys\")\n  2241\t    def test_alter_field_reloads_state_on_fk_with_to_field_target_type_change(self):\n  2242\t        app_label = \"test_alflrsfkwtflttc\"\n  2243\t        project_state = self.apply_operations(\n  2244\t            app_label,\n  2245\t            ProjectState(),\n  2246\t            operations=[\n  2247\t                migrations.CreateModel(\n  2248\t                    \"Rider\",\n  2249\t                    fields=[\n  2250\t                        (\"id\", models.AutoField(primary_key=True)),\n  2251\t                        (\"code\", models.IntegerField(unique=True)),\n  2252\t                    ],\n  2253\t                ),\n  2254\t                migrations.CreateModel(\n  2255\t                    \"Pony\",\n  2256\t                    fields=[\n  2257\t                        (\"id\", models.AutoField(primary_key=True)),\n  2258\t                        (\n  2259\t                            \"rider\",\n  2260\t                            models.ForeignKey(\n  2261\t                                \"%s.Rider\" % app_label, models.CASCADE, to_field=\"code\"\n  2262\t                            ),\n  2263\t                        ),\n  2264\t                    ],\n  2265\t                ),\n  2266\t            ],\n  2267\t        )\n  2268\t        operation = migrations.AlterField(\n  2269\t            \"Rider\",\n  2270\t            \"code\",\n  2271\t            models.CharField(max_length=100, unique=True),\n  2272\t        )\n  2273\t        self.apply_operations(app_label, project_state, operations=[operation])\n  2274\t        id_type, id_null = [\n  2275\t            (c.type_code, c.null_ok)\n  2276\t            for c in self.get_table_description(\"%s_rider\" % app_label)\n  2277\t            if c.name == \"code\"\n  2278\t        ][0]\n  2279\t        fk_type, fk_null = [\n  2280\t            (c.type_code, c.null_ok)\n  2281\t            for c in self.get_table_description(\"%s_pony\" % app_label)\n  2282\t            if c.name == \"rider_id\"\n  2283\t        ][0]\n  2284\t        self.assertEqual(id_type, fk_type)\n  2285\t        self.assertEqual(id_null, fk_null)\n  2286\t\n  2287\t    @skipUnlessDBFeature(\"supports_foreign_keys\")\n  2288\t    def test_alter_field_reloads_state_fk_with_to_field_related_name_target_type_change(\n  2289\t        self,\n  2290\t    ):\n  2291\t        app_label = \"test_alflrsfkwtflrnttc\"\n  2292\t        project_state = self.apply_operations(\n  2293\t            app_label,\n  2294\t            ProjectState(),\n  2295\t            operations=[\n  2296\t                migrations.CreateModel(\n  2297\t                    \"Rider\",\n  2298\t                    fields=[\n  2299\t                        (\"id\", models.AutoField(primary_key=True)),\n  2300\t                        (\"code\", models.PositiveIntegerField(unique=True)),\n  2301\t                    ],\n  2302\t                ),\n  2303\t                migrations.CreateModel(\n  2304\t                    \"Pony\",\n  2305\t                    fields=[\n  2306\t                        (\"id\", models.AutoField(primary_key=True)),\n  2307\t                        (\n  2308\t                            \"rider\",\n  2309\t                            models.ForeignKey(\n  2310\t                                \"%s.Rider\" % app_label,\n  2311\t                                models.CASCADE,\n  2312\t                                to_field=\"code\",\n  2313\t                                related_name=\"+\",\n  2314\t                            ),\n  2315\t                        ),\n  2316\t                    ],\n  2317\t                ),\n  2318\t            ],\n  2319\t        )\n  2320\t        operation = migrations.AlterField(\n  2321\t            \"Rider\",\n  2322\t            \"code\",\n  2323\t            models.CharField(max_length=100, unique=True),\n  2324\t        )\n  2325\t        self.apply_operations(app_label, project_state, operations=[operation])\n  2326\t\n  2327\t    def test_alter_field_reloads_state_on_fk_target_changes(self):\n  2328\t        \"\"\"\n  2329\t        If AlterField doesn't reload state appropriately, the second AlterField\n  2330\t        crashes on MySQL due to not dropping the PonyRider.pony foreign key\n  2331\t        constraint before modifying the column.\n  2332\t        \"\"\"\n  2333\t        app_label = \"alter_alter_field_reloads_state_on_fk_target_changes\"\n  2334\t        project_state = self.apply_operations(\n  2335\t            app_label,\n  2336\t            ProjectState(),\n  2337\t            operations=[\n  2338\t                migrations.CreateModel(\n  2339\t                    \"Rider\",\n  2340\t                    fields=[\n  2341\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2342\t                    ],\n  2343\t                ),\n  2344\t                migrations.CreateModel(\n  2345\t                    \"Pony\",\n  2346\t                    fields=[\n  2347\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2348\t                        (\n  2349\t                            \"rider\",\n  2350\t                            models.ForeignKey(\"%s.Rider\" % app_label, models.CASCADE),\n  2351\t                        ),\n  2352\t                    ],\n  2353\t                ),\n  2354\t                migrations.CreateModel(\n  2355\t                    \"PonyRider\",\n  2356\t                    fields=[\n  2357\t                        (\"id\", models.AutoField(primary_key=True)),\n  2358\t                        (\n  2359\t                            \"pony\",\n  2360\t                            models.ForeignKey(\"%s.Pony\" % app_label, models.CASCADE),\n  2361\t                        ),\n  2362\t                    ],\n  2363\t                ),\n  2364\t            ],\n  2365\t        )\n  2366\t        project_state = self.apply_operations(\n  2367\t            app_label,\n  2368\t            project_state,\n  2369\t            operations=[\n  2370\t                migrations.AlterField(\n  2371\t                    \"Rider\", \"id\", models.CharField(primary_key=True, max_length=99)\n  2372\t                ),\n  2373\t                migrations.AlterField(\n  2374\t                    \"Pony\", \"id\", models.CharField(primary_key=True, max_length=99)\n  2375\t                ),\n  2376\t            ],\n  2377\t        )\n  2378\t\n  2379\t    def test_alter_field_reloads_state_on_fk_with_to_field_target_changes(self):\n  2380\t        \"\"\"\n  2381\t        If AlterField doesn't reload state appropriately, the second AlterField\n  2382\t        crashes on MySQL due to not dropping the PonyRider.pony foreign key\n  2383\t        constraint before modifying the column.\n  2384\t        \"\"\"\n  2385\t        app_label = \"alter_alter_field_reloads_state_on_fk_with_to_field_target_changes\"\n  2386\t        project_state = self.apply_operations(\n  2387\t            app_label,\n  2388\t            ProjectState(),\n  2389\t            operations=[\n  2390\t                migrations.CreateModel(\n  2391\t                    \"Rider\",\n  2392\t                    fields=[\n  2393\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2394\t                        (\"slug\", models.CharField(unique=True, max_length=100)),\n  2395\t                    ],\n  2396\t                ),\n  2397\t                migrations.CreateModel(\n  2398\t                    \"Pony\",\n  2399\t                    fields=[\n  2400\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2401\t                        (\n  2402\t                            \"rider\",\n  2403\t                            models.ForeignKey(\n  2404\t                                \"%s.Rider\" % app_label, models.CASCADE, to_field=\"slug\"\n  2405\t                            ),\n  2406\t                        ),\n  2407\t                        (\"slug\", models.CharField(unique=True, max_length=100)),\n  2408\t                    ],\n  2409\t                ),\n  2410\t                migrations.CreateModel(\n  2411\t                    \"PonyRider\",\n  2412\t                    fields=[\n  2413\t                        (\"id\", models.AutoField(primary_key=True)),\n  2414\t                        (\n  2415\t                            \"pony\",\n  2416\t                            models.ForeignKey(\n  2417\t                                \"%s.Pony\" % app_label, models.CASCADE, to_field=\"slug\"\n  2418\t                            ),\n  2419\t                        ),\n  2420\t                    ],\n  2421\t                ),\n  2422\t            ],\n  2423\t        )\n  2424\t        project_state = self.apply_operations(\n  2425\t            app_label,\n  2426\t            project_state,\n  2427\t            operations=[\n  2428\t                migrations.AlterField(\n  2429\t                    \"Rider\", \"slug\", models.CharField(unique=True, max_length=99)\n  2430\t                ),\n  2431\t                migrations.AlterField(\n  2432\t                    \"Pony\", \"slug\", models.CharField(unique=True, max_length=99)\n  2433\t                ),\n  2434\t            ],\n  2435\t        )\n  2436\t\n  2437\t    def test_rename_field_reloads_state_on_fk_target_changes(self):\n  2438\t        \"\"\"\n  2439\t        If RenameField doesn't reload state appropriately, the AlterField\n  2440\t        crashes on MySQL due to not dropping the PonyRider.pony foreign key\n  2441\t        constraint before modifying the column.\n  2442\t        \"\"\"\n  2443\t        app_label = \"alter_rename_field_reloads_state_on_fk_target_changes\"\n  2444\t        project_state = self.apply_operations(\n  2445\t            app_label,\n  2446\t            ProjectState(),\n  2447\t            operations=[\n  2448\t                migrations.CreateModel(\n  2449\t                    \"Rider\",\n  2450\t                    fields=[\n  2451\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2452\t                    ],\n  2453\t                ),\n  2454\t                migrations.CreateModel(\n  2455\t                    \"Pony\",\n  2456\t                    fields=[\n  2457\t                        (\"id\", models.CharField(primary_key=True, max_length=100)),\n  2458\t                        (\n  2459\t                            \"rider\",\n  2460\t                            models.ForeignKey(\"%s.Rider\" % app_label, models.CASCADE),\n  2461\t                        ),\n  2462\t                    ],\n  2463\t                ),\n  2464\t                migrations.CreateModel(\n  2465\t                    \"PonyRider\",\n  2466\t                    fields=[\n  2467\t                        (\"id\", models.AutoField(primary_key=True)),\n  2468\t                        (\n  2469\t                            \"pony\",\n  2470\t                            models.ForeignKey(\"%s.Pony\" % app_label, models.CASCADE),\n  2471\t                        ),\n  2472\t                    ],\n  2473\t                ),\n  2474\t            ],\n  2475\t        )\n  2476\t        project_state = self.apply_operations(\n  2477\t            app_label,\n  2478\t            project_state,\n  2479\t            operations=[\n  2480\t                migrations.RenameField(\"Rider\", \"id\", \"id2\"),\n  2481\t                migrations.AlterField(\n  2482\t                    \"Pony\", \"id\", models.CharField(primary_key=True, max_length=99)\n  2483\t                ),\n  2484\t            ],\n  2485\t            atomic=connection.features.supports_atomic_references_rename,\n  2486\t        )\n  2487\t\n  2488\t    def test_rename_field(self):\n  2489\t        \"\"\"\n  2490\t        Tests the RenameField operation.\n  2491\t        \"\"\"\n  2492\t        project_state = self.set_up_test_model(\n  2493\t            \"test_rnfl\", unique_together=True, index_together=True\n  2494\t        )\n  2495\t        # Test the state alteration\n  2496\t        operation = migrations.RenameField(\"Pony\", \"pink\", \"blue\")\n  2497\t        self.assertEqual(operation.describe(), \"Rename field pink on Pony to blue\")\n  2498\t        self.assertEqual(operation.migration_name_fragment, \"rename_pink_pony_blue\")\n  2499\t        new_state = project_state.clone()\n  2500\t        operation.state_forwards(\"test_rnfl\", new_state)\n  2501\t        self.assertIn(\"blue\", new_state.models[\"test_rnfl\", \"pony\"].fields)\n  2502\t        self.assertNotIn(\"pink\", new_state.models[\"test_rnfl\", \"pony\"].fields)\n  2503\t        # Make sure the unique_together has the renamed column too\n  2504\t        self.assertIn(\n  2505\t            \"blue\", new_state.models[\"test_rnfl\", \"pony\"].options[\"unique_together\"][0]\n  2506\t        )\n  2507\t        self.assertNotIn(\n  2508\t            \"pink\", new_state.models[\"test_rnfl\", \"pony\"].options[\"unique_together\"][0]\n  2509\t        )\n  2510\t        # Make sure the index_together has the renamed column too\n  2511\t        self.assertIn(\n  2512\t            \"blue\", new_state.models[\"test_rnfl\", \"pony\"].options[\"index_together\"][0]\n  2513\t        )\n  2514\t        self.assertNotIn(\n  2515\t            \"pink\", new_state.models[\"test_rnfl\", \"pony\"].options[\"index_together\"][0]\n  2516\t        )\n  2517\t        # Test the database alteration\n  2518\t        self.assertColumnExists(\"test_rnfl_pony\", \"pink\")\n  2519\t        self.assertColumnNotExists(\"test_rnfl_pony\", \"blue\")\n  2520\t        with connection.schema_editor() as editor:\n  2521\t            operation.database_forwards(\"test_rnfl\", editor, project_state, new_state)\n  2522\t        self.assertColumnExists(\"test_rnfl_pony\", \"blue\")\n  2523\t        self.assertColumnNotExists(\"test_rnfl_pony\", \"pink\")\n  2524\t        # Ensure the unique constraint has been ported over\n  2525\t        with connection.cursor() as cursor:\n  2526\t            cursor.execute(\"INSERT INTO test_rnfl_pony (blue, weight) VALUES (1, 1)\")\n  2527\t            with self.assertRaises(IntegrityError):\n  2528\t                with atomic():\n  2529\t                    cursor.execute(\n  2530\t                        \"INSERT INTO test_rnfl_pony (blue, weight) VALUES (1, 1)\"\n  2531\t                    )\n  2532\t            cursor.execute(\"DELETE FROM test_rnfl_pony\")\n  2533\t        # Ensure the index constraint has been ported over\n  2534\t        self.assertIndexExists(\"test_rnfl_pony\", [\"weight\", \"blue\"])\n  2535\t        # And test reversal\n  2536\t        with connection.schema_editor() as editor:\n  2537\t            operation.database_backwards(\"test_rnfl\", editor, new_state, project_state)\n  2538\t        self.assertColumnExists(\"test_rnfl_pony\", \"pink\")\n  2539\t        self.assertColumnNotExists(\"test_rnfl_pony\", \"blue\")\n  2540\t        # Ensure the index constraint has been reset\n  2541\t        self.assertIndexExists(\"test_rnfl_pony\", [\"weight\", \"pink\"])\n  2542\t        # And deconstruction\n  2543\t        definition = operation.deconstruct()\n  2544\t        self.assertEqual(definition[0], \"RenameField\")\n  2545\t        self.assertEqual(definition[1], [])\n  2546\t        self.assertEqual(\n  2547\t            definition[2],\n  2548\t            {\"model_name\": \"Pony\", \"old_name\": \"pink\", \"new_name\": \"blue\"},\n  2549\t        )\n  2550\t\n  2551\t    def test_rename_field_with_db_column(self):\n  2552\t        project_state = self.apply_operations(\n  2553\t            \"test_rfwdbc\",\n  2554\t            ProjectState(),\n  2555\t            operations=[\n  2556\t                migrations.CreateModel(\n  2557\t                    \"Pony\",\n  2558\t                    fields=[\n  2559\t                        (\"id\", models.AutoField(primary_key=True)),\n  2560\t                        (\"field\", models.IntegerField(db_column=\"db_field\")),\n  2561\t                        (\n  2562\t                            \"fk_field\",\n  2563\t                            models.ForeignKey(\n  2564\t                                \"Pony\",\n  2565\t                                models.CASCADE,\n  2566\t                                db_column=\"db_fk_field\",\n  2567\t                            ),\n  2568\t                        ),\n  2569\t                    ],\n  2570\t                ),\n  2571\t            ],\n  2572\t        )\n  2573\t        new_state = project_state.clone()\n  2574\t        operation = migrations.RenameField(\"Pony\", \"field\", \"renamed_field\")\n  2575\t        operation.state_forwards(\"test_rfwdbc\", new_state)\n  2576\t        self.assertIn(\"renamed_field\", new_state.models[\"test_rfwdbc\", \"pony\"].fields)\n  2577\t        self.assertNotIn(\"field\", new_state.models[\"test_rfwdbc\", \"pony\"].fields)\n  2578\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_field\")\n  2579\t        with connection.schema_editor() as editor:\n  2580\t            with self.assertNumQueries(0):\n  2581\t                operation.database_forwards(\n  2582\t                    \"test_rfwdbc\", editor, project_state, new_state\n  2583\t                )\n  2584\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_field\")\n  2585\t        with connection.schema_editor() as editor:\n  2586\t            with self.assertNumQueries(0):\n  2587\t                operation.database_backwards(\n  2588\t                    \"test_rfwdbc\", editor, new_state, project_state\n  2589\t                )\n  2590\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_field\")\n  2591\t\n  2592\t        new_state = project_state.clone()\n  2593\t        operation = migrations.RenameField(\"Pony\", \"fk_field\", \"renamed_fk_field\")\n  2594\t        operation.state_forwards(\"test_rfwdbc\", new_state)\n  2595\t        self.assertIn(\n  2596\t            \"renamed_fk_field\", new_state.models[\"test_rfwdbc\", \"pony\"].fields\n  2597\t        )\n  2598\t        self.assertNotIn(\"fk_field\", new_state.models[\"test_rfwdbc\", \"pony\"].fields)\n  2599\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_fk_field\")\n  2600\t        with connection.schema_editor() as editor:\n  2601\t            with self.assertNumQueries(0):\n  2602\t                operation.database_forwards(\n  2603\t                    \"test_rfwdbc\", editor, project_state, new_state\n  2604\t                )\n  2605\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_fk_field\")\n  2606\t        with connection.schema_editor() as editor:\n  2607\t            with self.assertNumQueries(0):\n  2608\t                operation.database_backwards(\n  2609\t                    \"test_rfwdbc\", editor, new_state, project_state\n  2610\t                )\n  2611\t        self.assertColumnExists(\"test_rfwdbc_pony\", \"db_fk_field\")\n  2612\t\n  2613\t    def test_rename_field_case(self):\n  2614\t        project_state = self.apply_operations(\n  2615\t            \"test_rfmx\",\n  2616\t            ProjectState(),\n  2617\t            operations=[\n  2618\t                migrations.CreateModel(\n  2619\t                    \"Pony\",\n  2620\t                    fields=[\n  2621\t                        (\"id\", models.AutoField(primary_key=True)),\n  2622\t                        (\"field\", models.IntegerField()),\n  2623\t                    ],\n  2624\t                ),\n  2625\t            ],\n  2626\t        )\n  2627\t        new_state = project_state.clone()\n  2628\t        operation = migrations.RenameField(\"Pony\", \"field\", \"FiElD\")\n  2629\t        operation.state_forwards(\"test_rfmx\", new_state)\n  2630\t        self.assertIn(\"FiElD\", new_state.models[\"test_rfmx\", \"pony\"].fields)\n  2631\t        self.assertColumnExists(\"test_rfmx_pony\", \"field\")\n  2632\t        with connection.schema_editor() as editor:\n  2633\t            operation.database_forwards(\"test_rfmx\", editor, project_state, new_state)\n  2634\t        self.assertColumnExists(\n  2635\t            \"test_rfmx_pony\",\n  2636\t            connection.introspection.identifier_converter(\"FiElD\"),\n  2637\t        )\n  2638\t        with connection.schema_editor() as editor:\n  2639\t            operation.database_backwards(\"test_rfmx\", editor, new_state, project_state)\n  2640\t        self.assertColumnExists(\"test_rfmx_pony\", \"field\")\n  2641\t\n  2642\t    def test_rename_missing_field(self):\n  2643\t        state = ProjectState()\n  2644\t        state.add_model(ModelState(\"app\", \"model\", []))\n  2645\t        with self.assertRaisesMessage(\n  2646\t            FieldDoesNotExist, \"app.model has no field named 'field'\"\n  2647\t        ):\n  2648\t            migrations.RenameField(\"model\", \"field\", \"new_field\").state_forwards(\n  2649\t                \"app\", state\n  2650\t            )\n  2651\t\n  2652\t    def test_rename_referenced_field_state_forward(self):\n  2653\t        state = ProjectState()\n  2654\t        state.add_model(\n  2655\t            ModelState(\n  2656\t                \"app\",\n  2657\t                \"Model\",\n  2658\t                [\n  2659\t                    (\"id\", models.AutoField(primary_key=True)),\n  2660\t                    (\"field\", models.IntegerField(unique=True)),\n  2661\t                ],\n  2662\t            )\n  2663\t        )\n  2664\t        state.add_model(\n  2665\t            ModelState(\n  2666\t                \"app\",\n  2667\t                \"OtherModel\",\n  2668\t                [\n  2669\t                    (\"id\", models.AutoField(primary_key=True)),\n  2670\t                    (\n  2671\t                        \"fk\",\n  2672\t                        models.ForeignKey(\"Model\", models.CASCADE, to_field=\"field\"),\n  2673\t                    ),\n  2674\t                    (\n  2675\t                        \"fo\",\n  2676\t                        models.ForeignObject(\n  2677\t                            \"Model\",\n  2678\t                            models.CASCADE,\n  2679\t                            from_fields=(\"fk\",),\n  2680\t                            to_fields=(\"field\",),\n  2681\t                        ),\n  2682\t                    ),\n  2683\t                ],\n  2684\t            )\n  2685\t        )\n  2686\t        operation = migrations.RenameField(\"Model\", \"field\", \"renamed\")\n  2687\t        new_state = state.clone()\n  2688\t        operation.state_forwards(\"app\", new_state)\n  2689\t        self.assertEqual(\n  2690\t            new_state.models[\"app\", \"othermodel\"].fields[\"fk\"].remote_field.field_name,\n  2691\t            \"renamed\",\n  2692\t        )\n  2693\t        self.assertEqual(\n  2694\t            new_state.models[\"app\", \"othermodel\"].fields[\"fk\"].from_fields, [\"self\"]\n  2695\t        )\n  2696\t        self.assertEqual(\n  2697\t            new_state.models[\"app\", \"othermodel\"].fields[\"fk\"].to_fields, (\"renamed\",)\n  2698\t        )\n  2699\t        self.assertEqual(\n  2700\t            new_state.models[\"app\", \"othermodel\"].fields[\"fo\"].from_fields, (\"fk\",)\n  2701\t        )\n  2702\t        self.assertEqual(\n  2703\t            new_state.models[\"app\", \"othermodel\"].fields[\"fo\"].to_fields, (\"renamed\",)\n  2704\t        )\n  2705\t        operation = migrations.RenameField(\"OtherModel\", \"fk\", \"renamed_fk\")\n  2706\t        new_state = state.clone()\n  2707\t        operation.state_forwards(\"app\", new_state)\n  2708\t        self.assertEqual(\n  2709\t            new_state.models[\"app\", \"othermodel\"]\n  2710\t            .fields[\"renamed_fk\"]\n  2711\t            .remote_field.field_name,\n  2712\t            \"renamed\",\n  2713\t        )\n  2714\t        self.assertEqual(\n  2715\t            new_state.models[\"app\", \"othermodel\"].fields[\"renamed_fk\"].from_fields,\n  2716\t            (\"self\",),\n  2717\t        )\n  2718\t        self.assertEqual(\n  2719\t            new_state.models[\"app\", \"othermodel\"].fields[\"renamed_fk\"].to_fields,\n  2720\t            (\"renamed\",),\n  2721\t        )\n  2722\t        self.assertEqual(\n  2723\t            new_state.models[\"app\", \"othermodel\"].fields[\"fo\"].from_fields,\n  2724\t            (\"renamed_fk\",),\n  2725\t        )\n  2726\t        self.assertEqual(\n  2727\t            new_state.models[\"app\", \"othermodel\"].fields[\"fo\"].to_fields, (\"renamed\",)\n  2728\t        )\n  2729\t\n  2730\t    def test_alter_unique_together(self):\n  2731\t        \"\"\"\n  2732\t        Tests the AlterUniqueTogether operation.\n  2733\t        \"\"\"\n  2734\t        project_state = self.set_up_test_model(\"test_alunto\")\n  2735\t        # Test the state alteration\n  2736\t        operation = migrations.AlterUniqueTogether(\"Pony\", [(\"pink\", \"weight\")])\n  2737\t        self.assertEqual(\n  2738\t            operation.describe(), \"Alter unique_together for Pony (1 constraint(s))\"\n  2739\t        )\n  2740\t        self.assertEqual(\n  2741\t            operation.migration_name_fragment,\n  2742\t            \"alter_pony_unique_together\",\n  2743\t        )\n  2744\t        new_state = project_state.clone()\n  2745\t        operation.state_forwards(\"test_alunto\", new_state)\n  2746\t        self.assertEqual(\n  2747\t            len(\n  2748\t                project_state.models[\"test_alunto\", \"pony\"].options.get(\n  2749\t                    \"unique_together\", set()\n  2750\t                )\n  2751\t            ),\n  2752\t            0,\n  2753\t        )\n  2754\t        self.assertEqual(\n  2755\t            len(\n  2756\t                new_state.models[\"test_alunto\", \"pony\"].options.get(\n  2757\t                    \"unique_together\", set()\n  2758\t                )\n  2759\t            ),\n  2760\t            1,\n  2761\t        )\n  2762\t        # Make sure we can insert duplicate rows\n  2763\t        with connection.cursor() as cursor:\n  2764\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2765\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2766\t            cursor.execute(\"DELETE FROM test_alunto_pony\")\n  2767\t            # Test the database alteration\n  2768\t            with connection.schema_editor() as editor:\n  2769\t                operation.database_forwards(\n  2770\t                    \"test_alunto\", editor, project_state, new_state\n  2771\t                )\n  2772\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2773\t            with self.assertRaises(IntegrityError):\n  2774\t                with atomic():\n  2775\t                    cursor.execute(\n  2776\t                        \"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\"\n  2777\t                    )\n  2778\t            cursor.execute(\"DELETE FROM test_alunto_pony\")\n  2779\t            # And test reversal\n  2780\t            with connection.schema_editor() as editor:\n  2781\t                operation.database_backwards(\n  2782\t                    \"test_alunto\", editor, new_state, project_state\n  2783\t                )\n  2784\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2785\t            cursor.execute(\"INSERT INTO test_alunto_pony (pink, weight) VALUES (1, 1)\")\n  2786\t            cursor.execute(\"DELETE FROM test_alunto_pony\")\n  2787\t        # Test flat unique_together\n  2788\t        operation = migrations.AlterUniqueTogether(\"Pony\", (\"pink\", \"weight\"))\n  2789\t        operation.state_forwards(\"test_alunto\", new_state)\n  2790\t        self.assertEqual(\n  2791\t            len(\n  2792\t                new_state.models[\"test_alunto\", \"pony\"].options.get(\n  2793\t                    \"unique_together\", set()\n  2794\t                )\n  2795\t            ),\n  2796\t            1,\n  2797\t        )\n  2798\t        # And deconstruction\n  2799\t        definition = operation.deconstruct()\n  2800\t        self.assertEqual(definition[0], \"AlterUniqueTogether\")\n  2801\t        self.assertEqual(definition[1], [])\n  2802\t        self.assertEqual(\n  2803\t            definition[2], {\"name\": \"Pony\", \"unique_together\": {(\"pink\", \"weight\")}}\n  2804\t        )\n  2805\t\n  2806\t    def test_alter_unique_together_remove(self):\n  2807\t        operation = migrations.AlterUniqueTogether(\"Pony\", None)\n  2808\t        self.assertEqual(\n  2809\t            operation.describe(), \"Alter unique_together for Pony (0 constraint(s))\"\n  2810\t        )\n  2811\t\n  2812\t    def test_add_index(self):\n  2813\t        \"\"\"\n  2814\t        Test the AddIndex operation.\n  2815\t        \"\"\"\n  2816\t        project_state = self.set_up_test_model(\"test_adin\")\n  2817\t        msg = (\n  2818\t            \"Indexes passed to AddIndex operations require a name argument. \"\n  2819\t            \"<Index: fields=['pink']> doesn't have one.\"\n  2820\t        )\n  2821\t        with self.assertRaisesMessage(ValueError, msg):\n  2822\t            migrations.AddIndex(\"Pony\", models.Index(fields=[\"pink\"]))\n  2823\t        index = models.Index(fields=[\"pink\"], name=\"test_adin_pony_pink_idx\")\n  2824\t        operation = migrations.AddIndex(\"Pony\", index)\n  2825\t        self.assertEqual(\n  2826\t            operation.describe(),\n  2827\t            \"Create index test_adin_pony_pink_idx on field(s) pink of model Pony\",\n  2828\t        )\n  2829\t        self.assertEqual(\n  2830\t            operation.migration_name_fragment,\n  2831\t            \"pony_test_adin_pony_pink_idx\",\n  2832\t        )\n  2833\t        new_state = project_state.clone()\n  2834\t        operation.state_forwards(\"test_adin\", new_state)\n  2835\t        # Test the database alteration\n  2836\t        self.assertEqual(\n  2837\t            len(new_state.models[\"test_adin\", \"pony\"].options[\"indexes\"]), 1\n  2838\t        )\n  2839\t        self.assertIndexNotExists(\"test_adin_pony\", [\"pink\"])\n  2840\t        with connection.schema_editor() as editor:\n  2841\t            operation.database_forwards(\"test_adin\", editor, project_state, new_state)\n  2842\t        self.assertIndexExists(\"test_adin_pony\", [\"pink\"])\n  2843\t        # And test reversal\n  2844\t        with connection.schema_editor() as editor:\n  2845\t            operation.database_backwards(\"test_adin\", editor, new_state, project_state)\n  2846\t        self.assertIndexNotExists(\"test_adin_pony\", [\"pink\"])\n  2847\t        # And deconstruction\n  2848\t        definition = operation.deconstruct()\n  2849\t        self.assertEqual(definition[0], \"AddIndex\")\n  2850\t        self.assertEqual(definition[1], [])\n  2851\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"index\": index})\n  2852\t\n  2853\t    def test_remove_index(self):\n  2854\t        \"\"\"\n  2855\t        Test the RemoveIndex operation.\n  2856\t        \"\"\"\n  2857\t        project_state = self.set_up_test_model(\"test_rmin\", multicol_index=True)\n  2858\t        self.assertTableExists(\"test_rmin_pony\")\n  2859\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2860\t        operation = migrations.RemoveIndex(\"Pony\", \"pony_test_idx\")\n  2861\t        self.assertEqual(operation.describe(), \"Remove index pony_test_idx from Pony\")\n  2862\t        self.assertEqual(\n  2863\t            operation.migration_name_fragment,\n  2864\t            \"remove_pony_pony_test_idx\",\n  2865\t        )\n  2866\t        new_state = project_state.clone()\n  2867\t        operation.state_forwards(\"test_rmin\", new_state)\n  2868\t        # Test the state alteration\n  2869\t        self.assertEqual(\n  2870\t            len(new_state.models[\"test_rmin\", \"pony\"].options[\"indexes\"]), 0\n  2871\t        )\n  2872\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2873\t        # Test the database alteration\n  2874\t        with connection.schema_editor() as editor:\n  2875\t            operation.database_forwards(\"test_rmin\", editor, project_state, new_state)\n  2876\t        self.assertIndexNotExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2877\t        # And test reversal\n  2878\t        with connection.schema_editor() as editor:\n  2879\t            operation.database_backwards(\"test_rmin\", editor, new_state, project_state)\n  2880\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2881\t        # And deconstruction\n  2882\t        definition = operation.deconstruct()\n  2883\t        self.assertEqual(definition[0], \"RemoveIndex\")\n  2884\t        self.assertEqual(definition[1], [])\n  2885\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"name\": \"pony_test_idx\"})\n  2886\t\n  2887\t        # Also test a field dropped with index - sqlite remake issue\n  2888\t        operations = [\n  2889\t            migrations.RemoveIndex(\"Pony\", \"pony_test_idx\"),\n  2890\t            migrations.RemoveField(\"Pony\", \"pink\"),\n  2891\t        ]\n  2892\t        self.assertColumnExists(\"test_rmin_pony\", \"pink\")\n  2893\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2894\t        # Test database alteration\n  2895\t        new_state = project_state.clone()\n  2896\t        self.apply_operations(\"test_rmin\", new_state, operations=operations)\n  2897\t        self.assertColumnNotExists(\"test_rmin_pony\", \"pink\")\n  2898\t        self.assertIndexNotExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2899\t        # And test reversal\n  2900\t        self.unapply_operations(\"test_rmin\", project_state, operations=operations)\n  2901\t        self.assertIndexExists(\"test_rmin_pony\", [\"pink\", \"weight\"])\n  2902\t\n  2903\t    def test_rename_index(self):\n  2904\t        app_label = \"test_rnin\"\n  2905\t        project_state = self.set_up_test_model(app_label, index=True)\n  2906\t        table_name = app_label + \"_pony\"\n  2907\t        self.assertIndexNameExists(table_name, \"pony_pink_idx\")\n  2908\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2909\t        operation = migrations.RenameIndex(\n  2910\t            \"Pony\", new_name=\"new_pony_test_idx\", old_name=\"pony_pink_idx\"\n  2911\t        )\n  2912\t        self.assertEqual(\n  2913\t            operation.describe(),\n  2914\t            \"Rename index pony_pink_idx on Pony to new_pony_test_idx\",\n  2915\t        )\n  2916\t        self.assertEqual(\n  2917\t            operation.migration_name_fragment,\n  2918\t            \"rename_pony_pink_idx_new_pony_test_idx\",\n  2919\t        )\n  2920\t\n  2921\t        new_state = project_state.clone()\n  2922\t        operation.state_forwards(app_label, new_state)\n  2923\t        # Rename index.\n  2924\t        expected_queries = 1 if connection.features.can_rename_index else 2\n  2925\t        with connection.schema_editor() as editor, self.assertNumQueries(\n  2926\t            expected_queries\n  2927\t        ):\n  2928\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2929\t        self.assertIndexNameNotExists(table_name, \"pony_pink_idx\")\n  2930\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2931\t        # Reversal.\n  2932\t        with connection.schema_editor() as editor, self.assertNumQueries(\n  2933\t            expected_queries\n  2934\t        ):\n  2935\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2936\t        self.assertIndexNameExists(table_name, \"pony_pink_idx\")\n  2937\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2938\t        # Deconstruction.\n  2939\t        definition = operation.deconstruct()\n  2940\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2941\t        self.assertEqual(definition[1], [])\n  2942\t        self.assertEqual(\n  2943\t            definition[2],\n  2944\t            {\n  2945\t                \"model_name\": \"Pony\",\n  2946\t                \"old_name\": \"pony_pink_idx\",\n  2947\t                \"new_name\": \"new_pony_test_idx\",\n  2948\t            },\n  2949\t        )\n  2950\t\n  2951\t    def test_rename_index_arguments(self):\n  2952\t        msg = \"RenameIndex.old_name and old_fields are mutually exclusive.\"\n  2953\t        with self.assertRaisesMessage(ValueError, msg):\n  2954\t            migrations.RenameIndex(\n  2955\t                \"Pony\",\n  2956\t                new_name=\"new_idx_name\",\n  2957\t                old_name=\"old_idx_name\",\n  2958\t                old_fields=(\"weight\", \"pink\"),\n  2959\t            )\n  2960\t        msg = \"RenameIndex requires one of old_name and old_fields arguments to be set.\"\n  2961\t        with self.assertRaisesMessage(ValueError, msg):\n  2962\t            migrations.RenameIndex(\"Pony\", new_name=\"new_idx_name\")\n  2963\t\n  2964\t    def test_rename_index_unnamed_index(self):\n  2965\t        app_label = \"test_rninui\"\n  2966\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  2967\t        table_name = app_label + \"_pony\"\n  2968\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2969\t        operation = migrations.RenameIndex(\n  2970\t            \"Pony\", new_name=\"new_pony_test_idx\", old_fields=(\"weight\", \"pink\")\n  2971\t        )\n  2972\t        self.assertEqual(\n  2973\t            operation.describe(),\n  2974\t            \"Rename unnamed index for ('weight', 'pink') on Pony to new_pony_test_idx\",\n  2975\t        )\n  2976\t        self.assertEqual(\n  2977\t            operation.migration_name_fragment,\n  2978\t            \"rename_pony_weight_pink_new_pony_test_idx\",\n  2979\t        )\n  2980\t\n  2981\t        new_state = project_state.clone()\n  2982\t        operation.state_forwards(app_label, new_state)\n  2983\t        # Rename index.\n  2984\t        with connection.schema_editor() as editor:\n  2985\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2986\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2987\t        # Reverse is a no-op.\n  2988\t        with connection.schema_editor() as editor, self.assertNumQueries(0):\n  2989\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2990\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2991\t        # Deconstruction.\n  2992\t        definition = operation.deconstruct()\n  2993\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2994\t        self.assertEqual(definition[1], [])\n  2995\t        self.assertEqual(\n  2996\t            definition[2],\n  2997\t            {\n  2998\t                \"model_name\": \"Pony\",\n  2999\t                \"new_name\": \"new_pony_test_idx\",\n  3000\t                \"old_fields\": (\"weight\", \"pink\"),\n  3001\t            },\n  3002\t        )\n  3003\t\n  3004\t    def test_rename_index_unknown_unnamed_index(self):\n  3005\t        app_label = \"test_rninuui\"\n  3006\t        project_state = self.set_up_test_model(app_label)\n  3007\t        operation = migrations.RenameIndex(\n  3008\t            \"Pony\", new_name=\"new_pony_test_idx\", old_fields=(\"weight\", \"pink\")\n  3009\t        )\n  3010\t        new_state = project_state.clone()\n  3011\t        operation.state_forwards(app_label, new_state)\n  3012\t        msg = \"Found wrong number (0) of indexes for test_rninuui_pony(weight, pink).\"\n  3013\t        with connection.schema_editor() as editor:\n  3014\t            with self.assertRaisesMessage(ValueError, msg):\n  3015\t                operation.database_forwards(app_label, editor, project_state, new_state)\n  3016\t\n  3017\t    def test_add_index_state_forwards(self):\n  3018\t        project_state = self.set_up_test_model(\"test_adinsf\")\n  3019\t        index = models.Index(fields=[\"pink\"], name=\"test_adinsf_pony_pink_idx\")\n  3020\t        old_model = project_state.apps.get_model(\"test_adinsf\", \"Pony\")\n  3021\t        new_state = project_state.clone()\n  3022\t\n  3023\t        operation = migrations.AddIndex(\"Pony\", index)\n  3024\t        operation.state_forwards(\"test_adinsf\", new_state)\n  3025\t        new_model = new_state.apps.get_model(\"test_adinsf\", \"Pony\")\n  3026\t        self.assertIsNot(old_model, new_model)\n  3027\t\n  3028\t    def test_remove_index_state_forwards(self):\n  3029\t        project_state = self.set_up_test_model(\"test_rminsf\")\n  3030\t        index = models.Index(fields=[\"pink\"], name=\"test_rminsf_pony_pink_idx\")\n  3031\t        migrations.AddIndex(\"Pony\", index).state_forwards(\"test_rminsf\", project_state)\n  3032\t        old_model = project_state.apps.get_model(\"test_rminsf\", \"Pony\")\n  3033\t        new_state = project_state.clone()\n  3034\t\n  3035\t        operation = migrations.RemoveIndex(\"Pony\", \"test_rminsf_pony_pink_idx\")\n  3036\t        operation.state_forwards(\"test_rminsf\", new_state)\n  3037\t        new_model = new_state.apps.get_model(\"test_rminsf\", \"Pony\")\n  3038\t        self.assertIsNot(old_model, new_model)\n  3039\t\n  3040\t    def test_rename_index_state_forwards(self):\n  3041\t        app_label = \"test_rnidsf\"\n  3042\t        project_state = self.set_up_test_model(app_label, index=True)\n  3043\t        old_model = project_state.apps.get_model(app_label, \"Pony\")\n  3044\t        new_state = project_state.clone()\n  3045\t\n  3046\t        operation = migrations.RenameIndex(\n  3047\t            \"Pony\", new_name=\"new_pony_pink_idx\", old_name=\"pony_pink_idx\"\n  3048\t        )\n  3049\t        operation.state_forwards(app_label, new_state)\n  3050\t        new_model = new_state.apps.get_model(app_label, \"Pony\")\n  3051\t        self.assertIsNot(old_model, new_model)\n  3052\t        self.assertEqual(new_model._meta.indexes[0].name, \"new_pony_pink_idx\")\n  3053\t\n  3054\t    def test_rename_index_state_forwards_unnamed_index(self):\n  3055\t        app_label = \"test_rnidsfui\"\n  3056\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  3057\t        old_model = project_state.apps.get_model(app_label, \"Pony\")\n  3058\t        new_state = project_state.clone()\n  3059\t\n  3060\t        operation = migrations.RenameIndex(\n  3061\t            \"Pony\", new_name=\"new_pony_pink_idx\", old_fields=(\"weight\", \"pink\")\n  3062\t        )\n  3063\t        operation.state_forwards(app_label, new_state)\n  3064\t        new_model = new_state.apps.get_model(app_label, \"Pony\")\n  3065\t        self.assertIsNot(old_model, new_model)\n  3066\t        self.assertEqual(new_model._meta.index_together, tuple())\n  3067\t        self.assertEqual(new_model._meta.indexes[0].name, \"new_pony_pink_idx\")\n  3068\t\n  3069\t    @skipUnlessDBFeature(\"supports_expression_indexes\")\n  3070\t    def test_add_func_index(self):\n  3071\t        app_label = \"test_addfuncin\"\n  3072\t        index_name = f\"{app_label}_pony_abs_idx\"\n  3073\t        table_name = f\"{app_label}_pony\"\n  3074\t        project_state = self.set_up_test_model(app_label)\n  3075\t        index = models.Index(Abs(\"weight\"), name=index_name)\n  3076\t        operation = migrations.AddIndex(\"Pony\", index)\n  3077\t        self.assertEqual(\n  3078\t            operation.describe(),\n  3079\t            \"Create index test_addfuncin_pony_abs_idx on Abs(F(weight)) on model Pony\",\n  3080\t        )\n  3081\t        self.assertEqual(\n  3082\t            operation.migration_name_fragment,\n  3083\t            \"pony_test_addfuncin_pony_abs_idx\",\n  3084\t        )\n  3085\t        new_state = project_state.clone()\n  3086\t        operation.state_forwards(app_label, new_state)\n  3087\t        self.assertEqual(len(new_state.models[app_label, \"pony\"].options[\"indexes\"]), 1)\n  3088\t        self.assertIndexNameNotExists(table_name, index_name)\n  3089\t        # Add index.\n  3090\t        with connection.schema_editor() as editor:\n  3091\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3092\t        self.assertIndexNameExists(table_name, index_name)\n  3093\t        # Reversal.\n  3094\t        with connection.schema_editor() as editor:\n  3095\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3096\t        self.assertIndexNameNotExists(table_name, index_name)\n  3097\t        # Deconstruction.\n  3098\t        definition = operation.deconstruct()\n  3099\t        self.assertEqual(definition[0], \"AddIndex\")\n  3100\t        self.assertEqual(definition[1], [])\n  3101\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"index\": index})\n  3102\t\n  3103\t    @skipUnlessDBFeature(\"supports_expression_indexes\")\n  3104\t    def test_remove_func_index(self):\n  3105\t        app_label = \"test_rmfuncin\"\n  3106\t        index_name = f\"{app_label}_pony_abs_idx\"\n  3107\t        table_name = f\"{app_label}_pony\"\n  3108\t        project_state = self.set_up_test_model(\n  3109\t            app_label,\n  3110\t            indexes=[\n  3111\t                models.Index(Abs(\"weight\"), name=index_name),\n  3112\t            ],\n  3113\t        )\n  3114\t        self.assertTableExists(table_name)\n  3115\t        self.assertIndexNameExists(table_name, index_name)\n  3116\t        operation = migrations.RemoveIndex(\"Pony\", index_name)\n  3117\t        self.assertEqual(\n  3118\t            operation.describe(),\n  3119\t            \"Remove index test_rmfuncin_pony_abs_idx from Pony\",\n  3120\t        )\n  3121\t        self.assertEqual(\n  3122\t            operation.migration_name_fragment,\n  3123\t            \"remove_pony_test_rmfuncin_pony_abs_idx\",\n  3124\t        )\n  3125\t        new_state = project_state.clone()\n  3126\t        operation.state_forwards(app_label, new_state)\n  3127\t        self.assertEqual(len(new_state.models[app_label, \"pony\"].options[\"indexes\"]), 0)\n  3128\t        # Remove index.\n  3129\t        with connection.schema_editor() as editor:\n  3130\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3131\t        self.assertIndexNameNotExists(table_name, index_name)\n  3132\t        # Reversal.\n  3133\t        with connection.schema_editor() as editor:\n  3134\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3135\t        self.assertIndexNameExists(table_name, index_name)\n  3136\t        # Deconstruction.\n  3137\t        definition = operation.deconstruct()\n  3138\t        self.assertEqual(definition[0], \"RemoveIndex\")\n  3139\t        self.assertEqual(definition[1], [])\n  3140\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"name\": index_name})\n  3141\t\n  3142\t    @skipUnlessDBFeature(\"supports_expression_indexes\")\n  3143\t    def test_alter_field_with_func_index(self):\n  3144\t        app_label = \"test_alfuncin\"\n  3145\t        index_name = f\"{app_label}_pony_idx\"\n  3146\t        table_name = f\"{app_label}_pony\"\n  3147\t        project_state = self.set_up_test_model(\n  3148\t            app_label,\n  3149\t            indexes=[models.Index(Abs(\"pink\"), name=index_name)],\n  3150\t        )\n  3151\t        operation = migrations.AlterField(\n  3152\t            \"Pony\", \"pink\", models.IntegerField(null=True)\n  3153\t        )\n  3154\t        new_state = project_state.clone()\n  3155\t        operation.state_forwards(app_label, new_state)\n  3156\t        with connection.schema_editor() as editor:\n  3157\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3158\t        self.assertIndexNameExists(table_name, index_name)\n  3159\t        with connection.schema_editor() as editor:\n  3160\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3161\t        self.assertIndexNameExists(table_name, index_name)\n  3162\t\n  3163\t    def test_alter_field_with_index(self):\n  3164\t        \"\"\"\n  3165\t        Test AlterField operation with an index to ensure indexes created via\n  3166\t        Meta.indexes don't get dropped with sqlite3 remake.\n  3167\t        \"\"\"\n  3168\t        project_state = self.set_up_test_model(\"test_alflin\", index=True)\n  3169\t        operation = migrations.AlterField(\n  3170\t            \"Pony\", \"pink\", models.IntegerField(null=True)\n  3171\t        )\n  3172\t        new_state = project_state.clone()\n  3173\t        operation.state_forwards(\"test_alflin\", new_state)\n  3174\t        # Test the database alteration\n  3175\t        self.assertColumnNotNull(\"test_alflin_pony\", \"pink\")\n  3176\t        with connection.schema_editor() as editor:\n  3177\t            operation.database_forwards(\"test_alflin\", editor, project_state, new_state)\n  3178\t        # Index hasn't been dropped\n  3179\t        self.assertIndexExists(\"test_alflin_pony\", [\"pink\"])\n  3180\t        # And test reversal\n  3181\t        with connection.schema_editor() as editor:\n  3182\t            operation.database_backwards(\n  3183\t                \"test_alflin\", editor, new_state, project_state\n  3184\t            )\n  3185\t        # Ensure the index is still there\n  3186\t        self.assertIndexExists(\"test_alflin_pony\", [\"pink\"])\n  3187\t\n  3188\t    def test_alter_index_together(self):\n  3189\t        \"\"\"\n  3190\t        Tests the AlterIndexTogether operation.\n  3191\t        \"\"\"\n  3192\t        project_state = self.set_up_test_model(\"test_alinto\")\n  3193\t        # Test the state alteration\n  3194\t        operation = migrations.AlterIndexTogether(\"Pony\", [(\"pink\", \"weight\")])\n  3195\t        self.assertEqual(\n  3196\t            operation.describe(), \"Alter index_together for Pony (1 constraint(s))\"\n  3197\t        )\n  3198\t        self.assertEqual(\n  3199\t            operation.migration_name_fragment,\n  3200\t            \"alter_pony_index_together\",\n  3201\t        )\n  3202\t        new_state = project_state.clone()\n  3203\t        operation.state_forwards(\"test_alinto\", new_state)\n  3204\t        self.assertEqual(\n  3205\t            len(\n  3206\t                project_state.models[\"test_alinto\", \"pony\"].options.get(\n  3207\t                    \"index_together\", set()\n  3208\t                )\n  3209\t            ),\n  3210\t            0,\n  3211\t        )\n  3212\t        self.assertEqual(\n  3213\t            len(\n  3214\t                new_state.models[\"test_alinto\", \"pony\"].options.get(\n  3215\t                    \"index_together\", set()\n  3216\t                )\n  3217\t            ),\n  3218\t            1,\n  3219\t        )\n  3220\t        # Make sure there's no matching index\n  3221\t        self.assertIndexNotExists(\"test_alinto_pony\", [\"pink\", \"weight\"])\n  3222\t        # Test the database alteration\n  3223\t        with connection.schema_editor() as editor:\n  3224\t            operation.database_forwards(\"test_alinto\", editor, project_state, new_state)\n  3225\t        self.assertIndexExists(\"test_alinto_pony\", [\"pink\", \"weight\"])\n  3226\t        # And test reversal\n  3227\t        with connection.schema_editor() as editor:\n  3228\t            operation.database_backwards(\n  3229\t                \"test_alinto\", editor, new_state, project_state\n  3230\t            )\n  3231\t        self.assertIndexNotExists(\"test_alinto_pony\", [\"pink\", \"weight\"])\n  3232\t        # And deconstruction\n  3233\t        definition = operation.deconstruct()\n  3234\t        self.assertEqual(definition[0], \"AlterIndexTogether\")\n  3235\t        self.assertEqual(definition[1], [])\n  3236\t        self.assertEqual(\n  3237\t            definition[2], {\"name\": \"Pony\", \"index_together\": {(\"pink\", \"weight\")}}\n  3238\t        )\n  3239\t\n  3240\t    def test_alter_index_together_remove(self):\n  3241\t        operation = migrations.AlterIndexTogether(\"Pony\", None)\n  3242\t        self.assertEqual(\n  3243\t            operation.describe(), \"Alter index_together for Pony (0 constraint(s))\"\n  3244\t        )\n  3245\t\n  3246\t    @skipUnlessDBFeature(\"allows_multiple_constraints_on_same_fields\")\n  3247\t    def test_alter_index_together_remove_with_unique_together(self):\n  3248\t        app_label = \"test_alintoremove_wunto\"\n  3249\t        table_name = \"%s_pony\" % app_label\n  3250\t        project_state = self.set_up_test_model(app_label, unique_together=True)\n  3251\t        self.assertUniqueConstraintExists(table_name, [\"pink\", \"weight\"])\n  3252\t        # Add index together.\n  3253\t        new_state = project_state.clone()\n  3254\t        operation = migrations.AlterIndexTogether(\"Pony\", [(\"pink\", \"weight\")])\n  3255\t        operation.state_forwards(app_label, new_state)\n  3256\t        with connection.schema_editor() as editor:\n  3257\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3258\t        self.assertIndexExists(table_name, [\"pink\", \"weight\"])\n  3259\t        # Remove index together.\n  3260\t        project_state = new_state\n  3261\t        new_state = project_state.clone()\n  3262\t        operation = migrations.AlterIndexTogether(\"Pony\", set())\n  3263\t        operation.state_forwards(app_label, new_state)\n  3264\t        with connection.schema_editor() as editor:\n  3265\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3266\t        self.assertIndexNotExists(table_name, [\"pink\", \"weight\"])\n  3267\t        self.assertUniqueConstraintExists(table_name, [\"pink\", \"weight\"])\n  3268\t\n  3269\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3270\t    def test_add_constraint(self):\n  3271\t        project_state = self.set_up_test_model(\"test_addconstraint\")\n  3272\t        gt_check = models.Q(pink__gt=2)\n  3273\t        gt_constraint = models.CheckConstraint(\n  3274\t            check=gt_check, name=\"test_add_constraint_pony_pink_gt_2\"\n  3275\t        )\n  3276\t        gt_operation = migrations.AddConstraint(\"Pony\", gt_constraint)\n  3277\t        self.assertEqual(\n  3278\t            gt_operation.describe(),\n  3279\t            \"Create constraint test_add_constraint_pony_pink_gt_2 on model Pony\",\n  3280\t        )\n  3281\t        self.assertEqual(\n  3282\t            gt_operation.migration_name_fragment,\n  3283\t            \"pony_test_add_constraint_pony_pink_gt_2\",\n  3284\t        )\n  3285\t        # Test the state alteration\n  3286\t        new_state = project_state.clone()\n  3287\t        gt_operation.state_forwards(\"test_addconstraint\", new_state)\n  3288\t        self.assertEqual(\n  3289\t            len(new_state.models[\"test_addconstraint\", \"pony\"].options[\"constraints\"]),\n  3290\t            1,\n  3291\t        )\n  3292\t        Pony = new_state.apps.get_model(\"test_addconstraint\", \"Pony\")\n  3293\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3294\t        # Test the database alteration\n  3295\t        with connection.schema_editor() as editor:\n  3296\t            gt_operation.database_forwards(\n  3297\t                \"test_addconstraint\", editor, project_state, new_state\n  3298\t            )\n  3299\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3300\t            Pony.objects.create(pink=1, weight=1.0)\n  3301\t        # Add another one.\n  3302\t        lt_check = models.Q(pink__lt=100)\n  3303\t        lt_constraint = models.CheckConstraint(\n  3304\t            check=lt_check, name=\"test_add_constraint_pony_pink_lt_100\"\n  3305\t        )\n  3306\t        lt_operation = migrations.AddConstraint(\"Pony\", lt_constraint)\n  3307\t        lt_operation.state_forwards(\"test_addconstraint\", new_state)\n  3308\t        self.assertEqual(\n  3309\t            len(new_state.models[\"test_addconstraint\", \"pony\"].options[\"constraints\"]),\n  3310\t            2,\n  3311\t        )\n  3312\t        Pony = new_state.apps.get_model(\"test_addconstraint\", \"Pony\")\n  3313\t        self.assertEqual(len(Pony._meta.constraints), 2)\n  3314\t        with connection.schema_editor() as editor:\n  3315\t            lt_operation.database_forwards(\n  3316\t                \"test_addconstraint\", editor, project_state, new_state\n  3317\t            )\n  3318\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3319\t            Pony.objects.create(pink=100, weight=1.0)\n  3320\t        # Test reversal\n  3321\t        with connection.schema_editor() as editor:\n  3322\t            gt_operation.database_backwards(\n  3323\t                \"test_addconstraint\", editor, new_state, project_state\n  3324\t            )\n  3325\t        Pony.objects.create(pink=1, weight=1.0)\n  3326\t        # Test deconstruction\n  3327\t        definition = gt_operation.deconstruct()\n  3328\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3329\t        self.assertEqual(definition[1], [])\n  3330\t        self.assertEqual(\n  3331\t            definition[2], {\"model_name\": \"Pony\", \"constraint\": gt_constraint}\n  3332\t        )\n  3333\t\n  3334\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3335\t    def test_add_constraint_percent_escaping(self):\n  3336\t        app_label = \"add_constraint_string_quoting\"\n  3337\t        operations = [\n  3338\t            migrations.CreateModel(\n  3339\t                \"Author\",\n  3340\t                fields=[\n  3341\t                    (\"id\", models.AutoField(primary_key=True)),\n  3342\t                    (\"name\", models.CharField(max_length=100)),\n  3343\t                    (\"surname\", models.CharField(max_length=100, default=\"\")),\n  3344\t                    (\"rebate\", models.CharField(max_length=100)),\n  3345\t                ],\n  3346\t            ),\n  3347\t        ]\n  3348\t        from_state = self.apply_operations(app_label, ProjectState(), operations)\n  3349\t        # \"%\" generated in startswith lookup should be escaped in a way that is\n  3350\t        # considered a leading wildcard.\n  3351\t        check = models.Q(name__startswith=\"Albert\")\n  3352\t        constraint = models.CheckConstraint(check=check, name=\"name_constraint\")\n  3353\t        operation = migrations.AddConstraint(\"Author\", constraint)\n  3354\t        to_state = from_state.clone()\n  3355\t        operation.state_forwards(app_label, to_state)\n  3356\t        with connection.schema_editor() as editor:\n  3357\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3358\t        Author = to_state.apps.get_model(app_label, \"Author\")\n  3359\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3360\t            Author.objects.create(name=\"Artur\")\n  3361\t        # Literal \"%\" should be escaped in a way that is not a considered a\n  3362\t        # wildcard.\n  3363\t        check = models.Q(rebate__endswith=\"%\")\n  3364\t        constraint = models.CheckConstraint(check=check, name=\"rebate_constraint\")\n  3365\t        operation = migrations.AddConstraint(\"Author\", constraint)\n  3366\t        from_state = to_state\n  3367\t        to_state = from_state.clone()\n  3368\t        operation.state_forwards(app_label, to_state)\n  3369\t        Author = to_state.apps.get_model(app_label, \"Author\")\n  3370\t        with connection.schema_editor() as editor:\n  3371\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3372\t        Author = to_state.apps.get_model(app_label, \"Author\")\n  3373\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3374\t            Author.objects.create(name=\"Albert\", rebate=\"10$\")\n  3375\t        author = Author.objects.create(name=\"Albert\", rebate=\"10%\")\n  3376\t        self.assertEqual(Author.objects.get(), author)\n  3377\t        # Right-hand-side baked \"%\" literals should not be used for parameters\n  3378\t        # interpolation.\n  3379\t        check = ~models.Q(surname__startswith=models.F(\"name\"))\n  3380\t        constraint = models.CheckConstraint(check=check, name=\"name_constraint_rhs\")\n  3381\t        operation = migrations.AddConstraint(\"Author\", constraint)\n  3382\t        from_state = to_state\n  3383\t        to_state = from_state.clone()\n  3384\t        operation.state_forwards(app_label, to_state)\n  3385\t        with connection.schema_editor() as editor:\n  3386\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3387\t        Author = to_state.apps.get_model(app_label, \"Author\")\n  3388\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3389\t            Author.objects.create(name=\"Albert\", surname=\"Alberto\")\n  3390\t\n  3391\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3392\t    def test_add_or_constraint(self):\n  3393\t        app_label = \"test_addorconstraint\"\n  3394\t        constraint_name = \"add_constraint_or\"\n  3395\t        from_state = self.set_up_test_model(app_label)\n  3396\t        check = models.Q(pink__gt=2, weight__gt=2) | models.Q(weight__lt=0)\n  3397\t        constraint = models.CheckConstraint(check=check, name=constraint_name)\n  3398\t        operation = migrations.AddConstraint(\"Pony\", constraint)\n  3399\t        to_state = from_state.clone()\n  3400\t        operation.state_forwards(app_label, to_state)\n  3401\t        with connection.schema_editor() as editor:\n  3402\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3403\t        Pony = to_state.apps.get_model(app_label, \"Pony\")\n  3404\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3405\t            Pony.objects.create(pink=2, weight=3.0)\n  3406\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3407\t            Pony.objects.create(pink=3, weight=1.0)\n  3408\t        Pony.objects.bulk_create(\n  3409\t            [\n  3410\t                Pony(pink=3, weight=-1.0),\n  3411\t                Pony(pink=1, weight=-1.0),\n  3412\t                Pony(pink=3, weight=3.0),\n  3413\t            ]\n  3414\t        )\n  3415\t\n  3416\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3417\t    def test_add_constraint_combinable(self):\n  3418\t        app_label = \"test_addconstraint_combinable\"\n  3419\t        operations = [\n  3420\t            migrations.CreateModel(\n  3421\t                \"Book\",\n  3422\t                fields=[\n  3423\t                    (\"id\", models.AutoField(primary_key=True)),\n  3424\t                    (\"read\", models.PositiveIntegerField()),\n  3425\t                    (\"unread\", models.PositiveIntegerField()),\n  3426\t                ],\n  3427\t            ),\n  3428\t        ]\n  3429\t        from_state = self.apply_operations(app_label, ProjectState(), operations)\n  3430\t        constraint = models.CheckConstraint(\n  3431\t            check=models.Q(read=(100 - models.F(\"unread\"))),\n  3432\t            name=\"test_addconstraint_combinable_sum_100\",\n  3433\t        )\n  3434\t        operation = migrations.AddConstraint(\"Book\", constraint)\n  3435\t        to_state = from_state.clone()\n  3436\t        operation.state_forwards(app_label, to_state)\n  3437\t        with connection.schema_editor() as editor:\n  3438\t            operation.database_forwards(app_label, editor, from_state, to_state)\n  3439\t        Book = to_state.apps.get_model(app_label, \"Book\")\n  3440\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3441\t            Book.objects.create(read=70, unread=10)\n  3442\t        Book.objects.create(read=70, unread=30)\n  3443\t\n  3444\t    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n  3445\t    def test_remove_constraint(self):\n  3446\t        project_state = self.set_up_test_model(\n  3447\t            \"test_removeconstraint\",\n  3448\t            constraints=[\n  3449\t                models.CheckConstraint(\n  3450\t                    check=models.Q(pink__gt=2),\n  3451\t                    name=\"test_remove_constraint_pony_pink_gt_2\",\n  3452\t                ),\n  3453\t                models.CheckConstraint(\n  3454\t                    check=models.Q(pink__lt=100),\n  3455\t                    name=\"test_remove_constraint_pony_pink_lt_100\",\n  3456\t                ),\n  3457\t            ],\n  3458\t        )\n  3459\t        gt_operation = migrations.RemoveConstraint(\n  3460\t            \"Pony\", \"test_remove_constraint_pony_pink_gt_2\"\n  3461\t        )\n  3462\t        self.assertEqual(\n  3463\t            gt_operation.describe(),\n  3464\t            \"Remove constraint test_remove_constraint_pony_pink_gt_2 from model Pony\",\n  3465\t        )\n  3466\t        self.assertEqual(\n  3467\t            gt_operation.migration_name_fragment,\n  3468\t            \"remove_pony_test_remove_constraint_pony_pink_gt_2\",\n  3469\t        )\n  3470\t        # Test state alteration\n  3471\t        new_state = project_state.clone()\n  3472\t        gt_operation.state_forwards(\"test_removeconstraint\", new_state)\n  3473\t        self.assertEqual(\n  3474\t            len(\n  3475\t                new_state.models[\"test_removeconstraint\", \"pony\"].options[\"constraints\"]\n  3476\t            ),\n  3477\t            1,\n  3478\t        )\n  3479\t        Pony = new_state.apps.get_model(\"test_removeconstraint\", \"Pony\")\n  3480\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3481\t        # Test database alteration\n  3482\t        with connection.schema_editor() as editor:\n  3483\t            gt_operation.database_forwards(\n  3484\t                \"test_removeconstraint\", editor, project_state, new_state\n  3485\t            )\n  3486\t        Pony.objects.create(pink=1, weight=1.0).delete()\n  3487\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3488\t            Pony.objects.create(pink=100, weight=1.0)\n  3489\t        # Remove the other one.\n  3490\t        lt_operation = migrations.RemoveConstraint(\n  3491\t            \"Pony\", \"test_remove_constraint_pony_pink_lt_100\"\n  3492\t        )\n  3493\t        lt_operation.state_forwards(\"test_removeconstraint\", new_state)\n  3494\t        self.assertEqual(\n  3495\t            len(\n  3496\t                new_state.models[\"test_removeconstraint\", \"pony\"].options[\"constraints\"]\n  3497\t            ),\n  3498\t            0,\n  3499\t        )\n  3500\t        Pony = new_state.apps.get_model(\"test_removeconstraint\", \"Pony\")\n  3501\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3502\t        with connection.schema_editor() as editor:\n  3503\t            lt_operation.database_forwards(\n  3504\t                \"test_removeconstraint\", editor, project_state, new_state\n  3505\t            )\n  3506\t        Pony.objects.create(pink=100, weight=1.0).delete()\n  3507\t        # Test reversal\n  3508\t        with connection.schema_editor() as editor:\n  3509\t            gt_operation.database_backwards(\n  3510\t                \"test_removeconstraint\", editor, new_state, project_state\n  3511\t            )\n  3512\t        with self.assertRaises(IntegrityError), transaction.atomic():\n  3513\t            Pony.objects.create(pink=1, weight=1.0)\n  3514\t        # Test deconstruction\n  3515\t        definition = gt_operation.deconstruct()\n  3516\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3517\t        self.assertEqual(definition[1], [])\n  3518\t        self.assertEqual(\n  3519\t            definition[2],\n  3520\t            {\"model_name\": \"Pony\", \"name\": \"test_remove_constraint_pony_pink_gt_2\"},\n  3521\t        )\n  3522\t\n  3523\t    def test_add_partial_unique_constraint(self):\n  3524\t        project_state = self.set_up_test_model(\"test_addpartialuniqueconstraint\")\n  3525\t        partial_unique_constraint = models.UniqueConstraint(\n  3526\t            fields=[\"pink\"],\n  3527\t            condition=models.Q(weight__gt=5),\n  3528\t            name=\"test_constraint_pony_pink_for_weight_gt_5_uniq\",\n  3529\t        )\n  3530\t        operation = migrations.AddConstraint(\"Pony\", partial_unique_constraint)\n  3531\t        self.assertEqual(\n  3532\t            operation.describe(),\n  3533\t            \"Create constraint test_constraint_pony_pink_for_weight_gt_5_uniq \"\n  3534\t            \"on model Pony\",\n  3535\t        )\n  3536\t        # Test the state alteration\n  3537\t        new_state = project_state.clone()\n  3538\t        operation.state_forwards(\"test_addpartialuniqueconstraint\", new_state)\n  3539\t        self.assertEqual(\n  3540\t            len(\n  3541\t                new_state.models[\"test_addpartialuniqueconstraint\", \"pony\"].options[\n  3542\t                    \"constraints\"\n  3543\t                ]\n  3544\t            ),\n  3545\t            1,\n  3546\t        )\n  3547\t        Pony = new_state.apps.get_model(\"test_addpartialuniqueconstraint\", \"Pony\")\n  3548\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3549\t        # Test the database alteration\n  3550\t        with connection.schema_editor() as editor:\n  3551\t            operation.database_forwards(\n  3552\t                \"test_addpartialuniqueconstraint\", editor, project_state, new_state\n  3553\t            )\n  3554\t        # Test constraint works\n  3555\t        Pony.objects.create(pink=1, weight=4.0)\n  3556\t        Pony.objects.create(pink=1, weight=4.0)\n  3557\t        Pony.objects.create(pink=1, weight=6.0)\n  3558\t        if connection.features.supports_partial_indexes:\n  3559\t            with self.assertRaises(IntegrityError), transaction.atomic():\n  3560\t                Pony.objects.create(pink=1, weight=7.0)\n  3561\t        else:\n  3562\t            Pony.objects.create(pink=1, weight=7.0)\n  3563\t        # Test reversal\n  3564\t        with connection.schema_editor() as editor:\n  3565\t            operation.database_backwards(\n  3566\t                \"test_addpartialuniqueconstraint\", editor, new_state, project_state\n  3567\t            )\n  3568\t        # Test constraint doesn't work\n  3569\t        Pony.objects.create(pink=1, weight=7.0)\n  3570\t        # Test deconstruction\n  3571\t        definition = operation.deconstruct()\n  3572\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3573\t        self.assertEqual(definition[1], [])\n  3574\t        self.assertEqual(\n  3575\t            definition[2],\n  3576\t            {\"model_name\": \"Pony\", \"constraint\": partial_unique_constraint},\n  3577\t        )\n  3578\t\n  3579\t    def test_remove_partial_unique_constraint(self):\n  3580\t        project_state = self.set_up_test_model(\n  3581\t            \"test_removepartialuniqueconstraint\",\n  3582\t            constraints=[\n  3583\t                models.UniqueConstraint(\n  3584\t                    fields=[\"pink\"],\n  3585\t                    condition=models.Q(weight__gt=5),\n  3586\t                    name=\"test_constraint_pony_pink_for_weight_gt_5_uniq\",\n  3587\t                ),\n  3588\t            ],\n  3589\t        )\n  3590\t        gt_operation = migrations.RemoveConstraint(\n  3591\t            \"Pony\", \"test_constraint_pony_pink_for_weight_gt_5_uniq\"\n  3592\t        )\n  3593\t        self.assertEqual(\n  3594\t            gt_operation.describe(),\n  3595\t            \"Remove constraint test_constraint_pony_pink_for_weight_gt_5_uniq from \"\n  3596\t            \"model Pony\",\n  3597\t        )\n  3598\t        # Test state alteration\n  3599\t        new_state = project_state.clone()\n  3600\t        gt_operation.state_forwards(\"test_removepartialuniqueconstraint\", new_state)\n  3601\t        self.assertEqual(\n  3602\t            len(\n  3603\t                new_state.models[\"test_removepartialuniqueconstraint\", \"pony\"].options[\n  3604\t                    \"constraints\"\n  3605\t                ]\n  3606\t            ),\n  3607\t            0,\n  3608\t        )\n  3609\t        Pony = new_state.apps.get_model(\"test_removepartialuniqueconstraint\", \"Pony\")\n  3610\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3611\t        # Test database alteration\n  3612\t        with connection.schema_editor() as editor:\n  3613\t            gt_operation.database_forwards(\n  3614\t                \"test_removepartialuniqueconstraint\", editor, project_state, new_state\n  3615\t            )\n  3616\t        # Test constraint doesn't work\n  3617\t        Pony.objects.create(pink=1, weight=4.0)\n  3618\t        Pony.objects.create(pink=1, weight=4.0)\n  3619\t        Pony.objects.create(pink=1, weight=6.0)\n  3620\t        Pony.objects.create(pink=1, weight=7.0).delete()\n  3621\t        # Test reversal\n  3622\t        with connection.schema_editor() as editor:\n  3623\t            gt_operation.database_backwards(\n  3624\t                \"test_removepartialuniqueconstraint\", editor, new_state, project_state\n  3625\t            )\n  3626\t        # Test constraint works\n  3627\t        if connection.features.supports_partial_indexes:\n  3628\t            with self.assertRaises(IntegrityError), transaction.atomic():\n  3629\t                Pony.objects.create(pink=1, weight=7.0)\n  3630\t        else:\n  3631\t            Pony.objects.create(pink=1, weight=7.0)\n  3632\t        # Test deconstruction\n  3633\t        definition = gt_operation.deconstruct()\n  3634\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3635\t        self.assertEqual(definition[1], [])\n  3636\t        self.assertEqual(\n  3637\t            definition[2],\n  3638\t            {\n  3639\t                \"model_name\": \"Pony\",\n  3640\t                \"name\": \"test_constraint_pony_pink_for_weight_gt_5_uniq\",\n  3641\t            },\n  3642\t        )\n  3643\t\n  3644\t    def test_add_deferred_unique_constraint(self):\n  3645\t        app_label = \"test_adddeferred_uc\"\n  3646\t        project_state = self.set_up_test_model(app_label)\n  3647\t        deferred_unique_constraint = models.UniqueConstraint(\n  3648\t            fields=[\"pink\"],\n  3649\t            name=\"deferred_pink_constraint_add\",\n  3650\t            deferrable=models.Deferrable.DEFERRED,\n  3651\t        )\n  3652\t        operation = migrations.AddConstraint(\"Pony\", deferred_unique_constraint)\n  3653\t        self.assertEqual(\n  3654\t            operation.describe(),\n  3655\t            \"Create constraint deferred_pink_constraint_add on model Pony\",\n  3656\t        )\n  3657\t        # Add constraint.\n  3658\t        new_state = project_state.clone()\n  3659\t        operation.state_forwards(app_label, new_state)\n  3660\t        self.assertEqual(\n  3661\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 1\n  3662\t        )\n  3663\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3664\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3665\t        with connection.schema_editor() as editor, CaptureQueriesContext(\n  3666\t            connection\n  3667\t        ) as ctx:\n  3668\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3669\t        Pony.objects.create(pink=1, weight=4.0)\n  3670\t        if connection.features.supports_deferrable_unique_constraints:\n  3671\t            # Unique constraint is deferred.\n  3672\t            with transaction.atomic():\n  3673\t                obj = Pony.objects.create(pink=1, weight=4.0)\n  3674\t                obj.pink = 2\n  3675\t                obj.save()\n  3676\t            # Constraint behavior can be changed with SET CONSTRAINTS.\n  3677\t            with self.assertRaises(IntegrityError):\n  3678\t                with transaction.atomic(), connection.cursor() as cursor:\n  3679\t                    quoted_name = connection.ops.quote_name(\n  3680\t                        deferred_unique_constraint.name\n  3681\t                    )\n  3682\t                    cursor.execute(\"SET CONSTRAINTS %s IMMEDIATE\" % quoted_name)\n  3683\t                    obj = Pony.objects.create(pink=1, weight=4.0)\n  3684\t                    obj.pink = 3\n  3685\t                    obj.save()\n  3686\t        else:\n  3687\t            self.assertEqual(len(ctx), 0)\n  3688\t            Pony.objects.create(pink=1, weight=4.0)\n  3689\t        # Reversal.\n  3690\t        with connection.schema_editor() as editor:\n  3691\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3692\t        # Constraint doesn't work.\n  3693\t        Pony.objects.create(pink=1, weight=4.0)\n  3694\t        # Deconstruction.\n  3695\t        definition = operation.deconstruct()\n  3696\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3697\t        self.assertEqual(definition[1], [])\n  3698\t        self.assertEqual(\n  3699\t            definition[2],\n  3700\t            {\"model_name\": \"Pony\", \"constraint\": deferred_unique_constraint},\n  3701\t        )\n  3702\t\n  3703\t    def test_remove_deferred_unique_constraint(self):\n  3704\t        app_label = \"test_removedeferred_uc\"\n  3705\t        deferred_unique_constraint = models.UniqueConstraint(\n  3706\t            fields=[\"pink\"],\n  3707\t            name=\"deferred_pink_constraint_rm\",\n  3708\t            deferrable=models.Deferrable.DEFERRED,\n  3709\t        )\n  3710\t        project_state = self.set_up_test_model(\n  3711\t            app_label, constraints=[deferred_unique_constraint]\n  3712\t        )\n  3713\t        operation = migrations.RemoveConstraint(\"Pony\", deferred_unique_constraint.name)\n  3714\t        self.assertEqual(\n  3715\t            operation.describe(),\n  3716\t            \"Remove constraint deferred_pink_constraint_rm from model Pony\",\n  3717\t        )\n  3718\t        # Remove constraint.\n  3719\t        new_state = project_state.clone()\n  3720\t        operation.state_forwards(app_label, new_state)\n  3721\t        self.assertEqual(\n  3722\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 0\n  3723\t        )\n  3724\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3725\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3726\t        with connection.schema_editor() as editor, CaptureQueriesContext(\n  3727\t            connection\n  3728\t        ) as ctx:\n  3729\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3730\t        # Constraint doesn't work.\n  3731\t        Pony.objects.create(pink=1, weight=4.0)\n  3732\t        Pony.objects.create(pink=1, weight=4.0).delete()\n  3733\t        if not connection.features.supports_deferrable_unique_constraints:\n  3734\t            self.assertEqual(len(ctx), 0)\n  3735\t        # Reversal.\n  3736\t        with connection.schema_editor() as editor:\n  3737\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3738\t        if connection.features.supports_deferrable_unique_constraints:\n  3739\t            # Unique constraint is deferred.\n  3740\t            with transaction.atomic():\n  3741\t                obj = Pony.objects.create(pink=1, weight=4.0)\n  3742\t                obj.pink = 2\n  3743\t                obj.save()\n  3744\t            # Constraint behavior can be changed with SET CONSTRAINTS.\n  3745\t            with self.assertRaises(IntegrityError):\n  3746\t                with transaction.atomic(), connection.cursor() as cursor:\n  3747\t                    quoted_name = connection.ops.quote_name(\n  3748\t                        deferred_unique_constraint.name\n  3749\t                    )\n  3750\t                    cursor.execute(\"SET CONSTRAINTS %s IMMEDIATE\" % quoted_name)\n  3751\t                    obj = Pony.objects.create(pink=1, weight=4.0)\n  3752\t                    obj.pink = 3\n  3753\t                    obj.save()\n  3754\t        else:\n  3755\t            Pony.objects.create(pink=1, weight=4.0)\n  3756\t        # Deconstruction.\n  3757\t        definition = operation.deconstruct()\n  3758\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3759\t        self.assertEqual(definition[1], [])\n  3760\t        self.assertEqual(\n  3761\t            definition[2],\n  3762\t            {\n  3763\t                \"model_name\": \"Pony\",\n  3764\t                \"name\": \"deferred_pink_constraint_rm\",\n  3765\t            },\n  3766\t        )\n  3767\t\n  3768\t    def test_add_covering_unique_constraint(self):\n  3769\t        app_label = \"test_addcovering_uc\"\n  3770\t        project_state = self.set_up_test_model(app_label)\n  3771\t        covering_unique_constraint = models.UniqueConstraint(\n  3772\t            fields=[\"pink\"],\n  3773\t            name=\"covering_pink_constraint_add\",\n  3774\t            include=[\"weight\"],\n  3775\t        )\n  3776\t        operation = migrations.AddConstraint(\"Pony\", covering_unique_constraint)\n  3777\t        self.assertEqual(\n  3778\t            operation.describe(),\n  3779\t            \"Create constraint covering_pink_constraint_add on model Pony\",\n  3780\t        )\n  3781\t        # Add constraint.\n  3782\t        new_state = project_state.clone()\n  3783\t        operation.state_forwards(app_label, new_state)\n  3784\t        self.assertEqual(\n  3785\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 1\n  3786\t        )\n  3787\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3788\t        self.assertEqual(len(Pony._meta.constraints), 1)\n  3789\t        with connection.schema_editor() as editor, CaptureQueriesContext(\n  3790\t            connection\n  3791\t        ) as ctx:\n  3792\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3793\t        Pony.objects.create(pink=1, weight=4.0)\n  3794\t        if connection.features.supports_covering_indexes:\n  3795\t            with self.assertRaises(IntegrityError):\n  3796\t                Pony.objects.create(pink=1, weight=4.0)\n  3797\t        else:\n  3798\t            self.assertEqual(len(ctx), 0)\n  3799\t            Pony.objects.create(pink=1, weight=4.0)\n  3800\t        # Reversal.\n  3801\t        with connection.schema_editor() as editor:\n  3802\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3803\t        # Constraint doesn't work.\n  3804\t        Pony.objects.create(pink=1, weight=4.0)\n  3805\t        # Deconstruction.\n  3806\t        definition = operation.deconstruct()\n  3807\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3808\t        self.assertEqual(definition[1], [])\n  3809\t        self.assertEqual(\n  3810\t            definition[2],\n  3811\t            {\"model_name\": \"Pony\", \"constraint\": covering_unique_constraint},\n  3812\t        )\n  3813\t\n  3814\t    def test_remove_covering_unique_constraint(self):\n  3815\t        app_label = \"test_removecovering_uc\"\n  3816\t        covering_unique_constraint = models.UniqueConstraint(\n  3817\t            fields=[\"pink\"],\n  3818\t            name=\"covering_pink_constraint_rm\",\n  3819\t            include=[\"weight\"],\n  3820\t        )\n  3821\t        project_state = self.set_up_test_model(\n  3822\t            app_label, constraints=[covering_unique_constraint]\n  3823\t        )\n  3824\t        operation = migrations.RemoveConstraint(\"Pony\", covering_unique_constraint.name)\n  3825\t        self.assertEqual(\n  3826\t            operation.describe(),\n  3827\t            \"Remove constraint covering_pink_constraint_rm from model Pony\",\n  3828\t        )\n  3829\t        # Remove constraint.\n  3830\t        new_state = project_state.clone()\n  3831\t        operation.state_forwards(app_label, new_state)\n  3832\t        self.assertEqual(\n  3833\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 0\n  3834\t        )\n  3835\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3836\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3837\t        with connection.schema_editor() as editor, CaptureQueriesContext(\n  3838\t            connection\n  3839\t        ) as ctx:\n  3840\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3841\t        # Constraint doesn't work.\n  3842\t        Pony.objects.create(pink=1, weight=4.0)\n  3843\t        Pony.objects.create(pink=1, weight=4.0).delete()\n  3844\t        if not connection.features.supports_covering_indexes:\n  3845\t            self.assertEqual(len(ctx), 0)\n  3846\t        # Reversal.\n  3847\t        with connection.schema_editor() as editor:\n  3848\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3849\t        if connection.features.supports_covering_indexes:\n  3850\t            with self.assertRaises(IntegrityError):\n  3851\t                Pony.objects.create(pink=1, weight=4.0)\n  3852\t        else:\n  3853\t            Pony.objects.create(pink=1, weight=4.0)\n  3854\t        # Deconstruction.\n  3855\t        definition = operation.deconstruct()\n  3856\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3857\t        self.assertEqual(definition[1], [])\n  3858\t        self.assertEqual(\n  3859\t            definition[2],\n  3860\t            {\n  3861\t                \"model_name\": \"Pony\",\n  3862\t                \"name\": \"covering_pink_constraint_rm\",\n  3863\t            },\n  3864\t        )\n  3865\t\n  3866\t    def test_alter_field_with_func_unique_constraint(self):\n  3867\t        app_label = \"test_alfuncuc\"\n  3868\t        constraint_name = f\"{app_label}_pony_uq\"\n  3869\t        table_name = f\"{app_label}_pony\"\n  3870\t        project_state = self.set_up_test_model(\n  3871\t            app_label,\n  3872\t            constraints=[\n  3873\t                models.UniqueConstraint(\"pink\", \"weight\", name=constraint_name)\n  3874\t            ],\n  3875\t        )\n  3876\t        operation = migrations.AlterField(\n  3877\t            \"Pony\", \"pink\", models.IntegerField(null=True)\n  3878\t        )\n  3879\t        new_state = project_state.clone()\n  3880\t        operation.state_forwards(app_label, new_state)\n  3881\t        with connection.schema_editor() as editor:\n  3882\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3883\t        if connection.features.supports_expression_indexes:\n  3884\t            self.assertIndexNameExists(table_name, constraint_name)\n  3885\t        with connection.schema_editor() as editor:\n  3886\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3887\t        if connection.features.supports_expression_indexes:\n  3888\t            self.assertIndexNameExists(table_name, constraint_name)\n  3889\t\n  3890\t    def test_add_func_unique_constraint(self):\n  3891\t        app_label = \"test_adfuncuc\"\n  3892\t        constraint_name = f\"{app_label}_pony_abs_uq\"\n  3893\t        table_name = f\"{app_label}_pony\"\n  3894\t        project_state = self.set_up_test_model(app_label)\n  3895\t        constraint = models.UniqueConstraint(Abs(\"weight\"), name=constraint_name)\n  3896\t        operation = migrations.AddConstraint(\"Pony\", constraint)\n  3897\t        self.assertEqual(\n  3898\t            operation.describe(),\n  3899\t            \"Create constraint test_adfuncuc_pony_abs_uq on model Pony\",\n  3900\t        )\n  3901\t        self.assertEqual(\n  3902\t            operation.migration_name_fragment,\n  3903\t            \"pony_test_adfuncuc_pony_abs_uq\",\n  3904\t        )\n  3905\t        new_state = project_state.clone()\n  3906\t        operation.state_forwards(app_label, new_state)\n  3907\t        self.assertEqual(\n  3908\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 1\n  3909\t        )\n  3910\t        self.assertIndexNameNotExists(table_name, constraint_name)\n  3911\t        # Add constraint.\n  3912\t        with connection.schema_editor() as editor:\n  3913\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3914\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3915\t        Pony.objects.create(weight=4.0)\n  3916\t        if connection.features.supports_expression_indexes:\n  3917\t            self.assertIndexNameExists(table_name, constraint_name)\n  3918\t            with self.assertRaises(IntegrityError):\n  3919\t                Pony.objects.create(weight=-4.0)\n  3920\t        else:\n  3921\t            self.assertIndexNameNotExists(table_name, constraint_name)\n  3922\t            Pony.objects.create(weight=-4.0)\n  3923\t        # Reversal.\n  3924\t        with connection.schema_editor() as editor:\n  3925\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3926\t        self.assertIndexNameNotExists(table_name, constraint_name)\n  3927\t        # Constraint doesn't work.\n  3928\t        Pony.objects.create(weight=-4.0)\n  3929\t        # Deconstruction.\n  3930\t        definition = operation.deconstruct()\n  3931\t        self.assertEqual(definition[0], \"AddConstraint\")\n  3932\t        self.assertEqual(definition[1], [])\n  3933\t        self.assertEqual(\n  3934\t            definition[2],\n  3935\t            {\"model_name\": \"Pony\", \"constraint\": constraint},\n  3936\t        )\n  3937\t\n  3938\t    def test_remove_func_unique_constraint(self):\n  3939\t        app_label = \"test_rmfuncuc\"\n  3940\t        constraint_name = f\"{app_label}_pony_abs_uq\"\n  3941\t        table_name = f\"{app_label}_pony\"\n  3942\t        project_state = self.set_up_test_model(\n  3943\t            app_label,\n  3944\t            constraints=[\n  3945\t                models.UniqueConstraint(Abs(\"weight\"), name=constraint_name),\n  3946\t            ],\n  3947\t        )\n  3948\t        self.assertTableExists(table_name)\n  3949\t        if connection.features.supports_expression_indexes:\n  3950\t            self.assertIndexNameExists(table_name, constraint_name)\n  3951\t        operation = migrations.RemoveConstraint(\"Pony\", constraint_name)\n  3952\t        self.assertEqual(\n  3953\t            operation.describe(),\n  3954\t            \"Remove constraint test_rmfuncuc_pony_abs_uq from model Pony\",\n  3955\t        )\n  3956\t        self.assertEqual(\n  3957\t            operation.migration_name_fragment,\n  3958\t            \"remove_pony_test_rmfuncuc_pony_abs_uq\",\n  3959\t        )\n  3960\t        new_state = project_state.clone()\n  3961\t        operation.state_forwards(app_label, new_state)\n  3962\t        self.assertEqual(\n  3963\t            len(new_state.models[app_label, \"pony\"].options[\"constraints\"]), 0\n  3964\t        )\n  3965\t        Pony = new_state.apps.get_model(app_label, \"Pony\")\n  3966\t        self.assertEqual(len(Pony._meta.constraints), 0)\n  3967\t        # Remove constraint.\n  3968\t        with connection.schema_editor() as editor:\n  3969\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  3970\t        self.assertIndexNameNotExists(table_name, constraint_name)\n  3971\t        # Constraint doesn't work.\n  3972\t        Pony.objects.create(pink=1, weight=4.0)\n  3973\t        Pony.objects.create(pink=1, weight=-4.0).delete()\n  3974\t        # Reversal.\n  3975\t        with connection.schema_editor() as editor:\n  3976\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  3977\t        if connection.features.supports_expression_indexes:\n  3978\t            self.assertIndexNameExists(table_name, constraint_name)\n  3979\t            with self.assertRaises(IntegrityError):\n  3980\t                Pony.objects.create(weight=-4.0)\n  3981\t        else:\n  3982\t            self.assertIndexNameNotExists(table_name, constraint_name)\n  3983\t            Pony.objects.create(weight=-4.0)\n  3984\t        # Deconstruction.\n  3985\t        definition = operation.deconstruct()\n  3986\t        self.assertEqual(definition[0], \"RemoveConstraint\")\n  3987\t        self.assertEqual(definition[1], [])\n  3988\t        self.assertEqual(definition[2], {\"model_name\": \"Pony\", \"name\": constraint_name})\n  3989\t\n  3990\t    def test_alter_model_options(self):\n  3991\t        \"\"\"\n  3992\t        Tests the AlterModelOptions operation.\n  3993\t        \"\"\"\n  3994\t        project_state = self.set_up_test_model(\"test_almoop\")\n  3995\t        # Test the state alteration (no DB alteration to test)\n  3996\t        operation = migrations.AlterModelOptions(\n  3997\t            \"Pony\", {\"permissions\": [(\"can_groom\", \"Can groom\")]}\n  3998\t        )\n  3999\t        self.assertEqual(operation.describe(), \"Change Meta options on Pony\")\n  4000\t        self.assertEqual(operation.migration_name_fragment, \"alter_pony_options\")\n  4001\t        new_state = project_state.clone()\n  4002\t        operation.state_forwards(\"test_almoop\", new_state)\n  4003\t        self.assertEqual(\n  4004\t            len(\n  4005\t                project_state.models[\"test_almoop\", \"pony\"].options.get(\n  4006\t                    \"permissions\", []\n  4007\t                )\n  4008\t            ),\n  4009\t            0,\n  4010\t        )\n  4011\t        self.assertEqual(\n  4012\t            len(new_state.models[\"test_almoop\", \"pony\"].options.get(\"permissions\", [])),\n  4013\t            1,\n  4014\t        )\n  4015\t        self.assertEqual(\n  4016\t            new_state.models[\"test_almoop\", \"pony\"].options[\"permissions\"][0][0],\n  4017\t            \"can_groom\",\n  4018\t        )\n  4019\t        # And deconstruction\n  4020\t        definition = operation.deconstruct()\n  4021\t        self.assertEqual(definition[0], \"AlterModelOptions\")\n  4022\t        self.assertEqual(definition[1], [])\n  4023\t        self.assertEqual(\n  4024\t            definition[2],\n  4025\t            {\"name\": \"Pony\", \"options\": {\"permissions\": [(\"can_groom\", \"Can groom\")]}},\n  4026\t        )\n  4027\t\n  4028\t    def test_alter_model_options_emptying(self):\n  4029\t        \"\"\"\n  4030\t        The AlterModelOptions operation removes keys from the dict (#23121)\n  4031\t        \"\"\"\n  4032\t        project_state = self.set_up_test_model(\"test_almoop\", options=True)\n  4033\t        # Test the state alteration (no DB alteration to test)\n  4034\t        operation = migrations.AlterModelOptions(\"Pony\", {})\n  4035\t        self.assertEqual(operation.describe(), \"Change Meta options on Pony\")\n  4036\t        new_state = project_state.clone()\n  4037\t        operation.state_forwards(\"test_almoop\", new_state)\n  4038\t        self.assertEqual(\n  4039\t            len(\n  4040\t                project_state.models[\"test_almoop\", \"pony\"].options.get(\n  4041\t                    \"permissions\", []\n  4042\t                )\n  4043\t            ),\n  4044\t            1,\n  4045\t        )\n  4046\t        self.assertEqual(\n  4047\t            len(new_state.models[\"test_almoop\", \"pony\"].options.get(\"permissions\", [])),\n  4048\t            0,\n  4049\t        )\n  4050\t        # And deconstruction\n  4051\t        definition = operation.deconstruct()\n  4052\t        self.assertEqual(definition[0], \"AlterModelOptions\")\n  4053\t        self.assertEqual(definition[1], [])\n  4054\t        self.assertEqual(definition[2], {\"name\": \"Pony\", \"options\": {}})\n  4055\t\n  4056\t    def test_alter_order_with_respect_to(self):\n  4057\t        \"\"\"\n  4058\t        Tests the AlterOrderWithRespectTo operation.\n  4059\t        \"\"\"\n  4060\t        project_state = self.set_up_test_model(\"test_alorwrtto\", related_model=True)\n  4061\t        # Test the state alteration\n  4062\t        operation = migrations.AlterOrderWithRespectTo(\"Rider\", \"pony\")\n  4063\t        self.assertEqual(\n  4064\t            operation.describe(), \"Set order_with_respect_to on Rider to pony\"\n  4065\t        )\n  4066\t        self.assertEqual(\n  4067\t            operation.migration_name_fragment,\n  4068\t            \"alter_rider_order_with_respect_to\",\n  4069\t        )\n  4070\t        new_state = project_state.clone()\n  4071\t        operation.state_forwards(\"test_alorwrtto\", new_state)\n  4072\t        self.assertIsNone(\n  4073\t            project_state.models[\"test_alorwrtto\", \"rider\"].options.get(\n  4074\t                \"order_with_respect_to\", None\n  4075\t            )\n  4076\t        )\n  4077\t        self.assertEqual(\n  4078\t            new_state.models[\"test_alorwrtto\", \"rider\"].options.get(\n  4079\t                \"order_with_respect_to\", None\n  4080\t            ),\n  4081\t            \"pony\",\n  4082\t        )\n  4083\t        # Make sure there's no matching index\n  4084\t        self.assertColumnNotExists(\"test_alorwrtto_rider\", \"_order\")\n  4085\t        # Create some rows before alteration\n  4086\t        rendered_state = project_state.apps\n  4087\t        pony = rendered_state.get_model(\"test_alorwrtto\", \"Pony\").objects.create(\n  4088\t            weight=50\n  4089\t        )\n  4090\t        rider1 = rendered_state.get_model(\"test_alorwrtto\", \"Rider\").objects.create(\n  4091\t            pony=pony\n  4092\t        )\n  4093\t        rider1.friend = rider1\n  4094\t        rider1.save()\n  4095\t        rider2 = rendered_state.get_model(\"test_alorwrtto\", \"Rider\").objects.create(\n  4096\t            pony=pony\n  4097\t        )\n  4098\t        rider2.friend = rider2\n  4099\t        rider2.save()\n  4100\t        # Test the database alteration\n  4101\t        with connection.schema_editor() as editor:\n  4102\t            operation.database_forwards(\n  4103\t                \"test_alorwrtto\", editor, project_state, new_state\n  4104\t            )\n  4105\t        self.assertColumnExists(\"test_alorwrtto_rider\", \"_order\")\n  4106\t        # Check for correct value in rows\n  4107\t        updated_riders = new_state.apps.get_model(\n  4108\t            \"test_alorwrtto\", \"Rider\"\n  4109\t        ).objects.all()\n  4110\t        self.assertEqual(updated_riders[0]._order, 0)\n  4111\t        self.assertEqual(updated_riders[1]._order, 0)\n  4112\t        # And test reversal\n  4113\t        with connection.schema_editor() as editor:\n  4114\t            operation.database_backwards(\n  4115\t                \"test_alorwrtto\", editor, new_state, project_state\n  4116\t            )\n  4117\t        self.assertColumnNotExists(\"test_alorwrtto_rider\", \"_order\")\n  4118\t        # And deconstruction\n  4119\t        definition = operation.deconstruct()\n  4120\t        self.assertEqual(definition[0], \"AlterOrderWithRespectTo\")\n  4121\t        self.assertEqual(definition[1], [])\n  4122\t        self.assertEqual(\n  4123\t            definition[2], {\"name\": \"Rider\", \"order_with_respect_to\": \"pony\"}\n  4124\t        )\n  4125\t\n  4126\t    def test_alter_model_managers(self):\n  4127\t        \"\"\"\n  4128\t        The managers on a model are set.\n  4129\t        \"\"\"\n  4130\t        project_state = self.set_up_test_model(\"test_almoma\")\n  4131\t        # Test the state alteration\n  4132\t        operation = migrations.AlterModelManagers(\n  4133\t            \"Pony\",\n  4134\t            managers=[\n  4135\t                (\"food_qs\", FoodQuerySet.as_manager()),\n  4136\t                (\"food_mgr\", FoodManager(\"a\", \"b\")),\n  4137\t                (\"food_mgr_kwargs\", FoodManager(\"x\", \"y\", 3, 4)),\n  4138\t            ],\n  4139\t        )\n  4140\t        self.assertEqual(operation.describe(), \"Change managers on Pony\")\n  4141\t        self.assertEqual(operation.migration_name_fragment, \"alter_pony_managers\")\n  4142\t        managers = project_state.models[\"test_almoma\", \"pony\"].managers\n  4143\t        self.assertEqual(managers, [])\n  4144\t\n  4145\t        new_state = project_state.clone()\n  4146\t        operation.state_forwards(\"test_almoma\", new_state)\n  4147\t        self.assertIn((\"test_almoma\", \"pony\"), new_state.models)\n  4148\t        managers = new_state.models[\"test_almoma\", \"pony\"].managers\n  4149\t        self.assertEqual(managers[0][0], \"food_qs\")\n  4150\t        self.assertIsInstance(managers[0][1], models.Manager)\n  4151\t        self.assertEqual(managers[1][0], \"food_mgr\")\n  4152\t        self.assertIsInstance(managers[1][1], FoodManager)\n  4153\t        self.assertEqual(managers[1][1].args, (\"a\", \"b\", 1, 2))\n  4154\t        self.assertEqual(managers[2][0], \"food_mgr_kwargs\")\n  4155\t        self.assertIsInstance(managers[2][1], FoodManager)\n  4156\t        self.assertEqual(managers[2][1].args, (\"x\", \"y\", 3, 4))\n  4157\t        rendered_state = new_state.apps\n  4158\t        model = rendered_state.get_model(\"test_almoma\", \"pony\")\n  4159\t        self.assertIsInstance(model.food_qs, models.Manager)\n  4160\t        self.assertIsInstance(model.food_mgr, FoodManager)\n  4161\t        self.assertIsInstance(model.food_mgr_kwargs, FoodManager)\n  4162\t\n  4163\t    def test_alter_model_managers_emptying(self):\n  4164\t        \"\"\"\n  4165\t        The managers on a model are set.\n  4166\t        \"\"\"\n  4167\t        project_state = self.set_up_test_model(\"test_almomae\", manager_model=True)\n  4168\t        # Test the state alteration\n  4169\t        operation = migrations.AlterModelManagers(\"Food\", managers=[])\n  4170\t        self.assertEqual(operation.describe(), \"Change managers on Food\")\n  4171\t        self.assertIn((\"test_almomae\", \"food\"), project_state.models)\n  4172\t        managers = project_state.models[\"test_almomae\", \"food\"].managers\n  4173\t        self.assertEqual(managers[0][0], \"food_qs\")\n  4174\t        self.assertIsInstance(managers[0][1], models.Manager)\n  4175\t        self.assertEqual(managers[1][0], \"food_mgr\")\n  4176\t        self.assertIsInstance(managers[1][1], FoodManager)\n  4177\t        self.assertEqual(managers[1][1].args, (\"a\", \"b\", 1, 2))\n  4178\t        self.assertEqual(managers[2][0], \"food_mgr_kwargs\")\n  4179\t        self.assertIsInstance(managers[2][1], FoodManager)\n  4180\t        self.assertEqual(managers[2][1].args, (\"x\", \"y\", 3, 4))\n  4181\t\n  4182\t        new_state = project_state.clone()\n  4183\t        operation.state_forwards(\"test_almomae\", new_state)\n  4184\t        managers = new_state.models[\"test_almomae\", \"food\"].managers\n  4185\t        self.assertEqual(managers, [])\n  4186\t\n  4187\t    def test_alter_fk(self):\n  4188\t        \"\"\"\n  4189\t        Creating and then altering an FK works correctly\n  4190\t        and deals with the pending SQL (#23091)\n  4191\t        \"\"\"\n  4192\t        project_state = self.set_up_test_model(\"test_alfk\")\n  4193\t        # Test adding and then altering the FK in one go\n  4194\t        create_operation = migrations.CreateModel(\n  4195\t            name=\"Rider\",\n  4196\t            fields=[\n  4197\t                (\"id\", models.AutoField(primary_key=True)),\n  4198\t                (\"pony\", models.ForeignKey(\"Pony\", models.CASCADE)),\n  4199\t            ],\n  4200\t        )\n  4201\t        create_state = project_state.clone()\n  4202\t        create_operation.state_forwards(\"test_alfk\", create_state)\n  4203\t        alter_operation = migrations.AlterField(\n  4204\t            model_name=\"Rider\",\n  4205\t            name=\"pony\",\n  4206\t            field=models.ForeignKey(\"Pony\", models.CASCADE, editable=False),\n  4207\t        )\n  4208\t        alter_state = create_state.clone()\n  4209\t        alter_operation.state_forwards(\"test_alfk\", alter_state)\n  4210\t        with connection.schema_editor() as editor:\n  4211\t            create_operation.database_forwards(\n  4212\t                \"test_alfk\", editor, project_state, create_state\n  4213\t            )\n  4214\t            alter_operation.database_forwards(\n  4215\t                \"test_alfk\", editor, create_state, alter_state\n  4216\t            )\n  4217\t\n  4218\t    def test_alter_fk_non_fk(self):\n  4219\t        \"\"\"\n  4220\t        Altering an FK to a non-FK works (#23244)\n  4221\t        \"\"\"\n  4222\t        # Test the state alteration\n  4223\t        operation = migrations.AlterField(\n  4224\t            model_name=\"Rider\",\n  4225\t            name=\"pony\",\n  4226\t            field=models.FloatField(),\n  4227\t        )\n  4228\t        project_state, new_state = self.make_test_state(\n  4229\t            \"test_afknfk\", operation, related_model=True\n  4230\t        )\n  4231\t        # Test the database alteration\n  4232\t        self.assertColumnExists(\"test_afknfk_rider\", \"pony_id\")\n  4233\t        self.assertColumnNotExists(\"test_afknfk_rider\", \"pony\")\n  4234\t        with connection.schema_editor() as editor:\n  4235\t            operation.database_forwards(\"test_afknfk\", editor, project_state, new_state)\n  4236\t        self.assertColumnExists(\"test_afknfk_rider\", \"pony\")\n  4237\t        self.assertColumnNotExists(\"test_afknfk_rider\", \"pony_id\")\n  4238\t        # And test reversal\n  4239\t        with connection.schema_editor() as editor:\n  4240\t            operation.database_backwards(\n  4241\t                \"test_afknfk\", editor, new_state, project_state\n  4242\t            )\n  4243\t        self.assertColumnExists(\"test_afknfk_rider\", \"pony_id\")\n  4244\t        self.assertColumnNotExists(\"test_afknfk_rider\", \"pony\")\n  4245\t\n  4246\t    def test_run_sql(self):\n  4247\t        \"\"\"\n  4248\t        Tests the RunSQL operation.\n  4249\t        \"\"\"\n  4250\t        project_state = self.set_up_test_model(\"test_runsql\")\n  4251\t        # Create the operation\n  4252\t        operation = migrations.RunSQL(\n  4253\t            # Use a multi-line string with a comment to test splitting on\n  4254\t            # SQLite and MySQL respectively.\n  4255\t            \"CREATE TABLE i_love_ponies (id int, special_thing varchar(15));\\n\"\n  4256\t            \"INSERT INTO i_love_ponies (id, special_thing) \"\n  4257\t            \"VALUES (1, 'i love ponies'); -- this is magic!\\n\"\n  4258\t            \"INSERT INTO i_love_ponies (id, special_thing) \"\n  4259\t            \"VALUES (2, 'i love django');\\n\"\n  4260\t            \"UPDATE i_love_ponies SET special_thing = 'Ponies' \"\n  4261\t            \"WHERE special_thing LIKE '%%ponies';\"\n  4262\t            \"UPDATE i_love_ponies SET special_thing = 'Django' \"\n  4263\t            \"WHERE special_thing LIKE '%django';\",\n  4264\t            # Run delete queries to test for parameter substitution failure\n  4265\t            # reported in #23426\n  4266\t            \"DELETE FROM i_love_ponies WHERE special_thing LIKE '%Django%';\"\n  4267\t            \"DELETE FROM i_love_ponies WHERE special_thing LIKE '%%Ponies%%';\"\n  4268\t            \"DROP TABLE i_love_ponies\",\n  4269\t            state_operations=[\n  4270\t                migrations.CreateModel(\n  4271\t                    \"SomethingElse\", [(\"id\", models.AutoField(primary_key=True))]\n  4272\t                )\n  4273\t            ],\n  4274\t        )\n  4275\t        self.assertEqual(operation.describe(), \"Raw SQL operation\")\n  4276\t        # Test the state alteration\n  4277\t        new_state = project_state.clone()\n  4278\t        operation.state_forwards(\"test_runsql\", new_state)\n  4279\t        self.assertEqual(\n  4280\t            len(new_state.models[\"test_runsql\", \"somethingelse\"].fields), 1\n  4281\t        )\n  4282\t        # Make sure there's no table\n  4283\t        self.assertTableNotExists(\"i_love_ponies\")\n  4284\t        # Test SQL collection\n  4285\t        with connection.schema_editor(collect_sql=True) as editor:\n  4286\t            operation.database_forwards(\"test_runsql\", editor, project_state, new_state)\n  4287\t            self.assertIn(\"LIKE '%%ponies';\", \"\\n\".join(editor.collected_sql))\n  4288\t            operation.database_backwards(\n  4289\t                \"test_runsql\", editor, project_state, new_state\n  4290\t            )\n  4291\t            self.assertIn(\"LIKE '%%Ponies%%';\", \"\\n\".join(editor.collected_sql))\n  4292\t        # Test the database alteration\n  4293\t        with connection.schema_editor() as editor:\n  4294\t            operation.database_forwards(\"test_runsql\", editor, project_state, new_state)\n  4295\t        self.assertTableExists(\"i_love_ponies\")\n  4296\t        # Make sure all the SQL was processed\n  4297\t        with connection.cursor() as cursor:\n  4298\t            cursor.execute(\"SELECT COUNT(*) FROM i_love_ponies\")\n  4299\t            self.assertEqual(cursor.fetchall()[0][0], 2)\n  4300\t            cursor.execute(\n  4301\t                \"SELECT COUNT(*) FROM i_love_ponies WHERE special_thing = 'Django'\"\n  4302\t            )\n  4303\t            self.assertEqual(cursor.fetchall()[0][0], 1)\n  4304\t            cursor.execute(\n  4305\t                \"SELECT COUNT(*) FROM i_love_ponies WHERE special_thing = 'Ponies'\"\n  4306\t            )\n  4307\t            self.assertEqual(cursor.fetchall()[0][0], 1)\n  4308\t        # And test reversal\n  4309\t        self.assertTrue(operation.reversible)\n  4310\t        with connection.schema_editor() as editor:\n  4311\t            operation.database_backwards(\n  4312\t                \"test_runsql\", editor, new_state, project_state\n  4313\t            )\n  4314\t        self.assertTableNotExists(\"i_love_ponies\")\n  4315\t        # And deconstruction\n  4316\t        definition = operation.deconstruct()\n  4317\t        self.assertEqual(definition[0], \"RunSQL\")\n  4318\t        self.assertEqual(definition[1], [])\n  4319\t        self.assertEqual(\n  4320\t            sorted(definition[2]), [\"reverse_sql\", \"sql\", \"state_operations\"]\n  4321\t        )\n  4322\t        # And elidable reduction\n  4323\t        self.assertIs(False, operation.reduce(operation, []))\n  4324\t        elidable_operation = migrations.RunSQL(\"SELECT 1 FROM void;\", elidable=True)\n  4325\t        self.assertEqual(elidable_operation.reduce(operation, []), [operation])\n  4326\t\n  4327\t    def test_run_sql_params(self):\n  4328\t        \"\"\"\n  4329\t        #23426 - RunSQL should accept parameters.\n  4330\t        \"\"\"\n  4331\t        project_state = self.set_up_test_model(\"test_runsql\")\n  4332\t        # Create the operation\n  4333\t        operation = migrations.RunSQL(\n  4334\t            [\"CREATE TABLE i_love_ponies (id int, special_thing varchar(15));\"],\n  4335\t            [\"DROP TABLE i_love_ponies\"],\n  4336\t        )\n  4337\t        param_operation = migrations.RunSQL(\n  4338\t            # forwards\n  4339\t            (\n  4340\t                \"INSERT INTO i_love_ponies (id, special_thing) VALUES (1, 'Django');\",\n  4341\t                [\n  4342\t                    \"INSERT INTO i_love_ponies (id, special_thing) VALUES (2, %s);\",\n  4343\t                    [\"Ponies\"],\n  4344\t                ],\n  4345\t                (\n  4346\t                    \"INSERT INTO i_love_ponies (id, special_thing) VALUES (%s, %s);\",\n  4347\t                    (\n  4348\t                        3,\n  4349\t                        \"Python\",\n  4350\t                    ),\n  4351\t                ),\n  4352\t            ),\n  4353\t            # backwards\n  4354\t            [\n  4355\t                \"DELETE FROM i_love_ponies WHERE special_thing = 'Django';\",\n  4356\t                [\"DELETE FROM i_love_ponies WHERE special_thing = 'Ponies';\", None],\n  4357\t                (\n  4358\t                    \"DELETE FROM i_love_ponies WHERE id = %s OR special_thing = %s;\",\n  4359\t                    [3, \"Python\"],\n  4360\t                ),\n  4361\t            ],\n  4362\t        )\n  4363\t\n  4364\t        # Make sure there's no table\n  4365\t        self.assertTableNotExists(\"i_love_ponies\")\n  4366\t        new_state = project_state.clone()\n  4367\t        # Test the database alteration\n  4368\t        with connection.schema_editor() as editor:\n  4369\t            operation.database_forwards(\"test_runsql\", editor, project_state, new_state)\n  4370\t\n  4371\t        # Test parameter passing\n  4372\t        with connection.schema_editor() as editor:\n  4373\t            param_operation.database_forwards(\n  4374\t                \"test_runsql\", editor, project_state, new_state\n  4375\t            )\n  4376\t        # Make sure all the SQL was processed\n  4377\t        with connection.cursor() as cursor:\n  4378\t            cursor.execute(\"SELECT COUNT(*) FROM i_love_ponies\")\n  4379\t            self.assertEqual(cursor.fetchall()[0][0], 3)\n  4380\t\n  4381\t        with connection.schema_editor() as editor:\n  4382\t            param_operation.database_backwards(\n  4383\t                \"test_runsql\", editor, new_state, project_state\n  4384\t            )\n  4385\t        with connection.cursor() as cursor:\n  4386\t            cursor.execute(\"SELECT COUNT(*) FROM i_love_ponies\")\n  4387\t            self.assertEqual(cursor.fetchall()[0][0], 0)\n  4388\t\n  4389\t        # And test reversal\n  4390\t        with connection.schema_editor() as editor:\n  4391\t            operation.database_backwards(\n  4392\t                \"test_runsql\", editor, new_state, project_state\n  4393\t            )\n  4394\t        self.assertTableNotExists(\"i_love_ponies\")\n  4395\t\n  4396\t    def test_run_sql_params_invalid(self):\n  4397\t        \"\"\"\n  4398\t        #23426 - RunSQL should fail when a list of statements with an incorrect\n  4399\t        number of tuples is given.\n  4400\t        \"\"\"\n  4401\t        project_state = self.set_up_test_model(\"test_runsql\")\n  4402\t        new_state = project_state.clone()\n  4403\t        operation = migrations.RunSQL(\n  4404\t            # forwards\n  4405\t            [[\"INSERT INTO foo (bar) VALUES ('buz');\"]],\n  4406\t            # backwards\n  4407\t            ((\"DELETE FROM foo WHERE bar = 'buz';\", \"invalid\", \"parameter count\"),),\n  4408\t        )\n  4409\t\n  4410\t        with connection.schema_editor() as editor:\n  4411\t            with self.assertRaisesMessage(ValueError, \"Expected a 2-tuple but got 1\"):\n  4412\t                operation.database_forwards(\n  4413\t                    \"test_runsql\", editor, project_state, new_state\n  4414\t                )\n  4415\t\n  4416\t        with connection.schema_editor() as editor:\n  4417\t            with self.assertRaisesMessage(ValueError, \"Expected a 2-tuple but got 3\"):\n  4418\t                operation.database_backwards(\n  4419\t                    \"test_runsql\", editor, new_state, project_state\n  4420\t                )\n  4421\t\n  4422\t    def test_run_sql_noop(self):\n  4423\t        \"\"\"\n  4424\t        #24098 - Tests no-op RunSQL operations.\n  4425\t        \"\"\"\n  4426\t        operation = migrations.RunSQL(migrations.RunSQL.noop, migrations.RunSQL.noop)\n  4427\t        with connection.schema_editor() as editor:\n  4428\t            operation.database_forwards(\"test_runsql\", editor, None, None)\n  4429\t            operation.database_backwards(\"test_runsql\", editor, None, None)\n  4430\t\n  4431\t    def test_run_sql_add_missing_semicolon_on_collect_sql(self):\n  4432\t        project_state = self.set_up_test_model(\"test_runsql\")\n  4433\t        new_state = project_state.clone()\n  4434\t        tests = [\n  4435\t            \"INSERT INTO test_runsql_pony (pink, weight) VALUES (1, 1);\\n\",\n  4436\t            \"INSERT INTO test_runsql_pony (pink, weight) VALUES (1, 1)\\n\",\n  4437\t        ]\n  4438\t        for sql in tests:\n  4439\t            with self.subTest(sql=sql):\n  4440\t                operation = migrations.RunSQL(sql, migrations.RunPython.noop)\n  4441\t                with connection.schema_editor(collect_sql=True) as editor:\n  4442\t                    operation.database_forwards(\n  4443\t                        \"test_runsql\", editor, project_state, new_state\n  4444\t                    )\n  4445\t                    collected_sql = \"\\n\".join(editor.collected_sql)\n  4446\t                    self.assertEqual(collected_sql.count(\";\"), 1)\n  4447\t\n  4448\t    def test_run_python(self):\n  4449\t        \"\"\"\n  4450\t        Tests the RunPython operation\n  4451\t        \"\"\"\n  4452\t\n  4453\t        project_state = self.set_up_test_model(\"test_runpython\", mti_model=True)\n  4454\t\n  4455\t        # Create the operation\n  4456\t        def inner_method(models, schema_editor):\n  4457\t            Pony = models.get_model(\"test_runpython\", \"Pony\")\n  4458\t            Pony.objects.create(pink=1, weight=3.55)\n  4459\t            Pony.objects.create(weight=5)\n  4460\t\n  4461\t        def inner_method_reverse(models, schema_editor):\n  4462\t            Pony = models.get_model(\"test_runpython\", \"Pony\")\n  4463\t            Pony.objects.filter(pink=1, weight=3.55).delete()\n  4464\t            Pony.objects.filter(weight=5).delete()\n  4465\t\n  4466\t        operation = migrations.RunPython(\n  4467\t            inner_method, reverse_code=inner_method_reverse\n  4468\t        )\n  4469\t        self.assertEqual(operation.describe(), \"Raw Python operation\")\n  4470\t        # Test the state alteration does nothing\n  4471\t        new_state = project_state.clone()\n  4472\t        operation.state_forwards(\"test_runpython\", new_state)\n  4473\t        self.assertEqual(new_state, project_state)\n  4474\t        # Test the database alteration\n  4475\t        self.assertEqual(\n  4476\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 0\n  4477\t        )\n  4478\t        with connection.schema_editor() as editor:\n  4479\t            operation.database_forwards(\n  4480\t                \"test_runpython\", editor, project_state, new_state\n  4481\t            )\n  4482\t        self.assertEqual(\n  4483\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 2\n  4484\t        )\n  4485\t        # Now test reversal\n  4486\t        self.assertTrue(operation.reversible)\n  4487\t        with connection.schema_editor() as editor:\n  4488\t            operation.database_backwards(\n  4489\t                \"test_runpython\", editor, project_state, new_state\n  4490\t            )\n  4491\t        self.assertEqual(\n  4492\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 0\n  4493\t        )\n  4494\t        # Now test we can't use a string\n  4495\t        with self.assertRaisesMessage(\n  4496\t            ValueError, \"RunPython must be supplied with a callable\"\n  4497\t        ):\n  4498\t            migrations.RunPython(\"print 'ahahaha'\")\n  4499\t        # And deconstruction\n  4500\t        definition = operation.deconstruct()\n  4501\t        self.assertEqual(definition[0], \"RunPython\")\n  4502\t        self.assertEqual(definition[1], [])\n  4503\t        self.assertEqual(sorted(definition[2]), [\"code\", \"reverse_code\"])\n  4504\t\n  4505\t        # Also test reversal fails, with an operation identical to above but\n  4506\t        # without reverse_code set.\n  4507\t        no_reverse_operation = migrations.RunPython(inner_method)\n  4508\t        self.assertFalse(no_reverse_operation.reversible)\n  4509\t        with connection.schema_editor() as editor:\n  4510\t            no_reverse_operation.database_forwards(\n  4511\t                \"test_runpython\", editor, project_state, new_state\n  4512\t            )\n  4513\t            with self.assertRaises(NotImplementedError):\n  4514\t                no_reverse_operation.database_backwards(\n  4515\t                    \"test_runpython\", editor, new_state, project_state\n  4516\t                )\n  4517\t        self.assertEqual(\n  4518\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 2\n  4519\t        )\n  4520\t\n  4521\t        def create_ponies(models, schema_editor):\n  4522\t            Pony = models.get_model(\"test_runpython\", \"Pony\")\n  4523\t            pony1 = Pony.objects.create(pink=1, weight=3.55)\n  4524\t            self.assertIsNot(pony1.pk, None)\n  4525\t            pony2 = Pony.objects.create(weight=5)\n  4526\t            self.assertIsNot(pony2.pk, None)\n  4527\t            self.assertNotEqual(pony1.pk, pony2.pk)\n  4528\t\n  4529\t        operation = migrations.RunPython(create_ponies)\n  4530\t        with connection.schema_editor() as editor:\n  4531\t            operation.database_forwards(\n  4532\t                \"test_runpython\", editor, project_state, new_state\n  4533\t            )\n  4534\t        self.assertEqual(\n  4535\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 4\n  4536\t        )\n  4537\t        # And deconstruction\n  4538\t        definition = operation.deconstruct()\n  4539\t        self.assertEqual(definition[0], \"RunPython\")\n  4540\t        self.assertEqual(definition[1], [])\n  4541\t        self.assertEqual(sorted(definition[2]), [\"code\"])\n  4542\t\n  4543\t        def create_shetlandponies(models, schema_editor):\n  4544\t            ShetlandPony = models.get_model(\"test_runpython\", \"ShetlandPony\")\n  4545\t            pony1 = ShetlandPony.objects.create(weight=4.0)\n  4546\t            self.assertIsNot(pony1.pk, None)\n  4547\t            pony2 = ShetlandPony.objects.create(weight=5.0)\n  4548\t            self.assertIsNot(pony2.pk, None)\n  4549\t            self.assertNotEqual(pony1.pk, pony2.pk)\n  4550\t\n  4551\t        operation = migrations.RunPython(create_shetlandponies)\n  4552\t        with connection.schema_editor() as editor:\n  4553\t            operation.database_forwards(\n  4554\t                \"test_runpython\", editor, project_state, new_state\n  4555\t            )\n  4556\t        self.assertEqual(\n  4557\t            project_state.apps.get_model(\"test_runpython\", \"Pony\").objects.count(), 6\n  4558\t        )\n  4559\t        self.assertEqual(\n  4560\t            project_state.apps.get_model(\n  4561\t                \"test_runpython\", \"ShetlandPony\"\n  4562\t            ).objects.count(),\n  4563\t            2,\n  4564\t        )\n  4565\t        # And elidable reduction\n  4566\t        self.assertIs(False, operation.reduce(operation, []))\n  4567\t        elidable_operation = migrations.RunPython(inner_method, elidable=True)\n  4568\t        self.assertEqual(elidable_operation.reduce(operation, []), [operation])\n  4569\t\n  4570\t    def test_run_python_atomic(self):\n  4571\t        \"\"\"\n  4572\t        Tests the RunPython operation correctly handles the \"atomic\" keyword\n  4573\t        \"\"\"\n  4574\t        project_state = self.set_up_test_model(\"test_runpythonatomic\", mti_model=True)\n  4575\t\n  4576\t        def inner_method(models, schema_editor):\n  4577\t            Pony = models.get_model(\"test_runpythonatomic\", \"Pony\")\n  4578\t            Pony.objects.create(pink=1, weight=3.55)\n  4579\t            raise ValueError(\"Adrian hates ponies.\")\n  4580\t\n  4581\t        # Verify atomicity when applying.\n  4582\t        atomic_migration = Migration(\"test\", \"test_runpythonatomic\")\n  4583\t        atomic_migration.operations = [\n  4584\t            migrations.RunPython(inner_method, reverse_code=inner_method)\n  4585\t        ]\n  4586\t        non_atomic_migration = Migration(\"test\", \"test_runpythonatomic\")\n  4587\t        non_atomic_migration.operations = [\n  4588\t            migrations.RunPython(inner_method, reverse_code=inner_method, atomic=False)\n  4589\t        ]\n  4590\t        # If we're a fully-transactional database, both versions should rollback\n  4591\t        if connection.features.can_rollback_ddl:\n  4592\t            self.assertEqual(\n  4593\t                project_state.apps.get_model(\n  4594\t                    \"test_runpythonatomic\", \"Pony\"\n  4595\t                ).objects.count(),\n  4596\t                0,\n  4597\t            )\n  4598\t            with self.assertRaises(ValueError):\n  4599\t                with connection.schema_editor() as editor:\n  4600\t                    atomic_migration.apply(project_state, editor)\n  4601\t            self.assertEqual(\n  4602\t                project_state.apps.get_model(\n  4603\t                    \"test_runpythonatomic\", \"Pony\"\n  4604\t                ).objects.count(),\n  4605\t                0,\n  4606\t            )\n  4607\t            with self.assertRaises(ValueError):\n  4608\t                with connection.schema_editor() as editor:\n  4609\t                    non_atomic_migration.apply(project_state, editor)\n  4610\t            self.assertEqual(\n  4611\t                project_state.apps.get_model(\n  4612\t                    \"test_runpythonatomic\", \"Pony\"\n  4613\t                ).objects.count(),\n  4614\t                0,\n  4615\t            )\n  4616\t        # Otherwise, the non-atomic operation should leave a row there\n  4617\t        else:\n  4618\t            self.assertEqual(\n  4619\t                project_state.apps.get_model(\n  4620\t                    \"test_runpythonatomic\", \"Pony\"\n  4621\t                ).objects.count(),\n  4622\t                0,\n  4623\t            )\n  4624\t            with self.assertRaises(ValueError):\n  4625\t                with connection.schema_editor() as editor:\n  4626\t                    atomic_migration.apply(project_state, editor)\n  4627\t            self.assertEqual(\n  4628\t                project_state.apps.get_model(\n  4629\t                    \"test_runpythonatomic\", \"Pony\"\n  4630\t                ).objects.count(),\n  4631\t                0,\n  4632\t            )\n  4633\t            with self.assertRaises(ValueError):\n  4634\t                with connection.schema_editor() as editor:\n  4635\t                    non_atomic_migration.apply(project_state, editor)\n  4636\t            self.assertEqual(\n  4637\t                project_state.apps.get_model(\n  4638\t                    \"test_runpythonatomic\", \"Pony\"\n  4639\t                ).objects.count(),\n  4640\t                1,\n  4641\t            )\n  4642\t        # Reset object count to zero and verify atomicity when unapplying.\n  4643\t        project_state.apps.get_model(\n  4644\t            \"test_runpythonatomic\", \"Pony\"\n  4645\t        ).objects.all().delete()\n  4646\t        # On a fully-transactional database, both versions rollback.\n  4647\t        if connection.features.can_rollback_ddl:\n  4648\t            self.assertEqual(\n  4649\t                project_state.apps.get_model(\n  4650\t                    \"test_runpythonatomic\", \"Pony\"\n  4651\t                ).objects.count(),\n  4652\t                0,\n  4653\t            )\n  4654\t            with self.assertRaises(ValueError):\n  4655\t                with connection.schema_editor() as editor:\n  4656\t                    atomic_migration.unapply(project_state, editor)\n  4657\t            self.assertEqual(\n  4658\t                project_state.apps.get_model(\n  4659\t                    \"test_runpythonatomic\", \"Pony\"\n  4660\t                ).objects.count(),\n  4661\t                0,\n  4662\t            )\n  4663\t            with self.assertRaises(ValueError):\n  4664\t                with connection.schema_editor() as editor:\n  4665\t                    non_atomic_migration.unapply(project_state, editor)\n  4666\t            self.assertEqual(\n  4667\t                project_state.apps.get_model(\n  4668\t                    \"test_runpythonatomic\", \"Pony\"\n  4669\t                ).objects.count(),\n  4670\t                0,\n  4671\t            )\n  4672\t        # Otherwise, the non-atomic operation leaves a row there.\n  4673\t        else:\n  4674\t            self.assertEqual(\n  4675\t                project_state.apps.get_model(\n  4676\t                    \"test_runpythonatomic\", \"Pony\"\n  4677\t                ).objects.count(),\n  4678\t                0,\n  4679\t            )\n  4680\t            with self.assertRaises(ValueError):\n  4681\t                with connection.schema_editor() as editor:\n  4682\t                    atomic_migration.unapply(project_state, editor)\n  4683\t            self.assertEqual(\n  4684\t                project_state.apps.get_model(\n  4685\t                    \"test_runpythonatomic\", \"Pony\"\n  4686\t                ).objects.count(),\n  4687\t                0,\n  4688\t            )\n  4689\t            with self.assertRaises(ValueError):\n  4690\t                with connection.schema_editor() as editor:\n  4691\t                    non_atomic_migration.unapply(project_state, editor)\n  4692\t            self.assertEqual(\n  4693\t                project_state.apps.get_model(\n  4694\t                    \"test_runpythonatomic\", \"Pony\"\n  4695\t                ).objects.count(),\n  4696\t                1,\n  4697\t            )\n  4698\t        # Verify deconstruction.\n  4699\t        definition = non_atomic_migration.operations[0].deconstruct()\n  4700\t        self.assertEqual(definition[0], \"RunPython\")\n  4701\t        self.assertEqual(definition[1], [])\n  4702\t        self.assertEqual(sorted(definition[2]), [\"atomic\", \"code\", \"reverse_code\"])\n  4703\t\n  4704\t    def test_run_python_related_assignment(self):\n  4705\t        \"\"\"\n  4706\t        #24282 - Model changes to a FK reverse side update the model\n  4707\t        on the FK side as well.\n  4708\t        \"\"\"\n  4709\t\n  4710\t        def inner_method(models, schema_editor):\n  4711\t            Author = models.get_model(\"test_authors\", \"Author\")\n  4712\t            Book = models.get_model(\"test_books\", \"Book\")\n  4713\t            author = Author.objects.create(name=\"Hemingway\")\n  4714\t            Book.objects.create(title=\"Old Man and The Sea\", author=author)\n  4715\t\n  4716\t        create_author = migrations.CreateModel(\n  4717\t            \"Author\",\n  4718\t            [\n  4719\t                (\"id\", models.AutoField(primary_key=True)),\n  4720\t                (\"name\", models.CharField(max_length=100)),\n  4721\t            ],\n  4722\t            options={},\n  4723\t        )\n  4724\t        create_book = migrations.CreateModel(\n  4725\t            \"Book\",\n  4726\t            [\n  4727\t                (\"id\", models.AutoField(primary_key=True)),\n  4728\t                (\"title\", models.CharField(max_length=100)),\n  4729\t                (\"author\", models.ForeignKey(\"test_authors.Author\", models.CASCADE)),\n  4730\t            ],\n  4731\t            options={},\n  4732\t        )\n  4733\t        add_hometown = migrations.AddField(\n  4734\t            \"Author\",\n  4735\t            \"hometown\",\n  4736\t            models.CharField(max_length=100),\n  4737\t        )\n  4738\t        create_old_man = migrations.RunPython(inner_method, inner_method)\n  4739\t\n  4740\t        project_state = ProjectState()\n  4741\t        new_state = project_state.clone()\n  4742\t        with connection.schema_editor() as editor:\n  4743\t            create_author.state_forwards(\"test_authors\", new_state)\n  4744\t            create_author.database_forwards(\n  4745\t                \"test_authors\", editor, project_state, new_state\n  4746\t            )\n  4747\t        project_state = new_state\n  4748\t        new_state = new_state.clone()\n  4749\t        with connection.schema_editor() as editor:\n  4750\t            create_book.state_forwards(\"test_books\", new_state)\n  4751\t            create_book.database_forwards(\n  4752\t                \"test_books\", editor, project_state, new_state\n  4753\t            )\n  4754\t        project_state = new_state\n  4755\t        new_state = new_state.clone()\n  4756\t        with connection.schema_editor() as editor:\n  4757\t            add_hometown.state_forwards(\"test_authors\", new_state)\n  4758\t            add_hometown.database_forwards(\n  4759\t                \"test_authors\", editor, project_state, new_state\n  4760\t            )\n  4761\t        project_state = new_state\n  4762\t        new_state = new_state.clone()\n  4763\t        with connection.schema_editor() as editor:\n  4764\t            create_old_man.state_forwards(\"test_books\", new_state)\n  4765\t            create_old_man.database_forwards(\n  4766\t                \"test_books\", editor, project_state, new_state\n  4767\t            )\n  4768\t\n  4769\t    def test_model_with_bigautofield(self):\n  4770\t        \"\"\"\n  4771\t        A model with BigAutoField can be created.\n  4772\t        \"\"\"\n  4773\t\n  4774\t        def create_data(models, schema_editor):\n  4775\t            Author = models.get_model(\"test_author\", \"Author\")\n  4776\t            Book = models.get_model(\"test_book\", \"Book\")\n  4777\t            author1 = Author.objects.create(name=\"Hemingway\")\n  4778\t            Book.objects.create(title=\"Old Man and The Sea\", author=author1)\n  4779\t            Book.objects.create(id=2**33, title=\"A farewell to arms\", author=author1)\n  4780\t\n  4781\t            author2 = Author.objects.create(id=2**33, name=\"Remarque\")\n  4782\t            Book.objects.create(title=\"All quiet on the western front\", author=author2)\n  4783\t            Book.objects.create(title=\"Arc de Triomphe\", author=author2)\n  4784\t\n  4785\t        create_author = migrations.CreateModel(\n  4786\t            \"Author\",\n  4787\t            [\n  4788\t                (\"id\", models.BigAutoField(primary_key=True)),\n  4789\t                (\"name\", models.CharField(max_length=100)),\n  4790\t            ],\n  4791\t            options={},\n  4792\t        )\n  4793\t        create_book = migrations.CreateModel(\n  4794\t            \"Book\",\n  4795\t            [\n  4796\t                (\"id\", models.BigAutoField(primary_key=True)),\n  4797\t                (\"title\", models.CharField(max_length=100)),\n  4798\t                (\n  4799\t                    \"author\",\n  4800\t                    models.ForeignKey(\n  4801\t                        to=\"test_author.Author\", on_delete=models.CASCADE\n  4802\t                    ),\n  4803\t                ),\n  4804\t            ],\n  4805\t            options={},\n  4806\t        )\n  4807\t        fill_data = migrations.RunPython(create_data)\n  4808\t\n  4809\t        project_state = ProjectState()\n  4810\t        new_state = project_state.clone()\n  4811\t        with connection.schema_editor() as editor:\n  4812\t            create_author.state_forwards(\"test_author\", new_state)\n  4813\t            create_author.database_forwards(\n  4814\t                \"test_author\", editor, project_state, new_state\n  4815\t            )\n  4816\t\n  4817\t        project_state = new_state\n  4818\t        new_state = new_state.clone()\n  4819\t        with connection.schema_editor() as editor:\n  4820\t            create_book.state_forwards(\"test_book\", new_state)\n  4821\t            create_book.database_forwards(\"test_book\", editor, project_state, new_state)\n  4822\t\n  4823\t        project_state = new_state\n  4824\t        new_state = new_state.clone()\n  4825\t        with connection.schema_editor() as editor:\n  4826\t            fill_data.state_forwards(\"fill_data\", new_state)\n  4827\t            fill_data.database_forwards(\"fill_data\", editor, project_state, new_state)\n  4828\t\n  4829\t    def _test_autofield_foreignfield_growth(\n  4830\t        self, source_field, target_field, target_value\n  4831\t    ):\n  4832\t        \"\"\"\n  4833\t        A field may be migrated in the following ways:\n  4834\t\n  4835\t        - AutoField to BigAutoField\n  4836\t        - SmallAutoField to AutoField\n  4837\t        - SmallAutoField to BigAutoField\n  4838\t        \"\"\"\n  4839\t\n  4840\t        def create_initial_data(models, schema_editor):\n  4841\t            Article = models.get_model(\"test_article\", \"Article\")\n  4842\t            Blog = models.get_model(\"test_blog\", \"Blog\")\n  4843\t            blog = Blog.objects.create(name=\"web development done right\")\n  4844\t            Article.objects.create(name=\"Frameworks\", blog=blog)\n  4845\t            Article.objects.create(name=\"Programming Languages\", blog=blog)\n  4846\t\n  4847\t        def create_big_data(models, schema_editor):\n  4848\t            Article = models.get_model(\"test_article\", \"Article\")\n  4849\t            Blog = models.get_model(\"test_blog\", \"Blog\")\n  4850\t            blog2 = Blog.objects.create(name=\"Frameworks\", id=target_value)\n  4851\t            Article.objects.create(name=\"Django\", blog=blog2)\n  4852\t            Article.objects.create(id=target_value, name=\"Django2\", blog=blog2)\n  4853\t\n  4854\t        create_blog = migrations.CreateModel(\n  4855\t            \"Blog\",\n  4856\t            [\n  4857\t                (\"id\", source_field(primary_key=True)),\n  4858\t                (\"name\", models.CharField(max_length=100)),\n  4859\t            ],\n  4860\t            options={},\n  4861\t        )\n  4862\t        create_article = migrations.CreateModel(\n  4863\t            \"Article\",\n  4864\t            [\n  4865\t                (\"id\", source_field(primary_key=True)),\n  4866\t                (\n  4867\t                    \"blog\",\n  4868\t                    models.ForeignKey(to=\"test_blog.Blog\", on_delete=models.CASCADE),\n  4869\t                ),\n  4870\t                (\"name\", models.CharField(max_length=100)),\n  4871\t                (\"data\", models.TextField(default=\"\")),\n  4872\t            ],\n  4873\t            options={},\n  4874\t        )\n  4875\t        fill_initial_data = migrations.RunPython(\n  4876\t            create_initial_data, create_initial_data\n  4877\t        )\n  4878\t        fill_big_data = migrations.RunPython(create_big_data, create_big_data)\n  4879\t\n  4880\t        grow_article_id = migrations.AlterField(\n  4881\t            \"Article\", \"id\", target_field(primary_key=True)\n  4882\t        )\n  4883\t        grow_blog_id = migrations.AlterField(\n  4884\t            \"Blog\", \"id\", target_field(primary_key=True)\n  4885\t        )\n  4886\t\n  4887\t        project_state = ProjectState()\n  4888\t        new_state = project_state.clone()\n  4889\t        with connection.schema_editor() as editor:\n  4890\t            create_blog.state_forwards(\"test_blog\", new_state)\n  4891\t            create_blog.database_forwards(\"test_blog\", editor, project_state, new_state)\n  4892\t\n  4893\t        project_state = new_state\n  4894\t        new_state = new_state.clone()\n  4895\t        with connection.schema_editor() as editor:\n  4896\t            create_article.state_forwards(\"test_article\", new_state)\n  4897\t            create_article.database_forwards(\n  4898\t                \"test_article\", editor, project_state, new_state\n  4899\t            )\n  4900\t\n  4901\t        project_state = new_state\n  4902\t        new_state = new_state.clone()\n  4903\t        with connection.schema_editor() as editor:\n  4904\t            fill_initial_data.state_forwards(\"fill_initial_data\", new_state)\n  4905\t            fill_initial_data.database_forwards(\n  4906\t                \"fill_initial_data\", editor, project_state, new_state\n  4907\t            )\n  4908\t\n  4909\t        project_state = new_state\n  4910\t        new_state = new_state.clone()\n  4911\t        with connection.schema_editor() as editor:\n  4912\t            grow_article_id.state_forwards(\"test_article\", new_state)\n  4913\t            grow_article_id.database_forwards(\n  4914\t                \"test_article\", editor, project_state, new_state\n  4915\t            )\n  4916\t\n  4917\t        state = new_state.clone()\n  4918\t        article = state.apps.get_model(\"test_article.Article\")\n  4919\t        self.assertIsInstance(article._meta.pk, target_field)\n  4920\t\n  4921\t        project_state = new_state\n  4922\t        new_state = new_state.clone()\n  4923\t        with connection.schema_editor() as editor:\n  4924\t            grow_blog_id.state_forwards(\"test_blog\", new_state)\n  4925\t            grow_blog_id.database_forwards(\n  4926\t                \"test_blog\", editor, project_state, new_state\n  4927\t            )\n  4928\t\n  4929\t        state = new_state.clone()\n  4930\t        blog = state.apps.get_model(\"test_blog.Blog\")\n  4931\t        self.assertIsInstance(blog._meta.pk, target_field)\n  4932\t\n  4933\t        project_state = new_state\n  4934\t        new_state = new_state.clone()\n  4935\t        with connection.schema_editor() as editor:\n  4936\t            fill_big_data.state_forwards(\"fill_big_data\", new_state)\n  4937\t            fill_big_data.database_forwards(\n  4938\t                \"fill_big_data\", editor, project_state, new_state\n  4939\t            )\n  4940\t\n  4941\t    def test_autofield__bigautofield_foreignfield_growth(self):\n  4942\t        \"\"\"A field may be migrated from AutoField to BigAutoField.\"\"\"\n  4943\t        self._test_autofield_foreignfield_growth(\n  4944\t            models.AutoField,\n  4945\t            models.BigAutoField,\n  4946\t            2**33,\n  4947\t        )\n  4948\t\n  4949\t    def test_smallfield_autofield_foreignfield_growth(self):\n  4950\t        \"\"\"A field may be migrated from SmallAutoField to AutoField.\"\"\"\n  4951\t        self._test_autofield_foreignfield_growth(\n  4952\t            models.SmallAutoField,\n  4953\t            models.AutoField,\n  4954\t            2**22,\n  4955\t        )\n  4956\t\n  4957\t    def test_smallfield_bigautofield_foreignfield_growth(self):\n  4958\t        \"\"\"A field may be migrated from SmallAutoField to BigAutoField.\"\"\"\n  4959\t        self._test_autofield_foreignfield_growth(\n  4960\t            models.SmallAutoField,\n  4961\t            models.BigAutoField,\n  4962\t            2**33,\n  4963\t        )\n  4964\t\n  4965\t    def test_run_python_noop(self):\n  4966\t        \"\"\"\n  4967\t        #24098 - Tests no-op RunPython operations.\n  4968\t        \"\"\"\n  4969\t        project_state = ProjectState()\n  4970\t        new_state = project_state.clone()\n  4971\t        operation = migrations.RunPython(\n  4972\t            migrations.RunPython.noop, migrations.RunPython.noop\n  4973\t        )\n  4974\t        with connection.schema_editor() as editor:\n  4975\t            operation.database_forwards(\n  4976\t                \"test_runpython\", editor, project_state, new_state\n  4977\t            )\n  4978\t            operation.database_backwards(\n  4979\t                \"test_runpython\", editor, new_state, project_state\n  4980\t            )\n  4981\t\n  4982\t    def test_separate_database_and_state(self):\n  4983\t        \"\"\"\n  4984\t        Tests the SeparateDatabaseAndState operation.\n  4985\t        \"\"\"\n  4986\t        project_state = self.set_up_test_model(\"test_separatedatabaseandstate\")\n  4987\t        # Create the operation\n  4988\t        database_operation = migrations.RunSQL(\n  4989\t            \"CREATE TABLE i_love_ponies (id int, special_thing int);\",\n  4990\t            \"DROP TABLE i_love_ponies;\",\n  4991\t        )\n  4992\t        state_operation = migrations.CreateModel(\n  4993\t            \"SomethingElse\", [(\"id\", models.AutoField(primary_key=True))]\n  4994\t        )\n  4995\t        operation = migrations.SeparateDatabaseAndState(\n  4996\t            state_operations=[state_operation], database_operations=[database_operation]\n  4997\t        )\n  4998\t        self.assertEqual(\n  4999\t            operation.describe(), \"Custom state/database change combination\"\n  5000\t        )\n  5001\t        # Test the state alteration\n  5002\t        new_state = project_state.clone()\n  5003\t        operation.state_forwards(\"test_separatedatabaseandstate\", new_state)\n  5004\t        self.assertEqual(\n  5005\t            len(\n  5006\t                new_state.models[\n  5007\t                    \"test_separatedatabaseandstate\", \"somethingelse\"\n  5008\t                ].fields\n  5009\t            ),\n  5010\t            1,\n  5011\t        )\n  5012\t        # Make sure there's no table\n  5013\t        self.assertTableNotExists(\"i_love_ponies\")\n  5014\t        # Test the database alteration\n  5015\t        with connection.schema_editor() as editor:\n  5016\t            operation.database_forwards(\n  5017\t                \"test_separatedatabaseandstate\", editor, project_state, new_state\n  5018\t            )\n  5019\t        self.assertTableExists(\"i_love_ponies\")\n  5020\t        # And test reversal\n  5021\t        self.assertTrue(operation.reversible)\n  5022\t        with connection.schema_editor() as editor:\n  5023\t            operation.database_backwards(\n  5024\t                \"test_separatedatabaseandstate\", editor, new_state, project_state\n  5025\t            )\n  5026\t        self.assertTableNotExists(\"i_love_ponies\")\n  5027\t        # And deconstruction\n  5028\t        definition = operation.deconstruct()\n  5029\t        self.assertEqual(definition[0], \"SeparateDatabaseAndState\")\n  5030\t        self.assertEqual(definition[1], [])\n  5031\t        self.assertEqual(\n  5032\t            sorted(definition[2]), [\"database_operations\", \"state_operations\"]\n  5033\t        )\n  5034\t\n  5035\t    def test_separate_database_and_state2(self):\n  5036\t        \"\"\"\n  5037\t        A complex SeparateDatabaseAndState operation: Multiple operations both\n  5038\t        for state and database. Verify the state dependencies within each list\n  5039\t        and that state ops don't affect the database.\n  5040\t        \"\"\"\n  5041\t        app_label = \"test_separatedatabaseandstate2\"\n  5042\t        project_state = self.set_up_test_model(app_label)\n  5043\t        # Create the operation\n  5044\t        database_operations = [\n  5045\t            migrations.CreateModel(\n  5046\t                \"ILovePonies\",\n  5047\t                [(\"id\", models.AutoField(primary_key=True))],\n  5048\t                options={\"db_table\": \"iloveponies\"},\n  5049\t            ),\n  5050\t            migrations.CreateModel(\n  5051\t                \"ILoveMorePonies\",\n  5052\t                # We use IntegerField and not AutoField because\n  5053\t                # the model is going to be deleted immediately\n  5054\t                # and with an AutoField this fails on Oracle\n  5055\t                [(\"id\", models.IntegerField(primary_key=True))],\n  5056\t                options={\"db_table\": \"ilovemoreponies\"},\n  5057\t            ),\n  5058\t            migrations.DeleteModel(\"ILoveMorePonies\"),\n  5059\t            migrations.CreateModel(\n  5060\t                \"ILoveEvenMorePonies\",\n  5061\t                [(\"id\", models.AutoField(primary_key=True))],\n  5062\t                options={\"db_table\": \"iloveevenmoreponies\"},\n  5063\t            ),\n  5064\t        ]\n  5065\t        state_operations = [\n  5066\t            migrations.CreateModel(\n  5067\t                \"SomethingElse\",\n  5068\t                [(\"id\", models.AutoField(primary_key=True))],\n  5069\t                options={\"db_table\": \"somethingelse\"},\n  5070\t            ),\n  5071\t            migrations.DeleteModel(\"SomethingElse\"),\n  5072\t            migrations.CreateModel(\n  5073\t                \"SomethingCompletelyDifferent\",\n  5074\t                [(\"id\", models.AutoField(primary_key=True))],\n  5075\t                options={\"db_table\": \"somethingcompletelydifferent\"},\n  5076\t            ),\n  5077\t        ]\n  5078\t        operation = migrations.SeparateDatabaseAndState(\n  5079\t            state_operations=state_operations,\n  5080\t            database_operations=database_operations,\n  5081\t        )\n  5082\t        # Test the state alteration\n  5083\t        new_state = project_state.clone()\n  5084\t        operation.state_forwards(app_label, new_state)\n  5085\t\n  5086\t        def assertModelsAndTables(after_db):\n  5087\t            # Tables and models exist, or don't, as they should:\n  5088\t            self.assertNotIn((app_label, \"somethingelse\"), new_state.models)\n  5089\t            self.assertEqual(\n  5090\t                len(new_state.models[app_label, \"somethingcompletelydifferent\"].fields),\n  5091\t                1,\n  5092\t            )\n  5093\t            self.assertNotIn((app_label, \"iloveponiesonies\"), new_state.models)\n  5094\t            self.assertNotIn((app_label, \"ilovemoreponies\"), new_state.models)\n  5095\t            self.assertNotIn((app_label, \"iloveevenmoreponies\"), new_state.models)\n  5096\t            self.assertTableNotExists(\"somethingelse\")\n  5097\t            self.assertTableNotExists(\"somethingcompletelydifferent\")\n  5098\t            self.assertTableNotExists(\"ilovemoreponies\")\n  5099\t            if after_db:\n  5100\t                self.assertTableExists(\"iloveponies\")\n  5101\t                self.assertTableExists(\"iloveevenmoreponies\")\n  5102\t            else:\n  5103\t                self.assertTableNotExists(\"iloveponies\")\n  5104\t                self.assertTableNotExists(\"iloveevenmoreponies\")\n  5105\t\n  5106\t        assertModelsAndTables(after_db=False)\n  5107\t        # Test the database alteration\n  5108\t        with connection.schema_editor() as editor:\n  5109\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  5110\t        assertModelsAndTables(after_db=True)\n  5111\t        # And test reversal\n  5112\t        self.assertTrue(operation.reversible)\n  5113\t        with connection.schema_editor() as editor:\n  5114\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  5115\t        assertModelsAndTables(after_db=False)\n  5116\t\n  5117\t\n  5118\tclass SwappableOperationTests(OperationTestBase):\n  5119\t    \"\"\"\n  5120\t    Key operations ignore swappable models\n  5121\t    (we don't want to replicate all of them here, as the functionality\n  5122\t    is in a common base class anyway)\n  5123\t    \"\"\"\n  5124\t\n  5125\t    available_apps = [\"migrations\"]\n  5126\t\n  5127\t    @override_settings(TEST_SWAP_MODEL=\"migrations.SomeFakeModel\")\n  5128\t    def test_create_ignore_swapped(self):\n  5129\t        \"\"\"\n  5130\t        The CreateTable operation ignores swapped models.\n  5131\t        \"\"\"\n  5132\t        operation = migrations.CreateModel(\n  5133\t            \"Pony\",\n  5134\t            [\n  5135\t                (\"id\", models.AutoField(primary_key=True)),\n  5136\t                (\"pink\", models.IntegerField(default=1)),\n  5137\t            ],\n  5138\t            options={\n  5139\t                \"swappable\": \"TEST_SWAP_MODEL\",\n  5140\t            },\n  5141\t        )\n  5142\t        # Test the state alteration (it should still be there!)\n  5143\t        project_state = ProjectState()\n  5144\t        new_state = project_state.clone()\n  5145\t        operation.state_forwards(\"test_crigsw\", new_state)\n  5146\t        self.assertEqual(new_state.models[\"test_crigsw\", \"pony\"].name, \"Pony\")\n  5147\t        self.assertEqual(len(new_state.models[\"test_crigsw\", \"pony\"].fields), 2)\n  5148\t        # Test the database alteration\n  5149\t        self.assertTableNotExists(\"test_crigsw_pony\")\n  5150\t        with connection.schema_editor() as editor:\n  5151\t            operation.database_forwards(\"test_crigsw\", editor, project_state, new_state)\n  5152\t        self.assertTableNotExists(\"test_crigsw_pony\")\n  5153\t        # And test reversal\n  5154\t        with connection.schema_editor() as editor:\n  5155\t            operation.database_backwards(\n  5156\t                \"test_crigsw\", editor, new_state, project_state\n  5157\t            )\n  5158\t        self.assertTableNotExists(\"test_crigsw_pony\")\n  5159\t\n  5160\t    @override_settings(TEST_SWAP_MODEL=\"migrations.SomeFakeModel\")\n  5161\t    def test_delete_ignore_swapped(self):\n  5162\t        \"\"\"\n  5163\t        Tests the DeleteModel operation ignores swapped models.\n  5164\t        \"\"\"\n  5165\t        operation = migrations.DeleteModel(\"Pony\")\n  5166\t        project_state, new_state = self.make_test_state(\"test_dligsw\", operation)\n  5167\t        # Test the database alteration\n  5168\t        self.assertTableNotExists(\"test_dligsw_pony\")\n  5169\t        with connection.schema_editor() as editor:\n  5170\t            operation.database_forwards(\"test_dligsw\", editor, project_state, new_state)\n  5171\t        self.assertTableNotExists(\"test_dligsw_pony\")\n  5172\t        # And test reversal\n  5173\t        with connection.schema_editor() as editor:\n  5174\t            operation.database_backwards(\n  5175\t                \"test_dligsw\", editor, new_state, project_state\n  5176\t            )\n  5177\t        self.assertTableNotExists(\"test_dligsw_pony\")\n  5178\t\n  5179\t    @override_settings(TEST_SWAP_MODEL=\"migrations.SomeFakeModel\")\n  5180\t    def test_add_field_ignore_swapped(self):\n  5181\t        \"\"\"\n  5182\t        Tests the AddField operation.\n  5183\t        \"\"\"\n  5184\t        # Test the state alteration\n  5185\t        operation = migrations.AddField(\n  5186\t            \"Pony\",\n  5187\t            \"height\",\n  5188\t            models.FloatField(null=True, default=5),\n  5189\t        )\n  5190\t        project_state, new_state = self.make_test_state(\"test_adfligsw\", operation)\n  5191\t        # Test the database alteration\n  5192\t        self.assertTableNotExists(\"test_adfligsw_pony\")\n  5193\t        with connection.schema_editor() as editor:\n  5194\t            operation.database_forwards(\n  5195\t                \"test_adfligsw\", editor, project_state, new_state\n  5196\t            )\n  5197\t        self.assertTableNotExists(\"test_adfligsw_pony\")\n  5198\t        # And test reversal\n  5199\t        with connection.schema_editor() as editor:\n  5200\t            operation.database_backwards(\n  5201\t                \"test_adfligsw\", editor, new_state, project_state\n  5202\t            )\n  5203\t        self.assertTableNotExists(\"test_adfligsw_pony\")\n  5204\t\n  5205\t    @override_settings(TEST_SWAP_MODEL=\"migrations.SomeFakeModel\")\n  5206\t    def test_indexes_ignore_swapped(self):\n  5207\t        \"\"\"\n  5208\t        Add/RemoveIndex operations ignore swapped models.\n  5209\t        \"\"\"\n  5210\t        operation = migrations.AddIndex(\n  5211\t            \"Pony\", models.Index(fields=[\"pink\"], name=\"my_name_idx\")\n  5212\t        )\n  5213\t        project_state, new_state = self.make_test_state(\"test_adinigsw\", operation)\n  5214\t        with connection.schema_editor() as editor:\n  5215\t            # No database queries should be run for swapped models\n  5216\t            operation.database_forwards(\n  5217\t                \"test_adinigsw\", editor, project_state, new_state\n  5218\t            )\n  5219\t            operation.database_backwards(\n  5220\t                \"test_adinigsw\", editor, new_state, project_state\n  5221\t            )\n  5222\t\n  5223\t        operation = migrations.RemoveIndex(\n  5224\t            \"Pony\", models.Index(fields=[\"pink\"], name=\"my_name_idx\")\n  5225\t        )\n  5226\t        project_state, new_state = self.make_test_state(\"test_rminigsw\", operation)\n  5227\t        with connection.schema_editor() as editor:\n  5228\t            operation.database_forwards(\n  5229\t                \"test_rminigsw\", editor, project_state, new_state\n  5230\t            )\n  5231\t            operation.database_backwards(\n  5232\t                \"test_rminigsw\", editor, new_state, project_state\n  5233\t            )\n  5234\t\n  5235\t\n  5236\tclass TestCreateModel(SimpleTestCase):\n  5237\t    def test_references_model_mixin(self):\n  5238\t        migrations.CreateModel(\n  5239\t            \"name\",\n  5240\t            fields=[],\n  5241\t            bases=(Mixin, models.Model),\n  5242\t        ).references_model(\"other_model\", \"migrations\")\n  5243\t\n  5244\t\n  5245\tclass FieldOperationTests(SimpleTestCase):\n  5246\t    def test_references_model(self):\n  5247\t        operation = FieldOperation(\n  5248\t            \"MoDel\", \"field\", models.ForeignKey(\"Other\", models.CASCADE)\n  5249\t        )\n  5250\t        # Model name match.\n  5251\t        self.assertIs(operation.references_model(\"mOdEl\", \"migrations\"), True)\n  5252\t        # Referenced field.\n  5253\t        self.assertIs(operation.references_model(\"oTher\", \"migrations\"), True)\n  5254\t        # Doesn't reference.\n  5255\t        self.assertIs(operation.references_model(\"Whatever\", \"migrations\"), False)\n  5256\t\n  5257\t    def test_references_field_by_name(self):\n  5258\t        operation = FieldOperation(\"MoDel\", \"field\", models.BooleanField(default=False))\n  5259\t        self.assertIs(operation.references_field(\"model\", \"field\", \"migrations\"), True)\n  5260\t\n  5261\t    def test_references_field_by_remote_field_model(self):\n  5262\t        operation = FieldOperation(\n  5263\t            \"Model\", \"field\", models.ForeignKey(\"Other\", models.CASCADE)\n  5264\t        )\n  5265\t        self.assertIs(\n  5266\t            operation.references_field(\"Other\", \"whatever\", \"migrations\"), True\n  5267\t        )\n  5268\t        self.assertIs(\n  5269\t            operation.references_field(\"Missing\", \"whatever\", \"migrations\"), False\n  5270\t        )\n  5271\t\n  5272\t    def test_references_field_by_from_fields(self):\n  5273\t        operation = FieldOperation(\n  5274\t            \"Model\",\n  5275\t            \"field\",\n  5276\t            models.fields.related.ForeignObject(\n  5277\t                \"Other\", models.CASCADE, [\"from\"], [\"to\"]\n  5278\t            ),\n  5279\t        )\n  5280\t        self.assertIs(operation.references_field(\"Model\", \"from\", \"migrations\"), True)\n  5281\t        self.assertIs(operation.references_field(\"Model\", \"to\", \"migrations\"), False)\n  5282\t        self.assertIs(operation.references_field(\"Other\", \"from\", \"migrations\"), False)\n  5283\t        self.assertIs(operation.references_field(\"Model\", \"to\", \"migrations\"), False)\n  5284\t\n  5285\t    def test_references_field_by_to_fields(self):\n  5286\t        operation = FieldOperation(\n  5287\t            \"Model\",\n  5288\t            \"field\",\n  5289\t            models.ForeignKey(\"Other\", models.CASCADE, to_field=\"field\"),\n  5290\t        )\n  5291\t        self.assertIs(operation.references_field(\"Other\", \"field\", \"migrations\"), True)\n  5292\t        self.assertIs(\n  5293\t            operation.references_field(\"Other\", \"whatever\", \"migrations\"), False\n  5294\t        )\n  5295\t        self.assertIs(\n  5296\t            operation.references_field(\"Missing\", \"whatever\", \"migrations\"), False\n  5297\t        )\n  5298\t\n  5299\t    def test_references_field_by_through(self):\n  5300\t        operation = FieldOperation(\n  5301\t            \"Model\", \"field\", models.ManyToManyField(\"Other\", through=\"Through\")\n  5302\t        )\n  5303\t        self.assertIs(\n  5304\t            operation.references_field(\"Other\", \"whatever\", \"migrations\"), True\n  5305\t        )\n  5306\t        self.assertIs(\n  5307\t            operation.references_field(\"Through\", \"whatever\", \"migrations\"), True\n  5308\t        )\n  5309\t        self.assertIs(\n  5310\t            operation.references_field(\"Missing\", \"whatever\", \"migrations\"), False\n  5311\t        )\n  5312\t\n  5313\t    def test_reference_field_by_through_fields(self):\n  5314\t        operation = FieldOperation(\n  5315\t            \"Model\",\n  5316\t            \"field\",\n  5317\t            models.ManyToManyField(\n  5318\t                \"Other\", through=\"Through\", through_fields=(\"first\", \"second\")\n  5319\t            ),\n  5320\t        )\n  5321\t        self.assertIs(\n  5322\t            operation.references_field(\"Other\", \"whatever\", \"migrations\"), True\n  5323\t        )\n  5324\t        self.assertIs(\n  5325\t            operation.references_field(\"Through\", \"whatever\", \"migrations\"), False\n  5326\t        )\n  5327\t        self.assertIs(\n  5328\t            operation.references_field(\"Through\", \"first\", \"migrations\"), True\n  5329\t        )\n  5330\t        self.assertIs(\n  5331\t            operation.references_field(\"Through\", \"second\", \"migrations\"), True\n  5332\t        )\n  5333\t\n```\n\n</observation>",
                  "type": "tool_result"
                }
              ]
            },
            {
              "role": "assistant",
              "content": [
                {
                  "type": "text",
                  "text": "<thoughts>\n1. From the test file, I can see this is related to the RenameIndex operation and how it handles unnamed indexes when moving backward and forward.\n\n2. Let me search for the RenameIndex operation implementation to understand how it currently works.\n</thoughts>"
                },
                {
                  "id": "call_459acff2",
                  "input": {
                    "file_pattern": null,
                    "query": "RenameIndex operation implementation",
                    "category": "implementation"
                  },
                  "type": "tool_use",
                  "name": "SemanticSearch"
                }
              ]
            },
            {
              "role": "user",
              "content": [
                {
                  "tool_use_id": "call_459acff2",
                  "content": "<observation>\nFound 15 code sections.\n\nViewed relevant code:\ndjango/db/migrations/operations/models.py\n```\n     1\tfrom django.db import models\n     2\tfrom django.db.migrations.operations.base import Operation\n     3\tfrom django.db.migrations.state import ModelState\n     4\tfrom django.db.migrations.utils import field_references, resolve_relation\n     5\tfrom django.db.models.options import normalize_together\n     6\tfrom django.utils.functional import cached_property\n     7\t\n     8\tfrom .fields import AddField, AlterField, FieldOperation, RemoveField, RenameField\n      # ...\n   877\t\n   878\t\n   879\tclass RenameIndex(IndexOperation):\n   880\t    \"\"\"Rename an index.\"\"\"\n   881\t\n   882\t    def __init__(self, model_name, new_name, old_name=None, old_fields=None):\n   883\t        if not old_name and not old_fields:\n   884\t            raise ValueError(\n   885\t                \"RenameIndex requires one of old_name and old_fields arguments to be \"\n   886\t                \"set.\"\n   887\t            )\n   888\t        if old_name and old_fields:\n   889\t            raise ValueError(\n   890\t                \"RenameIndex.old_name and old_fields are mutually exclusive.\"\n   891\t            )\n   892\t        self.model_name = model_name\n   893\t        self.new_name = new_name\n   894\t        self.old_name = old_name\n   895\t        self.old_fields = old_fields\n   896\t\n   897\t    @cached_property\n   898\t    def old_name_lower(self):\n   899\t        return self.old_name.lower()\n   900\t\n   901\t    @cached_property\n   902\t    def new_name_lower(self):\n   903\t        return self.new_name.lower()\n   904\t\n   905\t    def deconstruct(self):\n   906\t        kwargs = {\n   907\t            \"model_name\": self.model_name,\n   908\t            \"new_name\": self.new_name,\n   909\t        }\n   910\t        if self.old_name:\n   911\t            kwargs[\"old_name\"] = self.old_name\n   912\t        if self.old_fields:\n   913\t            kwargs[\"old_fields\"] = self.old_fields\n   914\t        return (self.__class__.__qualname__, [], kwargs)\n   915\t\n   916\t    def state_forwards(self, app_label, state):\n   917\t        if self.old_fields:\n   918\t            state.add_index(\n   919\t                app_label,\n   920\t                self.model_name_lower,\n   921\t                models.Index(fields=self.old_fields, name=self.new_name),\n   922\t            )\n   923\t            state.remove_model_options(\n   924\t                app_label,\n   925\t                self.model_name_lower,\n   926\t                AlterIndexTogether.option_name,\n   927\t                self.old_fields,\n   928\t            )\n   929\t        else:\n   930\t            state.rename_index(\n   931\t                app_label, self.model_name_lower, self.old_name, self.new_name\n   932\t            )\n   933\t\n   934\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n   935\t        model = to_state.apps.get_model(app_label, self.model_name)\n   936\t        if not self.allow_migrate_model(schema_editor.connection.alias, model):\n   937\t            return\n   938\t\n   939\t        if self.old_fields:\n   940\t            from_model = from_state.apps.get_model(app_label, self.model_name)\n   941\t            columns = [\n   942\t                from_model._meta.get_field(field).column for field in self.old_fields\n   943\t            ]\n   944\t            matching_index_name = schema_editor._constraint_names(\n   945\t                from_model, column_names=columns, index=True\n   946\t            )\n   947\t            if len(matching_index_name) != 1:\n   948\t                raise ValueError(\n   949\t                    \"Found wrong number (%s) of indexes for %s(%s).\"\n   950\t                    % (\n   951\t                        len(matching_index_name),\n   952\t                        from_model._meta.db_table,\n   953\t                        \", \".join(columns),\n   954\t                    )\n   955\t                )\n   956\t            old_index = models.Index(\n   957\t                fields=self.old_fields,\n   958\t                name=matching_index_name[0],\n   959\t            )\n   960\t        else:\n   961\t            from_model_state = from_state.models[app_label, self.model_name_lower]\n   962\t            old_index = from_model_state.get_index_by_name(self.old_name)\n   963\t\n   964\t        to_model_state = to_state.models[app_label, self.model_name_lower]\n   965\t        new_index = to_model_state.get_index_by_name(self.new_name)\n   966\t        schema_editor.rename_index(model, old_index, new_index)\n   967\t\n   968\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n   969\t        if self.old_fields:\n   970\t            # Backward operation with unnamed index is a no-op.\n   971\t            return\n   972\t\n   973\t        self.new_name_lower, self.old_name_lower = (\n   974\t            self.old_name_lower,\n   975\t            self.new_name_lower,\n   976\t        )\n   977\t        self.new_name, self.old_name = self.old_name, self.new_name\n   978\t\n   979\t        self.database_forwards(app_label, schema_editor, from_state, to_state)\n   980\t\n   981\t        self.new_name_lower, self.old_name_lower = (\n   982\t            self.old_name_lower,\n   983\t            self.new_name_lower,\n   984\t        )\n   985\t        self.new_name, self.old_name = self.old_name, self.new_name\n   986\t\n   987\t    def describe(self):\n   988\t        if self.old_name:\n   989\t            return (\n   990\t                f\"Rename index {self.old_name} on {self.model_name} to {self.new_name}\"\n   991\t            )\n   992\t        return (\n   993\t            f\"Rename unnamed index for {self.old_fields} on {self.model_name} to \"\n   994\t            f\"{self.new_name}\"\n   995\t        )\n   996\t\n   997\t    @property\n   998\t    def migration_name_fragment(self):\n   999\t        if self.old_name:\n  1000\t            return \"rename_%s_%s\" % (self.old_name_lower, self.new_name_lower)\n  1001\t        return \"rename_%s_%s_%s\" % (\n  1002\t            self.model_name_lower,\n  1003\t            \"_\".join(self.old_fields),\n  1004\t            self.new_name_lower,\n  1005\t        )\n  1006\t\n  1007\t    def reduce(self, operation, app_label):\n  1008\t        if (\n  1009\t            isinstance(operation, RenameIndex)\n  1010\t            and self.model_name_lower == operation.model_name_lower\n  1011\t            and operation.old_name\n  1012\t            and self.new_name_lower == operation.old_name_lower\n  1013\t        ):\n  1014\t            return [\n  1015\t                RenameIndex(\n  1016\t                    self.model_name,\n  1017\t                    new_name=operation.new_name,\n  1018\t                    old_name=self.old_name,\n  1019\t                    old_fields=self.old_fields,\n  1020\t                )\n  1021\t            ]\n  1022\t        return super().reduce(operation, app_label)\n      # ...\n```\n\n\ndjango/db/backends/base/schema.py\n```\n     1\timport logging\n     2\timport operator\n     3\tfrom datetime import datetime\n     4\t\n     5\tfrom django.db.backends.ddl_references import (\n     6\t    Columns,\n     7\t    Expressions,\n     8\t    ForeignKeyName,\n     9\t    IndexName,\n    10\t    Statement,\n    11\t    Table,\n    12\t)\n    13\tfrom django.db.backends.utils import names_digest, split_identifier\n    14\tfrom django.db.models import Deferrable, Index\n    15\tfrom django.db.models.sql import Query\n    16\tfrom django.db.transaction import TransactionManagementError, atomic\n    17\tfrom django.utils import timezone\n    18\t\n    19\tlogger = logging.getLogger(\"django.db.backends.schema\")\n      # ...\n    72\t\n    73\t\n    74\tclass BaseDatabaseSchemaEditor:\n    75\t    \"\"\"\n    76\t    This class and its subclasses are responsible for emitting schema-changing\n    77\t    statements to the databases - model creation/removal/alteration, field\n    78\t    renaming, index fiddling, and so on.\n    79\t    \"\"\"\n    80\t\n    81\t    # Overrideable SQL templates\n    82\t    sql_create_table = \"CREATE TABLE %(table)s (%(definition)s)\"\n    83\t    sql_rename_table = \"ALTER TABLE %(old_table)s RENAME TO %(new_table)s\"\n    84\t    sql_retablespace_table = \"ALTER TABLE %(table)s SET TABLESPACE %(new_tablespace)s\"\n    85\t    sql_delete_table = \"DROP TABLE %(table)s CASCADE\"\n    86\t\n    87\t    sql_create_column = \"ALTER TABLE %(table)s ADD COLUMN %(column)s %(definition)s\"\n    88\t    sql_alter_column = \"ALTER TABLE %(table)s %(changes)s\"\n    89\t    sql_alter_column_type = \"ALTER COLUMN %(column)s TYPE %(type)s\"\n    90\t    sql_alter_column_null = \"ALTER COLUMN %(column)s DROP NOT NULL\"\n    91\t    sql_alter_column_not_null = \"ALTER COLUMN %(column)s SET NOT NULL\"\n    92\t    sql_alter_column_default = \"ALTER COLUMN %(column)s SET DEFAULT %(default)s\"\n    93\t    sql_alter_column_no_default = \"ALTER COLUMN %(column)s DROP DEFAULT\"\n    94\t    sql_alter_column_no_default_null = sql_alter_column_no_default\n    95\t    sql_alter_column_collate = \"ALTER COLUMN %(column)s TYPE %(type)s%(collation)s\"\n    96\t    sql_delete_column = \"ALTER TABLE %(table)s DROP COLUMN %(column)s CASCADE\"\n    97\t    sql_rename_column = (\n    98\t        \"ALTER TABLE %(table)s RENAME COLUMN %(old_column)s TO %(new_column)s\"\n    99\t    )\n   100\t    sql_update_with_default = (\n   101\t        \"UPDATE %(table)s SET %(column)s = %(default)s WHERE %(column)s IS NULL\"\n   102\t    )\n   103\t\n   104\t    sql_unique_constraint = \"UNIQUE (%(columns)s)%(deferrable)s\"\n   105\t    sql_check_constraint = \"CHECK (%(check)s)\"\n   106\t    sql_delete_constraint = \"ALTER TABLE %(table)s DROP CONSTRAINT %(name)s\"\n   107\t    sql_constraint = \"CONSTRAINT %(name)s %(constraint)s\"\n   108\t\n   109\t    sql_create_check = \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s CHECK (%(check)s)\"\n   110\t    sql_delete_check = sql_delete_constraint\n   111\t\n   112\t    sql_create_unique = (\n   113\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s \"\n   114\t        \"UNIQUE (%(columns)s)%(deferrable)s\"\n   115\t    )\n   116\t    sql_delete_unique = sql_delete_constraint\n   117\t\n   118\t    sql_create_fk = (\n   119\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s FOREIGN KEY (%(column)s) \"\n   120\t        \"REFERENCES %(to_table)s (%(to_column)s)%(deferrable)s\"\n   121\t    )\n   122\t    sql_create_inline_fk = None\n   123\t    sql_create_column_inline_fk = None\n   124\t    sql_delete_fk = sql_delete_constraint\n   125\t\n   126\t    sql_create_index = (\n   127\t        \"CREATE INDEX %(name)s ON %(table)s \"\n   128\t        \"(%(columns)s)%(include)s%(extra)s%(condition)s\"\n   129\t    )\n   130\t    sql_create_unique_index = (\n   131\t        \"CREATE UNIQUE INDEX %(name)s ON %(table)s \"\n   132\t        \"(%(columns)s)%(include)s%(condition)s\"\n   133\t    )\n   134\t    sql_rename_index = \"ALTER INDEX %(old_name)s RENAME TO %(new_name)s\"\n   135\t    sql_delete_index = \"DROP INDEX %(name)s\"\n   136\t\n   137\t    sql_create_pk = (\n   138\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s PRIMARY KEY (%(columns)s)\"\n   139\t    )\n   140\t    sql_delete_pk = sql_delete_constraint\n   141\t\n   142\t    sql_delete_procedure = \"DROP PROCEDURE %(procedure)s\"\n          # ...\n  1374\t\n  1375\t    def _rename_index_sql(self, model, old_name, new_name):\n  1376\t        return Statement(\n  1377\t            self.sql_rename_index,\n  1378\t            table=Table(model._meta.db_table, self.quote_name),\n  1379\t            old_name=self.quote_name(old_name),\n  1380\t            new_name=self.quote_name(new_name),\n  1381\t        )\n          # ...\n```\n\n</observation>",
                  "type": "tool_result"
                }
              ]
            },
            {
              "role": "assistant",
              "content": [
                {
                  "type": "text",
                  "text": "<thoughts>\n1. Looking at the code, I can see that RenameIndex has two modes:\n   - Renaming an index by old_name \n   - Renaming an unnamed index by old_fields\n\n2. The issue appears to be in the database_backwards() method when dealing with unnamed indexes. The method has a comment \"Backward operation with unnamed index is a no-op\" and just returns without doing anything.\n\n3. This means that when trying to revert an unnamed index rename operation, it doesn't properly restore the old auto-generated name.\n\n4. The fix should be to:\n   - Remove the early return for unnamed indexes in database_backwards()\n   - Handle the reversal properly by swapping names and letting database_forwards() handle it\n\nLet me look at the test file again to understand the exact test case that's failing.\n</thoughts>"
                },
                {
                  "id": "call_a879f7cc",
                  "input": {
                    "files": [
                      {
                        "file_path": "tests/migrations/test_operations.py",
                        "start_line": 2980,
                        "end_line": 3000,
                        "span_ids": []
                      }
                    ]
                  },
                  "type": "tool_use",
                  "name": "ViewCode"
                }
              ]
            },
            {
              "role": "user",
              "content": [
                {
                  "tool_use_id": "call_a879f7cc",
                  "content": "<observation>\nHere's the contents of the requested code spans:\ntests/migrations/test_operations.py\n```\n     1\tfrom django.core.exceptions import FieldDoesNotExist\n     2\tfrom django.db import IntegrityError, connection, migrations, models, transaction\n     3\tfrom django.db.migrations.migration import Migration\n     4\tfrom django.db.migrations.operations.fields import FieldOperation\n     5\tfrom django.db.migrations.state import ModelState, ProjectState\n     6\tfrom django.db.models.functions import Abs\n     7\tfrom django.db.transaction import atomic\n     8\tfrom django.test import SimpleTestCase, override_settings, skipUnlessDBFeature\n     9\tfrom django.test.utils import CaptureQueriesContext\n    10\t\n    11\tfrom .models import FoodManager, FoodQuerySet, UnicodeModel\n    12\tfrom .test_base import OperationTestBase\n      # ...\n    17\t\n    18\t\n    19\tclass OperationTests(OperationTestBase):\n    20\t    \"\"\"\n    21\t    Tests running the operations and making sure they do what they say they do.\n    22\t    Each test looks at their state changing, and then their database operation -\n    23\t    both forwards and backwards.\n    24\t    \"\"\"\n          # ...\n  2963\t\n  2964\t    def test_rename_index_unnamed_index(self):\n  2965\t        app_label = \"test_rninui\"\n  2966\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  2967\t        table_name = app_label + \"_pony\"\n  2968\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2969\t        operation = migrations.RenameIndex(\n  2970\t            \"Pony\", new_name=\"new_pony_test_idx\", old_fields=(\"weight\", \"pink\")\n  2971\t        )\n  2972\t        self.assertEqual(\n  2973\t            operation.describe(),\n  2974\t            \"Rename unnamed index for ('weight', 'pink') on Pony to new_pony_test_idx\",\n  2975\t        )\n  2976\t        self.assertEqual(\n  2977\t            operation.migration_name_fragment,\n  2978\t            \"rename_pony_weight_pink_new_pony_test_idx\",\n  2979\t        )\n  2980\t\n  2981\t        new_state = project_state.clone()\n  2982\t        operation.state_forwards(app_label, new_state)\n  2983\t        # Rename index.\n  2984\t        with connection.schema_editor() as editor:\n  2985\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2986\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2987\t        # Reverse is a no-op.\n  2988\t        with connection.schema_editor() as editor, self.assertNumQueries(0):\n  2989\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2990\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2991\t        # Deconstruction.\n  2992\t        definition = operation.deconstruct()\n  2993\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2994\t        self.assertEqual(definition[1], [])\n  2995\t        self.assertEqual(\n  2996\t            definition[2],\n  2997\t            {\n  2998\t                \"model_name\": \"Pony\",\n  2999\t                \"new_name\": \"new_pony_test_idx\",\n  3000\t                \"old_fields\": (\"weight\", \"pink\"),\n  3001\t            },\n  3002\t        )\n          # ...\n      # ...\n```\n\n</observation>",
                  "type": "tool_result"
                }
              ]
            },
            {
              "role": "assistant",
              "content": [
                {
                  "type": "text",
                  "text": "<thoughts>\nLooking at the test case, I can see that:\n\n1. The test is specifically checking that RenameIndex works with unnamed indexes (created via index_together)\n\n2. The test expects that:\n   - Forward operation renames the unnamed index to \"new_pony_test_idx\"\n   - Backward operation is currently a no-op and keeps \"new_pony_test_idx\"\n\n3. The issue is that this behavior is incorrect - the backward operation should restore the original auto-generated name for the index.\n\n4. The fix needs to:\n   - Remove the early return in database_backwards() for unnamed indexes\n   - Let the normal name swapping and database_forwards() handle restoring the original name\n\nLet me look at the ProjectState code to understand how it handles index names.\n</thoughts>"
                },
                {
                  "id": "call_5a4e16aa",
                  "input": {
                    "file_pattern": null,
                    "query": "ProjectState index_together handling",
                    "category": "implementation"
                  },
                  "type": "tool_use",
                  "name": "SemanticSearch"
                }
              ]
            },
            {
              "role": "user",
              "content": [
                {
                  "tool_use_id": "call_5a4e16aa",
                  "content": "<observation>\nFound 14 code sections.\n\nViewed relevant code:\ndjango/db/migrations/state.py\n```\n     1\timport copy\n     2\tfrom collections import defaultdict\n     3\tfrom contextlib import contextmanager\n     4\tfrom functools import partial\n     5\t\n     6\tfrom django.apps import AppConfig\n     7\tfrom django.apps.registry import Apps\n     8\tfrom django.apps.registry import apps as global_apps\n     9\tfrom django.conf import settings\n    10\tfrom django.core.exceptions import FieldDoesNotExist\n    11\tfrom django.db import models\n    12\tfrom django.db.migrations.utils import field_is_referenced, get_references\n    13\tfrom django.db.models import NOT_PROVIDED\n    14\tfrom django.db.models.fields.related import RECURSIVE_RELATIONSHIP_CONSTANT\n    15\tfrom django.db.models.options import DEFAULT_NAMES, normalize_together\n    16\tfrom django.db.models.utils import make_model_tuple\n    17\tfrom django.utils.functional import cached_property\n    18\tfrom django.utils.module_loading import import_string\n    19\tfrom django.utils.version import get_docs_version\n    20\t\n    21\tfrom .exceptions import InvalidBasesError\n    22\tfrom .utils import resolve_relation\n      # ...\n    91\t\n    92\t\n    93\tclass ProjectState:\n    94\t    \"\"\"\n    95\t    Represent the entire project's overall state. This is the item that is\n    96\t    passed around - do it here rather than at the app level so that cross-app\n    97\t    FKs/etc. resolve properly.\n    98\t    \"\"\"\n          # ...\n   180\t\n   181\t    def alter_model_options(self, app_label, model_name, options, option_keys=None):\n   182\t        model_state = self.models[app_label, model_name]\n   183\t        model_state.options = {**model_state.options, **options}\n   184\t        if option_keys:\n   185\t            for key in option_keys:\n   186\t                if key not in options:\n   187\t                    model_state.options.pop(key, False)\n   188\t        self.reload_model(app_label, model_name, delay=True)\n   189\t\n   190\t    def remove_model_options(self, app_label, model_name, option_name, value_to_remove):\n   191\t        model_state = self.models[app_label, model_name]\n   192\t        if objs := model_state.options.get(option_name):\n   193\t            model_state.options[option_name] = [\n   194\t                obj for obj in objs if tuple(obj) != tuple(value_to_remove)\n   195\t            ]\n   196\t        self.reload_model(app_label, model_name, delay=True)\n          # ...\n      # ...\n```\n\n</observation>",
                  "type": "tool_result"
                }
              ]
            },
            {
              "role": "assistant",
              "content": [
                {
                  "type": "text",
                  "text": "<thoughts>\nLet me view the specific RenameIndex operation code to make the changes.\n</thoughts>"
                },
                {
                  "id": "call_983db9de",
                  "input": {
                    "files": [
                      {
                        "file_path": "django/db/migrations/operations/models.py",
                        "start_line": 879,
                        "end_line": 986,
                        "span_ids": []
                      }
                    ]
                  },
                  "type": "tool_use",
                  "name": "ViewCode"
                }
              ]
            },
            {
              "role": "user",
              "content": [
                {
                  "tool_use_id": "call_983db9de",
                  "content": "<observation>\nHere's the contents of the requested code spans:\ndjango/db/migrations/operations/models.py\n```\n     1\tfrom django.db import models\n     2\tfrom django.db.migrations.operations.base import Operation\n     3\tfrom django.db.migrations.state import ModelState\n     4\tfrom django.db.migrations.utils import field_references, resolve_relation\n     5\tfrom django.db.models.options import normalize_together\n     6\tfrom django.utils.functional import cached_property\n     7\t\n     8\tfrom .fields import AddField, AlterField, FieldOperation, RemoveField, RenameField\n      # ...\n   877\t\n   878\t\n   879\tclass RenameIndex(IndexOperation):\n   880\t    \"\"\"Rename an index.\"\"\"\n   881\t\n   882\t    def __init__(self, model_name, new_name, old_name=None, old_fields=None):\n   883\t        if not old_name and not old_fields:\n   884\t            raise ValueError(\n   885\t                \"RenameIndex requires one of old_name and old_fields arguments to be \"\n   886\t                \"set.\"\n   887\t            )\n   888\t        if old_name and old_fields:\n   889\t            raise ValueError(\n   890\t                \"RenameIndex.old_name and old_fields are mutually exclusive.\"\n   891\t            )\n   892\t        self.model_name = model_name\n   893\t        self.new_name = new_name\n   894\t        self.old_name = old_name\n   895\t        self.old_fields = old_fields\n   896\t\n   897\t    @cached_property\n   898\t    def old_name_lower(self):\n   899\t        return self.old_name.lower()\n   900\t\n   901\t    @cached_property\n   902\t    def new_name_lower(self):\n   903\t        return self.new_name.lower()\n   904\t\n   905\t    def deconstruct(self):\n   906\t        kwargs = {\n   907\t            \"model_name\": self.model_name,\n   908\t            \"new_name\": self.new_name,\n   909\t        }\n   910\t        if self.old_name:\n   911\t            kwargs[\"old_name\"] = self.old_name\n   912\t        if self.old_fields:\n   913\t            kwargs[\"old_fields\"] = self.old_fields\n   914\t        return (self.__class__.__qualname__, [], kwargs)\n   915\t\n   916\t    def state_forwards(self, app_label, state):\n   917\t        if self.old_fields:\n   918\t            state.add_index(\n   919\t                app_label,\n   920\t                self.model_name_lower,\n   921\t                models.Index(fields=self.old_fields, name=self.new_name),\n   922\t            )\n   923\t            state.remove_model_options(\n   924\t                app_label,\n   925\t                self.model_name_lower,\n   926\t                AlterIndexTogether.option_name,\n   927\t                self.old_fields,\n   928\t            )\n   929\t        else:\n   930\t            state.rename_index(\n   931\t                app_label, self.model_name_lower, self.old_name, self.new_name\n   932\t            )\n   933\t\n   934\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n   935\t        model = to_state.apps.get_model(app_label, self.model_name)\n   936\t        if not self.allow_migrate_model(schema_editor.connection.alias, model):\n   937\t            return\n   938\t\n   939\t        if self.old_fields:\n   940\t            from_model = from_state.apps.get_model(app_label, self.model_name)\n   941\t            columns = [\n   942\t                from_model._meta.get_field(field).column for field in self.old_fields\n   943\t            ]\n   944\t            matching_index_name = schema_editor._constraint_names(\n   945\t                from_model, column_names=columns, index=True\n   946\t            )\n   947\t            if len(matching_index_name) != 1:\n   948\t                raise ValueError(\n   949\t                    \"Found wrong number (%s) of indexes for %s(%s).\"\n   950\t                    % (\n   951\t                        len(matching_index_name),\n   952\t                        from_model._meta.db_table,\n   953\t                        \", \".join(columns),\n   954\t                    )\n   955\t                )\n   956\t            old_index = models.Index(\n   957\t                fields=self.old_fields,\n   958\t                name=matching_index_name[0],\n   959\t            )\n   960\t        else:\n   961\t            from_model_state = from_state.models[app_label, self.model_name_lower]\n   962\t            old_index = from_model_state.get_index_by_name(self.old_name)\n   963\t\n   964\t        to_model_state = to_state.models[app_label, self.model_name_lower]\n   965\t        new_index = to_model_state.get_index_by_name(self.new_name)\n   966\t        schema_editor.rename_index(model, old_index, new_index)\n   967\t\n   968\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n   969\t        if self.old_fields:\n   970\t            # Backward operation with unnamed index is a no-op.\n   971\t            return\n   972\t\n   973\t        self.new_name_lower, self.old_name_lower = (\n   974\t            self.old_name_lower,\n   975\t            self.new_name_lower,\n   976\t        )\n   977\t        self.new_name, self.old_name = self.old_name, self.new_name\n   978\t\n   979\t        self.database_forwards(app_label, schema_editor, from_state, to_state)\n   980\t\n   981\t        self.new_name_lower, self.old_name_lower = (\n   982\t            self.old_name_lower,\n   983\t            self.new_name_lower,\n   984\t        )\n   985\t        self.new_name, self.old_name = self.old_name, self.new_name\n          # ...\n      # ...\n```\n\n</observation>",
                  "type": "tool_result",
                  "cache_control": {
                    "type": "ephemeral"
                  }
                }
              ]
            },
            {
              "role": "assistant",
              "content": [
                {
                  "type": "text",
                  "text": "<thoughts>\nI can now see the issue clearly:\n\n1. The problem is in database_backwards() where it has an early return for unnamed indexes:\n```python\nif self.old_fields:\n    # Backward operation with unnamed index is a no-op.\n    return\n```\n\n2. This means that when trying to revert a rename of an unnamed index, it does nothing, leaving the new name in place.\n\n3. Instead, it should:\n   - Keep track of the original auto-generated name from database_forwards()\n   - Allow the reversal to happen by removing the early return\n   - Let the normal name swapping and database_forwards() handle restoring the original name\n\n4. The fix should:\n   - Remove the early return for old_fields case\n   - Let the name swapping and database_forwards() handle the reversal just like it does for named indexes\n\nLet me prepare the fix.\n</thoughts>"
                },
                {
                  "id": "call_28d1ee84",
                  "input": {
                    "command": "view",
                    "path": "django/db/migrations/operations/models.py",
                    "file_text": null,
                    "view_range": null,
                    "old_str": null,
                    "new_str": null,
                    "insert_line": null
                  },
                  "type": "tool_use",
                  "name": "str_replace_editor",
                  "cache_control": {
                    "type": "ephemeral"
                  }
                }
              ]
            },
            {
              "role": "user",
              "content": [
                {
                  "tool_use_id": "call_28d1ee84",
                  "content": "<observation>\nFile django/db/migrations/operations/models.py is too large (7725 tokens) to view in its entirety. Maximum allowed is 2000 tokens. Please specify a line range using view_range or spans with ViewCode to view specific parts of the file.\nHere's a structure of the file django/db/migrations/operations/models.py\n```\n\n      # ...\n     9\t\n    10\t\n    11\tdef _check_for_duplicates(arg_name, objs):\n          # ...\n    19\t\n    20\t\n    21\tclass ModelOperation(Operation):\n    22\t    def __init__(self, name):\n              # ...\n    24\t\n    25\t    @cached_property\n    26\t    def name_lower(self):\n              # ...\n    28\t\n    29\t    def references_model(self, name, app_label):\n              # ...\n    31\t\n    32\t    def reduce(self, operation, app_label):\n              # ...\n    36\t\n    37\t    def can_reduce_through(self, operation, app_label):\n              # ...\n    39\t\n    40\t\n    41\tclass CreateModel(ModelOperation):\n          # ...\n    45\t\n    46\t    def __init__(self, name, fields, options=None, bases=None, managers=None):\n              # ...\n    67\t\n    68\t    def deconstruct(self):\n              # ...\n    80\t\n    81\t    def state_forwards(self, app_label, state):\n              # ...\n    92\t\n    93\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n    97\t\n    98\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   102\t\n   103\t    def describe(self):\n              # ...\n   108\t\n   109\t    @property\n   110\t    def migration_name_fragment(self):\n              # ...\n   112\t\n   113\t    def references_model(self, name, app_label):\n              # ...\n   135\t\n   136\t    def reduce(self, operation, app_label):\n              # ...\n   307\t\n   308\t\n   309\tclass DeleteModel(ModelOperation):\n   311\t\n   312\t    def deconstruct(self):\n              # ...\n   317\t\n   318\t    def state_forwards(self, app_label, state):\n              # ...\n   320\t\n   321\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   325\t\n   326\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   330\t\n   331\t    def references_model(self, name, app_label):\n              # ...\n   335\t\n   336\t    def describe(self):\n              # ...\n   338\t\n   339\t    @property\n   340\t    def migration_name_fragment(self):\n              # ...\n   342\t\n   343\t\n   344\tclass RenameModel(ModelOperation):\n   346\t\n   347\t    def __init__(self, old_name, new_name):\n              # ...\n   351\t\n   352\t    @cached_property\n   353\t    def old_name_lower(self):\n              # ...\n   355\t\n   356\t    @cached_property\n   357\t    def new_name_lower(self):\n              # ...\n   359\t\n   360\t    def deconstruct(self):\n              # ...\n   366\t\n   367\t    def state_forwards(self, app_label, state):\n              # ...\n   369\t\n   370\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   426\t\n   427\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   441\t\n   442\t    def references_model(self, name, app_label):\n              # ...\n   446\t\n   447\t    def describe(self):\n              # ...\n   449\t\n   450\t    @property\n   451\t    def migration_name_fragment(self):\n              # ...\n   453\t\n   454\t    def reduce(self, operation, app_label):\n              # ...\n   470\t\n   471\t\n   472\tclass ModelOptionOperation(ModelOperation):\n   473\t    def reduce(self, operation, app_label):\n              # ...\n   480\t\n   481\t\n   482\tclass AlterModelTable(ModelOptionOperation):\n   484\t\n   485\t    def __init__(self, name, table):\n              # ...\n   488\t\n   489\t    def deconstruct(self):\n              # ...\n   495\t\n   496\t    def state_forwards(self, app_label, state):\n              # ...\n   498\t\n   499\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   518\t\n   519\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   521\t\n   522\t    def describe(self):\n              # ...\n   527\t\n   528\t    @property\n   529\t    def migration_name_fragment(self):\n              # ...\n   531\t\n   532\t\n   533\tclass AlterTogetherOptionOperation(ModelOptionOperation):\n          # ...\n   535\t\n   536\t    def __init__(self, name, option_value):\n              # ...\n   541\t\n   542\t    @cached_property\n   543\t    def option_value(self):\n              # ...\n   545\t\n   546\t    def deconstruct(self):\n              # ...\n   552\t\n   553\t    def state_forwards(self, app_label, state):\n              # ...\n   559\t\n   560\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   570\t\n   571\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   573\t\n   574\t    def references_field(self, model_name, name, app_label):\n              # ...\n   579\t\n   580\t    def describe(self):\n              # ...\n   586\t\n   587\t    @property\n   588\t    def migration_name_fragment(self):\n              # ...\n   590\t\n   591\t    def can_reduce_through(self, operation, app_label):\n              # ...\n   596\t\n   597\t\n   598\tclass AlterUniqueTogether(AlterTogetherOptionOperation):\n          # ...\n   605\t\n   606\t    def __init__(self, name, unique_together):\n              # ...\n   608\t\n   609\t\n   610\tclass AlterIndexTogether(AlterTogetherOptionOperation):\n          # ...\n   617\t\n   618\t    def __init__(self, name, index_together):\n              # ...\n   620\t\n   621\t\n   622\tclass AlterOrderWithRespectTo(ModelOptionOperation):\n          # ...\n   626\t\n   627\t    def __init__(self, name, order_with_respect_to):\n              # ...\n   630\t\n   631\t    def deconstruct(self):\n              # ...\n   637\t\n   638\t    def state_forwards(self, app_label, state):\n              # ...\n   644\t\n   645\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   670\t\n   671\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   673\t\n   674\t    def references_field(self, model_name, name, app_label):\n              # ...\n   678\t\n   679\t    def describe(self):\n              # ...\n   684\t\n   685\t    @property\n   686\t    def migration_name_fragment(self):\n              # ...\n   688\t\n   689\t\n   690\tclass AlterModelOptions(ModelOptionOperation):\n          # ...\n   711\t\n   712\t    def __init__(self, name, options):\n              # ...\n   715\t\n   716\t    def deconstruct(self):\n              # ...\n   722\t\n   723\t    def state_forwards(self, app_label, state):\n              # ...\n   730\t\n   731\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   733\t\n   734\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   736\t\n   737\t    def describe(self):\n              # ...\n   739\t\n   740\t    @property\n   741\t    def migration_name_fragment(self):\n              # ...\n   743\t\n   744\t\n   745\tclass AlterModelManagers(ModelOptionOperation):\n          # ...\n   749\t\n   750\t    def __init__(self, name, managers):\n              # ...\n   753\t\n   754\t    def deconstruct(self):\n              # ...\n   756\t\n   757\t    def state_forwards(self, app_label, state):\n              # ...\n   759\t\n   760\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   762\t\n   763\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   765\t\n   766\t    def describe(self):\n              # ...\n   768\t\n   769\t    @property\n   770\t    def migration_name_fragment(self):\n              # ...\n   772\t\n   773\t\n   774\tclass IndexOperation(Operation):\n          # ...\n   776\t\n   777\t    @cached_property\n   778\t    def model_name_lower(self):\n              # ...\n   780\t\n   781\t\n   782\tclass AddIndex(IndexOperation):\n   784\t\n   785\t    def __init__(self, model_name, index):\n              # ...\n   793\t\n   794\t    def state_forwards(self, app_label, state):\n              # ...\n   796\t\n   797\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   801\t\n   802\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   806\t\n   807\t    def deconstruct(self):\n              # ...\n   817\t\n   818\t    def describe(self):\n              # ...\n   830\t\n   831\t    @property\n   832\t    def migration_name_fragment(self):\n              # ...\n   834\t\n   835\t\n   836\tclass RemoveIndex(IndexOperation):\n   838\t\n   839\t    def __init__(self, model_name, name):\n              # ...\n   842\t\n   843\t    def state_forwards(self, app_label, state):\n              # ...\n   845\t\n   846\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   852\t\n   853\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   859\t\n   860\t    def deconstruct(self):\n              # ...\n   870\t\n   871\t    def describe(self):\n              # ...\n   873\t\n   874\t    @property\n   875\t    def migration_name_fragment(self):\n              # ...\n   877\t\n   878\t\n   879\tclass RenameIndex(IndexOperation):\n   881\t\n   882\t    def __init__(self, model_name, new_name, old_name=None, old_fields=None):\n              # ...\n   896\t\n   897\t    @cached_property\n   898\t    def old_name_lower(self):\n              # ...\n   900\t\n   901\t    @cached_property\n   902\t    def new_name_lower(self):\n              # ...\n   904\t\n   905\t    def deconstruct(self):\n              # ...\n   915\t\n   916\t    def state_forwards(self, app_label, state):\n              # ...\n   933\t\n   934\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   967\t\n   968\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n   986\t\n   987\t    def describe(self):\n              # ...\n   996\t\n   997\t    @property\n   998\t    def migration_name_fragment(self):\n              # ...\n  1006\t\n  1007\t    def reduce(self, operation, app_label):\n              # ...\n  1023\t\n  1024\t\n  1025\tclass AddConstraint(IndexOperation):\n          # ...\n  1027\t\n  1028\t    def __init__(self, model_name, constraint):\n              # ...\n  1031\t\n  1032\t    def state_forwards(self, app_label, state):\n              # ...\n  1034\t\n  1035\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n  1039\t\n  1040\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n  1044\t\n  1045\t    def deconstruct(self):\n              # ...\n  1054\t\n  1055\t    def describe(self):\n              # ...\n  1060\t\n  1061\t    @property\n  1062\t    def migration_name_fragment(self):\n              # ...\n  1064\t\n  1065\t\n  1066\tclass RemoveConstraint(IndexOperation):\n          # ...\n  1068\t\n  1069\t    def __init__(self, model_name, name):\n              # ...\n  1072\t\n  1073\t    def state_forwards(self, app_label, state):\n              # ...\n  1075\t\n  1076\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n  1082\t\n  1083\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n              # ...\n  1089\t\n  1090\t    def deconstruct(self):\n              # ...\n  1099\t\n  1100\t    def describe(self):\n              # ...\n  1102\t\n  1103\t    @property\n  1104\t    def migration_name_fragment(self):\n              # ...\n```\n\n</observation>",
                  "type": "tool_result",
                  "cache_control": {
                    "type": "ephemeral"
                  }
                }
              ]
            }
          ],
          "response": {
            "id": "msg_01NkKERQDey2dp5ZMVZckcuG",
            "content": [
              {
                "text": "<thoughts>\nLet me view the specific RenameIndex database_backwards method to make the changes.\n</thoughts>",
                "type": "text"
              },
              {
                "id": "toolu_012WkK2HnQU5qnFkdyzAJsjY",
                "input": {
                  "files": [
                    {
                      "file_path": "django/db/migrations/operations/models.py",
                      "start_line": 968,
                      "end_line": 986,
                      "span_ids": []
                    }
                  ]
                },
                "name": "ViewCode",
                "type": "tool_use"
              }
            ],
            "model": "claude-3-5-sonnet-20241022",
            "role": "assistant",
            "stop_reason": "tool_use",
            "stop_sequence": null,
            "type": "message",
            "usage": {
              "cache_creation_input_tokens": 4073,
              "cache_read_input_tokens": 95217,
              "input_tokens": 0,
              "output_tokens": 122
            }
          },
          "usage": {
            "completion_cost": 0.014049,
            "completion_tokens": 122,
            "prompt_tokens": 4073,
            "cached_tokens": 95217
          }
        }
      },
      "possible_actions": [
        "SemanticSearch",
        "FindClass",
        "FindFunction",
        "FindCodeSnippet",
        "ViewCode",
        "ClaudeEditTool"
      ],
      "output": {
        "message": "Here's the contents of the requested code spans:\ndjango/db/migrations/operations/models.py\n```\n     1\tfrom django.db import models\n     2\tfrom django.db.migrations.operations.base import Operation\n     3\tfrom django.db.migrations.state import ModelState\n     4\tfrom django.db.migrations.utils import field_references, resolve_relation\n     5\tfrom django.db.models.options import normalize_together\n     6\tfrom django.utils.functional import cached_property\n     7\t\n     8\tfrom .fields import AddField, AlterField, FieldOperation, RemoveField, RenameField\n      # ...\n   877\t\n   878\t\n   879\tclass RenameIndex(IndexOperation):\n   880\t    \"\"\"Rename an index.\"\"\"\n          # ...\n   967\t\n   968\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n   969\t        if self.old_fields:\n   970\t            # Backward operation with unnamed index is a no-op.\n   971\t            return\n   972\t\n   973\t        self.new_name_lower, self.old_name_lower = (\n   974\t            self.old_name_lower,\n   975\t            self.new_name_lower,\n   976\t        )\n   977\t        self.new_name, self.old_name = self.old_name, self.new_name\n   978\t\n   979\t        self.database_forwards(app_label, schema_editor, from_state, to_state)\n   980\t\n   981\t        self.new_name_lower, self.old_name_lower = (\n   982\t            self.old_name_lower,\n   983\t            self.new_name_lower,\n   984\t        )\n   985\t        self.new_name, self.old_name = self.old_name, self.new_name\n          # ...\n      # ...\n```\n",
        "summary": "Showed the following code spans:\n\nFile: tests/migrations/test_operations.py\n- Showing all code in file\n\nFile: django/db/migrations/operations/models.py\n- imports\n- RenameIndex\n- RenameIndex.__init__\n- RenameIndex.old_name_lower\n- RenameIndex.new_name_lower\n- RenameIndex.deconstruct\n- RenameIndex.state_forwards\n- RenameIndex.database_forwards\n- RenameIndex.database_backwards\n- RenameIndex.describe\n- RenameIndex.migration_name_fragment\n- RenameIndex.reduce\n\nFile: django/db/backends/base/schema.py\n- imports\n- BaseDatabaseSchemaEditor\n- BaseDatabaseSchemaEditor._rename_index_sql\n\nFile: django/db/migrations/state.py\n- imports\n- ProjectState\n- ProjectState.alter_model_options\n- ProjectState.remove_model_options\n",
        "terminal": false,
        "expect_correction": false,
        "properties": {
          "files": {
            "django/db/migrations/operations/models.py": {
              "new_span_ids": []
            }
          },
          "fail_reason": "no_spans_added",
          "retries": 1
        }
      },
      "parent_id": 5
    },
    {
      "node_id": 7,
      "action": {
        "scratch_pad": "1. First, I need to understand the context better by:\n   - Looking at the test file to see the full test case\n   - Finding the RenameIndex operation implementation\n   - Understanding how index naming works in this context\n\n2. Let's start by viewing the test file to see the full test case context.",
        "files": [
          {
            "file_path": "tests/migrations/test_operations.py",
            "span_ids": []
          }
        ],
        "action_args_class": "moatless.actions.view_code.ViewCodeArgs"
      },
      "file_context": {
        "max_tokens": 8000,
        "files": []
      },
      "completions": {
        "build_action": {
          "model": "claude-3-5-sonnet-20241022",
          "input": [
            {
              "role": "user",
              "content": "<task>\nRenameIndex() crashes when unnamed index is moving backward and forward.\nDescription\n\t\nRenameIndex() should restore the old auto-generated name when an unnamed index for unique_together is moving backward. Now re-applying RenameIndex() crashes. For example:\ntests/migrations/test_operations.py\ndiff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex cfd28b1b39..c0a55023bb 100644\n\t\t\t\t\t\n\t\t\t\t\t a\n\t\t\t\t \n\t\t\t\t\t\n\t\t\t\t\t b\n\t\t\t\t \n class OperationTests(OperationTestBase):\u00a0\n29882988\u00a0 \u00a0 \u00a0 \u00a0 with connection.schema_editor() as editor, self.assertNumQueries(0):\n29892989\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 operation.database_backwards(app_label, editor, new_state, project_state)\n29902990\u00a0 \u00a0 \u00a0 \u00a0 self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n\u00a02991\u00a0 \u00a0 \u00a0 \u00a0 # Re-apply renaming.\n\u00a02992\u00a0 \u00a0 \u00a0 \u00a0 with connection.schema_editor() as editor:\n\u00a02993\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 operation.database_forwards(app_label, editor, project_state, new_state)\n\u00a02994\u00a0 \u00a0 \u00a0 \u00a0 self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n29912995\u00a0 \u00a0 \u00a0 \u00a0 # Deconstruction.\n29922996\u00a0 \u00a0 \u00a0 \u00a0 definition = operation.deconstruct()\n29932997\u00a0 \u00a0 \u00a0 \u00a0 self.assertEqual(definition[0], \"RenameIndex\")\ncrashes on PostgreSQL:\ndjango.db.utils.ProgrammingError: relation \"new_pony_test_idx\" already exists\n\n</task>"
            }
          ],
          "response": {
            "id": "msg_011Sfp1MXfa1Md2daLS1n68w",
            "content": [
              {
                "text": "Let me help investigate and fix this issue with RenameIndex() crashing when dealing with unnamed index movements.\n\n<thoughts>\n1. First, I need to understand the context better by:\n   - Looking at the test file to see the full test case\n   - Finding the RenameIndex operation implementation\n   - Understanding how index naming works in this context\n\n2. Let's start by viewing the test file to see the full test case context.\n</thoughts>",
                "type": "text"
              },
              {
                "id": "toolu_01BtE3rEw43887nwHzbzo2mh",
                "input": {
                  "files": [
                    {
                      "file_path": "tests/migrations/test_operations.py"
                    }
                  ]
                },
                "name": "ViewCode",
                "type": "tool_use"
              }
            ],
            "model": "claude-3-5-sonnet-20241022",
            "role": "assistant",
            "stop_reason": "tool_use",
            "stop_sequence": null,
            "type": "message",
            "usage": {
              "cache_creation_input_tokens": 0,
              "cache_read_input_tokens": 3981,
              "input_tokens": 524,
              "output_tokens": 170
            }
          },
          "usage": {
            "completion_cost": 0.004122000000000001,
            "completion_tokens": 170,
            "prompt_tokens": 524,
            "cached_tokens": 3981
          }
        }
      },
      "possible_actions": [
        "SemanticSearch",
        "FindClass",
        "FindFunction",
        "FindCodeSnippet",
        "ViewCode",
        "ClaudeEditTool"
      ],
      "is_duplicate": true,
      "parent_id": 6
    },
    {
      "node_id": 8,
      "action": {
        "scratch_pad": "It seems I need to use a different approach to find the relevant test code. Let me use SemanticSearch to find tests related to RenameIndex operations.",
        "query": "test RenameIndex operation migration",
        "category": "test",
        "action_args_class": "moatless.actions.semantic_search.SemanticSearchArgs"
      },
      "observation": {
        "message": "Found 15 code sections.\n\nViewed relevant code:\ntests/migrations/test_operations.py\n```\n     1\tfrom django.core.exceptions import FieldDoesNotExist\n     2\tfrom django.db import IntegrityError, connection, migrations, models, transaction\n     3\tfrom django.db.migrations.migration import Migration\n     4\tfrom django.db.migrations.operations.fields import FieldOperation\n     5\tfrom django.db.migrations.state import ModelState, ProjectState\n     6\tfrom django.db.models.functions import Abs\n     7\tfrom django.db.transaction import atomic\n     8\tfrom django.test import SimpleTestCase, override_settings, skipUnlessDBFeature\n     9\tfrom django.test.utils import CaptureQueriesContext\n    10\t\n    11\tfrom .models import FoodManager, FoodQuerySet, UnicodeModel\n    12\tfrom .test_base import OperationTestBase\n      # ...\n    17\t\n    18\t\n    19\tclass OperationTests(OperationTestBase):\n    20\t    \"\"\"\n    21\t    Tests running the operations and making sure they do what they say they do.\n    22\t    Each test looks at their state changing, and then their database operation -\n    23\t    both forwards and backwards.\n    24\t    \"\"\"\n          # ...\n  2902\t\n  2903\t    def test_rename_index(self):\n  2904\t        app_label = \"test_rnin\"\n  2905\t        project_state = self.set_up_test_model(app_label, index=True)\n  2906\t        table_name = app_label + \"_pony\"\n  2907\t        self.assertIndexNameExists(table_name, \"pony_pink_idx\")\n  2908\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2909\t        operation = migrations.RenameIndex(\n  2910\t            \"Pony\", new_name=\"new_pony_test_idx\", old_name=\"pony_pink_idx\"\n  2911\t        )\n  2912\t        self.assertEqual(\n  2913\t            operation.describe(),\n  2914\t            \"Rename index pony_pink_idx on Pony to new_pony_test_idx\",\n  2915\t        )\n  2916\t        self.assertEqual(\n  2917\t            operation.migration_name_fragment,\n  2918\t            \"rename_pony_pink_idx_new_pony_test_idx\",\n  2919\t        )\n  2920\t\n  2921\t        new_state = project_state.clone()\n  2922\t        operation.state_forwards(app_label, new_state)\n  2923\t        # Rename index.\n  2924\t        expected_queries = 1 if connection.features.can_rename_index else 2\n  2925\t        with connection.schema_editor() as editor, self.assertNumQueries(\n  2926\t            expected_queries\n  2927\t        ):\n  2928\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2929\t        self.assertIndexNameNotExists(table_name, \"pony_pink_idx\")\n  2930\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2931\t        # Reversal.\n  2932\t        with connection.schema_editor() as editor, self.assertNumQueries(\n  2933\t            expected_queries\n  2934\t        ):\n  2935\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2936\t        self.assertIndexNameExists(table_name, \"pony_pink_idx\")\n  2937\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2938\t        # Deconstruction.\n  2939\t        definition = operation.deconstruct()\n  2940\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2941\t        self.assertEqual(definition[1], [])\n  2942\t        self.assertEqual(\n  2943\t            definition[2],\n  2944\t            {\n  2945\t                \"model_name\": \"Pony\",\n  2946\t                \"old_name\": \"pony_pink_idx\",\n  2947\t                \"new_name\": \"new_pony_test_idx\",\n  2948\t            },\n  2949\t        )\n  2950\t\n  2951\t    def test_rename_index_arguments(self):\n  2952\t        msg = \"RenameIndex.old_name and old_fields are mutually exclusive.\"\n  2953\t        with self.assertRaisesMessage(ValueError, msg):\n  2954\t            migrations.RenameIndex(\n  2955\t                \"Pony\",\n  2956\t                new_name=\"new_idx_name\",\n  2957\t                old_name=\"old_idx_name\",\n  2958\t                old_fields=(\"weight\", \"pink\"),\n  2959\t            )\n  2960\t        msg = \"RenameIndex requires one of old_name and old_fields arguments to be set.\"\n  2961\t        with self.assertRaisesMessage(ValueError, msg):\n  2962\t            migrations.RenameIndex(\"Pony\", new_name=\"new_idx_name\")\n  2963\t\n  2964\t    def test_rename_index_unnamed_index(self):\n  2965\t        app_label = \"test_rninui\"\n  2966\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  2967\t        table_name = app_label + \"_pony\"\n  2968\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2969\t        operation = migrations.RenameIndex(\n  2970\t            \"Pony\", new_name=\"new_pony_test_idx\", old_fields=(\"weight\", \"pink\")\n  2971\t        )\n  2972\t        self.assertEqual(\n  2973\t            operation.describe(),\n  2974\t            \"Rename unnamed index for ('weight', 'pink') on Pony to new_pony_test_idx\",\n  2975\t        )\n  2976\t        self.assertEqual(\n  2977\t            operation.migration_name_fragment,\n  2978\t            \"rename_pony_weight_pink_new_pony_test_idx\",\n  2979\t        )\n  2980\t\n  2981\t        new_state = project_state.clone()\n  2982\t        operation.state_forwards(app_label, new_state)\n  2983\t        # Rename index.\n  2984\t        with connection.schema_editor() as editor:\n  2985\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2986\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2987\t        # Reverse is a no-op.\n  2988\t        with connection.schema_editor() as editor, self.assertNumQueries(0):\n  2989\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2990\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2991\t        # Deconstruction.\n  2992\t        definition = operation.deconstruct()\n  2993\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2994\t        self.assertEqual(definition[1], [])\n  2995\t        self.assertEqual(\n  2996\t            definition[2],\n  2997\t            {\n  2998\t                \"model_name\": \"Pony\",\n  2999\t                \"new_name\": \"new_pony_test_idx\",\n  3000\t                \"old_fields\": (\"weight\", \"pink\"),\n  3001\t            },\n  3002\t        )\n          # ...\n  3039\t\n  3040\t    def test_rename_index_state_forwards(self):\n  3041\t        app_label = \"test_rnidsf\"\n  3042\t        project_state = self.set_up_test_model(app_label, index=True)\n  3043\t        old_model = project_state.apps.get_model(app_label, \"Pony\")\n  3044\t        new_state = project_state.clone()\n  3045\t\n  3046\t        operation = migrations.RenameIndex(\n  3047\t            \"Pony\", new_name=\"new_pony_pink_idx\", old_name=\"pony_pink_idx\"\n  3048\t        )\n  3049\t        operation.state_forwards(app_label, new_state)\n  3050\t        new_model = new_state.apps.get_model(app_label, \"Pony\")\n  3051\t        self.assertIsNot(old_model, new_model)\n  3052\t        self.assertEqual(new_model._meta.indexes[0].name, \"new_pony_pink_idx\")\n  3053\t\n  3054\t    def test_rename_index_state_forwards_unnamed_index(self):\n  3055\t        app_label = \"test_rnidsfui\"\n  3056\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  3057\t        old_model = project_state.apps.get_model(app_label, \"Pony\")\n  3058\t        new_state = project_state.clone()\n  3059\t\n  3060\t        operation = migrations.RenameIndex(\n  3061\t            \"Pony\", new_name=\"new_pony_pink_idx\", old_fields=(\"weight\", \"pink\")\n  3062\t        )\n  3063\t        operation.state_forwards(app_label, new_state)\n  3064\t        new_model = new_state.apps.get_model(app_label, \"Pony\")\n  3065\t        self.assertIsNot(old_model, new_model)\n  3066\t        self.assertEqual(new_model._meta.index_together, tuple())\n  3067\t        self.assertEqual(new_model._meta.indexes[0].name, \"new_pony_pink_idx\")\n          # ...\n      # ...\n```\n\n\ntests/migrations/test_optimizer.py\n```\n     1\tfrom django.db import migrations, models\n     2\tfrom django.db.migrations import operations\n     3\tfrom django.db.migrations.optimizer import MigrationOptimizer\n     4\tfrom django.db.migrations.serializer import serializer_factory\n     5\tfrom django.test import SimpleTestCase\n     6\t\n     7\tfrom .models import EmptyManager, UnicodeModel\n     8\t\n     9\t\n    10\tclass OptimizerTests(SimpleTestCase):\n    11\t    \"\"\"\n    12\t    Tests the migration autodetector.\n    13\t    \"\"\"\n          # ...\n  1117\t\n  1118\t    def test_rename_index(self):\n  1119\t        self.assertOptimizesTo(\n  1120\t            [\n  1121\t                migrations.RenameIndex(\n  1122\t                    \"Pony\", new_name=\"mid_name\", old_fields=(\"weight\", \"pink\")\n  1123\t                ),\n  1124\t                migrations.RenameIndex(\n  1125\t                    \"Pony\", new_name=\"new_name\", old_name=\"mid_name\"\n  1126\t                ),\n  1127\t            ],\n  1128\t            [\n  1129\t                migrations.RenameIndex(\n  1130\t                    \"Pony\", new_name=\"new_name\", old_fields=(\"weight\", \"pink\")\n  1131\t                ),\n  1132\t            ],\n  1133\t        )\n  1134\t        self.assertOptimizesTo(\n  1135\t            [\n  1136\t                migrations.RenameIndex(\n  1137\t                    \"Pony\", new_name=\"mid_name\", old_name=\"old_name\"\n  1138\t                ),\n  1139\t                migrations.RenameIndex(\n  1140\t                    \"Pony\", new_name=\"new_name\", old_name=\"mid_name\"\n  1141\t                ),\n  1142\t            ],\n  1143\t            [migrations.RenameIndex(\"Pony\", new_name=\"new_name\", old_name=\"old_name\")],\n  1144\t        )\n  1145\t        self.assertDoesNotOptimize(\n  1146\t            [\n  1147\t                migrations.RenameIndex(\n  1148\t                    \"Pony\", new_name=\"mid_name\", old_name=\"old_name\"\n  1149\t                ),\n  1150\t                migrations.RenameIndex(\n  1151\t                    \"Pony\", new_name=\"new_name\", old_fields=(\"weight\", \"pink\")\n  1152\t                ),\n  1153\t            ]\n  1154\t        )\n```\n",
        "summary": "Found relevant code sections in the search results.",
        "terminal": false,
        "expect_correction": false,
        "properties": {
          "search_hits": [],
          "search_tokens": 3473,
          "new_span_ids": [
            "OperationTests",
            "OperationTests.test_rename_index",
            "OperationTests.test_rename_index_arguments",
            "OperationTests.test_rename_index_unnamed_index",
            "OperationTests.test_rename_index_state_forwards",
            "OperationTests.test_rename_index_state_forwards_unnamed_index",
            "OptimizerTests",
            "OptimizerTests.test_rename_index"
          ]
        },
        "execution_completion": {
          "model": "claude-3-5-sonnet-20241022",
          "input": [
            {
              "role": "user",
              "content": "Search request:\nSearching for code using the query: test RenameIndex operation migration\n\nIdentify the relevant code sections in the search results to use them. \n\n<search_results>\ntests/migrations/test_operations.py\n```\n\n\n\n<span id='imports'>\n     1\tfrom django.core.exceptions import FieldDoesNotExist\n     2\tfrom django.db import IntegrityError, connection, migrations, models, transaction\n     3\tfrom django.db.migrations.migration import Migration\n     4\tfrom django.db.migrations.operations.fields import FieldOperation\n     5\tfrom django.db.migrations.state import ModelState, ProjectState\n     6\tfrom django.db.models.functions import Abs\n     7\tfrom django.db.transaction import atomic\n     8\tfrom django.test import SimpleTestCase, override_settings, skipUnlessDBFeature\n     9\tfrom django.test.utils import CaptureQueriesContext\n    10\t\n    11\tfrom .models import FoodManager, FoodQuerySet, UnicodeModel\n    12\tfrom .test_base import OperationTestBase\n      # ...\n\n\n<span id='OperationTests'>\n    17\t\n    18\t\n    19\tclass OperationTests(OperationTestBase):\n    20\t    \"\"\"\n    21\t    Tests running the operations and making sure they do what they say they do.\n    22\t    Each test looks at their state changing, and then their database operation -\n    23\t    both forwards and backwards.\n    24\t    \"\"\"\n          # ...\n\n\n<span id='OperationTests.test_rename_model'>\n   774\t\n   775\t    def test_rename_model(self):\n   776\t        \"\"\"\n   777\t        Tests the RenameModel operation.\n   778\t        \"\"\"\n   779\t        project_state = self.set_up_test_model(\"test_rnmo\", related_model=True)\n   780\t        # Test the state alteration\n   781\t        operation = migrations.RenameModel(\"Pony\", \"Horse\")\n   782\t        self.assertEqual(operation.describe(), \"Rename model Pony to Horse\")\n   783\t        self.assertEqual(operation.migration_name_fragment, \"rename_pony_horse\")\n   784\t        # Test initial state and database\n   785\t        self.assertIn((\"test_rnmo\", \"pony\"), project_state.models)\n   786\t        self.assertNotIn((\"test_rnmo\", \"horse\"), project_state.models)\n   787\t        self.assertTableExists(\"test_rnmo_pony\")\n   788\t        self.assertTableNotExists(\"test_rnmo_horse\")\n   789\t        if connection.features.supports_foreign_keys:\n   790\t            self.assertFKExists(\n   791\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_pony\", \"id\")\n   792\t            )\n   793\t            self.assertFKNotExists(\n   794\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_horse\", \"id\")\n   795\t            )\n   796\t        # Migrate forwards\n   797\t        new_state = project_state.clone()\n   798\t        atomic_rename = connection.features.supports_atomic_references_rename\n   799\t        new_state = self.apply_operations(\n   800\t            \"test_rnmo\", new_state, [operation], atomic=atomic_rename\n   801\t        )\n   802\t        # Test new state and database\n   803\t        self.assertNotIn((\"test_rnmo\", \"pony\"), new_state.models)\n   804\t        self.assertIn((\"test_rnmo\", \"horse\"), new_state.models)\n   805\t        # RenameModel also repoints all incoming FKs and M2Ms\n   806\t        self.assertEqual(\n   807\t            new_state.models[\"test_rnmo\", \"rider\"].fields[\"pony\"].remote_field.model,\n   808\t            \"test_rnmo.Horse\",\n   809\t        )\n   810\t        self.assertTableNotExists(\"test_rnmo_pony\")\n   811\t        self.assertTableExists(\"test_rnmo_horse\")\n   812\t        if connection.features.supports_foreign_keys:\n   813\t            self.assertFKNotExists(\n   814\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_pony\", \"id\")\n   815\t            )\n   816\t            self.assertFKExists(\n   817\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_horse\", \"id\")\n   818\t            )\n   819\t        # Migrate backwards\n   820\t        original_state = self.unapply_operations(\n   821\t            \"test_rnmo\", project_state, [operation], atomic=atomic_rename\n   822\t        )\n   823\t        # Test original state and database\n   824\t        self.assertIn((\"test_rnmo\", \"pony\"), original_state.models)\n   825\t        self.assertNotIn((\"test_rnmo\", \"horse\"), original_state.models)\n   826\t        self.assertEqual(\n   827\t            original_state.models[\"test_rnmo\", \"rider\"]\n   828\t            .fields[\"pony\"]\n   829\t            .remote_field.model,\n   830\t            \"Pony\",\n   831\t        )\n   832\t        self.assertTableExists(\"test_rnmo_pony\")\n   833\t        self.assertTableNotExists(\"test_rnmo_horse\")\n   834\t        if connection.features.supports_foreign_keys:\n   835\t            self.assertFKExists(\n   836\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_pony\", \"id\")\n   837\t            )\n   838\t            self.assertFKNotExists(\n   839\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_horse\", \"id\")\n   840\t            )\n   841\t        # And deconstruction\n   842\t        definition = operation.deconstruct()\n   843\t        self.assertEqual(definition[0], \"RenameModel\")\n   844\t        self.assertEqual(definition[1], [])\n   845\t        self.assertEqual(definition[2], {\"old_name\": \"Pony\", \"new_name\": \"Horse\"})\n          # ...\n\n\n<span id='OperationTests.test_rename_field'>\n  2487\t\n  2488\t    def test_rename_field(self):\n  2489\t        \"\"\"\n  2490\t        Tests the RenameField operation.\n  2491\t        \"\"\"\n  2492\t        project_state = self.set_up_test_model(\n  2493\t            \"test_rnfl\", unique_together=True, index_together=True\n  2494\t        )\n  2495\t        # Test the state alteration\n  2496\t        operation = migrations.RenameField(\"Pony\", \"pink\", \"blue\")\n  2497\t        self.assertEqual(operation.describe(), \"Rename field pink on Pony to blue\")\n  2498\t        self.assertEqual(operation.migration_name_fragment, \"rename_pink_pony_blue\")\n  2499\t        new_state = project_state.clone()\n  2500\t        operation.state_forwards(\"test_rnfl\", new_state)\n  2501\t        self.assertIn(\"blue\", new_state.models[\"test_rnfl\", \"pony\"].fields)\n  2502\t        self.assertNotIn(\"pink\", new_state.models[\"test_rnfl\", \"pony\"].fields)\n  2503\t        # Make sure the unique_together has the renamed column too\n  2504\t        self.assertIn(\n  2505\t            \"blue\", new_state.models[\"test_rnfl\", \"pony\"].options[\"unique_together\"][0]\n  2506\t        )\n  2507\t        self.assertNotIn(\n  2508\t            \"pink\", new_state.models[\"test_rnfl\", \"pony\"].options[\"unique_together\"][0]\n  2509\t        )\n  2510\t        # Make sure the index_together has the renamed column too\n  2511\t        self.assertIn(\n  2512\t            \"blue\", new_state.models[\"test_rnfl\", \"pony\"].options[\"index_together\"][0]\n  2513\t        )\n  2514\t        self.assertNotIn(\n  2515\t            \"pink\", new_state.models[\"test_rnfl\", \"pony\"].options[\"index_together\"][0]\n  2516\t        )\n  2517\t        # Test the database alteration\n  2518\t        self.assertColumnExists(\"test_rnfl_pony\", \"pink\")\n  2519\t        self.assertColumnNotExists(\"test_rnfl_pony\", \"blue\")\n  2520\t        with connection.schema_editor() as editor:\n  2521\t            operation.database_forwards(\"test_rnfl\", editor, project_state, new_state)\n  2522\t        self.assertColumnExists(\"test_rnfl_pony\", \"blue\")\n  2523\t        self.assertColumnNotExists(\"test_rnfl_pony\", \"pink\")\n  2524\t        # Ensure the unique constraint has been ported over\n  2525\t        with connection.cursor() as cursor:\n  2526\t            cursor.execute(\"INSERT INTO test_rnfl_pony (blue, weight) VALUES (1, 1)\")\n  2527\t            with self.assertRaises(IntegrityError):\n  2528\t                with atomic():\n  2529\t                    cursor.execute(\n  2530\t                        \"INSERT INTO test_rnfl_pony (blue, weight) VALUES (1, 1)\"\n  2531\t                    )\n  2532\t            cursor.execute(\"DELETE FROM test_rnfl_pony\")\n  2533\t        # Ensure the index constraint has been ported over\n  2534\t        self.assertIndexExists(\"test_rnfl_pony\", [\"weight\", \"blue\"])\n  2535\t        # And test reversal\n  2536\t        with connection.schema_editor() as editor:\n  2537\t            operation.database_backwards(\"test_rnfl\", editor, new_state, project_state)\n  2538\t        self.assertColumnExists(\"test_rnfl_pony\", \"pink\")\n  2539\t        self.assertColumnNotExists(\"test_rnfl_pony\", \"blue\")\n  2540\t        # Ensure the index constraint has been reset\n  2541\t        self.assertIndexExists(\"test_rnfl_pony\", [\"weight\", \"pink\"])\n  2542\t        # And deconstruction\n  2543\t        definition = operation.deconstruct()\n  2544\t        self.assertEqual(definition[0], \"RenameField\")\n  2545\t        self.assertEqual(definition[1], [])\n  2546\t        self.assertEqual(\n  2547\t            definition[2],\n  2548\t            {\"model_name\": \"Pony\", \"old_name\": \"pink\", \"new_name\": \"blue\"},\n  2549\t        )\n          # ...\n\n\n<span id='OperationTests.test_rename_field_case'>\n  2612\t\n  2613\t    def test_rename_field_case(self):\n  2614\t        project_state = self.apply_operations(\n  2615\t            \"test_rfmx\",\n  2616\t            ProjectState(),\n  2617\t            operations=[\n  2618\t                migrations.CreateModel(\n  2619\t                    \"Pony\",\n  2620\t                    fields=[\n  2621\t                        (\"id\", models.AutoField(primary_key=True)),\n  2622\t                        (\"field\", models.IntegerField()),\n  2623\t                    ],\n  2624\t                ),\n  2625\t            ],\n  2626\t        )\n  2627\t        new_state = project_state.clone()\n  2628\t        operation = migrations.RenameField(\"Pony\", \"field\", \"FiElD\")\n  2629\t        operation.state_forwards(\"test_rfmx\", new_state)\n  2630\t        self.assertIn(\"FiElD\", new_state.models[\"test_rfmx\", \"pony\"].fields)\n  2631\t        self.assertColumnExists(\"test_rfmx_pony\", \"field\")\n  2632\t        with connection.schema_editor() as editor:\n  2633\t            operation.database_forwards(\"test_rfmx\", editor, project_state, new_state)\n  2634\t        self.assertColumnExists(\n  2635\t            \"test_rfmx_pony\",\n  2636\t            connection.introspection.identifier_converter(\"FiElD\"),\n  2637\t        )\n  2638\t        with connection.schema_editor() as editor:\n  2639\t            operation.database_backwards(\"test_rfmx\", editor, new_state, project_state)\n  2640\t        self.assertColumnExists(\"test_rfmx_pony\", \"field\")\n\n\n<span id='OperationTests.test_rename_missing_field'>\n  2641\t\n  2642\t    def test_rename_missing_field(self):\n  2643\t        state = ProjectState()\n  2644\t        state.add_model(ModelState(\"app\", \"model\", []))\n  2645\t        with self.assertRaisesMessage(\n  2646\t            FieldDoesNotExist, \"app.model has no field named 'field'\"\n  2647\t        ):\n  2648\t            migrations.RenameField(\"model\", \"field\", \"new_field\").state_forwards(\n  2649\t                \"app\", state\n  2650\t            )\n          # ...\n\n\n<span id='OperationTests.test_rename_index'>\n  2902\t\n  2903\t    def test_rename_index(self):\n  2904\t        app_label = \"test_rnin\"\n  2905\t        project_state = self.set_up_test_model(app_label, index=True)\n  2906\t        table_name = app_label + \"_pony\"\n  2907\t        self.assertIndexNameExists(table_name, \"pony_pink_idx\")\n  2908\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2909\t        operation = migrations.RenameIndex(\n  2910\t            \"Pony\", new_name=\"new_pony_test_idx\", old_name=\"pony_pink_idx\"\n  2911\t        )\n  2912\t        self.assertEqual(\n  2913\t            operation.describe(),\n  2914\t            \"Rename index pony_pink_idx on Pony to new_pony_test_idx\",\n  2915\t        )\n  2916\t        self.assertEqual(\n  2917\t            operation.migration_name_fragment,\n  2918\t            \"rename_pony_pink_idx_new_pony_test_idx\",\n  2919\t        )\n  2920\t\n  2921\t        new_state = project_state.clone()\n  2922\t        operation.state_forwards(app_label, new_state)\n  2923\t        # Rename index.\n  2924\t        expected_queries = 1 if connection.features.can_rename_index else 2\n  2925\t        with connection.schema_editor() as editor, self.assertNumQueries(\n  2926\t            expected_queries\n  2927\t        ):\n  2928\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2929\t        self.assertIndexNameNotExists(table_name, \"pony_pink_idx\")\n  2930\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2931\t        # Reversal.\n  2932\t        with connection.schema_editor() as editor, self.assertNumQueries(\n  2933\t            expected_queries\n  2934\t        ):\n  2935\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2936\t        self.assertIndexNameExists(table_name, \"pony_pink_idx\")\n  2937\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2938\t        # Deconstruction.\n  2939\t        definition = operation.deconstruct()\n  2940\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2941\t        self.assertEqual(definition[1], [])\n  2942\t        self.assertEqual(\n  2943\t            definition[2],\n  2944\t            {\n  2945\t                \"model_name\": \"Pony\",\n  2946\t                \"old_name\": \"pony_pink_idx\",\n  2947\t                \"new_name\": \"new_pony_test_idx\",\n  2948\t            },\n  2949\t        )\n\n\n<span id='OperationTests.test_rename_index_arguments'>\n  2950\t\n  2951\t    def test_rename_index_arguments(self):\n  2952\t        msg = \"RenameIndex.old_name and old_fields are mutually exclusive.\"\n  2953\t        with self.assertRaisesMessage(ValueError, msg):\n  2954\t            migrations.RenameIndex(\n  2955\t                \"Pony\",\n  2956\t                new_name=\"new_idx_name\",\n  2957\t                old_name=\"old_idx_name\",\n  2958\t                old_fields=(\"weight\", \"pink\"),\n  2959\t            )\n  2960\t        msg = \"RenameIndex requires one of old_name and old_fields arguments to be set.\"\n  2961\t        with self.assertRaisesMessage(ValueError, msg):\n  2962\t            migrations.RenameIndex(\"Pony\", new_name=\"new_idx_name\")\n\n\n<span id='OperationTests.test_rename_index_unnamed_index'>\n  2963\t\n  2964\t    def test_rename_index_unnamed_index(self):\n  2965\t        app_label = \"test_rninui\"\n  2966\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  2967\t        table_name = app_label + \"_pony\"\n  2968\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2969\t        operation = migrations.RenameIndex(\n  2970\t            \"Pony\", new_name=\"new_pony_test_idx\", old_fields=(\"weight\", \"pink\")\n  2971\t        )\n  2972\t        self.assertEqual(\n  2973\t            operation.describe(),\n  2974\t            \"Rename unnamed index for ('weight', 'pink') on Pony to new_pony_test_idx\",\n  2975\t        )\n  2976\t        self.assertEqual(\n  2977\t            operation.migration_name_fragment,\n  2978\t            \"rename_pony_weight_pink_new_pony_test_idx\",\n  2979\t        )\n  2980\t\n  2981\t        new_state = project_state.clone()\n  2982\t        operation.state_forwards(app_label, new_state)\n  2983\t        # Rename index.\n  2984\t        with connection.schema_editor() as editor:\n  2985\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2986\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2987\t        # Reverse is a no-op.\n  2988\t        with connection.schema_editor() as editor, self.assertNumQueries(0):\n  2989\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2990\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2991\t        # Deconstruction.\n  2992\t        definition = operation.deconstruct()\n  2993\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2994\t        self.assertEqual(definition[1], [])\n  2995\t        self.assertEqual(\n  2996\t            definition[2],\n  2997\t            {\n  2998\t                \"model_name\": \"Pony\",\n  2999\t                \"new_name\": \"new_pony_test_idx\",\n  3000\t                \"old_fields\": (\"weight\", \"pink\"),\n  3001\t            },\n  3002\t        )\n\n\n<span id='OperationTests.test_rename_index_unknown_unnamed_index'>\n  3003\t\n  3004\t    def test_rename_index_unknown_unnamed_index(self):\n  3005\t        app_label = \"test_rninuui\"\n  3006\t        project_state = self.set_up_test_model(app_label)\n  3007\t        operation = migrations.RenameIndex(\n  3008\t            \"Pony\", new_name=\"new_pony_test_idx\", old_fields=(\"weight\", \"pink\")\n  3009\t        )\n  3010\t        new_state = project_state.clone()\n  3011\t        operation.state_forwards(app_label, new_state)\n  3012\t        msg = \"Found wrong number (0) of indexes for test_rninuui_pony(weight, pink).\"\n  3013\t        with connection.schema_editor() as editor:\n  3014\t            with self.assertRaisesMessage(ValueError, msg):\n  3015\t                operation.database_forwards(app_label, editor, project_state, new_state)\n          # ...\n\n\n<span id='OperationTests.test_rename_index_state_forwards'>\n  3039\t\n  3040\t    def test_rename_index_state_forwards(self):\n  3041\t        app_label = \"test_rnidsf\"\n  3042\t        project_state = self.set_up_test_model(app_label, index=True)\n  3043\t        old_model = project_state.apps.get_model(app_label, \"Pony\")\n  3044\t        new_state = project_state.clone()\n  3045\t\n  3046\t        operation = migrations.RenameIndex(\n  3047\t            \"Pony\", new_name=\"new_pony_pink_idx\", old_name=\"pony_pink_idx\"\n  3048\t        )\n  3049\t        operation.state_forwards(app_label, new_state)\n  3050\t        new_model = new_state.apps.get_model(app_label, \"Pony\")\n  3051\t        self.assertIsNot(old_model, new_model)\n  3052\t        self.assertEqual(new_model._meta.indexes[0].name, \"new_pony_pink_idx\")\n\n\n<span id='OperationTests.test_rename_index_state_forwards_unnamed_index'>\n  3053\t\n  3054\t    def test_rename_index_state_forwards_unnamed_index(self):\n  3055\t        app_label = \"test_rnidsfui\"\n  3056\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  3057\t        old_model = project_state.apps.get_model(app_label, \"Pony\")\n  3058\t        new_state = project_state.clone()\n  3059\t\n  3060\t        operation = migrations.RenameIndex(\n  3061\t            \"Pony\", new_name=\"new_pony_pink_idx\", old_fields=(\"weight\", \"pink\")\n  3062\t        )\n  3063\t        operation.state_forwards(app_label, new_state)\n  3064\t        new_model = new_state.apps.get_model(app_label, \"Pony\")\n  3065\t        self.assertIsNot(old_model, new_model)\n  3066\t        self.assertEqual(new_model._meta.index_together, tuple())\n  3067\t        self.assertEqual(new_model._meta.indexes[0].name, \"new_pony_pink_idx\")\n          # ...\n      # ...\n```\n\n\ntests/migrations/test_optimizer.py\n```\n\n\n\n<span id='imports'>\n     1\tfrom django.db import migrations, models\n     2\tfrom django.db.migrations import operations\n     3\tfrom django.db.migrations.optimizer import MigrationOptimizer\n     4\tfrom django.db.migrations.serializer import serializer_factory\n     5\tfrom django.test import SimpleTestCase\n     6\t\n     7\tfrom .models import EmptyManager, UnicodeModel\n\n\n<span id='OptimizerTests'>\n     8\t\n     9\t\n    10\tclass OptimizerTests(SimpleTestCase):\n    11\t    \"\"\"\n    12\t    Tests the migration autodetector.\n    13\t    \"\"\"\n          # ...\n\n\n<span id='OptimizerTests.test_rename_index'>\n  1117\t\n  1118\t    def test_rename_index(self):\n  1119\t        self.assertOptimizesTo(\n  1120\t            [\n  1121\t                migrations.RenameIndex(\n  1122\t                    \"Pony\", new_name=\"mid_name\", old_fields=(\"weight\", \"pink\")\n  1123\t                ),\n  1124\t                migrations.RenameIndex(\n  1125\t                    \"Pony\", new_name=\"new_name\", old_name=\"mid_name\"\n  1126\t                ),\n  1127\t            ],\n  1128\t            [\n  1129\t                migrations.RenameIndex(\n  1130\t                    \"Pony\", new_name=\"new_name\", old_fields=(\"weight\", \"pink\")\n  1131\t                ),\n  1132\t            ],\n  1133\t        )\n  1134\t        self.assertOptimizesTo(\n  1135\t            [\n  1136\t                migrations.RenameIndex(\n  1137\t                    \"Pony\", new_name=\"mid_name\", old_name=\"old_name\"\n  1138\t                ),\n  1139\t                migrations.RenameIndex(\n  1140\t                    \"Pony\", new_name=\"new_name\", old_name=\"mid_name\"\n  1141\t                ),\n  1142\t            ],\n  1143\t            [migrations.RenameIndex(\"Pony\", new_name=\"new_name\", old_name=\"old_name\")],\n  1144\t        )\n  1145\t        self.assertDoesNotOptimize(\n  1146\t            [\n  1147\t                migrations.RenameIndex(\n  1148\t                    \"Pony\", new_name=\"mid_name\", old_name=\"old_name\"\n  1149\t                ),\n  1150\t                migrations.RenameIndex(\n  1151\t                    \"Pony\", new_name=\"new_name\", old_fields=(\"weight\", \"pink\")\n  1152\t                ),\n  1153\t            ]\n  1154\t        )\n```\n\n</search_result>\n"
            }
          ],
          "response": {
            "id": "msg_01SFsdqcad32MdJmeLRBupQz",
            "content": [
              {
                "text": "I'll analyze the search results for code related to testing RenameIndex operation migration. The most relevant sections are found in the test files, particularly focusing on the RenameIndex operation tests.\n\nLet me identify the relevant code sections:",
                "type": "text"
              },
              {
                "id": "toolu_01RqxcnoTwN6adTEZGvF3Li9",
                "input": {
                  "scratch_pad": "The most relevant code sections for testing RenameIndex operations are:\n\n1. Main RenameIndex test (test_rename_index) - This is the primary test case that verifies the basic functionality of RenameIndex operation, including:\n   - Index renaming\n   - State changes\n   - Database operations\n   - Reversibility\n   - Operation description and deconstruction\n\n2. RenameIndex arguments test (test_rename_index_arguments) - Tests validation of operation arguments\n\n3. RenameIndex unnamed index test (test_rename_index_unnamed_index) - Tests renaming of unnamed indexes\n\n4. RenameIndex state forwards tests (test_rename_index_state_forwards) - Tests state management for named and unnamed indexes\n\n5. RenameIndex optimization tests - Shows how RenameIndex operations can be optimized when chained together\n\nThese sections provide comprehensive testing of the RenameIndex migration operation functionality.",
                  "identified_spans": [
                    {
                      "file_path": "tests/migrations/test_operations.py",
                      "start_line": 2903,
                      "end_line": 2949
                    },
                    {
                      "file_path": "tests/migrations/test_operations.py",
                      "start_line": 2951,
                      "end_line": 2962
                    },
                    {
                      "file_path": "tests/migrations/test_operations.py",
                      "start_line": 2964,
                      "end_line": 3002
                    },
                    {
                      "file_path": "tests/migrations/test_operations.py",
                      "start_line": 3040,
                      "end_line": 3067
                    },
                    {
                      "file_path": "tests/migrations/test_optimizer.py",
                      "start_line": 1118,
                      "end_line": 1154
                    }
                  ]
                },
                "name": "Action",
                "type": "tool_use"
              }
            ],
            "model": "claude-3-5-sonnet-20241022",
            "role": "assistant",
            "stop_reason": "tool_use",
            "stop_sequence": null,
            "type": "message",
            "usage": {
              "cache_creation_input_tokens": 0,
              "cache_read_input_tokens": 0,
              "input_tokens": 7625,
              "output_tokens": 553
            }
          },
          "usage": {
            "completion_cost": 0.03117,
            "completion_tokens": 553,
            "prompt_tokens": 7625,
            "cached_tokens": 0
          }
        }
      },
      "file_context": {
        "max_tokens": 8000,
        "files": [
          {
            "file_path": "tests/migrations/test_operations.py",
            "spans": [
              {
                "span_id": "imports",
                "pinned": false
              },
              {
                "span_id": "OperationTests",
                "pinned": false
              },
              {
                "span_id": "OperationTests.test_rename_index",
                "pinned": false
              },
              {
                "span_id": "OperationTests.test_rename_index_arguments",
                "pinned": false
              },
              {
                "span_id": "OperationTests.test_rename_index_unnamed_index",
                "pinned": false
              },
              {
                "span_id": "OperationTests.test_rename_index_state_forwards",
                "pinned": false
              },
              {
                "span_id": "OperationTests.test_rename_index_state_forwards_unnamed_index",
                "pinned": false
              }
            ],
            "show_all_spans": false,
            "patch": null
          },
          {
            "file_path": "tests/migrations/test_optimizer.py",
            "spans": [
              {
                "span_id": "imports",
                "pinned": false
              },
              {
                "span_id": "OptimizerTests",
                "pinned": false
              },
              {
                "span_id": "OptimizerTests.test_rename_index",
                "pinned": false
              }
            ],
            "show_all_spans": false,
            "patch": null
          }
        ]
      },
      "completions": {
        "build_action": {
          "model": "claude-3-5-sonnet-20241022",
          "input": [
            {
              "role": "user",
              "content": "<task>\nRenameIndex() crashes when unnamed index is moving backward and forward.\nDescription\n\t\nRenameIndex() should restore the old auto-generated name when an unnamed index for unique_together is moving backward. Now re-applying RenameIndex() crashes. For example:\ntests/migrations/test_operations.py\ndiff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex cfd28b1b39..c0a55023bb 100644\n\t\t\t\t\t\n\t\t\t\t\t a\n\t\t\t\t \n\t\t\t\t\t\n\t\t\t\t\t b\n\t\t\t\t \n class OperationTests(OperationTestBase):\u00a0\n29882988\u00a0 \u00a0 \u00a0 \u00a0 with connection.schema_editor() as editor, self.assertNumQueries(0):\n29892989\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 operation.database_backwards(app_label, editor, new_state, project_state)\n29902990\u00a0 \u00a0 \u00a0 \u00a0 self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n\u00a02991\u00a0 \u00a0 \u00a0 \u00a0 # Re-apply renaming.\n\u00a02992\u00a0 \u00a0 \u00a0 \u00a0 with connection.schema_editor() as editor:\n\u00a02993\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 operation.database_forwards(app_label, editor, project_state, new_state)\n\u00a02994\u00a0 \u00a0 \u00a0 \u00a0 self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n29912995\u00a0 \u00a0 \u00a0 \u00a0 # Deconstruction.\n29922996\u00a0 \u00a0 \u00a0 \u00a0 definition = operation.deconstruct()\n29932997\u00a0 \u00a0 \u00a0 \u00a0 self.assertEqual(definition[0], \"RenameIndex\")\ncrashes on PostgreSQL:\ndjango.db.utils.ProgrammingError: relation \"new_pony_test_idx\" already exists\n\n</task>"
            },
            {
              "role": "assistant",
              "content": [
                {
                  "type": "text",
                  "text": "<thoughts>\n1. First, I need to understand the context better by:\n   - Looking at the test file to see the full test case\n   - Finding the RenameIndex operation implementation\n   - Understanding how index naming works in this context\n\n2. Let's start by viewing the test file to see the full test case context.\n</thoughts>"
                },
                {
                  "id": "call_8635dcc7",
                  "input": {
                    "files": [
                      {
                        "file_path": "tests/migrations/test_operations.py",
                        "start_line": null,
                        "end_line": null,
                        "span_ids": []
                      }
                    ]
                  },
                  "type": "tool_use",
                  "name": "ViewCode",
                  "cache_control": {
                    "type": "ephemeral"
                  }
                }
              ]
            },
            {
              "role": "user",
              "content": [
                {
                  "tool_use_id": "call_8635dcc7",
                  "content": "<observation>\n\n</observation>",
                  "type": "tool_result",
                  "cache_control": {
                    "type": "ephemeral"
                  }
                }
              ]
            }
          ],
          "response": {
            "id": "msg_016fRC6txDdkKLx9mHN31C9y",
            "content": [
              {
                "text": "<thoughts>\nIt seems I need to use a different approach to find the relevant test code. Let me use SemanticSearch to find tests related to RenameIndex operations.\n</thoughts>",
                "type": "text"
              },
              {
                "id": "toolu_01UNcf7X2LA5caHxVck9AAKV",
                "input": {
                  "query": "test RenameIndex operation migration",
                  "category": "test"
                },
                "name": "SemanticSearch",
                "type": "tool_use"
              }
            ],
            "model": "claude-3-5-sonnet-20241022",
            "role": "assistant",
            "stop_reason": "tool_use",
            "stop_sequence": null,
            "type": "message",
            "usage": {
              "cache_creation_input_tokens": 21,
              "cache_read_input_tokens": 4662,
              "input_tokens": 5,
              "output_tokens": 121
            }
          },
          "usage": {
            "completion_cost": 0.001893,
            "completion_tokens": 121,
            "prompt_tokens": 26,
            "cached_tokens": 4662
          }
        },
        "execute_action": {
          "model": "claude-3-5-sonnet-20241022",
          "input": [
            {
              "role": "user",
              "content": "Search request:\nSearching for code using the query: test RenameIndex operation migration\n\nIdentify the relevant code sections in the search results to use them. \n\n<search_results>\ntests/migrations/test_operations.py\n```\n\n\n\n<span id='imports'>\n     1\tfrom django.core.exceptions import FieldDoesNotExist\n     2\tfrom django.db import IntegrityError, connection, migrations, models, transaction\n     3\tfrom django.db.migrations.migration import Migration\n     4\tfrom django.db.migrations.operations.fields import FieldOperation\n     5\tfrom django.db.migrations.state import ModelState, ProjectState\n     6\tfrom django.db.models.functions import Abs\n     7\tfrom django.db.transaction import atomic\n     8\tfrom django.test import SimpleTestCase, override_settings, skipUnlessDBFeature\n     9\tfrom django.test.utils import CaptureQueriesContext\n    10\t\n    11\tfrom .models import FoodManager, FoodQuerySet, UnicodeModel\n    12\tfrom .test_base import OperationTestBase\n      # ...\n\n\n<span id='OperationTests'>\n    17\t\n    18\t\n    19\tclass OperationTests(OperationTestBase):\n    20\t    \"\"\"\n    21\t    Tests running the operations and making sure they do what they say they do.\n    22\t    Each test looks at their state changing, and then their database operation -\n    23\t    both forwards and backwards.\n    24\t    \"\"\"\n          # ...\n\n\n<span id='OperationTests.test_rename_model'>\n   774\t\n   775\t    def test_rename_model(self):\n   776\t        \"\"\"\n   777\t        Tests the RenameModel operation.\n   778\t        \"\"\"\n   779\t        project_state = self.set_up_test_model(\"test_rnmo\", related_model=True)\n   780\t        # Test the state alteration\n   781\t        operation = migrations.RenameModel(\"Pony\", \"Horse\")\n   782\t        self.assertEqual(operation.describe(), \"Rename model Pony to Horse\")\n   783\t        self.assertEqual(operation.migration_name_fragment, \"rename_pony_horse\")\n   784\t        # Test initial state and database\n   785\t        self.assertIn((\"test_rnmo\", \"pony\"), project_state.models)\n   786\t        self.assertNotIn((\"test_rnmo\", \"horse\"), project_state.models)\n   787\t        self.assertTableExists(\"test_rnmo_pony\")\n   788\t        self.assertTableNotExists(\"test_rnmo_horse\")\n   789\t        if connection.features.supports_foreign_keys:\n   790\t            self.assertFKExists(\n   791\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_pony\", \"id\")\n   792\t            )\n   793\t            self.assertFKNotExists(\n   794\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_horse\", \"id\")\n   795\t            )\n   796\t        # Migrate forwards\n   797\t        new_state = project_state.clone()\n   798\t        atomic_rename = connection.features.supports_atomic_references_rename\n   799\t        new_state = self.apply_operations(\n   800\t            \"test_rnmo\", new_state, [operation], atomic=atomic_rename\n   801\t        )\n   802\t        # Test new state and database\n   803\t        self.assertNotIn((\"test_rnmo\", \"pony\"), new_state.models)\n   804\t        self.assertIn((\"test_rnmo\", \"horse\"), new_state.models)\n   805\t        # RenameModel also repoints all incoming FKs and M2Ms\n   806\t        self.assertEqual(\n   807\t            new_state.models[\"test_rnmo\", \"rider\"].fields[\"pony\"].remote_field.model,\n   808\t            \"test_rnmo.Horse\",\n   809\t        )\n   810\t        self.assertTableNotExists(\"test_rnmo_pony\")\n   811\t        self.assertTableExists(\"test_rnmo_horse\")\n   812\t        if connection.features.supports_foreign_keys:\n   813\t            self.assertFKNotExists(\n   814\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_pony\", \"id\")\n   815\t            )\n   816\t            self.assertFKExists(\n   817\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_horse\", \"id\")\n   818\t            )\n   819\t        # Migrate backwards\n   820\t        original_state = self.unapply_operations(\n   821\t            \"test_rnmo\", project_state, [operation], atomic=atomic_rename\n   822\t        )\n   823\t        # Test original state and database\n   824\t        self.assertIn((\"test_rnmo\", \"pony\"), original_state.models)\n   825\t        self.assertNotIn((\"test_rnmo\", \"horse\"), original_state.models)\n   826\t        self.assertEqual(\n   827\t            original_state.models[\"test_rnmo\", \"rider\"]\n   828\t            .fields[\"pony\"]\n   829\t            .remote_field.model,\n   830\t            \"Pony\",\n   831\t        )\n   832\t        self.assertTableExists(\"test_rnmo_pony\")\n   833\t        self.assertTableNotExists(\"test_rnmo_horse\")\n   834\t        if connection.features.supports_foreign_keys:\n   835\t            self.assertFKExists(\n   836\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_pony\", \"id\")\n   837\t            )\n   838\t            self.assertFKNotExists(\n   839\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_horse\", \"id\")\n   840\t            )\n   841\t        # And deconstruction\n   842\t        definition = operation.deconstruct()\n   843\t        self.assertEqual(definition[0], \"RenameModel\")\n   844\t        self.assertEqual(definition[1], [])\n   845\t        self.assertEqual(definition[2], {\"old_name\": \"Pony\", \"new_name\": \"Horse\"})\n          # ...\n\n\n<span id='OperationTests.test_rename_field'>\n  2487\t\n  2488\t    def test_rename_field(self):\n  2489\t        \"\"\"\n  2490\t        Tests the RenameField operation.\n  2491\t        \"\"\"\n  2492\t        project_state = self.set_up_test_model(\n  2493\t            \"test_rnfl\", unique_together=True, index_together=True\n  2494\t        )\n  2495\t        # Test the state alteration\n  2496\t        operation = migrations.RenameField(\"Pony\", \"pink\", \"blue\")\n  2497\t        self.assertEqual(operation.describe(), \"Rename field pink on Pony to blue\")\n  2498\t        self.assertEqual(operation.migration_name_fragment, \"rename_pink_pony_blue\")\n  2499\t        new_state = project_state.clone()\n  2500\t        operation.state_forwards(\"test_rnfl\", new_state)\n  2501\t        self.assertIn(\"blue\", new_state.models[\"test_rnfl\", \"pony\"].fields)\n  2502\t        self.assertNotIn(\"pink\", new_state.models[\"test_rnfl\", \"pony\"].fields)\n  2503\t        # Make sure the unique_together has the renamed column too\n  2504\t        self.assertIn(\n  2505\t            \"blue\", new_state.models[\"test_rnfl\", \"pony\"].options[\"unique_together\"][0]\n  2506\t        )\n  2507\t        self.assertNotIn(\n  2508\t            \"pink\", new_state.models[\"test_rnfl\", \"pony\"].options[\"unique_together\"][0]\n  2509\t        )\n  2510\t        # Make sure the index_together has the renamed column too\n  2511\t        self.assertIn(\n  2512\t            \"blue\", new_state.models[\"test_rnfl\", \"pony\"].options[\"index_together\"][0]\n  2513\t        )\n  2514\t        self.assertNotIn(\n  2515\t            \"pink\", new_state.models[\"test_rnfl\", \"pony\"].options[\"index_together\"][0]\n  2516\t        )\n  2517\t        # Test the database alteration\n  2518\t        self.assertColumnExists(\"test_rnfl_pony\", \"pink\")\n  2519\t        self.assertColumnNotExists(\"test_rnfl_pony\", \"blue\")\n  2520\t        with connection.schema_editor() as editor:\n  2521\t            operation.database_forwards(\"test_rnfl\", editor, project_state, new_state)\n  2522\t        self.assertColumnExists(\"test_rnfl_pony\", \"blue\")\n  2523\t        self.assertColumnNotExists(\"test_rnfl_pony\", \"pink\")\n  2524\t        # Ensure the unique constraint has been ported over\n  2525\t        with connection.cursor() as cursor:\n  2526\t            cursor.execute(\"INSERT INTO test_rnfl_pony (blue, weight) VALUES (1, 1)\")\n  2527\t            with self.assertRaises(IntegrityError):\n  2528\t                with atomic():\n  2529\t                    cursor.execute(\n  2530\t                        \"INSERT INTO test_rnfl_pony (blue, weight) VALUES (1, 1)\"\n  2531\t                    )\n  2532\t            cursor.execute(\"DELETE FROM test_rnfl_pony\")\n  2533\t        # Ensure the index constraint has been ported over\n  2534\t        self.assertIndexExists(\"test_rnfl_pony\", [\"weight\", \"blue\"])\n  2535\t        # And test reversal\n  2536\t        with connection.schema_editor() as editor:\n  2537\t            operation.database_backwards(\"test_rnfl\", editor, new_state, project_state)\n  2538\t        self.assertColumnExists(\"test_rnfl_pony\", \"pink\")\n  2539\t        self.assertColumnNotExists(\"test_rnfl_pony\", \"blue\")\n  2540\t        # Ensure the index constraint has been reset\n  2541\t        self.assertIndexExists(\"test_rnfl_pony\", [\"weight\", \"pink\"])\n  2542\t        # And deconstruction\n  2543\t        definition = operation.deconstruct()\n  2544\t        self.assertEqual(definition[0], \"RenameField\")\n  2545\t        self.assertEqual(definition[1], [])\n  2546\t        self.assertEqual(\n  2547\t            definition[2],\n  2548\t            {\"model_name\": \"Pony\", \"old_name\": \"pink\", \"new_name\": \"blue\"},\n  2549\t        )\n          # ...\n\n\n<span id='OperationTests.test_rename_field_case'>\n  2612\t\n  2613\t    def test_rename_field_case(self):\n  2614\t        project_state = self.apply_operations(\n  2615\t            \"test_rfmx\",\n  2616\t            ProjectState(),\n  2617\t            operations=[\n  2618\t                migrations.CreateModel(\n  2619\t                    \"Pony\",\n  2620\t                    fields=[\n  2621\t                        (\"id\", models.AutoField(primary_key=True)),\n  2622\t                        (\"field\", models.IntegerField()),\n  2623\t                    ],\n  2624\t                ),\n  2625\t            ],\n  2626\t        )\n  2627\t        new_state = project_state.clone()\n  2628\t        operation = migrations.RenameField(\"Pony\", \"field\", \"FiElD\")\n  2629\t        operation.state_forwards(\"test_rfmx\", new_state)\n  2630\t        self.assertIn(\"FiElD\", new_state.models[\"test_rfmx\", \"pony\"].fields)\n  2631\t        self.assertColumnExists(\"test_rfmx_pony\", \"field\")\n  2632\t        with connection.schema_editor() as editor:\n  2633\t            operation.database_forwards(\"test_rfmx\", editor, project_state, new_state)\n  2634\t        self.assertColumnExists(\n  2635\t            \"test_rfmx_pony\",\n  2636\t            connection.introspection.identifier_converter(\"FiElD\"),\n  2637\t        )\n  2638\t        with connection.schema_editor() as editor:\n  2639\t            operation.database_backwards(\"test_rfmx\", editor, new_state, project_state)\n  2640\t        self.assertColumnExists(\"test_rfmx_pony\", \"field\")\n\n\n<span id='OperationTests.test_rename_missing_field'>\n  2641\t\n  2642\t    def test_rename_missing_field(self):\n  2643\t        state = ProjectState()\n  2644\t        state.add_model(ModelState(\"app\", \"model\", []))\n  2645\t        with self.assertRaisesMessage(\n  2646\t            FieldDoesNotExist, \"app.model has no field named 'field'\"\n  2647\t        ):\n  2648\t            migrations.RenameField(\"model\", \"field\", \"new_field\").state_forwards(\n  2649\t                \"app\", state\n  2650\t            )\n          # ...\n\n\n<span id='OperationTests.test_rename_index'>\n  2902\t\n  2903\t    def test_rename_index(self):\n  2904\t        app_label = \"test_rnin\"\n  2905\t        project_state = self.set_up_test_model(app_label, index=True)\n  2906\t        table_name = app_label + \"_pony\"\n  2907\t        self.assertIndexNameExists(table_name, \"pony_pink_idx\")\n  2908\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2909\t        operation = migrations.RenameIndex(\n  2910\t            \"Pony\", new_name=\"new_pony_test_idx\", old_name=\"pony_pink_idx\"\n  2911\t        )\n  2912\t        self.assertEqual(\n  2913\t            operation.describe(),\n  2914\t            \"Rename index pony_pink_idx on Pony to new_pony_test_idx\",\n  2915\t        )\n  2916\t        self.assertEqual(\n  2917\t            operation.migration_name_fragment,\n  2918\t            \"rename_pony_pink_idx_new_pony_test_idx\",\n  2919\t        )\n  2920\t\n  2921\t        new_state = project_state.clone()\n  2922\t        operation.state_forwards(app_label, new_state)\n  2923\t        # Rename index.\n  2924\t        expected_queries = 1 if connection.features.can_rename_index else 2\n  2925\t        with connection.schema_editor() as editor, self.assertNumQueries(\n  2926\t            expected_queries\n  2927\t        ):\n  2928\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2929\t        self.assertIndexNameNotExists(table_name, \"pony_pink_idx\")\n  2930\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2931\t        # Reversal.\n  2932\t        with connection.schema_editor() as editor, self.assertNumQueries(\n  2933\t            expected_queries\n  2934\t        ):\n  2935\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2936\t        self.assertIndexNameExists(table_name, \"pony_pink_idx\")\n  2937\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2938\t        # Deconstruction.\n  2939\t        definition = operation.deconstruct()\n  2940\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2941\t        self.assertEqual(definition[1], [])\n  2942\t        self.assertEqual(\n  2943\t            definition[2],\n  2944\t            {\n  2945\t                \"model_name\": \"Pony\",\n  2946\t                \"old_name\": \"pony_pink_idx\",\n  2947\t                \"new_name\": \"new_pony_test_idx\",\n  2948\t            },\n  2949\t        )\n\n\n<span id='OperationTests.test_rename_index_arguments'>\n  2950\t\n  2951\t    def test_rename_index_arguments(self):\n  2952\t        msg = \"RenameIndex.old_name and old_fields are mutually exclusive.\"\n  2953\t        with self.assertRaisesMessage(ValueError, msg):\n  2954\t            migrations.RenameIndex(\n  2955\t                \"Pony\",\n  2956\t                new_name=\"new_idx_name\",\n  2957\t                old_name=\"old_idx_name\",\n  2958\t                old_fields=(\"weight\", \"pink\"),\n  2959\t            )\n  2960\t        msg = \"RenameIndex requires one of old_name and old_fields arguments to be set.\"\n  2961\t        with self.assertRaisesMessage(ValueError, msg):\n  2962\t            migrations.RenameIndex(\"Pony\", new_name=\"new_idx_name\")\n\n\n<span id='OperationTests.test_rename_index_unnamed_index'>\n  2963\t\n  2964\t    def test_rename_index_unnamed_index(self):\n  2965\t        app_label = \"test_rninui\"\n  2966\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  2967\t        table_name = app_label + \"_pony\"\n  2968\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2969\t        operation = migrations.RenameIndex(\n  2970\t            \"Pony\", new_name=\"new_pony_test_idx\", old_fields=(\"weight\", \"pink\")\n  2971\t        )\n  2972\t        self.assertEqual(\n  2973\t            operation.describe(),\n  2974\t            \"Rename unnamed index for ('weight', 'pink') on Pony to new_pony_test_idx\",\n  2975\t        )\n  2976\t        self.assertEqual(\n  2977\t            operation.migration_name_fragment,\n  2978\t            \"rename_pony_weight_pink_new_pony_test_idx\",\n  2979\t        )\n  2980\t\n  2981\t        new_state = project_state.clone()\n  2982\t        operation.state_forwards(app_label, new_state)\n  2983\t        # Rename index.\n  2984\t        with connection.schema_editor() as editor:\n  2985\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2986\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2987\t        # Reverse is a no-op.\n  2988\t        with connection.schema_editor() as editor, self.assertNumQueries(0):\n  2989\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2990\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2991\t        # Deconstruction.\n  2992\t        definition = operation.deconstruct()\n  2993\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2994\t        self.assertEqual(definition[1], [])\n  2995\t        self.assertEqual(\n  2996\t            definition[2],\n  2997\t            {\n  2998\t                \"model_name\": \"Pony\",\n  2999\t                \"new_name\": \"new_pony_test_idx\",\n  3000\t                \"old_fields\": (\"weight\", \"pink\"),\n  3001\t            },\n  3002\t        )\n\n\n<span id='OperationTests.test_rename_index_unknown_unnamed_index'>\n  3003\t\n  3004\t    def test_rename_index_unknown_unnamed_index(self):\n  3005\t        app_label = \"test_rninuui\"\n  3006\t        project_state = self.set_up_test_model(app_label)\n  3007\t        operation = migrations.RenameIndex(\n  3008\t            \"Pony\", new_name=\"new_pony_test_idx\", old_fields=(\"weight\", \"pink\")\n  3009\t        )\n  3010\t        new_state = project_state.clone()\n  3011\t        operation.state_forwards(app_label, new_state)\n  3012\t        msg = \"Found wrong number (0) of indexes for test_rninuui_pony(weight, pink).\"\n  3013\t        with connection.schema_editor() as editor:\n  3014\t            with self.assertRaisesMessage(ValueError, msg):\n  3015\t                operation.database_forwards(app_label, editor, project_state, new_state)\n          # ...\n\n\n<span id='OperationTests.test_rename_index_state_forwards'>\n  3039\t\n  3040\t    def test_rename_index_state_forwards(self):\n  3041\t        app_label = \"test_rnidsf\"\n  3042\t        project_state = self.set_up_test_model(app_label, index=True)\n  3043\t        old_model = project_state.apps.get_model(app_label, \"Pony\")\n  3044\t        new_state = project_state.clone()\n  3045\t\n  3046\t        operation = migrations.RenameIndex(\n  3047\t            \"Pony\", new_name=\"new_pony_pink_idx\", old_name=\"pony_pink_idx\"\n  3048\t        )\n  3049\t        operation.state_forwards(app_label, new_state)\n  3050\t        new_model = new_state.apps.get_model(app_label, \"Pony\")\n  3051\t        self.assertIsNot(old_model, new_model)\n  3052\t        self.assertEqual(new_model._meta.indexes[0].name, \"new_pony_pink_idx\")\n\n\n<span id='OperationTests.test_rename_index_state_forwards_unnamed_index'>\n  3053\t\n  3054\t    def test_rename_index_state_forwards_unnamed_index(self):\n  3055\t        app_label = \"test_rnidsfui\"\n  3056\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  3057\t        old_model = project_state.apps.get_model(app_label, \"Pony\")\n  3058\t        new_state = project_state.clone()\n  3059\t\n  3060\t        operation = migrations.RenameIndex(\n  3061\t            \"Pony\", new_name=\"new_pony_pink_idx\", old_fields=(\"weight\", \"pink\")\n  3062\t        )\n  3063\t        operation.state_forwards(app_label, new_state)\n  3064\t        new_model = new_state.apps.get_model(app_label, \"Pony\")\n  3065\t        self.assertIsNot(old_model, new_model)\n  3066\t        self.assertEqual(new_model._meta.index_together, tuple())\n  3067\t        self.assertEqual(new_model._meta.indexes[0].name, \"new_pony_pink_idx\")\n          # ...\n      # ...\n```\n\n\ntests/migrations/test_optimizer.py\n```\n\n\n\n<span id='imports'>\n     1\tfrom django.db import migrations, models\n     2\tfrom django.db.migrations import operations\n     3\tfrom django.db.migrations.optimizer import MigrationOptimizer\n     4\tfrom django.db.migrations.serializer import serializer_factory\n     5\tfrom django.test import SimpleTestCase\n     6\t\n     7\tfrom .models import EmptyManager, UnicodeModel\n\n\n<span id='OptimizerTests'>\n     8\t\n     9\t\n    10\tclass OptimizerTests(SimpleTestCase):\n    11\t    \"\"\"\n    12\t    Tests the migration autodetector.\n    13\t    \"\"\"\n          # ...\n\n\n<span id='OptimizerTests.test_rename_index'>\n  1117\t\n  1118\t    def test_rename_index(self):\n  1119\t        self.assertOptimizesTo(\n  1120\t            [\n  1121\t                migrations.RenameIndex(\n  1122\t                    \"Pony\", new_name=\"mid_name\", old_fields=(\"weight\", \"pink\")\n  1123\t                ),\n  1124\t                migrations.RenameIndex(\n  1125\t                    \"Pony\", new_name=\"new_name\", old_name=\"mid_name\"\n  1126\t                ),\n  1127\t            ],\n  1128\t            [\n  1129\t                migrations.RenameIndex(\n  1130\t                    \"Pony\", new_name=\"new_name\", old_fields=(\"weight\", \"pink\")\n  1131\t                ),\n  1132\t            ],\n  1133\t        )\n  1134\t        self.assertOptimizesTo(\n  1135\t            [\n  1136\t                migrations.RenameIndex(\n  1137\t                    \"Pony\", new_name=\"mid_name\", old_name=\"old_name\"\n  1138\t                ),\n  1139\t                migrations.RenameIndex(\n  1140\t                    \"Pony\", new_name=\"new_name\", old_name=\"mid_name\"\n  1141\t                ),\n  1142\t            ],\n  1143\t            [migrations.RenameIndex(\"Pony\", new_name=\"new_name\", old_name=\"old_name\")],\n  1144\t        )\n  1145\t        self.assertDoesNotOptimize(\n  1146\t            [\n  1147\t                migrations.RenameIndex(\n  1148\t                    \"Pony\", new_name=\"mid_name\", old_name=\"old_name\"\n  1149\t                ),\n  1150\t                migrations.RenameIndex(\n  1151\t                    \"Pony\", new_name=\"new_name\", old_fields=(\"weight\", \"pink\")\n  1152\t                ),\n  1153\t            ]\n  1154\t        )\n```\n\n</search_result>\n"
            }
          ],
          "response": {
            "id": "msg_01SFsdqcad32MdJmeLRBupQz",
            "content": [
              {
                "text": "I'll analyze the search results for code related to testing RenameIndex operation migration. The most relevant sections are found in the test files, particularly focusing on the RenameIndex operation tests.\n\nLet me identify the relevant code sections:",
                "type": "text"
              },
              {
                "id": "toolu_01RqxcnoTwN6adTEZGvF3Li9",
                "input": {
                  "scratch_pad": "The most relevant code sections for testing RenameIndex operations are:\n\n1. Main RenameIndex test (test_rename_index) - This is the primary test case that verifies the basic functionality of RenameIndex operation, including:\n   - Index renaming\n   - State changes\n   - Database operations\n   - Reversibility\n   - Operation description and deconstruction\n\n2. RenameIndex arguments test (test_rename_index_arguments) - Tests validation of operation arguments\n\n3. RenameIndex unnamed index test (test_rename_index_unnamed_index) - Tests renaming of unnamed indexes\n\n4. RenameIndex state forwards tests (test_rename_index_state_forwards) - Tests state management for named and unnamed indexes\n\n5. RenameIndex optimization tests - Shows how RenameIndex operations can be optimized when chained together\n\nThese sections provide comprehensive testing of the RenameIndex migration operation functionality.",
                  "identified_spans": [
                    {
                      "file_path": "tests/migrations/test_operations.py",
                      "start_line": 2903,
                      "end_line": 2949
                    },
                    {
                      "file_path": "tests/migrations/test_operations.py",
                      "start_line": 2951,
                      "end_line": 2962
                    },
                    {
                      "file_path": "tests/migrations/test_operations.py",
                      "start_line": 2964,
                      "end_line": 3002
                    },
                    {
                      "file_path": "tests/migrations/test_operations.py",
                      "start_line": 3040,
                      "end_line": 3067
                    },
                    {
                      "file_path": "tests/migrations/test_optimizer.py",
                      "start_line": 1118,
                      "end_line": 1154
                    }
                  ]
                },
                "name": "Action",
                "type": "tool_use"
              }
            ],
            "model": "claude-3-5-sonnet-20241022",
            "role": "assistant",
            "stop_reason": "tool_use",
            "stop_sequence": null,
            "type": "message",
            "usage": {
              "cache_creation_input_tokens": 0,
              "cache_read_input_tokens": 0,
              "input_tokens": 7625,
              "output_tokens": 553
            }
          },
          "usage": {
            "completion_cost": 0.03117,
            "completion_tokens": 553,
            "prompt_tokens": 7625,
            "cached_tokens": 0
          }
        }
      },
      "possible_actions": [
        "SemanticSearch",
        "FindClass",
        "FindFunction",
        "FindCodeSnippet",
        "ViewCode",
        "ClaudeEditTool"
      ],
      "output": {
        "message": "Found 15 code sections.\n\nViewed relevant code:\ntests/migrations/test_operations.py\n```\n     1\tfrom django.core.exceptions import FieldDoesNotExist\n     2\tfrom django.db import IntegrityError, connection, migrations, models, transaction\n     3\tfrom django.db.migrations.migration import Migration\n     4\tfrom django.db.migrations.operations.fields import FieldOperation\n     5\tfrom django.db.migrations.state import ModelState, ProjectState\n     6\tfrom django.db.models.functions import Abs\n     7\tfrom django.db.transaction import atomic\n     8\tfrom django.test import SimpleTestCase, override_settings, skipUnlessDBFeature\n     9\tfrom django.test.utils import CaptureQueriesContext\n    10\t\n    11\tfrom .models import FoodManager, FoodQuerySet, UnicodeModel\n    12\tfrom .test_base import OperationTestBase\n      # ...\n    17\t\n    18\t\n    19\tclass OperationTests(OperationTestBase):\n    20\t    \"\"\"\n    21\t    Tests running the operations and making sure they do what they say they do.\n    22\t    Each test looks at their state changing, and then their database operation -\n    23\t    both forwards and backwards.\n    24\t    \"\"\"\n          # ...\n  2902\t\n  2903\t    def test_rename_index(self):\n  2904\t        app_label = \"test_rnin\"\n  2905\t        project_state = self.set_up_test_model(app_label, index=True)\n  2906\t        table_name = app_label + \"_pony\"\n  2907\t        self.assertIndexNameExists(table_name, \"pony_pink_idx\")\n  2908\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2909\t        operation = migrations.RenameIndex(\n  2910\t            \"Pony\", new_name=\"new_pony_test_idx\", old_name=\"pony_pink_idx\"\n  2911\t        )\n  2912\t        self.assertEqual(\n  2913\t            operation.describe(),\n  2914\t            \"Rename index pony_pink_idx on Pony to new_pony_test_idx\",\n  2915\t        )\n  2916\t        self.assertEqual(\n  2917\t            operation.migration_name_fragment,\n  2918\t            \"rename_pony_pink_idx_new_pony_test_idx\",\n  2919\t        )\n  2920\t\n  2921\t        new_state = project_state.clone()\n  2922\t        operation.state_forwards(app_label, new_state)\n  2923\t        # Rename index.\n  2924\t        expected_queries = 1 if connection.features.can_rename_index else 2\n  2925\t        with connection.schema_editor() as editor, self.assertNumQueries(\n  2926\t            expected_queries\n  2927\t        ):\n  2928\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2929\t        self.assertIndexNameNotExists(table_name, \"pony_pink_idx\")\n  2930\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2931\t        # Reversal.\n  2932\t        with connection.schema_editor() as editor, self.assertNumQueries(\n  2933\t            expected_queries\n  2934\t        ):\n  2935\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2936\t        self.assertIndexNameExists(table_name, \"pony_pink_idx\")\n  2937\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2938\t        # Deconstruction.\n  2939\t        definition = operation.deconstruct()\n  2940\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2941\t        self.assertEqual(definition[1], [])\n  2942\t        self.assertEqual(\n  2943\t            definition[2],\n  2944\t            {\n  2945\t                \"model_name\": \"Pony\",\n  2946\t                \"old_name\": \"pony_pink_idx\",\n  2947\t                \"new_name\": \"new_pony_test_idx\",\n  2948\t            },\n  2949\t        )\n  2950\t\n  2951\t    def test_rename_index_arguments(self):\n  2952\t        msg = \"RenameIndex.old_name and old_fields are mutually exclusive.\"\n  2953\t        with self.assertRaisesMessage(ValueError, msg):\n  2954\t            migrations.RenameIndex(\n  2955\t                \"Pony\",\n  2956\t                new_name=\"new_idx_name\",\n  2957\t                old_name=\"old_idx_name\",\n  2958\t                old_fields=(\"weight\", \"pink\"),\n  2959\t            )\n  2960\t        msg = \"RenameIndex requires one of old_name and old_fields arguments to be set.\"\n  2961\t        with self.assertRaisesMessage(ValueError, msg):\n  2962\t            migrations.RenameIndex(\"Pony\", new_name=\"new_idx_name\")\n  2963\t\n  2964\t    def test_rename_index_unnamed_index(self):\n  2965\t        app_label = \"test_rninui\"\n  2966\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  2967\t        table_name = app_label + \"_pony\"\n  2968\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2969\t        operation = migrations.RenameIndex(\n  2970\t            \"Pony\", new_name=\"new_pony_test_idx\", old_fields=(\"weight\", \"pink\")\n  2971\t        )\n  2972\t        self.assertEqual(\n  2973\t            operation.describe(),\n  2974\t            \"Rename unnamed index for ('weight', 'pink') on Pony to new_pony_test_idx\",\n  2975\t        )\n  2976\t        self.assertEqual(\n  2977\t            operation.migration_name_fragment,\n  2978\t            \"rename_pony_weight_pink_new_pony_test_idx\",\n  2979\t        )\n  2980\t\n  2981\t        new_state = project_state.clone()\n  2982\t        operation.state_forwards(app_label, new_state)\n  2983\t        # Rename index.\n  2984\t        with connection.schema_editor() as editor:\n  2985\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2986\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2987\t        # Reverse is a no-op.\n  2988\t        with connection.schema_editor() as editor, self.assertNumQueries(0):\n  2989\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2990\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2991\t        # Deconstruction.\n  2992\t        definition = operation.deconstruct()\n  2993\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2994\t        self.assertEqual(definition[1], [])\n  2995\t        self.assertEqual(\n  2996\t            definition[2],\n  2997\t            {\n  2998\t                \"model_name\": \"Pony\",\n  2999\t                \"new_name\": \"new_pony_test_idx\",\n  3000\t                \"old_fields\": (\"weight\", \"pink\"),\n  3001\t            },\n  3002\t        )\n          # ...\n  3039\t\n  3040\t    def test_rename_index_state_forwards(self):\n  3041\t        app_label = \"test_rnidsf\"\n  3042\t        project_state = self.set_up_test_model(app_label, index=True)\n  3043\t        old_model = project_state.apps.get_model(app_label, \"Pony\")\n  3044\t        new_state = project_state.clone()\n  3045\t\n  3046\t        operation = migrations.RenameIndex(\n  3047\t            \"Pony\", new_name=\"new_pony_pink_idx\", old_name=\"pony_pink_idx\"\n  3048\t        )\n  3049\t        operation.state_forwards(app_label, new_state)\n  3050\t        new_model = new_state.apps.get_model(app_label, \"Pony\")\n  3051\t        self.assertIsNot(old_model, new_model)\n  3052\t        self.assertEqual(new_model._meta.indexes[0].name, \"new_pony_pink_idx\")\n  3053\t\n  3054\t    def test_rename_index_state_forwards_unnamed_index(self):\n  3055\t        app_label = \"test_rnidsfui\"\n  3056\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  3057\t        old_model = project_state.apps.get_model(app_label, \"Pony\")\n  3058\t        new_state = project_state.clone()\n  3059\t\n  3060\t        operation = migrations.RenameIndex(\n  3061\t            \"Pony\", new_name=\"new_pony_pink_idx\", old_fields=(\"weight\", \"pink\")\n  3062\t        )\n  3063\t        operation.state_forwards(app_label, new_state)\n  3064\t        new_model = new_state.apps.get_model(app_label, \"Pony\")\n  3065\t        self.assertIsNot(old_model, new_model)\n  3066\t        self.assertEqual(new_model._meta.index_together, tuple())\n  3067\t        self.assertEqual(new_model._meta.indexes[0].name, \"new_pony_pink_idx\")\n          # ...\n      # ...\n```\n\n\ntests/migrations/test_optimizer.py\n```\n     1\tfrom django.db import migrations, models\n     2\tfrom django.db.migrations import operations\n     3\tfrom django.db.migrations.optimizer import MigrationOptimizer\n     4\tfrom django.db.migrations.serializer import serializer_factory\n     5\tfrom django.test import SimpleTestCase\n     6\t\n     7\tfrom .models import EmptyManager, UnicodeModel\n     8\t\n     9\t\n    10\tclass OptimizerTests(SimpleTestCase):\n    11\t    \"\"\"\n    12\t    Tests the migration autodetector.\n    13\t    \"\"\"\n          # ...\n  1117\t\n  1118\t    def test_rename_index(self):\n  1119\t        self.assertOptimizesTo(\n  1120\t            [\n  1121\t                migrations.RenameIndex(\n  1122\t                    \"Pony\", new_name=\"mid_name\", old_fields=(\"weight\", \"pink\")\n  1123\t                ),\n  1124\t                migrations.RenameIndex(\n  1125\t                    \"Pony\", new_name=\"new_name\", old_name=\"mid_name\"\n  1126\t                ),\n  1127\t            ],\n  1128\t            [\n  1129\t                migrations.RenameIndex(\n  1130\t                    \"Pony\", new_name=\"new_name\", old_fields=(\"weight\", \"pink\")\n  1131\t                ),\n  1132\t            ],\n  1133\t        )\n  1134\t        self.assertOptimizesTo(\n  1135\t            [\n  1136\t                migrations.RenameIndex(\n  1137\t                    \"Pony\", new_name=\"mid_name\", old_name=\"old_name\"\n  1138\t                ),\n  1139\t                migrations.RenameIndex(\n  1140\t                    \"Pony\", new_name=\"new_name\", old_name=\"mid_name\"\n  1141\t                ),\n  1142\t            ],\n  1143\t            [migrations.RenameIndex(\"Pony\", new_name=\"new_name\", old_name=\"old_name\")],\n  1144\t        )\n  1145\t        self.assertDoesNotOptimize(\n  1146\t            [\n  1147\t                migrations.RenameIndex(\n  1148\t                    \"Pony\", new_name=\"mid_name\", old_name=\"old_name\"\n  1149\t                ),\n  1150\t                migrations.RenameIndex(\n  1151\t                    \"Pony\", new_name=\"new_name\", old_fields=(\"weight\", \"pink\")\n  1152\t                ),\n  1153\t            ]\n  1154\t        )\n```\n",
        "summary": "Found relevant code sections in the search results.",
        "terminal": false,
        "expect_correction": false,
        "properties": {
          "search_hits": [],
          "search_tokens": 3473,
          "new_span_ids": [
            "OperationTests",
            "OperationTests.test_rename_index",
            "OperationTests.test_rename_index_arguments",
            "OperationTests.test_rename_index_unnamed_index",
            "OperationTests.test_rename_index_state_forwards",
            "OperationTests.test_rename_index_state_forwards_unnamed_index",
            "OptimizerTests",
            "OptimizerTests.test_rename_index"
          ]
        },
        "execution_completion": {
          "model": "claude-3-5-sonnet-20241022",
          "input": [
            {
              "role": "user",
              "content": "Search request:\nSearching for code using the query: test RenameIndex operation migration\n\nIdentify the relevant code sections in the search results to use them. \n\n<search_results>\ntests/migrations/test_operations.py\n```\n\n\n\n<span id='imports'>\n     1\tfrom django.core.exceptions import FieldDoesNotExist\n     2\tfrom django.db import IntegrityError, connection, migrations, models, transaction\n     3\tfrom django.db.migrations.migration import Migration\n     4\tfrom django.db.migrations.operations.fields import FieldOperation\n     5\tfrom django.db.migrations.state import ModelState, ProjectState\n     6\tfrom django.db.models.functions import Abs\n     7\tfrom django.db.transaction import atomic\n     8\tfrom django.test import SimpleTestCase, override_settings, skipUnlessDBFeature\n     9\tfrom django.test.utils import CaptureQueriesContext\n    10\t\n    11\tfrom .models import FoodManager, FoodQuerySet, UnicodeModel\n    12\tfrom .test_base import OperationTestBase\n      # ...\n\n\n<span id='OperationTests'>\n    17\t\n    18\t\n    19\tclass OperationTests(OperationTestBase):\n    20\t    \"\"\"\n    21\t    Tests running the operations and making sure they do what they say they do.\n    22\t    Each test looks at their state changing, and then their database operation -\n    23\t    both forwards and backwards.\n    24\t    \"\"\"\n          # ...\n\n\n<span id='OperationTests.test_rename_model'>\n   774\t\n   775\t    def test_rename_model(self):\n   776\t        \"\"\"\n   777\t        Tests the RenameModel operation.\n   778\t        \"\"\"\n   779\t        project_state = self.set_up_test_model(\"test_rnmo\", related_model=True)\n   780\t        # Test the state alteration\n   781\t        operation = migrations.RenameModel(\"Pony\", \"Horse\")\n   782\t        self.assertEqual(operation.describe(), \"Rename model Pony to Horse\")\n   783\t        self.assertEqual(operation.migration_name_fragment, \"rename_pony_horse\")\n   784\t        # Test initial state and database\n   785\t        self.assertIn((\"test_rnmo\", \"pony\"), project_state.models)\n   786\t        self.assertNotIn((\"test_rnmo\", \"horse\"), project_state.models)\n   787\t        self.assertTableExists(\"test_rnmo_pony\")\n   788\t        self.assertTableNotExists(\"test_rnmo_horse\")\n   789\t        if connection.features.supports_foreign_keys:\n   790\t            self.assertFKExists(\n   791\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_pony\", \"id\")\n   792\t            )\n   793\t            self.assertFKNotExists(\n   794\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_horse\", \"id\")\n   795\t            )\n   796\t        # Migrate forwards\n   797\t        new_state = project_state.clone()\n   798\t        atomic_rename = connection.features.supports_atomic_references_rename\n   799\t        new_state = self.apply_operations(\n   800\t            \"test_rnmo\", new_state, [operation], atomic=atomic_rename\n   801\t        )\n   802\t        # Test new state and database\n   803\t        self.assertNotIn((\"test_rnmo\", \"pony\"), new_state.models)\n   804\t        self.assertIn((\"test_rnmo\", \"horse\"), new_state.models)\n   805\t        # RenameModel also repoints all incoming FKs and M2Ms\n   806\t        self.assertEqual(\n   807\t            new_state.models[\"test_rnmo\", \"rider\"].fields[\"pony\"].remote_field.model,\n   808\t            \"test_rnmo.Horse\",\n   809\t        )\n   810\t        self.assertTableNotExists(\"test_rnmo_pony\")\n   811\t        self.assertTableExists(\"test_rnmo_horse\")\n   812\t        if connection.features.supports_foreign_keys:\n   813\t            self.assertFKNotExists(\n   814\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_pony\", \"id\")\n   815\t            )\n   816\t            self.assertFKExists(\n   817\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_horse\", \"id\")\n   818\t            )\n   819\t        # Migrate backwards\n   820\t        original_state = self.unapply_operations(\n   821\t            \"test_rnmo\", project_state, [operation], atomic=atomic_rename\n   822\t        )\n   823\t        # Test original state and database\n   824\t        self.assertIn((\"test_rnmo\", \"pony\"), original_state.models)\n   825\t        self.assertNotIn((\"test_rnmo\", \"horse\"), original_state.models)\n   826\t        self.assertEqual(\n   827\t            original_state.models[\"test_rnmo\", \"rider\"]\n   828\t            .fields[\"pony\"]\n   829\t            .remote_field.model,\n   830\t            \"Pony\",\n   831\t        )\n   832\t        self.assertTableExists(\"test_rnmo_pony\")\n   833\t        self.assertTableNotExists(\"test_rnmo_horse\")\n   834\t        if connection.features.supports_foreign_keys:\n   835\t            self.assertFKExists(\n   836\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_pony\", \"id\")\n   837\t            )\n   838\t            self.assertFKNotExists(\n   839\t                \"test_rnmo_rider\", [\"pony_id\"], (\"test_rnmo_horse\", \"id\")\n   840\t            )\n   841\t        # And deconstruction\n   842\t        definition = operation.deconstruct()\n   843\t        self.assertEqual(definition[0], \"RenameModel\")\n   844\t        self.assertEqual(definition[1], [])\n   845\t        self.assertEqual(definition[2], {\"old_name\": \"Pony\", \"new_name\": \"Horse\"})\n          # ...\n\n\n<span id='OperationTests.test_rename_field'>\n  2487\t\n  2488\t    def test_rename_field(self):\n  2489\t        \"\"\"\n  2490\t        Tests the RenameField operation.\n  2491\t        \"\"\"\n  2492\t        project_state = self.set_up_test_model(\n  2493\t            \"test_rnfl\", unique_together=True, index_together=True\n  2494\t        )\n  2495\t        # Test the state alteration\n  2496\t        operation = migrations.RenameField(\"Pony\", \"pink\", \"blue\")\n  2497\t        self.assertEqual(operation.describe(), \"Rename field pink on Pony to blue\")\n  2498\t        self.assertEqual(operation.migration_name_fragment, \"rename_pink_pony_blue\")\n  2499\t        new_state = project_state.clone()\n  2500\t        operation.state_forwards(\"test_rnfl\", new_state)\n  2501\t        self.assertIn(\"blue\", new_state.models[\"test_rnfl\", \"pony\"].fields)\n  2502\t        self.assertNotIn(\"pink\", new_state.models[\"test_rnfl\", \"pony\"].fields)\n  2503\t        # Make sure the unique_together has the renamed column too\n  2504\t        self.assertIn(\n  2505\t            \"blue\", new_state.models[\"test_rnfl\", \"pony\"].options[\"unique_together\"][0]\n  2506\t        )\n  2507\t        self.assertNotIn(\n  2508\t            \"pink\", new_state.models[\"test_rnfl\", \"pony\"].options[\"unique_together\"][0]\n  2509\t        )\n  2510\t        # Make sure the index_together has the renamed column too\n  2511\t        self.assertIn(\n  2512\t            \"blue\", new_state.models[\"test_rnfl\", \"pony\"].options[\"index_together\"][0]\n  2513\t        )\n  2514\t        self.assertNotIn(\n  2515\t            \"pink\", new_state.models[\"test_rnfl\", \"pony\"].options[\"index_together\"][0]\n  2516\t        )\n  2517\t        # Test the database alteration\n  2518\t        self.assertColumnExists(\"test_rnfl_pony\", \"pink\")\n  2519\t        self.assertColumnNotExists(\"test_rnfl_pony\", \"blue\")\n  2520\t        with connection.schema_editor() as editor:\n  2521\t            operation.database_forwards(\"test_rnfl\", editor, project_state, new_state)\n  2522\t        self.assertColumnExists(\"test_rnfl_pony\", \"blue\")\n  2523\t        self.assertColumnNotExists(\"test_rnfl_pony\", \"pink\")\n  2524\t        # Ensure the unique constraint has been ported over\n  2525\t        with connection.cursor() as cursor:\n  2526\t            cursor.execute(\"INSERT INTO test_rnfl_pony (blue, weight) VALUES (1, 1)\")\n  2527\t            with self.assertRaises(IntegrityError):\n  2528\t                with atomic():\n  2529\t                    cursor.execute(\n  2530\t                        \"INSERT INTO test_rnfl_pony (blue, weight) VALUES (1, 1)\"\n  2531\t                    )\n  2532\t            cursor.execute(\"DELETE FROM test_rnfl_pony\")\n  2533\t        # Ensure the index constraint has been ported over\n  2534\t        self.assertIndexExists(\"test_rnfl_pony\", [\"weight\", \"blue\"])\n  2535\t        # And test reversal\n  2536\t        with connection.schema_editor() as editor:\n  2537\t            operation.database_backwards(\"test_rnfl\", editor, new_state, project_state)\n  2538\t        self.assertColumnExists(\"test_rnfl_pony\", \"pink\")\n  2539\t        self.assertColumnNotExists(\"test_rnfl_pony\", \"blue\")\n  2540\t        # Ensure the index constraint has been reset\n  2541\t        self.assertIndexExists(\"test_rnfl_pony\", [\"weight\", \"pink\"])\n  2542\t        # And deconstruction\n  2543\t        definition = operation.deconstruct()\n  2544\t        self.assertEqual(definition[0], \"RenameField\")\n  2545\t        self.assertEqual(definition[1], [])\n  2546\t        self.assertEqual(\n  2547\t            definition[2],\n  2548\t            {\"model_name\": \"Pony\", \"old_name\": \"pink\", \"new_name\": \"blue\"},\n  2549\t        )\n          # ...\n\n\n<span id='OperationTests.test_rename_field_case'>\n  2612\t\n  2613\t    def test_rename_field_case(self):\n  2614\t        project_state = self.apply_operations(\n  2615\t            \"test_rfmx\",\n  2616\t            ProjectState(),\n  2617\t            operations=[\n  2618\t                migrations.CreateModel(\n  2619\t                    \"Pony\",\n  2620\t                    fields=[\n  2621\t                        (\"id\", models.AutoField(primary_key=True)),\n  2622\t                        (\"field\", models.IntegerField()),\n  2623\t                    ],\n  2624\t                ),\n  2625\t            ],\n  2626\t        )\n  2627\t        new_state = project_state.clone()\n  2628\t        operation = migrations.RenameField(\"Pony\", \"field\", \"FiElD\")\n  2629\t        operation.state_forwards(\"test_rfmx\", new_state)\n  2630\t        self.assertIn(\"FiElD\", new_state.models[\"test_rfmx\", \"pony\"].fields)\n  2631\t        self.assertColumnExists(\"test_rfmx_pony\", \"field\")\n  2632\t        with connection.schema_editor() as editor:\n  2633\t            operation.database_forwards(\"test_rfmx\", editor, project_state, new_state)\n  2634\t        self.assertColumnExists(\n  2635\t            \"test_rfmx_pony\",\n  2636\t            connection.introspection.identifier_converter(\"FiElD\"),\n  2637\t        )\n  2638\t        with connection.schema_editor() as editor:\n  2639\t            operation.database_backwards(\"test_rfmx\", editor, new_state, project_state)\n  2640\t        self.assertColumnExists(\"test_rfmx_pony\", \"field\")\n\n\n<span id='OperationTests.test_rename_missing_field'>\n  2641\t\n  2642\t    def test_rename_missing_field(self):\n  2643\t        state = ProjectState()\n  2644\t        state.add_model(ModelState(\"app\", \"model\", []))\n  2645\t        with self.assertRaisesMessage(\n  2646\t            FieldDoesNotExist, \"app.model has no field named 'field'\"\n  2647\t        ):\n  2648\t            migrations.RenameField(\"model\", \"field\", \"new_field\").state_forwards(\n  2649\t                \"app\", state\n  2650\t            )\n          # ...\n\n\n<span id='OperationTests.test_rename_index'>\n  2902\t\n  2903\t    def test_rename_index(self):\n  2904\t        app_label = \"test_rnin\"\n  2905\t        project_state = self.set_up_test_model(app_label, index=True)\n  2906\t        table_name = app_label + \"_pony\"\n  2907\t        self.assertIndexNameExists(table_name, \"pony_pink_idx\")\n  2908\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2909\t        operation = migrations.RenameIndex(\n  2910\t            \"Pony\", new_name=\"new_pony_test_idx\", old_name=\"pony_pink_idx\"\n  2911\t        )\n  2912\t        self.assertEqual(\n  2913\t            operation.describe(),\n  2914\t            \"Rename index pony_pink_idx on Pony to new_pony_test_idx\",\n  2915\t        )\n  2916\t        self.assertEqual(\n  2917\t            operation.migration_name_fragment,\n  2918\t            \"rename_pony_pink_idx_new_pony_test_idx\",\n  2919\t        )\n  2920\t\n  2921\t        new_state = project_state.clone()\n  2922\t        operation.state_forwards(app_label, new_state)\n  2923\t        # Rename index.\n  2924\t        expected_queries = 1 if connection.features.can_rename_index else 2\n  2925\t        with connection.schema_editor() as editor, self.assertNumQueries(\n  2926\t            expected_queries\n  2927\t        ):\n  2928\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2929\t        self.assertIndexNameNotExists(table_name, \"pony_pink_idx\")\n  2930\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2931\t        # Reversal.\n  2932\t        with connection.schema_editor() as editor, self.assertNumQueries(\n  2933\t            expected_queries\n  2934\t        ):\n  2935\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2936\t        self.assertIndexNameExists(table_name, \"pony_pink_idx\")\n  2937\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2938\t        # Deconstruction.\n  2939\t        definition = operation.deconstruct()\n  2940\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2941\t        self.assertEqual(definition[1], [])\n  2942\t        self.assertEqual(\n  2943\t            definition[2],\n  2944\t            {\n  2945\t                \"model_name\": \"Pony\",\n  2946\t                \"old_name\": \"pony_pink_idx\",\n  2947\t                \"new_name\": \"new_pony_test_idx\",\n  2948\t            },\n  2949\t        )\n\n\n<span id='OperationTests.test_rename_index_arguments'>\n  2950\t\n  2951\t    def test_rename_index_arguments(self):\n  2952\t        msg = \"RenameIndex.old_name and old_fields are mutually exclusive.\"\n  2953\t        with self.assertRaisesMessage(ValueError, msg):\n  2954\t            migrations.RenameIndex(\n  2955\t                \"Pony\",\n  2956\t                new_name=\"new_idx_name\",\n  2957\t                old_name=\"old_idx_name\",\n  2958\t                old_fields=(\"weight\", \"pink\"),\n  2959\t            )\n  2960\t        msg = \"RenameIndex requires one of old_name and old_fields arguments to be set.\"\n  2961\t        with self.assertRaisesMessage(ValueError, msg):\n  2962\t            migrations.RenameIndex(\"Pony\", new_name=\"new_idx_name\")\n\n\n<span id='OperationTests.test_rename_index_unnamed_index'>\n  2963\t\n  2964\t    def test_rename_index_unnamed_index(self):\n  2965\t        app_label = \"test_rninui\"\n  2966\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  2967\t        table_name = app_label + \"_pony\"\n  2968\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2969\t        operation = migrations.RenameIndex(\n  2970\t            \"Pony\", new_name=\"new_pony_test_idx\", old_fields=(\"weight\", \"pink\")\n  2971\t        )\n  2972\t        self.assertEqual(\n  2973\t            operation.describe(),\n  2974\t            \"Rename unnamed index for ('weight', 'pink') on Pony to new_pony_test_idx\",\n  2975\t        )\n  2976\t        self.assertEqual(\n  2977\t            operation.migration_name_fragment,\n  2978\t            \"rename_pony_weight_pink_new_pony_test_idx\",\n  2979\t        )\n  2980\t\n  2981\t        new_state = project_state.clone()\n  2982\t        operation.state_forwards(app_label, new_state)\n  2983\t        # Rename index.\n  2984\t        with connection.schema_editor() as editor:\n  2985\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2986\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2987\t        # Reverse is a no-op.\n  2988\t        with connection.schema_editor() as editor, self.assertNumQueries(0):\n  2989\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2990\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2991\t        # Deconstruction.\n  2992\t        definition = operation.deconstruct()\n  2993\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2994\t        self.assertEqual(definition[1], [])\n  2995\t        self.assertEqual(\n  2996\t            definition[2],\n  2997\t            {\n  2998\t                \"model_name\": \"Pony\",\n  2999\t                \"new_name\": \"new_pony_test_idx\",\n  3000\t                \"old_fields\": (\"weight\", \"pink\"),\n  3001\t            },\n  3002\t        )\n\n\n<span id='OperationTests.test_rename_index_unknown_unnamed_index'>\n  3003\t\n  3004\t    def test_rename_index_unknown_unnamed_index(self):\n  3005\t        app_label = \"test_rninuui\"\n  3006\t        project_state = self.set_up_test_model(app_label)\n  3007\t        operation = migrations.RenameIndex(\n  3008\t            \"Pony\", new_name=\"new_pony_test_idx\", old_fields=(\"weight\", \"pink\")\n  3009\t        )\n  3010\t        new_state = project_state.clone()\n  3011\t        operation.state_forwards(app_label, new_state)\n  3012\t        msg = \"Found wrong number (0) of indexes for test_rninuui_pony(weight, pink).\"\n  3013\t        with connection.schema_editor() as editor:\n  3014\t            with self.assertRaisesMessage(ValueError, msg):\n  3015\t                operation.database_forwards(app_label, editor, project_state, new_state)\n          # ...\n\n\n<span id='OperationTests.test_rename_index_state_forwards'>\n  3039\t\n  3040\t    def test_rename_index_state_forwards(self):\n  3041\t        app_label = \"test_rnidsf\"\n  3042\t        project_state = self.set_up_test_model(app_label, index=True)\n  3043\t        old_model = project_state.apps.get_model(app_label, \"Pony\")\n  3044\t        new_state = project_state.clone()\n  3045\t\n  3046\t        operation = migrations.RenameIndex(\n  3047\t            \"Pony\", new_name=\"new_pony_pink_idx\", old_name=\"pony_pink_idx\"\n  3048\t        )\n  3049\t        operation.state_forwards(app_label, new_state)\n  3050\t        new_model = new_state.apps.get_model(app_label, \"Pony\")\n  3051\t        self.assertIsNot(old_model, new_model)\n  3052\t        self.assertEqual(new_model._meta.indexes[0].name, \"new_pony_pink_idx\")\n\n\n<span id='OperationTests.test_rename_index_state_forwards_unnamed_index'>\n  3053\t\n  3054\t    def test_rename_index_state_forwards_unnamed_index(self):\n  3055\t        app_label = \"test_rnidsfui\"\n  3056\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  3057\t        old_model = project_state.apps.get_model(app_label, \"Pony\")\n  3058\t        new_state = project_state.clone()\n  3059\t\n  3060\t        operation = migrations.RenameIndex(\n  3061\t            \"Pony\", new_name=\"new_pony_pink_idx\", old_fields=(\"weight\", \"pink\")\n  3062\t        )\n  3063\t        operation.state_forwards(app_label, new_state)\n  3064\t        new_model = new_state.apps.get_model(app_label, \"Pony\")\n  3065\t        self.assertIsNot(old_model, new_model)\n  3066\t        self.assertEqual(new_model._meta.index_together, tuple())\n  3067\t        self.assertEqual(new_model._meta.indexes[0].name, \"new_pony_pink_idx\")\n          # ...\n      # ...\n```\n\n\ntests/migrations/test_optimizer.py\n```\n\n\n\n<span id='imports'>\n     1\tfrom django.db import migrations, models\n     2\tfrom django.db.migrations import operations\n     3\tfrom django.db.migrations.optimizer import MigrationOptimizer\n     4\tfrom django.db.migrations.serializer import serializer_factory\n     5\tfrom django.test import SimpleTestCase\n     6\t\n     7\tfrom .models import EmptyManager, UnicodeModel\n\n\n<span id='OptimizerTests'>\n     8\t\n     9\t\n    10\tclass OptimizerTests(SimpleTestCase):\n    11\t    \"\"\"\n    12\t    Tests the migration autodetector.\n    13\t    \"\"\"\n          # ...\n\n\n<span id='OptimizerTests.test_rename_index'>\n  1117\t\n  1118\t    def test_rename_index(self):\n  1119\t        self.assertOptimizesTo(\n  1120\t            [\n  1121\t                migrations.RenameIndex(\n  1122\t                    \"Pony\", new_name=\"mid_name\", old_fields=(\"weight\", \"pink\")\n  1123\t                ),\n  1124\t                migrations.RenameIndex(\n  1125\t                    \"Pony\", new_name=\"new_name\", old_name=\"mid_name\"\n  1126\t                ),\n  1127\t            ],\n  1128\t            [\n  1129\t                migrations.RenameIndex(\n  1130\t                    \"Pony\", new_name=\"new_name\", old_fields=(\"weight\", \"pink\")\n  1131\t                ),\n  1132\t            ],\n  1133\t        )\n  1134\t        self.assertOptimizesTo(\n  1135\t            [\n  1136\t                migrations.RenameIndex(\n  1137\t                    \"Pony\", new_name=\"mid_name\", old_name=\"old_name\"\n  1138\t                ),\n  1139\t                migrations.RenameIndex(\n  1140\t                    \"Pony\", new_name=\"new_name\", old_name=\"mid_name\"\n  1141\t                ),\n  1142\t            ],\n  1143\t            [migrations.RenameIndex(\"Pony\", new_name=\"new_name\", old_name=\"old_name\")],\n  1144\t        )\n  1145\t        self.assertDoesNotOptimize(\n  1146\t            [\n  1147\t                migrations.RenameIndex(\n  1148\t                    \"Pony\", new_name=\"mid_name\", old_name=\"old_name\"\n  1149\t                ),\n  1150\t                migrations.RenameIndex(\n  1151\t                    \"Pony\", new_name=\"new_name\", old_fields=(\"weight\", \"pink\")\n  1152\t                ),\n  1153\t            ]\n  1154\t        )\n```\n\n</search_result>\n"
            }
          ],
          "response": {
            "id": "msg_01SFsdqcad32MdJmeLRBupQz",
            "content": [
              {
                "text": "I'll analyze the search results for code related to testing RenameIndex operation migration. The most relevant sections are found in the test files, particularly focusing on the RenameIndex operation tests.\n\nLet me identify the relevant code sections:",
                "type": "text"
              },
              {
                "id": "toolu_01RqxcnoTwN6adTEZGvF3Li9",
                "input": {
                  "scratch_pad": "The most relevant code sections for testing RenameIndex operations are:\n\n1. Main RenameIndex test (test_rename_index) - This is the primary test case that verifies the basic functionality of RenameIndex operation, including:\n   - Index renaming\n   - State changes\n   - Database operations\n   - Reversibility\n   - Operation description and deconstruction\n\n2. RenameIndex arguments test (test_rename_index_arguments) - Tests validation of operation arguments\n\n3. RenameIndex unnamed index test (test_rename_index_unnamed_index) - Tests renaming of unnamed indexes\n\n4. RenameIndex state forwards tests (test_rename_index_state_forwards) - Tests state management for named and unnamed indexes\n\n5. RenameIndex optimization tests - Shows how RenameIndex operations can be optimized when chained together\n\nThese sections provide comprehensive testing of the RenameIndex migration operation functionality.",
                  "identified_spans": [
                    {
                      "file_path": "tests/migrations/test_operations.py",
                      "start_line": 2903,
                      "end_line": 2949
                    },
                    {
                      "file_path": "tests/migrations/test_operations.py",
                      "start_line": 2951,
                      "end_line": 2962
                    },
                    {
                      "file_path": "tests/migrations/test_operations.py",
                      "start_line": 2964,
                      "end_line": 3002
                    },
                    {
                      "file_path": "tests/migrations/test_operations.py",
                      "start_line": 3040,
                      "end_line": 3067
                    },
                    {
                      "file_path": "tests/migrations/test_optimizer.py",
                      "start_line": 1118,
                      "end_line": 1154
                    }
                  ]
                },
                "name": "Action",
                "type": "tool_use"
              }
            ],
            "model": "claude-3-5-sonnet-20241022",
            "role": "assistant",
            "stop_reason": "tool_use",
            "stop_sequence": null,
            "type": "message",
            "usage": {
              "cache_creation_input_tokens": 0,
              "cache_read_input_tokens": 0,
              "input_tokens": 7625,
              "output_tokens": 553
            }
          },
          "usage": {
            "completion_cost": 0.03117,
            "completion_tokens": 553,
            "prompt_tokens": 7625,
            "cached_tokens": 0
          }
        }
      },
      "parent_id": 7
    },
    {
      "node_id": 9,
      "action": {
        "scratch_pad": "After reviewing the code, I can see that:\n\n1. The issue is in the `test_rename_index_unnamed_index` test case where we're dealing with an unnamed index from `index_together`.\n\n2. The problem occurs because:\n   - When moving backwards, it's a no-op (as seen in line 2988-2989)\n   - When moving forwards again, it tries to create the index but fails because it already exists\n   - The test is not properly cleaning up the state between operations\n\n3. We need to modify the test to properly handle the case where:\n   - The index should be properly dropped when moving backwards\n   - The old auto-generated name should be restored\n   - Then it can be safely renamed again when moving forwards\n\n4. Let me look at the RenameIndex operation implementation to understand how it handles unnamed indexes.",
        "query": "RenameIndex operation implementation",
        "category": "implementation",
        "action_args_class": "moatless.actions.semantic_search.SemanticSearchArgs"
      },
      "observation": {
        "message": "Found 15 code sections.\n\nViewed relevant code:\ndjango/db/migrations/operations/models.py\n```\n     1\tfrom django.db import models\n     2\tfrom django.db.migrations.operations.base import Operation\n     3\tfrom django.db.migrations.state import ModelState\n     4\tfrom django.db.migrations.utils import field_references, resolve_relation\n     5\tfrom django.db.models.options import normalize_together\n     6\tfrom django.utils.functional import cached_property\n     7\t\n     8\tfrom .fields import AddField, AlterField, FieldOperation, RemoveField, RenameField\n      # ...\n   877\t\n   878\t\n   879\tclass RenameIndex(IndexOperation):\n   880\t    \"\"\"Rename an index.\"\"\"\n   881\t\n   882\t    def __init__(self, model_name, new_name, old_name=None, old_fields=None):\n   883\t        if not old_name and not old_fields:\n   884\t            raise ValueError(\n   885\t                \"RenameIndex requires one of old_name and old_fields arguments to be \"\n   886\t                \"set.\"\n   887\t            )\n   888\t        if old_name and old_fields:\n   889\t            raise ValueError(\n   890\t                \"RenameIndex.old_name and old_fields are mutually exclusive.\"\n   891\t            )\n   892\t        self.model_name = model_name\n   893\t        self.new_name = new_name\n   894\t        self.old_name = old_name\n   895\t        self.old_fields = old_fields\n   896\t\n   897\t    @cached_property\n   898\t    def old_name_lower(self):\n   899\t        return self.old_name.lower()\n   900\t\n   901\t    @cached_property\n   902\t    def new_name_lower(self):\n   903\t        return self.new_name.lower()\n   904\t\n   905\t    def deconstruct(self):\n   906\t        kwargs = {\n   907\t            \"model_name\": self.model_name,\n   908\t            \"new_name\": self.new_name,\n   909\t        }\n   910\t        if self.old_name:\n   911\t            kwargs[\"old_name\"] = self.old_name\n   912\t        if self.old_fields:\n   913\t            kwargs[\"old_fields\"] = self.old_fields\n   914\t        return (self.__class__.__qualname__, [], kwargs)\n   915\t\n   916\t    def state_forwards(self, app_label, state):\n   917\t        if self.old_fields:\n   918\t            state.add_index(\n   919\t                app_label,\n   920\t                self.model_name_lower,\n   921\t                models.Index(fields=self.old_fields, name=self.new_name),\n   922\t            )\n   923\t            state.remove_model_options(\n   924\t                app_label,\n   925\t                self.model_name_lower,\n   926\t                AlterIndexTogether.option_name,\n   927\t                self.old_fields,\n   928\t            )\n   929\t        else:\n   930\t            state.rename_index(\n   931\t                app_label, self.model_name_lower, self.old_name, self.new_name\n   932\t            )\n   933\t\n   934\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n   935\t        model = to_state.apps.get_model(app_label, self.model_name)\n   936\t        if not self.allow_migrate_model(schema_editor.connection.alias, model):\n   937\t            return\n   938\t\n   939\t        if self.old_fields:\n   940\t            from_model = from_state.apps.get_model(app_label, self.model_name)\n   941\t            columns = [\n   942\t                from_model._meta.get_field(field).column for field in self.old_fields\n   943\t            ]\n   944\t            matching_index_name = schema_editor._constraint_names(\n   945\t                from_model, column_names=columns, index=True\n   946\t            )\n   947\t            if len(matching_index_name) != 1:\n   948\t                raise ValueError(\n   949\t                    \"Found wrong number (%s) of indexes for %s(%s).\"\n   950\t                    % (\n   951\t                        len(matching_index_name),\n   952\t                        from_model._meta.db_table,\n   953\t                        \", \".join(columns),\n   954\t                    )\n   955\t                )\n   956\t            old_index = models.Index(\n   957\t                fields=self.old_fields,\n   958\t                name=matching_index_name[0],\n   959\t            )\n   960\t        else:\n   961\t            from_model_state = from_state.models[app_label, self.model_name_lower]\n   962\t            old_index = from_model_state.get_index_by_name(self.old_name)\n   963\t\n   964\t        to_model_state = to_state.models[app_label, self.model_name_lower]\n   965\t        new_index = to_model_state.get_index_by_name(self.new_name)\n   966\t        schema_editor.rename_index(model, old_index, new_index)\n   967\t\n   968\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n   969\t        if self.old_fields:\n   970\t            # Backward operation with unnamed index is a no-op.\n   971\t            return\n   972\t\n   973\t        self.new_name_lower, self.old_name_lower = (\n   974\t            self.old_name_lower,\n   975\t            self.new_name_lower,\n   976\t        )\n   977\t        self.new_name, self.old_name = self.old_name, self.new_name\n   978\t\n   979\t        self.database_forwards(app_label, schema_editor, from_state, to_state)\n   980\t\n   981\t        self.new_name_lower, self.old_name_lower = (\n   982\t            self.old_name_lower,\n   983\t            self.new_name_lower,\n   984\t        )\n   985\t        self.new_name, self.old_name = self.old_name, self.new_name\n   986\t\n   987\t    def describe(self):\n   988\t        if self.old_name:\n   989\t            return (\n   990\t                f\"Rename index {self.old_name} on {self.model_name} to {self.new_name}\"\n   991\t            )\n   992\t        return (\n   993\t            f\"Rename unnamed index for {self.old_fields} on {self.model_name} to \"\n   994\t            f\"{self.new_name}\"\n   995\t        )\n   996\t\n   997\t    @property\n   998\t    def migration_name_fragment(self):\n   999\t        if self.old_name:\n  1000\t            return \"rename_%s_%s\" % (self.old_name_lower, self.new_name_lower)\n  1001\t        return \"rename_%s_%s_%s\" % (\n  1002\t            self.model_name_lower,\n  1003\t            \"_\".join(self.old_fields),\n  1004\t            self.new_name_lower,\n  1005\t        )\n  1006\t\n  1007\t    def reduce(self, operation, app_label):\n  1008\t        if (\n  1009\t            isinstance(operation, RenameIndex)\n  1010\t            and self.model_name_lower == operation.model_name_lower\n  1011\t            and operation.old_name\n  1012\t            and self.new_name_lower == operation.old_name_lower\n  1013\t        ):\n  1014\t            return [\n  1015\t                RenameIndex(\n  1016\t                    self.model_name,\n  1017\t                    new_name=operation.new_name,\n  1018\t                    old_name=self.old_name,\n  1019\t                    old_fields=self.old_fields,\n  1020\t                )\n  1021\t            ]\n  1022\t        return super().reduce(operation, app_label)\n      # ...\n```\n\n\ndjango/db/backends/base/schema.py\n```\n     1\timport logging\n     2\timport operator\n     3\tfrom datetime import datetime\n     4\t\n     5\tfrom django.db.backends.ddl_references import (\n     6\t    Columns,\n     7\t    Expressions,\n     8\t    ForeignKeyName,\n     9\t    IndexName,\n    10\t    Statement,\n    11\t    Table,\n    12\t)\n    13\tfrom django.db.backends.utils import names_digest, split_identifier\n    14\tfrom django.db.models import Deferrable, Index\n    15\tfrom django.db.models.sql import Query\n    16\tfrom django.db.transaction import TransactionManagementError, atomic\n    17\tfrom django.utils import timezone\n    18\t\n    19\tlogger = logging.getLogger(\"django.db.backends.schema\")\n      # ...\n    72\t\n    73\t\n    74\tclass BaseDatabaseSchemaEditor:\n    75\t    \"\"\"\n    76\t    This class and its subclasses are responsible for emitting schema-changing\n    77\t    statements to the databases - model creation/removal/alteration, field\n    78\t    renaming, index fiddling, and so on.\n    79\t    \"\"\"\n    80\t\n    81\t    # Overrideable SQL templates\n    82\t    sql_create_table = \"CREATE TABLE %(table)s (%(definition)s)\"\n    83\t    sql_rename_table = \"ALTER TABLE %(old_table)s RENAME TO %(new_table)s\"\n    84\t    sql_retablespace_table = \"ALTER TABLE %(table)s SET TABLESPACE %(new_tablespace)s\"\n    85\t    sql_delete_table = \"DROP TABLE %(table)s CASCADE\"\n    86\t\n    87\t    sql_create_column = \"ALTER TABLE %(table)s ADD COLUMN %(column)s %(definition)s\"\n    88\t    sql_alter_column = \"ALTER TABLE %(table)s %(changes)s\"\n    89\t    sql_alter_column_type = \"ALTER COLUMN %(column)s TYPE %(type)s\"\n    90\t    sql_alter_column_null = \"ALTER COLUMN %(column)s DROP NOT NULL\"\n    91\t    sql_alter_column_not_null = \"ALTER COLUMN %(column)s SET NOT NULL\"\n    92\t    sql_alter_column_default = \"ALTER COLUMN %(column)s SET DEFAULT %(default)s\"\n    93\t    sql_alter_column_no_default = \"ALTER COLUMN %(column)s DROP DEFAULT\"\n    94\t    sql_alter_column_no_default_null = sql_alter_column_no_default\n    95\t    sql_alter_column_collate = \"ALTER COLUMN %(column)s TYPE %(type)s%(collation)s\"\n    96\t    sql_delete_column = \"ALTER TABLE %(table)s DROP COLUMN %(column)s CASCADE\"\n    97\t    sql_rename_column = (\n    98\t        \"ALTER TABLE %(table)s RENAME COLUMN %(old_column)s TO %(new_column)s\"\n    99\t    )\n   100\t    sql_update_with_default = (\n   101\t        \"UPDATE %(table)s SET %(column)s = %(default)s WHERE %(column)s IS NULL\"\n   102\t    )\n   103\t\n   104\t    sql_unique_constraint = \"UNIQUE (%(columns)s)%(deferrable)s\"\n   105\t    sql_check_constraint = \"CHECK (%(check)s)\"\n   106\t    sql_delete_constraint = \"ALTER TABLE %(table)s DROP CONSTRAINT %(name)s\"\n   107\t    sql_constraint = \"CONSTRAINT %(name)s %(constraint)s\"\n   108\t\n   109\t    sql_create_check = \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s CHECK (%(check)s)\"\n   110\t    sql_delete_check = sql_delete_constraint\n   111\t\n   112\t    sql_create_unique = (\n   113\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s \"\n   114\t        \"UNIQUE (%(columns)s)%(deferrable)s\"\n   115\t    )\n   116\t    sql_delete_unique = sql_delete_constraint\n   117\t\n   118\t    sql_create_fk = (\n   119\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s FOREIGN KEY (%(column)s) \"\n   120\t        \"REFERENCES %(to_table)s (%(to_column)s)%(deferrable)s\"\n   121\t    )\n   122\t    sql_create_inline_fk = None\n   123\t    sql_create_column_inline_fk = None\n   124\t    sql_delete_fk = sql_delete_constraint\n   125\t\n   126\t    sql_create_index = (\n   127\t        \"CREATE INDEX %(name)s ON %(table)s \"\n   128\t        \"(%(columns)s)%(include)s%(extra)s%(condition)s\"\n   129\t    )\n   130\t    sql_create_unique_index = (\n   131\t        \"CREATE UNIQUE INDEX %(name)s ON %(table)s \"\n   132\t        \"(%(columns)s)%(include)s%(condition)s\"\n   133\t    )\n   134\t    sql_rename_index = \"ALTER INDEX %(old_name)s RENAME TO %(new_name)s\"\n   135\t    sql_delete_index = \"DROP INDEX %(name)s\"\n   136\t\n   137\t    sql_create_pk = (\n   138\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s PRIMARY KEY (%(columns)s)\"\n   139\t    )\n   140\t    sql_delete_pk = sql_delete_constraint\n   141\t\n   142\t    sql_delete_procedure = \"DROP PROCEDURE %(procedure)s\"\n          # ...\n  1374\t\n  1375\t    def _rename_index_sql(self, model, old_name, new_name):\n  1376\t        return Statement(\n  1377\t            self.sql_rename_index,\n  1378\t            table=Table(model._meta.db_table, self.quote_name),\n  1379\t            old_name=self.quote_name(old_name),\n  1380\t            new_name=self.quote_name(new_name),\n  1381\t        )\n          # ...\n```\n",
        "summary": "Found relevant code sections in the search results.",
        "terminal": false,
        "expect_correction": false,
        "properties": {
          "search_hits": [],
          "search_tokens": 1804,
          "new_span_ids": [
            "RenameIndex",
            "RenameIndex.__init__",
            "RenameIndex.old_name_lower",
            "RenameIndex.new_name_lower",
            "RenameIndex.deconstruct",
            "RenameIndex.state_forwards",
            "RenameIndex.database_forwards",
            "RenameIndex.database_backwards",
            "RenameIndex.describe",
            "RenameIndex.migration_name_fragment",
            "RenameIndex.reduce",
            "BaseDatabaseSchemaEditor",
            "BaseDatabaseSchemaEditor._rename_index_sql"
          ]
        },
        "execution_completion": {
          "model": "claude-3-5-sonnet-20241022",
          "input": [
            {
              "role": "user",
              "content": "Search request:\nSearching for code using the query: RenameIndex operation implementation\n\nIdentify the relevant code sections in the search results to use them. \n\n<search_results>\ndjango/db/migrations/operations/models.py\n```\n\n\n\n<span id='imports'>\n     1\tfrom django.db import models\n     2\tfrom django.db.migrations.operations.base import Operation\n     3\tfrom django.db.migrations.state import ModelState\n     4\tfrom django.db.migrations.utils import field_references, resolve_relation\n     5\tfrom django.db.models.options import normalize_together\n     6\tfrom django.utils.functional import cached_property\n     7\t\n     8\tfrom .fields import AddField, AlterField, FieldOperation, RemoveField, RenameField\n      # ...\n\n\n<span id='RenameIndex'>\n   877\t\n   878\t\n   879\tclass RenameIndex(IndexOperation):\n   880\t    \"\"\"Rename an index.\"\"\"\n          # ...\n\n\n<span id='RenameIndex.old_name_lower'>\n   896\t\n   897\t    @cached_property\n   898\t    def old_name_lower(self):\n   899\t        return self.old_name.lower()\n\n\n<span id='RenameIndex.new_name_lower'>\n   900\t\n   901\t    @cached_property\n   902\t    def new_name_lower(self):\n   903\t        return self.new_name.lower()\n\n\n<span id='RenameIndex.deconstruct'>\n   904\t\n   905\t    def deconstruct(self):\n   906\t        kwargs = {\n   907\t            \"model_name\": self.model_name,\n   908\t            \"new_name\": self.new_name,\n   909\t        }\n   910\t        if self.old_name:\n   911\t            kwargs[\"old_name\"] = self.old_name\n   912\t        if self.old_fields:\n   913\t            kwargs[\"old_fields\"] = self.old_fields\n   914\t        return (self.__class__.__qualname__, [], kwargs)\n\n\n<span id='RenameIndex.state_forwards'>\n   915\t\n   916\t    def state_forwards(self, app_label, state):\n   917\t        if self.old_fields:\n   918\t            state.add_index(\n   919\t                app_label,\n   920\t                self.model_name_lower,\n   921\t                models.Index(fields=self.old_fields, name=self.new_name),\n   922\t            )\n   923\t            state.remove_model_options(\n   924\t                app_label,\n   925\t                self.model_name_lower,\n   926\t                AlterIndexTogether.option_name,\n   927\t                self.old_fields,\n   928\t            )\n   929\t        else:\n   930\t            state.rename_index(\n   931\t                app_label, self.model_name_lower, self.old_name, self.new_name\n   932\t            )\n\n\n<span id='RenameIndex.database_forwards'>\n   933\t\n   934\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n   935\t        model = to_state.apps.get_model(app_label, self.model_name)\n   936\t        if not self.allow_migrate_model(schema_editor.connection.alias, model):\n   937\t            return\n   938\t\n   939\t        if self.old_fields:\n   940\t            from_model = from_state.apps.get_model(app_label, self.model_name)\n   941\t            columns = [\n   942\t                from_model._meta.get_field(field).column for field in self.old_fields\n   943\t            ]\n   944\t            matching_index_name = schema_editor._constraint_names(\n   945\t                from_model, column_names=columns, index=True\n   946\t            )\n   947\t            if len(matching_index_name) != 1:\n   948\t                raise ValueError(\n   949\t                    \"Found wrong number (%s) of indexes for %s(%s).\"\n   950\t                    % (\n   951\t                        len(matching_index_name),\n   952\t                        from_model._meta.db_table,\n   953\t                        \", \".join(columns),\n   954\t                    )\n   955\t                )\n   956\t            old_index = models.Index(\n   957\t                fields=self.old_fields,\n   958\t                name=matching_index_name[0],\n   959\t            )\n   960\t        else:\n   961\t            from_model_state = from_state.models[app_label, self.model_name_lower]\n   962\t            old_index = from_model_state.get_index_by_name(self.old_name)\n   963\t\n   964\t        to_model_state = to_state.models[app_label, self.model_name_lower]\n   965\t        new_index = to_model_state.get_index_by_name(self.new_name)\n   966\t        schema_editor.rename_index(model, old_index, new_index)\n\n\n<span id='RenameIndex.database_backwards'>\n   967\t\n   968\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n   969\t        if self.old_fields:\n   970\t            # Backward operation with unnamed index is a no-op.\n   971\t            return\n   972\t\n   973\t        self.new_name_lower, self.old_name_lower = (\n   974\t            self.old_name_lower,\n   975\t            self.new_name_lower,\n   976\t        )\n   977\t        self.new_name, self.old_name = self.old_name, self.new_name\n   978\t\n   979\t        self.database_forwards(app_label, schema_editor, from_state, to_state)\n   980\t\n   981\t        self.new_name_lower, self.old_name_lower = (\n   982\t            self.old_name_lower,\n   983\t            self.new_name_lower,\n   984\t        )\n   985\t        self.new_name, self.old_name = self.old_name, self.new_name\n\n\n<span id='RenameIndex.describe'>\n   986\t\n   987\t    def describe(self):\n   988\t        if self.old_name:\n   989\t            return (\n   990\t                f\"Rename index {self.old_name} on {self.model_name} to {self.new_name}\"\n   991\t            )\n   992\t        return (\n   993\t            f\"Rename unnamed index for {self.old_fields} on {self.model_name} to \"\n   994\t            f\"{self.new_name}\"\n   995\t        )\n\n\n<span id='RenameIndex.migration_name_fragment'>\n   996\t\n   997\t    @property\n   998\t    def migration_name_fragment(self):\n   999\t        if self.old_name:\n  1000\t            return \"rename_%s_%s\" % (self.old_name_lower, self.new_name_lower)\n  1001\t        return \"rename_%s_%s_%s\" % (\n  1002\t            self.model_name_lower,\n  1003\t            \"_\".join(self.old_fields),\n  1004\t            self.new_name_lower,\n  1005\t        )\n\n\n<span id='RenameIndex.reduce'>\n  1006\t\n  1007\t    def reduce(self, operation, app_label):\n  1008\t        if (\n  1009\t            isinstance(operation, RenameIndex)\n  1010\t            and self.model_name_lower == operation.model_name_lower\n  1011\t            and operation.old_name\n  1012\t            and self.new_name_lower == operation.old_name_lower\n  1013\t        ):\n  1014\t            return [\n  1015\t                RenameIndex(\n  1016\t                    self.model_name,\n  1017\t                    new_name=operation.new_name,\n  1018\t                    old_name=self.old_name,\n  1019\t                    old_fields=self.old_fields,\n  1020\t                )\n  1021\t            ]\n  1022\t        return super().reduce(operation, app_label)\n      # ...\n```\n\n\ndjango/db/backends/base/schema.py\n```\n\n\n\n<span id='imports'>\n     1\timport logging\n     2\timport operator\n     3\tfrom datetime import datetime\n     4\t\n     5\tfrom django.db.backends.ddl_references import (\n     6\t    Columns,\n     7\t    Expressions,\n     8\t    ForeignKeyName,\n     9\t    IndexName,\n    10\t    Statement,\n    11\t    Table,\n    12\t)\n    13\tfrom django.db.backends.utils import names_digest, split_identifier\n    14\tfrom django.db.models import Deferrable, Index\n    15\tfrom django.db.models.sql import Query\n    16\tfrom django.db.transaction import TransactionManagementError, atomic\n    17\tfrom django.utils import timezone\n    18\t\n    19\tlogger = logging.getLogger(\"django.db.backends.schema\")\n      # ...\n\n\n<span id='BaseDatabaseSchemaEditor'>\n    72\t\n    73\t\n    74\tclass BaseDatabaseSchemaEditor:\n    75\t    \"\"\"\n    76\t    This class and its subclasses are responsible for emitting schema-changing\n    77\t    statements to the databases - model creation/removal/alteration, field\n    78\t    renaming, index fiddling, and so on.\n    79\t    \"\"\"\n    80\t\n    81\t    # Overrideable SQL templates\n    82\t    sql_create_table = \"CREATE TABLE %(table)s (%(definition)s)\"\n    83\t    sql_rename_table = \"ALTER TABLE %(old_table)s RENAME TO %(new_table)s\"\n    84\t    sql_retablespace_table = \"ALTER TABLE %(table)s SET TABLESPACE %(new_tablespace)s\"\n    85\t    sql_delete_table = \"DROP TABLE %(table)s CASCADE\"\n    86\t\n    87\t    sql_create_column = \"ALTER TABLE %(table)s ADD COLUMN %(column)s %(definition)s\"\n    88\t    sql_alter_column = \"ALTER TABLE %(table)s %(changes)s\"\n    89\t    sql_alter_column_type = \"ALTER COLUMN %(column)s TYPE %(type)s\"\n    90\t    sql_alter_column_null = \"ALTER COLUMN %(column)s DROP NOT NULL\"\n    91\t    sql_alter_column_not_null = \"ALTER COLUMN %(column)s SET NOT NULL\"\n    92\t    sql_alter_column_default = \"ALTER COLUMN %(column)s SET DEFAULT %(default)s\"\n    93\t    sql_alter_column_no_default = \"ALTER COLUMN %(column)s DROP DEFAULT\"\n    94\t    sql_alter_column_no_default_null = sql_alter_column_no_default\n    95\t    sql_alter_column_collate = \"ALTER COLUMN %(column)s TYPE %(type)s%(collation)s\"\n    96\t    sql_delete_column = \"ALTER TABLE %(table)s DROP COLUMN %(column)s CASCADE\"\n    97\t    sql_rename_column = (\n    98\t        \"ALTER TABLE %(table)s RENAME COLUMN %(old_column)s TO %(new_column)s\"\n    99\t    )\n   100\t    sql_update_with_default = (\n   101\t        \"UPDATE %(table)s SET %(column)s = %(default)s WHERE %(column)s IS NULL\"\n   102\t    )\n   103\t\n   104\t    sql_unique_constraint = \"UNIQUE (%(columns)s)%(deferrable)s\"\n   105\t    sql_check_constraint = \"CHECK (%(check)s)\"\n   106\t    sql_delete_constraint = \"ALTER TABLE %(table)s DROP CONSTRAINT %(name)s\"\n   107\t    sql_constraint = \"CONSTRAINT %(name)s %(constraint)s\"\n   108\t\n   109\t    sql_create_check = \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s CHECK (%(check)s)\"\n   110\t    sql_delete_check = sql_delete_constraint\n   111\t\n   112\t    sql_create_unique = (\n   113\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s \"\n   114\t        \"UNIQUE (%(columns)s)%(deferrable)s\"\n   115\t    )\n   116\t    sql_delete_unique = sql_delete_constraint\n   117\t\n   118\t    sql_create_fk = (\n   119\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s FOREIGN KEY (%(column)s) \"\n   120\t        \"REFERENCES %(to_table)s (%(to_column)s)%(deferrable)s\"\n   121\t    )\n   122\t    sql_create_inline_fk = None\n   123\t    sql_create_column_inline_fk = None\n   124\t    sql_delete_fk = sql_delete_constraint\n   125\t\n   126\t    sql_create_index = (\n   127\t        \"CREATE INDEX %(name)s ON %(table)s \"\n   128\t        \"(%(columns)s)%(include)s%(extra)s%(condition)s\"\n   129\t    )\n   130\t    sql_create_unique_index = (\n   131\t        \"CREATE UNIQUE INDEX %(name)s ON %(table)s \"\n   132\t        \"(%(columns)s)%(include)s%(condition)s\"\n   133\t    )\n   134\t    sql_rename_index = \"ALTER INDEX %(old_name)s RENAME TO %(new_name)s\"\n   135\t    sql_delete_index = \"DROP INDEX %(name)s\"\n   136\t\n   137\t    sql_create_pk = (\n   138\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s PRIMARY KEY (%(columns)s)\"\n   139\t    )\n   140\t    sql_delete_pk = sql_delete_constraint\n   141\t\n   142\t    sql_delete_procedure = \"DROP PROCEDURE %(procedure)s\"\n\n\n<span id='BaseDatabaseSchemaEditor.__init__'>\n   143\t\n   144\t    def __init__(self, connection, collect_sql=False, atomic=True):\n   145\t        self.connection = connection\n   146\t        self.collect_sql = collect_sql\n   147\t        if self.collect_sql:\n   148\t            self.collected_sql = []\n   149\t        self.atomic_migration = self.connection.features.can_rollback_ddl and atomic\n   150\t\n   151\t    # State-managing methods\n          # ...\n\n\n<span id='BaseDatabaseSchemaEditor._rename_index_sql'>\n  1374\t\n  1375\t    def _rename_index_sql(self, model, old_name, new_name):\n  1376\t        return Statement(\n  1377\t            self.sql_rename_index,\n  1378\t            table=Table(model._meta.db_table, self.quote_name),\n  1379\t            old_name=self.quote_name(old_name),\n  1380\t            new_name=self.quote_name(new_name),\n  1381\t        )\n          # ...\n```\n\n</search_result>\n"
            }
          ],
          "response": {
            "id": "msg_01MHySavf7ZRoDGp6qxGpmtv",
            "content": [
              {
                "text": "I'll help identify the relevant code sections for the RenameIndex operation implementation. Let me analyze the search results and mark the relevant sections.\n\nThe search results show the complete implementation of the RenameIndex operation in Django's migration system. The most relevant sections are in the django/db/migrations/operations/models.py file, which contains the main RenameIndex class implementation, and django/db/backends/base/schema.py which contains the supporting SQL generation code.",
                "type": "text"
              },
              {
                "id": "toolu_01KzQ4EZjttBquLniGCabMJV",
                "input": {
                  "scratch_pad": "The RenameIndex operation implementation consists of several key components:\n\n1. Main RenameIndex class (lines 879-1022) which includes:\n   - Core implementation of index renaming operation\n   - Methods for state management, database operations, and operation description\n   - Helper properties and reduction logic\n\n2. Supporting SQL generation code in BaseDatabaseSchemaEditor:\n   - SQL template for renaming indexes (line 134)\n   - Implementation of _rename_index_sql method (lines 1374-1381)\n\nKey methods in RenameIndex class:\n- state_forwards: Handles state changes\n- database_forwards: Implements forward migration\n- database_backwards: Implements backward migration\n- describe: Provides human-readable description\n- reduce: Handles operation optimization\n- deconstruct: Serializes the operation\n\nThese sections together provide the complete implementation of index renaming functionality in Django's migration system.",
                  "identified_spans": [
                    {
                      "file_path": "django/db/migrations/operations/models.py",
                      "start_line": 879,
                      "end_line": 1022
                    },
                    {
                      "file_path": "django/db/backends/base/schema.py",
                      "start_line": 134,
                      "end_line": 134
                    },
                    {
                      "file_path": "django/db/backends/base/schema.py",
                      "start_line": 1374,
                      "end_line": 1381
                    }
                  ]
                },
                "name": "Action",
                "type": "tool_use"
              }
            ],
            "model": "claude-3-5-sonnet-20241022",
            "role": "assistant",
            "stop_reason": "tool_use",
            "stop_sequence": null,
            "type": "message",
            "usage": {
              "cache_creation_input_tokens": 0,
              "cache_read_input_tokens": 0,
              "input_tokens": 4668,
              "output_tokens": 515
            }
          },
          "usage": {
            "completion_cost": 0.021729000000000002,
            "completion_tokens": 515,
            "prompt_tokens": 4668,
            "cached_tokens": 0
          }
        }
      },
      "file_context": {
        "max_tokens": 8000,
        "files": [
          {
            "file_path": "tests/migrations/test_operations.py",
            "spans": [
              {
                "span_id": "imports",
                "pinned": false
              },
              {
                "span_id": "OperationTests",
                "pinned": false
              },
              {
                "span_id": "OperationTests.test_rename_index",
                "pinned": false
              },
              {
                "span_id": "OperationTests.test_rename_index_arguments",
                "pinned": false
              },
              {
                "span_id": "OperationTests.test_rename_index_unnamed_index",
                "pinned": false
              },
              {
                "span_id": "OperationTests.test_rename_index_state_forwards",
                "pinned": false
              },
              {
                "span_id": "OperationTests.test_rename_index_state_forwards_unnamed_index",
                "pinned": false
              }
            ],
            "show_all_spans": false,
            "patch": null
          },
          {
            "file_path": "tests/migrations/test_optimizer.py",
            "spans": [
              {
                "span_id": "imports",
                "pinned": false
              },
              {
                "span_id": "OptimizerTests",
                "pinned": false
              },
              {
                "span_id": "OptimizerTests.test_rename_index",
                "pinned": false
              }
            ],
            "show_all_spans": false,
            "patch": null
          },
          {
            "file_path": "django/db/migrations/operations/models.py",
            "spans": [
              {
                "span_id": "imports",
                "pinned": false
              },
              {
                "span_id": "RenameIndex",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.__init__",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.old_name_lower",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.new_name_lower",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.deconstruct",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.state_forwards",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.database_forwards",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.database_backwards",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.describe",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.migration_name_fragment",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.reduce",
                "pinned": false
              }
            ],
            "show_all_spans": false,
            "patch": null
          },
          {
            "file_path": "django/db/backends/base/schema.py",
            "spans": [
              {
                "span_id": "imports",
                "pinned": false
              },
              {
                "span_id": "BaseDatabaseSchemaEditor",
                "pinned": false
              },
              {
                "span_id": "BaseDatabaseSchemaEditor._rename_index_sql",
                "pinned": false
              }
            ],
            "show_all_spans": false,
            "patch": null
          }
        ]
      },
      "completions": {
        "build_action": {
          "model": "claude-3-5-sonnet-20241022",
          "input": [
            {
              "role": "user",
              "content": "<task>\nRenameIndex() crashes when unnamed index is moving backward and forward.\nDescription\n\t\nRenameIndex() should restore the old auto-generated name when an unnamed index for unique_together is moving backward. Now re-applying RenameIndex() crashes. For example:\ntests/migrations/test_operations.py\ndiff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex cfd28b1b39..c0a55023bb 100644\n\t\t\t\t\t\n\t\t\t\t\t a\n\t\t\t\t \n\t\t\t\t\t\n\t\t\t\t\t b\n\t\t\t\t \n class OperationTests(OperationTestBase):\u00a0\n29882988\u00a0 \u00a0 \u00a0 \u00a0 with connection.schema_editor() as editor, self.assertNumQueries(0):\n29892989\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 operation.database_backwards(app_label, editor, new_state, project_state)\n29902990\u00a0 \u00a0 \u00a0 \u00a0 self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n\u00a02991\u00a0 \u00a0 \u00a0 \u00a0 # Re-apply renaming.\n\u00a02992\u00a0 \u00a0 \u00a0 \u00a0 with connection.schema_editor() as editor:\n\u00a02993\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 operation.database_forwards(app_label, editor, project_state, new_state)\n\u00a02994\u00a0 \u00a0 \u00a0 \u00a0 self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n29912995\u00a0 \u00a0 \u00a0 \u00a0 # Deconstruction.\n29922996\u00a0 \u00a0 \u00a0 \u00a0 definition = operation.deconstruct()\n29932997\u00a0 \u00a0 \u00a0 \u00a0 self.assertEqual(definition[0], \"RenameIndex\")\ncrashes on PostgreSQL:\ndjango.db.utils.ProgrammingError: relation \"new_pony_test_idx\" already exists\n\n</task>"
            },
            {
              "role": "assistant",
              "content": [
                {
                  "type": "text",
                  "text": "<thoughts>\n1. First, I need to understand the context better by:\n   - Looking at the test file to see the full test case\n   - Finding the RenameIndex operation implementation\n   - Understanding how index naming works in this context\n\n2. Let's start by viewing the test file to see the full test case context.\n</thoughts>"
                },
                {
                  "id": "call_8635dcc7",
                  "input": {
                    "files": [
                      {
                        "file_path": "tests/migrations/test_operations.py",
                        "start_line": null,
                        "end_line": null,
                        "span_ids": []
                      }
                    ]
                  },
                  "type": "tool_use",
                  "name": "ViewCode"
                }
              ]
            },
            {
              "role": "user",
              "content": [
                {
                  "tool_use_id": "call_8635dcc7",
                  "content": "<observation>\n\n</observation>",
                  "type": "tool_result",
                  "cache_control": {
                    "type": "ephemeral"
                  }
                }
              ]
            },
            {
              "role": "assistant",
              "content": [
                {
                  "type": "text",
                  "text": "<thoughts>\nIt seems I need to use a different approach to find the relevant test code. Let me use SemanticSearch to find tests related to RenameIndex operations.\n</thoughts>"
                },
                {
                  "id": "call_ab3070ba",
                  "input": {
                    "file_pattern": null,
                    "query": "test RenameIndex operation migration",
                    "category": "test"
                  },
                  "type": "tool_use",
                  "name": "SemanticSearch",
                  "cache_control": {
                    "type": "ephemeral"
                  }
                }
              ]
            },
            {
              "role": "user",
              "content": [
                {
                  "tool_use_id": "call_ab3070ba",
                  "content": "<observation>\nFound 15 code sections.\n\nViewed relevant code:\ntests/migrations/test_operations.py\n```\n     1\tfrom django.core.exceptions import FieldDoesNotExist\n     2\tfrom django.db import IntegrityError, connection, migrations, models, transaction\n     3\tfrom django.db.migrations.migration import Migration\n     4\tfrom django.db.migrations.operations.fields import FieldOperation\n     5\tfrom django.db.migrations.state import ModelState, ProjectState\n     6\tfrom django.db.models.functions import Abs\n     7\tfrom django.db.transaction import atomic\n     8\tfrom django.test import SimpleTestCase, override_settings, skipUnlessDBFeature\n     9\tfrom django.test.utils import CaptureQueriesContext\n    10\t\n    11\tfrom .models import FoodManager, FoodQuerySet, UnicodeModel\n    12\tfrom .test_base import OperationTestBase\n      # ...\n    17\t\n    18\t\n    19\tclass OperationTests(OperationTestBase):\n    20\t    \"\"\"\n    21\t    Tests running the operations and making sure they do what they say they do.\n    22\t    Each test looks at their state changing, and then their database operation -\n    23\t    both forwards and backwards.\n    24\t    \"\"\"\n          # ...\n  2902\t\n  2903\t    def test_rename_index(self):\n  2904\t        app_label = \"test_rnin\"\n  2905\t        project_state = self.set_up_test_model(app_label, index=True)\n  2906\t        table_name = app_label + \"_pony\"\n  2907\t        self.assertIndexNameExists(table_name, \"pony_pink_idx\")\n  2908\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2909\t        operation = migrations.RenameIndex(\n  2910\t            \"Pony\", new_name=\"new_pony_test_idx\", old_name=\"pony_pink_idx\"\n  2911\t        )\n  2912\t        self.assertEqual(\n  2913\t            operation.describe(),\n  2914\t            \"Rename index pony_pink_idx on Pony to new_pony_test_idx\",\n  2915\t        )\n  2916\t        self.assertEqual(\n  2917\t            operation.migration_name_fragment,\n  2918\t            \"rename_pony_pink_idx_new_pony_test_idx\",\n  2919\t        )\n  2920\t\n  2921\t        new_state = project_state.clone()\n  2922\t        operation.state_forwards(app_label, new_state)\n  2923\t        # Rename index.\n  2924\t        expected_queries = 1 if connection.features.can_rename_index else 2\n  2925\t        with connection.schema_editor() as editor, self.assertNumQueries(\n  2926\t            expected_queries\n  2927\t        ):\n  2928\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2929\t        self.assertIndexNameNotExists(table_name, \"pony_pink_idx\")\n  2930\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2931\t        # Reversal.\n  2932\t        with connection.schema_editor() as editor, self.assertNumQueries(\n  2933\t            expected_queries\n  2934\t        ):\n  2935\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2936\t        self.assertIndexNameExists(table_name, \"pony_pink_idx\")\n  2937\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2938\t        # Deconstruction.\n  2939\t        definition = operation.deconstruct()\n  2940\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2941\t        self.assertEqual(definition[1], [])\n  2942\t        self.assertEqual(\n  2943\t            definition[2],\n  2944\t            {\n  2945\t                \"model_name\": \"Pony\",\n  2946\t                \"old_name\": \"pony_pink_idx\",\n  2947\t                \"new_name\": \"new_pony_test_idx\",\n  2948\t            },\n  2949\t        )\n  2950\t\n  2951\t    def test_rename_index_arguments(self):\n  2952\t        msg = \"RenameIndex.old_name and old_fields are mutually exclusive.\"\n  2953\t        with self.assertRaisesMessage(ValueError, msg):\n  2954\t            migrations.RenameIndex(\n  2955\t                \"Pony\",\n  2956\t                new_name=\"new_idx_name\",\n  2957\t                old_name=\"old_idx_name\",\n  2958\t                old_fields=(\"weight\", \"pink\"),\n  2959\t            )\n  2960\t        msg = \"RenameIndex requires one of old_name and old_fields arguments to be set.\"\n  2961\t        with self.assertRaisesMessage(ValueError, msg):\n  2962\t            migrations.RenameIndex(\"Pony\", new_name=\"new_idx_name\")\n  2963\t\n  2964\t    def test_rename_index_unnamed_index(self):\n  2965\t        app_label = \"test_rninui\"\n  2966\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  2967\t        table_name = app_label + \"_pony\"\n  2968\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2969\t        operation = migrations.RenameIndex(\n  2970\t            \"Pony\", new_name=\"new_pony_test_idx\", old_fields=(\"weight\", \"pink\")\n  2971\t        )\n  2972\t        self.assertEqual(\n  2973\t            operation.describe(),\n  2974\t            \"Rename unnamed index for ('weight', 'pink') on Pony to new_pony_test_idx\",\n  2975\t        )\n  2976\t        self.assertEqual(\n  2977\t            operation.migration_name_fragment,\n  2978\t            \"rename_pony_weight_pink_new_pony_test_idx\",\n  2979\t        )\n  2980\t\n  2981\t        new_state = project_state.clone()\n  2982\t        operation.state_forwards(app_label, new_state)\n  2983\t        # Rename index.\n  2984\t        with connection.schema_editor() as editor:\n  2985\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2986\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2987\t        # Reverse is a no-op.\n  2988\t        with connection.schema_editor() as editor, self.assertNumQueries(0):\n  2989\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2990\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2991\t        # Deconstruction.\n  2992\t        definition = operation.deconstruct()\n  2993\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2994\t        self.assertEqual(definition[1], [])\n  2995\t        self.assertEqual(\n  2996\t            definition[2],\n  2997\t            {\n  2998\t                \"model_name\": \"Pony\",\n  2999\t                \"new_name\": \"new_pony_test_idx\",\n  3000\t                \"old_fields\": (\"weight\", \"pink\"),\n  3001\t            },\n  3002\t        )\n          # ...\n  3039\t\n  3040\t    def test_rename_index_state_forwards(self):\n  3041\t        app_label = \"test_rnidsf\"\n  3042\t        project_state = self.set_up_test_model(app_label, index=True)\n  3043\t        old_model = project_state.apps.get_model(app_label, \"Pony\")\n  3044\t        new_state = project_state.clone()\n  3045\t\n  3046\t        operation = migrations.RenameIndex(\n  3047\t            \"Pony\", new_name=\"new_pony_pink_idx\", old_name=\"pony_pink_idx\"\n  3048\t        )\n  3049\t        operation.state_forwards(app_label, new_state)\n  3050\t        new_model = new_state.apps.get_model(app_label, \"Pony\")\n  3051\t        self.assertIsNot(old_model, new_model)\n  3052\t        self.assertEqual(new_model._meta.indexes[0].name, \"new_pony_pink_idx\")\n  3053\t\n  3054\t    def test_rename_index_state_forwards_unnamed_index(self):\n  3055\t        app_label = \"test_rnidsfui\"\n  3056\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  3057\t        old_model = project_state.apps.get_model(app_label, \"Pony\")\n  3058\t        new_state = project_state.clone()\n  3059\t\n  3060\t        operation = migrations.RenameIndex(\n  3061\t            \"Pony\", new_name=\"new_pony_pink_idx\", old_fields=(\"weight\", \"pink\")\n  3062\t        )\n  3063\t        operation.state_forwards(app_label, new_state)\n  3064\t        new_model = new_state.apps.get_model(app_label, \"Pony\")\n  3065\t        self.assertIsNot(old_model, new_model)\n  3066\t        self.assertEqual(new_model._meta.index_together, tuple())\n  3067\t        self.assertEqual(new_model._meta.indexes[0].name, \"new_pony_pink_idx\")\n          # ...\n      # ...\n```\n\n\ntests/migrations/test_optimizer.py\n```\n     1\tfrom django.db import migrations, models\n     2\tfrom django.db.migrations import operations\n     3\tfrom django.db.migrations.optimizer import MigrationOptimizer\n     4\tfrom django.db.migrations.serializer import serializer_factory\n     5\tfrom django.test import SimpleTestCase\n     6\t\n     7\tfrom .models import EmptyManager, UnicodeModel\n     8\t\n     9\t\n    10\tclass OptimizerTests(SimpleTestCase):\n    11\t    \"\"\"\n    12\t    Tests the migration autodetector.\n    13\t    \"\"\"\n          # ...\n  1117\t\n  1118\t    def test_rename_index(self):\n  1119\t        self.assertOptimizesTo(\n  1120\t            [\n  1121\t                migrations.RenameIndex(\n  1122\t                    \"Pony\", new_name=\"mid_name\", old_fields=(\"weight\", \"pink\")\n  1123\t                ),\n  1124\t                migrations.RenameIndex(\n  1125\t                    \"Pony\", new_name=\"new_name\", old_name=\"mid_name\"\n  1126\t                ),\n  1127\t            ],\n  1128\t            [\n  1129\t                migrations.RenameIndex(\n  1130\t                    \"Pony\", new_name=\"new_name\", old_fields=(\"weight\", \"pink\")\n  1131\t                ),\n  1132\t            ],\n  1133\t        )\n  1134\t        self.assertOptimizesTo(\n  1135\t            [\n  1136\t                migrations.RenameIndex(\n  1137\t                    \"Pony\", new_name=\"mid_name\", old_name=\"old_name\"\n  1138\t                ),\n  1139\t                migrations.RenameIndex(\n  1140\t                    \"Pony\", new_name=\"new_name\", old_name=\"mid_name\"\n  1141\t                ),\n  1142\t            ],\n  1143\t            [migrations.RenameIndex(\"Pony\", new_name=\"new_name\", old_name=\"old_name\")],\n  1144\t        )\n  1145\t        self.assertDoesNotOptimize(\n  1146\t            [\n  1147\t                migrations.RenameIndex(\n  1148\t                    \"Pony\", new_name=\"mid_name\", old_name=\"old_name\"\n  1149\t                ),\n  1150\t                migrations.RenameIndex(\n  1151\t                    \"Pony\", new_name=\"new_name\", old_fields=(\"weight\", \"pink\")\n  1152\t                ),\n  1153\t            ]\n  1154\t        )\n```\n\n</observation>",
                  "type": "tool_result",
                  "cache_control": {
                    "type": "ephemeral"
                  }
                }
              ]
            }
          ],
          "response": {
            "id": "msg_01Y2XzcoMpRtCDLBddohoPXZ",
            "content": [
              {
                "text": "<thoughts>\nAfter reviewing the code, I can see that:\n\n1. The issue is in the `test_rename_index_unnamed_index` test case where we're dealing with an unnamed index from `index_together`.\n\n2. The problem occurs because:\n   - When moving backwards, it's a no-op (as seen in line 2988-2989)\n   - When moving forwards again, it tries to create the index but fails because it already exists\n   - The test is not properly cleaning up the state between operations\n\n3. We need to modify the test to properly handle the case where:\n   - The index should be properly dropped when moving backwards\n   - The old auto-generated name should be restored\n   - Then it can be safely renamed again when moving forwards\n\n4. Let me look at the RenameIndex operation implementation to understand how it handles unnamed indexes.\n</thoughts>",
                "type": "text"
              },
              {
                "id": "toolu_019we9art86WffM8PkdkRTgZ",
                "input": {
                  "query": "RenameIndex operation implementation",
                  "category": "implementation"
                },
                "name": "SemanticSearch",
                "type": "tool_use"
              }
            ],
            "model": "claude-3-5-sonnet-20241022",
            "role": "assistant",
            "stop_reason": "tool_use",
            "stop_sequence": null,
            "type": "message",
            "usage": {
              "cache_creation_input_tokens": 3421,
              "cache_read_input_tokens": 4683,
              "input_tokens": 4,
              "output_tokens": 273
            }
          },
          "usage": {
            "completion_cost": 0.014369999999999999,
            "completion_tokens": 273,
            "prompt_tokens": 3425,
            "cached_tokens": 4683
          }
        },
        "execute_action": {
          "model": "claude-3-5-sonnet-20241022",
          "input": [
            {
              "role": "user",
              "content": "Search request:\nSearching for code using the query: RenameIndex operation implementation\n\nIdentify the relevant code sections in the search results to use them. \n\n<search_results>\ndjango/db/migrations/operations/models.py\n```\n\n\n\n<span id='imports'>\n     1\tfrom django.db import models\n     2\tfrom django.db.migrations.operations.base import Operation\n     3\tfrom django.db.migrations.state import ModelState\n     4\tfrom django.db.migrations.utils import field_references, resolve_relation\n     5\tfrom django.db.models.options import normalize_together\n     6\tfrom django.utils.functional import cached_property\n     7\t\n     8\tfrom .fields import AddField, AlterField, FieldOperation, RemoveField, RenameField\n      # ...\n\n\n<span id='RenameIndex'>\n   877\t\n   878\t\n   879\tclass RenameIndex(IndexOperation):\n   880\t    \"\"\"Rename an index.\"\"\"\n          # ...\n\n\n<span id='RenameIndex.old_name_lower'>\n   896\t\n   897\t    @cached_property\n   898\t    def old_name_lower(self):\n   899\t        return self.old_name.lower()\n\n\n<span id='RenameIndex.new_name_lower'>\n   900\t\n   901\t    @cached_property\n   902\t    def new_name_lower(self):\n   903\t        return self.new_name.lower()\n\n\n<span id='RenameIndex.deconstruct'>\n   904\t\n   905\t    def deconstruct(self):\n   906\t        kwargs = {\n   907\t            \"model_name\": self.model_name,\n   908\t            \"new_name\": self.new_name,\n   909\t        }\n   910\t        if self.old_name:\n   911\t            kwargs[\"old_name\"] = self.old_name\n   912\t        if self.old_fields:\n   913\t            kwargs[\"old_fields\"] = self.old_fields\n   914\t        return (self.__class__.__qualname__, [], kwargs)\n\n\n<span id='RenameIndex.state_forwards'>\n   915\t\n   916\t    def state_forwards(self, app_label, state):\n   917\t        if self.old_fields:\n   918\t            state.add_index(\n   919\t                app_label,\n   920\t                self.model_name_lower,\n   921\t                models.Index(fields=self.old_fields, name=self.new_name),\n   922\t            )\n   923\t            state.remove_model_options(\n   924\t                app_label,\n   925\t                self.model_name_lower,\n   926\t                AlterIndexTogether.option_name,\n   927\t                self.old_fields,\n   928\t            )\n   929\t        else:\n   930\t            state.rename_index(\n   931\t                app_label, self.model_name_lower, self.old_name, self.new_name\n   932\t            )\n\n\n<span id='RenameIndex.database_forwards'>\n   933\t\n   934\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n   935\t        model = to_state.apps.get_model(app_label, self.model_name)\n   936\t        if not self.allow_migrate_model(schema_editor.connection.alias, model):\n   937\t            return\n   938\t\n   939\t        if self.old_fields:\n   940\t            from_model = from_state.apps.get_model(app_label, self.model_name)\n   941\t            columns = [\n   942\t                from_model._meta.get_field(field).column for field in self.old_fields\n   943\t            ]\n   944\t            matching_index_name = schema_editor._constraint_names(\n   945\t                from_model, column_names=columns, index=True\n   946\t            )\n   947\t            if len(matching_index_name) != 1:\n   948\t                raise ValueError(\n   949\t                    \"Found wrong number (%s) of indexes for %s(%s).\"\n   950\t                    % (\n   951\t                        len(matching_index_name),\n   952\t                        from_model._meta.db_table,\n   953\t                        \", \".join(columns),\n   954\t                    )\n   955\t                )\n   956\t            old_index = models.Index(\n   957\t                fields=self.old_fields,\n   958\t                name=matching_index_name[0],\n   959\t            )\n   960\t        else:\n   961\t            from_model_state = from_state.models[app_label, self.model_name_lower]\n   962\t            old_index = from_model_state.get_index_by_name(self.old_name)\n   963\t\n   964\t        to_model_state = to_state.models[app_label, self.model_name_lower]\n   965\t        new_index = to_model_state.get_index_by_name(self.new_name)\n   966\t        schema_editor.rename_index(model, old_index, new_index)\n\n\n<span id='RenameIndex.database_backwards'>\n   967\t\n   968\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n   969\t        if self.old_fields:\n   970\t            # Backward operation with unnamed index is a no-op.\n   971\t            return\n   972\t\n   973\t        self.new_name_lower, self.old_name_lower = (\n   974\t            self.old_name_lower,\n   975\t            self.new_name_lower,\n   976\t        )\n   977\t        self.new_name, self.old_name = self.old_name, self.new_name\n   978\t\n   979\t        self.database_forwards(app_label, schema_editor, from_state, to_state)\n   980\t\n   981\t        self.new_name_lower, self.old_name_lower = (\n   982\t            self.old_name_lower,\n   983\t            self.new_name_lower,\n   984\t        )\n   985\t        self.new_name, self.old_name = self.old_name, self.new_name\n\n\n<span id='RenameIndex.describe'>\n   986\t\n   987\t    def describe(self):\n   988\t        if self.old_name:\n   989\t            return (\n   990\t                f\"Rename index {self.old_name} on {self.model_name} to {self.new_name}\"\n   991\t            )\n   992\t        return (\n   993\t            f\"Rename unnamed index for {self.old_fields} on {self.model_name} to \"\n   994\t            f\"{self.new_name}\"\n   995\t        )\n\n\n<span id='RenameIndex.migration_name_fragment'>\n   996\t\n   997\t    @property\n   998\t    def migration_name_fragment(self):\n   999\t        if self.old_name:\n  1000\t            return \"rename_%s_%s\" % (self.old_name_lower, self.new_name_lower)\n  1001\t        return \"rename_%s_%s_%s\" % (\n  1002\t            self.model_name_lower,\n  1003\t            \"_\".join(self.old_fields),\n  1004\t            self.new_name_lower,\n  1005\t        )\n\n\n<span id='RenameIndex.reduce'>\n  1006\t\n  1007\t    def reduce(self, operation, app_label):\n  1008\t        if (\n  1009\t            isinstance(operation, RenameIndex)\n  1010\t            and self.model_name_lower == operation.model_name_lower\n  1011\t            and operation.old_name\n  1012\t            and self.new_name_lower == operation.old_name_lower\n  1013\t        ):\n  1014\t            return [\n  1015\t                RenameIndex(\n  1016\t                    self.model_name,\n  1017\t                    new_name=operation.new_name,\n  1018\t                    old_name=self.old_name,\n  1019\t                    old_fields=self.old_fields,\n  1020\t                )\n  1021\t            ]\n  1022\t        return super().reduce(operation, app_label)\n      # ...\n```\n\n\ndjango/db/backends/base/schema.py\n```\n\n\n\n<span id='imports'>\n     1\timport logging\n     2\timport operator\n     3\tfrom datetime import datetime\n     4\t\n     5\tfrom django.db.backends.ddl_references import (\n     6\t    Columns,\n     7\t    Expressions,\n     8\t    ForeignKeyName,\n     9\t    IndexName,\n    10\t    Statement,\n    11\t    Table,\n    12\t)\n    13\tfrom django.db.backends.utils import names_digest, split_identifier\n    14\tfrom django.db.models import Deferrable, Index\n    15\tfrom django.db.models.sql import Query\n    16\tfrom django.db.transaction import TransactionManagementError, atomic\n    17\tfrom django.utils import timezone\n    18\t\n    19\tlogger = logging.getLogger(\"django.db.backends.schema\")\n      # ...\n\n\n<span id='BaseDatabaseSchemaEditor'>\n    72\t\n    73\t\n    74\tclass BaseDatabaseSchemaEditor:\n    75\t    \"\"\"\n    76\t    This class and its subclasses are responsible for emitting schema-changing\n    77\t    statements to the databases - model creation/removal/alteration, field\n    78\t    renaming, index fiddling, and so on.\n    79\t    \"\"\"\n    80\t\n    81\t    # Overrideable SQL templates\n    82\t    sql_create_table = \"CREATE TABLE %(table)s (%(definition)s)\"\n    83\t    sql_rename_table = \"ALTER TABLE %(old_table)s RENAME TO %(new_table)s\"\n    84\t    sql_retablespace_table = \"ALTER TABLE %(table)s SET TABLESPACE %(new_tablespace)s\"\n    85\t    sql_delete_table = \"DROP TABLE %(table)s CASCADE\"\n    86\t\n    87\t    sql_create_column = \"ALTER TABLE %(table)s ADD COLUMN %(column)s %(definition)s\"\n    88\t    sql_alter_column = \"ALTER TABLE %(table)s %(changes)s\"\n    89\t    sql_alter_column_type = \"ALTER COLUMN %(column)s TYPE %(type)s\"\n    90\t    sql_alter_column_null = \"ALTER COLUMN %(column)s DROP NOT NULL\"\n    91\t    sql_alter_column_not_null = \"ALTER COLUMN %(column)s SET NOT NULL\"\n    92\t    sql_alter_column_default = \"ALTER COLUMN %(column)s SET DEFAULT %(default)s\"\n    93\t    sql_alter_column_no_default = \"ALTER COLUMN %(column)s DROP DEFAULT\"\n    94\t    sql_alter_column_no_default_null = sql_alter_column_no_default\n    95\t    sql_alter_column_collate = \"ALTER COLUMN %(column)s TYPE %(type)s%(collation)s\"\n    96\t    sql_delete_column = \"ALTER TABLE %(table)s DROP COLUMN %(column)s CASCADE\"\n    97\t    sql_rename_column = (\n    98\t        \"ALTER TABLE %(table)s RENAME COLUMN %(old_column)s TO %(new_column)s\"\n    99\t    )\n   100\t    sql_update_with_default = (\n   101\t        \"UPDATE %(table)s SET %(column)s = %(default)s WHERE %(column)s IS NULL\"\n   102\t    )\n   103\t\n   104\t    sql_unique_constraint = \"UNIQUE (%(columns)s)%(deferrable)s\"\n   105\t    sql_check_constraint = \"CHECK (%(check)s)\"\n   106\t    sql_delete_constraint = \"ALTER TABLE %(table)s DROP CONSTRAINT %(name)s\"\n   107\t    sql_constraint = \"CONSTRAINT %(name)s %(constraint)s\"\n   108\t\n   109\t    sql_create_check = \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s CHECK (%(check)s)\"\n   110\t    sql_delete_check = sql_delete_constraint\n   111\t\n   112\t    sql_create_unique = (\n   113\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s \"\n   114\t        \"UNIQUE (%(columns)s)%(deferrable)s\"\n   115\t    )\n   116\t    sql_delete_unique = sql_delete_constraint\n   117\t\n   118\t    sql_create_fk = (\n   119\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s FOREIGN KEY (%(column)s) \"\n   120\t        \"REFERENCES %(to_table)s (%(to_column)s)%(deferrable)s\"\n   121\t    )\n   122\t    sql_create_inline_fk = None\n   123\t    sql_create_column_inline_fk = None\n   124\t    sql_delete_fk = sql_delete_constraint\n   125\t\n   126\t    sql_create_index = (\n   127\t        \"CREATE INDEX %(name)s ON %(table)s \"\n   128\t        \"(%(columns)s)%(include)s%(extra)s%(condition)s\"\n   129\t    )\n   130\t    sql_create_unique_index = (\n   131\t        \"CREATE UNIQUE INDEX %(name)s ON %(table)s \"\n   132\t        \"(%(columns)s)%(include)s%(condition)s\"\n   133\t    )\n   134\t    sql_rename_index = \"ALTER INDEX %(old_name)s RENAME TO %(new_name)s\"\n   135\t    sql_delete_index = \"DROP INDEX %(name)s\"\n   136\t\n   137\t    sql_create_pk = (\n   138\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s PRIMARY KEY (%(columns)s)\"\n   139\t    )\n   140\t    sql_delete_pk = sql_delete_constraint\n   141\t\n   142\t    sql_delete_procedure = \"DROP PROCEDURE %(procedure)s\"\n\n\n<span id='BaseDatabaseSchemaEditor.__init__'>\n   143\t\n   144\t    def __init__(self, connection, collect_sql=False, atomic=True):\n   145\t        self.connection = connection\n   146\t        self.collect_sql = collect_sql\n   147\t        if self.collect_sql:\n   148\t            self.collected_sql = []\n   149\t        self.atomic_migration = self.connection.features.can_rollback_ddl and atomic\n   150\t\n   151\t    # State-managing methods\n          # ...\n\n\n<span id='BaseDatabaseSchemaEditor._rename_index_sql'>\n  1374\t\n  1375\t    def _rename_index_sql(self, model, old_name, new_name):\n  1376\t        return Statement(\n  1377\t            self.sql_rename_index,\n  1378\t            table=Table(model._meta.db_table, self.quote_name),\n  1379\t            old_name=self.quote_name(old_name),\n  1380\t            new_name=self.quote_name(new_name),\n  1381\t        )\n          # ...\n```\n\n</search_result>\n"
            }
          ],
          "response": {
            "id": "msg_01MHySavf7ZRoDGp6qxGpmtv",
            "content": [
              {
                "text": "I'll help identify the relevant code sections for the RenameIndex operation implementation. Let me analyze the search results and mark the relevant sections.\n\nThe search results show the complete implementation of the RenameIndex operation in Django's migration system. The most relevant sections are in the django/db/migrations/operations/models.py file, which contains the main RenameIndex class implementation, and django/db/backends/base/schema.py which contains the supporting SQL generation code.",
                "type": "text"
              },
              {
                "id": "toolu_01KzQ4EZjttBquLniGCabMJV",
                "input": {
                  "scratch_pad": "The RenameIndex operation implementation consists of several key components:\n\n1. Main RenameIndex class (lines 879-1022) which includes:\n   - Core implementation of index renaming operation\n   - Methods for state management, database operations, and operation description\n   - Helper properties and reduction logic\n\n2. Supporting SQL generation code in BaseDatabaseSchemaEditor:\n   - SQL template for renaming indexes (line 134)\n   - Implementation of _rename_index_sql method (lines 1374-1381)\n\nKey methods in RenameIndex class:\n- state_forwards: Handles state changes\n- database_forwards: Implements forward migration\n- database_backwards: Implements backward migration\n- describe: Provides human-readable description\n- reduce: Handles operation optimization\n- deconstruct: Serializes the operation\n\nThese sections together provide the complete implementation of index renaming functionality in Django's migration system.",
                  "identified_spans": [
                    {
                      "file_path": "django/db/migrations/operations/models.py",
                      "start_line": 879,
                      "end_line": 1022
                    },
                    {
                      "file_path": "django/db/backends/base/schema.py",
                      "start_line": 134,
                      "end_line": 134
                    },
                    {
                      "file_path": "django/db/backends/base/schema.py",
                      "start_line": 1374,
                      "end_line": 1381
                    }
                  ]
                },
                "name": "Action",
                "type": "tool_use"
              }
            ],
            "model": "claude-3-5-sonnet-20241022",
            "role": "assistant",
            "stop_reason": "tool_use",
            "stop_sequence": null,
            "type": "message",
            "usage": {
              "cache_creation_input_tokens": 0,
              "cache_read_input_tokens": 0,
              "input_tokens": 4668,
              "output_tokens": 515
            }
          },
          "usage": {
            "completion_cost": 0.021729000000000002,
            "completion_tokens": 515,
            "prompt_tokens": 4668,
            "cached_tokens": 0
          }
        }
      },
      "possible_actions": [
        "SemanticSearch",
        "FindClass",
        "FindFunction",
        "FindCodeSnippet",
        "ViewCode",
        "ClaudeEditTool"
      ],
      "output": {
        "message": "Found 15 code sections.\n\nViewed relevant code:\ndjango/db/migrations/operations/models.py\n```\n     1\tfrom django.db import models\n     2\tfrom django.db.migrations.operations.base import Operation\n     3\tfrom django.db.migrations.state import ModelState\n     4\tfrom django.db.migrations.utils import field_references, resolve_relation\n     5\tfrom django.db.models.options import normalize_together\n     6\tfrom django.utils.functional import cached_property\n     7\t\n     8\tfrom .fields import AddField, AlterField, FieldOperation, RemoveField, RenameField\n      # ...\n   877\t\n   878\t\n   879\tclass RenameIndex(IndexOperation):\n   880\t    \"\"\"Rename an index.\"\"\"\n   881\t\n   882\t    def __init__(self, model_name, new_name, old_name=None, old_fields=None):\n   883\t        if not old_name and not old_fields:\n   884\t            raise ValueError(\n   885\t                \"RenameIndex requires one of old_name and old_fields arguments to be \"\n   886\t                \"set.\"\n   887\t            )\n   888\t        if old_name and old_fields:\n   889\t            raise ValueError(\n   890\t                \"RenameIndex.old_name and old_fields are mutually exclusive.\"\n   891\t            )\n   892\t        self.model_name = model_name\n   893\t        self.new_name = new_name\n   894\t        self.old_name = old_name\n   895\t        self.old_fields = old_fields\n   896\t\n   897\t    @cached_property\n   898\t    def old_name_lower(self):\n   899\t        return self.old_name.lower()\n   900\t\n   901\t    @cached_property\n   902\t    def new_name_lower(self):\n   903\t        return self.new_name.lower()\n   904\t\n   905\t    def deconstruct(self):\n   906\t        kwargs = {\n   907\t            \"model_name\": self.model_name,\n   908\t            \"new_name\": self.new_name,\n   909\t        }\n   910\t        if self.old_name:\n   911\t            kwargs[\"old_name\"] = self.old_name\n   912\t        if self.old_fields:\n   913\t            kwargs[\"old_fields\"] = self.old_fields\n   914\t        return (self.__class__.__qualname__, [], kwargs)\n   915\t\n   916\t    def state_forwards(self, app_label, state):\n   917\t        if self.old_fields:\n   918\t            state.add_index(\n   919\t                app_label,\n   920\t                self.model_name_lower,\n   921\t                models.Index(fields=self.old_fields, name=self.new_name),\n   922\t            )\n   923\t            state.remove_model_options(\n   924\t                app_label,\n   925\t                self.model_name_lower,\n   926\t                AlterIndexTogether.option_name,\n   927\t                self.old_fields,\n   928\t            )\n   929\t        else:\n   930\t            state.rename_index(\n   931\t                app_label, self.model_name_lower, self.old_name, self.new_name\n   932\t            )\n   933\t\n   934\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n   935\t        model = to_state.apps.get_model(app_label, self.model_name)\n   936\t        if not self.allow_migrate_model(schema_editor.connection.alias, model):\n   937\t            return\n   938\t\n   939\t        if self.old_fields:\n   940\t            from_model = from_state.apps.get_model(app_label, self.model_name)\n   941\t            columns = [\n   942\t                from_model._meta.get_field(field).column for field in self.old_fields\n   943\t            ]\n   944\t            matching_index_name = schema_editor._constraint_names(\n   945\t                from_model, column_names=columns, index=True\n   946\t            )\n   947\t            if len(matching_index_name) != 1:\n   948\t                raise ValueError(\n   949\t                    \"Found wrong number (%s) of indexes for %s(%s).\"\n   950\t                    % (\n   951\t                        len(matching_index_name),\n   952\t                        from_model._meta.db_table,\n   953\t                        \", \".join(columns),\n   954\t                    )\n   955\t                )\n   956\t            old_index = models.Index(\n   957\t                fields=self.old_fields,\n   958\t                name=matching_index_name[0],\n   959\t            )\n   960\t        else:\n   961\t            from_model_state = from_state.models[app_label, self.model_name_lower]\n   962\t            old_index = from_model_state.get_index_by_name(self.old_name)\n   963\t\n   964\t        to_model_state = to_state.models[app_label, self.model_name_lower]\n   965\t        new_index = to_model_state.get_index_by_name(self.new_name)\n   966\t        schema_editor.rename_index(model, old_index, new_index)\n   967\t\n   968\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n   969\t        if self.old_fields:\n   970\t            # Backward operation with unnamed index is a no-op.\n   971\t            return\n   972\t\n   973\t        self.new_name_lower, self.old_name_lower = (\n   974\t            self.old_name_lower,\n   975\t            self.new_name_lower,\n   976\t        )\n   977\t        self.new_name, self.old_name = self.old_name, self.new_name\n   978\t\n   979\t        self.database_forwards(app_label, schema_editor, from_state, to_state)\n   980\t\n   981\t        self.new_name_lower, self.old_name_lower = (\n   982\t            self.old_name_lower,\n   983\t            self.new_name_lower,\n   984\t        )\n   985\t        self.new_name, self.old_name = self.old_name, self.new_name\n   986\t\n   987\t    def describe(self):\n   988\t        if self.old_name:\n   989\t            return (\n   990\t                f\"Rename index {self.old_name} on {self.model_name} to {self.new_name}\"\n   991\t            )\n   992\t        return (\n   993\t            f\"Rename unnamed index for {self.old_fields} on {self.model_name} to \"\n   994\t            f\"{self.new_name}\"\n   995\t        )\n   996\t\n   997\t    @property\n   998\t    def migration_name_fragment(self):\n   999\t        if self.old_name:\n  1000\t            return \"rename_%s_%s\" % (self.old_name_lower, self.new_name_lower)\n  1001\t        return \"rename_%s_%s_%s\" % (\n  1002\t            self.model_name_lower,\n  1003\t            \"_\".join(self.old_fields),\n  1004\t            self.new_name_lower,\n  1005\t        )\n  1006\t\n  1007\t    def reduce(self, operation, app_label):\n  1008\t        if (\n  1009\t            isinstance(operation, RenameIndex)\n  1010\t            and self.model_name_lower == operation.model_name_lower\n  1011\t            and operation.old_name\n  1012\t            and self.new_name_lower == operation.old_name_lower\n  1013\t        ):\n  1014\t            return [\n  1015\t                RenameIndex(\n  1016\t                    self.model_name,\n  1017\t                    new_name=operation.new_name,\n  1018\t                    old_name=self.old_name,\n  1019\t                    old_fields=self.old_fields,\n  1020\t                )\n  1021\t            ]\n  1022\t        return super().reduce(operation, app_label)\n      # ...\n```\n\n\ndjango/db/backends/base/schema.py\n```\n     1\timport logging\n     2\timport operator\n     3\tfrom datetime import datetime\n     4\t\n     5\tfrom django.db.backends.ddl_references import (\n     6\t    Columns,\n     7\t    Expressions,\n     8\t    ForeignKeyName,\n     9\t    IndexName,\n    10\t    Statement,\n    11\t    Table,\n    12\t)\n    13\tfrom django.db.backends.utils import names_digest, split_identifier\n    14\tfrom django.db.models import Deferrable, Index\n    15\tfrom django.db.models.sql import Query\n    16\tfrom django.db.transaction import TransactionManagementError, atomic\n    17\tfrom django.utils import timezone\n    18\t\n    19\tlogger = logging.getLogger(\"django.db.backends.schema\")\n      # ...\n    72\t\n    73\t\n    74\tclass BaseDatabaseSchemaEditor:\n    75\t    \"\"\"\n    76\t    This class and its subclasses are responsible for emitting schema-changing\n    77\t    statements to the databases - model creation/removal/alteration, field\n    78\t    renaming, index fiddling, and so on.\n    79\t    \"\"\"\n    80\t\n    81\t    # Overrideable SQL templates\n    82\t    sql_create_table = \"CREATE TABLE %(table)s (%(definition)s)\"\n    83\t    sql_rename_table = \"ALTER TABLE %(old_table)s RENAME TO %(new_table)s\"\n    84\t    sql_retablespace_table = \"ALTER TABLE %(table)s SET TABLESPACE %(new_tablespace)s\"\n    85\t    sql_delete_table = \"DROP TABLE %(table)s CASCADE\"\n    86\t\n    87\t    sql_create_column = \"ALTER TABLE %(table)s ADD COLUMN %(column)s %(definition)s\"\n    88\t    sql_alter_column = \"ALTER TABLE %(table)s %(changes)s\"\n    89\t    sql_alter_column_type = \"ALTER COLUMN %(column)s TYPE %(type)s\"\n    90\t    sql_alter_column_null = \"ALTER COLUMN %(column)s DROP NOT NULL\"\n    91\t    sql_alter_column_not_null = \"ALTER COLUMN %(column)s SET NOT NULL\"\n    92\t    sql_alter_column_default = \"ALTER COLUMN %(column)s SET DEFAULT %(default)s\"\n    93\t    sql_alter_column_no_default = \"ALTER COLUMN %(column)s DROP DEFAULT\"\n    94\t    sql_alter_column_no_default_null = sql_alter_column_no_default\n    95\t    sql_alter_column_collate = \"ALTER COLUMN %(column)s TYPE %(type)s%(collation)s\"\n    96\t    sql_delete_column = \"ALTER TABLE %(table)s DROP COLUMN %(column)s CASCADE\"\n    97\t    sql_rename_column = (\n    98\t        \"ALTER TABLE %(table)s RENAME COLUMN %(old_column)s TO %(new_column)s\"\n    99\t    )\n   100\t    sql_update_with_default = (\n   101\t        \"UPDATE %(table)s SET %(column)s = %(default)s WHERE %(column)s IS NULL\"\n   102\t    )\n   103\t\n   104\t    sql_unique_constraint = \"UNIQUE (%(columns)s)%(deferrable)s\"\n   105\t    sql_check_constraint = \"CHECK (%(check)s)\"\n   106\t    sql_delete_constraint = \"ALTER TABLE %(table)s DROP CONSTRAINT %(name)s\"\n   107\t    sql_constraint = \"CONSTRAINT %(name)s %(constraint)s\"\n   108\t\n   109\t    sql_create_check = \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s CHECK (%(check)s)\"\n   110\t    sql_delete_check = sql_delete_constraint\n   111\t\n   112\t    sql_create_unique = (\n   113\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s \"\n   114\t        \"UNIQUE (%(columns)s)%(deferrable)s\"\n   115\t    )\n   116\t    sql_delete_unique = sql_delete_constraint\n   117\t\n   118\t    sql_create_fk = (\n   119\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s FOREIGN KEY (%(column)s) \"\n   120\t        \"REFERENCES %(to_table)s (%(to_column)s)%(deferrable)s\"\n   121\t    )\n   122\t    sql_create_inline_fk = None\n   123\t    sql_create_column_inline_fk = None\n   124\t    sql_delete_fk = sql_delete_constraint\n   125\t\n   126\t    sql_create_index = (\n   127\t        \"CREATE INDEX %(name)s ON %(table)s \"\n   128\t        \"(%(columns)s)%(include)s%(extra)s%(condition)s\"\n   129\t    )\n   130\t    sql_create_unique_index = (\n   131\t        \"CREATE UNIQUE INDEX %(name)s ON %(table)s \"\n   132\t        \"(%(columns)s)%(include)s%(condition)s\"\n   133\t    )\n   134\t    sql_rename_index = \"ALTER INDEX %(old_name)s RENAME TO %(new_name)s\"\n   135\t    sql_delete_index = \"DROP INDEX %(name)s\"\n   136\t\n   137\t    sql_create_pk = (\n   138\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s PRIMARY KEY (%(columns)s)\"\n   139\t    )\n   140\t    sql_delete_pk = sql_delete_constraint\n   141\t\n   142\t    sql_delete_procedure = \"DROP PROCEDURE %(procedure)s\"\n          # ...\n  1374\t\n  1375\t    def _rename_index_sql(self, model, old_name, new_name):\n  1376\t        return Statement(\n  1377\t            self.sql_rename_index,\n  1378\t            table=Table(model._meta.db_table, self.quote_name),\n  1379\t            old_name=self.quote_name(old_name),\n  1380\t            new_name=self.quote_name(new_name),\n  1381\t        )\n          # ...\n```\n",
        "summary": "Found relevant code sections in the search results.",
        "terminal": false,
        "expect_correction": false,
        "properties": {
          "search_hits": [],
          "search_tokens": 1804,
          "new_span_ids": [
            "RenameIndex",
            "RenameIndex.__init__",
            "RenameIndex.old_name_lower",
            "RenameIndex.new_name_lower",
            "RenameIndex.deconstruct",
            "RenameIndex.state_forwards",
            "RenameIndex.database_forwards",
            "RenameIndex.database_backwards",
            "RenameIndex.describe",
            "RenameIndex.migration_name_fragment",
            "RenameIndex.reduce",
            "BaseDatabaseSchemaEditor",
            "BaseDatabaseSchemaEditor._rename_index_sql"
          ]
        },
        "execution_completion": {
          "model": "claude-3-5-sonnet-20241022",
          "input": [
            {
              "role": "user",
              "content": "Search request:\nSearching for code using the query: RenameIndex operation implementation\n\nIdentify the relevant code sections in the search results to use them. \n\n<search_results>\ndjango/db/migrations/operations/models.py\n```\n\n\n\n<span id='imports'>\n     1\tfrom django.db import models\n     2\tfrom django.db.migrations.operations.base import Operation\n     3\tfrom django.db.migrations.state import ModelState\n     4\tfrom django.db.migrations.utils import field_references, resolve_relation\n     5\tfrom django.db.models.options import normalize_together\n     6\tfrom django.utils.functional import cached_property\n     7\t\n     8\tfrom .fields import AddField, AlterField, FieldOperation, RemoveField, RenameField\n      # ...\n\n\n<span id='RenameIndex'>\n   877\t\n   878\t\n   879\tclass RenameIndex(IndexOperation):\n   880\t    \"\"\"Rename an index.\"\"\"\n          # ...\n\n\n<span id='RenameIndex.old_name_lower'>\n   896\t\n   897\t    @cached_property\n   898\t    def old_name_lower(self):\n   899\t        return self.old_name.lower()\n\n\n<span id='RenameIndex.new_name_lower'>\n   900\t\n   901\t    @cached_property\n   902\t    def new_name_lower(self):\n   903\t        return self.new_name.lower()\n\n\n<span id='RenameIndex.deconstruct'>\n   904\t\n   905\t    def deconstruct(self):\n   906\t        kwargs = {\n   907\t            \"model_name\": self.model_name,\n   908\t            \"new_name\": self.new_name,\n   909\t        }\n   910\t        if self.old_name:\n   911\t            kwargs[\"old_name\"] = self.old_name\n   912\t        if self.old_fields:\n   913\t            kwargs[\"old_fields\"] = self.old_fields\n   914\t        return (self.__class__.__qualname__, [], kwargs)\n\n\n<span id='RenameIndex.state_forwards'>\n   915\t\n   916\t    def state_forwards(self, app_label, state):\n   917\t        if self.old_fields:\n   918\t            state.add_index(\n   919\t                app_label,\n   920\t                self.model_name_lower,\n   921\t                models.Index(fields=self.old_fields, name=self.new_name),\n   922\t            )\n   923\t            state.remove_model_options(\n   924\t                app_label,\n   925\t                self.model_name_lower,\n   926\t                AlterIndexTogether.option_name,\n   927\t                self.old_fields,\n   928\t            )\n   929\t        else:\n   930\t            state.rename_index(\n   931\t                app_label, self.model_name_lower, self.old_name, self.new_name\n   932\t            )\n\n\n<span id='RenameIndex.database_forwards'>\n   933\t\n   934\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n   935\t        model = to_state.apps.get_model(app_label, self.model_name)\n   936\t        if not self.allow_migrate_model(schema_editor.connection.alias, model):\n   937\t            return\n   938\t\n   939\t        if self.old_fields:\n   940\t            from_model = from_state.apps.get_model(app_label, self.model_name)\n   941\t            columns = [\n   942\t                from_model._meta.get_field(field).column for field in self.old_fields\n   943\t            ]\n   944\t            matching_index_name = schema_editor._constraint_names(\n   945\t                from_model, column_names=columns, index=True\n   946\t            )\n   947\t            if len(matching_index_name) != 1:\n   948\t                raise ValueError(\n   949\t                    \"Found wrong number (%s) of indexes for %s(%s).\"\n   950\t                    % (\n   951\t                        len(matching_index_name),\n   952\t                        from_model._meta.db_table,\n   953\t                        \", \".join(columns),\n   954\t                    )\n   955\t                )\n   956\t            old_index = models.Index(\n   957\t                fields=self.old_fields,\n   958\t                name=matching_index_name[0],\n   959\t            )\n   960\t        else:\n   961\t            from_model_state = from_state.models[app_label, self.model_name_lower]\n   962\t            old_index = from_model_state.get_index_by_name(self.old_name)\n   963\t\n   964\t        to_model_state = to_state.models[app_label, self.model_name_lower]\n   965\t        new_index = to_model_state.get_index_by_name(self.new_name)\n   966\t        schema_editor.rename_index(model, old_index, new_index)\n\n\n<span id='RenameIndex.database_backwards'>\n   967\t\n   968\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n   969\t        if self.old_fields:\n   970\t            # Backward operation with unnamed index is a no-op.\n   971\t            return\n   972\t\n   973\t        self.new_name_lower, self.old_name_lower = (\n   974\t            self.old_name_lower,\n   975\t            self.new_name_lower,\n   976\t        )\n   977\t        self.new_name, self.old_name = self.old_name, self.new_name\n   978\t\n   979\t        self.database_forwards(app_label, schema_editor, from_state, to_state)\n   980\t\n   981\t        self.new_name_lower, self.old_name_lower = (\n   982\t            self.old_name_lower,\n   983\t            self.new_name_lower,\n   984\t        )\n   985\t        self.new_name, self.old_name = self.old_name, self.new_name\n\n\n<span id='RenameIndex.describe'>\n   986\t\n   987\t    def describe(self):\n   988\t        if self.old_name:\n   989\t            return (\n   990\t                f\"Rename index {self.old_name} on {self.model_name} to {self.new_name}\"\n   991\t            )\n   992\t        return (\n   993\t            f\"Rename unnamed index for {self.old_fields} on {self.model_name} to \"\n   994\t            f\"{self.new_name}\"\n   995\t        )\n\n\n<span id='RenameIndex.migration_name_fragment'>\n   996\t\n   997\t    @property\n   998\t    def migration_name_fragment(self):\n   999\t        if self.old_name:\n  1000\t            return \"rename_%s_%s\" % (self.old_name_lower, self.new_name_lower)\n  1001\t        return \"rename_%s_%s_%s\" % (\n  1002\t            self.model_name_lower,\n  1003\t            \"_\".join(self.old_fields),\n  1004\t            self.new_name_lower,\n  1005\t        )\n\n\n<span id='RenameIndex.reduce'>\n  1006\t\n  1007\t    def reduce(self, operation, app_label):\n  1008\t        if (\n  1009\t            isinstance(operation, RenameIndex)\n  1010\t            and self.model_name_lower == operation.model_name_lower\n  1011\t            and operation.old_name\n  1012\t            and self.new_name_lower == operation.old_name_lower\n  1013\t        ):\n  1014\t            return [\n  1015\t                RenameIndex(\n  1016\t                    self.model_name,\n  1017\t                    new_name=operation.new_name,\n  1018\t                    old_name=self.old_name,\n  1019\t                    old_fields=self.old_fields,\n  1020\t                )\n  1021\t            ]\n  1022\t        return super().reduce(operation, app_label)\n      # ...\n```\n\n\ndjango/db/backends/base/schema.py\n```\n\n\n\n<span id='imports'>\n     1\timport logging\n     2\timport operator\n     3\tfrom datetime import datetime\n     4\t\n     5\tfrom django.db.backends.ddl_references import (\n     6\t    Columns,\n     7\t    Expressions,\n     8\t    ForeignKeyName,\n     9\t    IndexName,\n    10\t    Statement,\n    11\t    Table,\n    12\t)\n    13\tfrom django.db.backends.utils import names_digest, split_identifier\n    14\tfrom django.db.models import Deferrable, Index\n    15\tfrom django.db.models.sql import Query\n    16\tfrom django.db.transaction import TransactionManagementError, atomic\n    17\tfrom django.utils import timezone\n    18\t\n    19\tlogger = logging.getLogger(\"django.db.backends.schema\")\n      # ...\n\n\n<span id='BaseDatabaseSchemaEditor'>\n    72\t\n    73\t\n    74\tclass BaseDatabaseSchemaEditor:\n    75\t    \"\"\"\n    76\t    This class and its subclasses are responsible for emitting schema-changing\n    77\t    statements to the databases - model creation/removal/alteration, field\n    78\t    renaming, index fiddling, and so on.\n    79\t    \"\"\"\n    80\t\n    81\t    # Overrideable SQL templates\n    82\t    sql_create_table = \"CREATE TABLE %(table)s (%(definition)s)\"\n    83\t    sql_rename_table = \"ALTER TABLE %(old_table)s RENAME TO %(new_table)s\"\n    84\t    sql_retablespace_table = \"ALTER TABLE %(table)s SET TABLESPACE %(new_tablespace)s\"\n    85\t    sql_delete_table = \"DROP TABLE %(table)s CASCADE\"\n    86\t\n    87\t    sql_create_column = \"ALTER TABLE %(table)s ADD COLUMN %(column)s %(definition)s\"\n    88\t    sql_alter_column = \"ALTER TABLE %(table)s %(changes)s\"\n    89\t    sql_alter_column_type = \"ALTER COLUMN %(column)s TYPE %(type)s\"\n    90\t    sql_alter_column_null = \"ALTER COLUMN %(column)s DROP NOT NULL\"\n    91\t    sql_alter_column_not_null = \"ALTER COLUMN %(column)s SET NOT NULL\"\n    92\t    sql_alter_column_default = \"ALTER COLUMN %(column)s SET DEFAULT %(default)s\"\n    93\t    sql_alter_column_no_default = \"ALTER COLUMN %(column)s DROP DEFAULT\"\n    94\t    sql_alter_column_no_default_null = sql_alter_column_no_default\n    95\t    sql_alter_column_collate = \"ALTER COLUMN %(column)s TYPE %(type)s%(collation)s\"\n    96\t    sql_delete_column = \"ALTER TABLE %(table)s DROP COLUMN %(column)s CASCADE\"\n    97\t    sql_rename_column = (\n    98\t        \"ALTER TABLE %(table)s RENAME COLUMN %(old_column)s TO %(new_column)s\"\n    99\t    )\n   100\t    sql_update_with_default = (\n   101\t        \"UPDATE %(table)s SET %(column)s = %(default)s WHERE %(column)s IS NULL\"\n   102\t    )\n   103\t\n   104\t    sql_unique_constraint = \"UNIQUE (%(columns)s)%(deferrable)s\"\n   105\t    sql_check_constraint = \"CHECK (%(check)s)\"\n   106\t    sql_delete_constraint = \"ALTER TABLE %(table)s DROP CONSTRAINT %(name)s\"\n   107\t    sql_constraint = \"CONSTRAINT %(name)s %(constraint)s\"\n   108\t\n   109\t    sql_create_check = \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s CHECK (%(check)s)\"\n   110\t    sql_delete_check = sql_delete_constraint\n   111\t\n   112\t    sql_create_unique = (\n   113\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s \"\n   114\t        \"UNIQUE (%(columns)s)%(deferrable)s\"\n   115\t    )\n   116\t    sql_delete_unique = sql_delete_constraint\n   117\t\n   118\t    sql_create_fk = (\n   119\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s FOREIGN KEY (%(column)s) \"\n   120\t        \"REFERENCES %(to_table)s (%(to_column)s)%(deferrable)s\"\n   121\t    )\n   122\t    sql_create_inline_fk = None\n   123\t    sql_create_column_inline_fk = None\n   124\t    sql_delete_fk = sql_delete_constraint\n   125\t\n   126\t    sql_create_index = (\n   127\t        \"CREATE INDEX %(name)s ON %(table)s \"\n   128\t        \"(%(columns)s)%(include)s%(extra)s%(condition)s\"\n   129\t    )\n   130\t    sql_create_unique_index = (\n   131\t        \"CREATE UNIQUE INDEX %(name)s ON %(table)s \"\n   132\t        \"(%(columns)s)%(include)s%(condition)s\"\n   133\t    )\n   134\t    sql_rename_index = \"ALTER INDEX %(old_name)s RENAME TO %(new_name)s\"\n   135\t    sql_delete_index = \"DROP INDEX %(name)s\"\n   136\t\n   137\t    sql_create_pk = (\n   138\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s PRIMARY KEY (%(columns)s)\"\n   139\t    )\n   140\t    sql_delete_pk = sql_delete_constraint\n   141\t\n   142\t    sql_delete_procedure = \"DROP PROCEDURE %(procedure)s\"\n\n\n<span id='BaseDatabaseSchemaEditor.__init__'>\n   143\t\n   144\t    def __init__(self, connection, collect_sql=False, atomic=True):\n   145\t        self.connection = connection\n   146\t        self.collect_sql = collect_sql\n   147\t        if self.collect_sql:\n   148\t            self.collected_sql = []\n   149\t        self.atomic_migration = self.connection.features.can_rollback_ddl and atomic\n   150\t\n   151\t    # State-managing methods\n          # ...\n\n\n<span id='BaseDatabaseSchemaEditor._rename_index_sql'>\n  1374\t\n  1375\t    def _rename_index_sql(self, model, old_name, new_name):\n  1376\t        return Statement(\n  1377\t            self.sql_rename_index,\n  1378\t            table=Table(model._meta.db_table, self.quote_name),\n  1379\t            old_name=self.quote_name(old_name),\n  1380\t            new_name=self.quote_name(new_name),\n  1381\t        )\n          # ...\n```\n\n</search_result>\n"
            }
          ],
          "response": {
            "id": "msg_01MHySavf7ZRoDGp6qxGpmtv",
            "content": [
              {
                "text": "I'll help identify the relevant code sections for the RenameIndex operation implementation. Let me analyze the search results and mark the relevant sections.\n\nThe search results show the complete implementation of the RenameIndex operation in Django's migration system. The most relevant sections are in the django/db/migrations/operations/models.py file, which contains the main RenameIndex class implementation, and django/db/backends/base/schema.py which contains the supporting SQL generation code.",
                "type": "text"
              },
              {
                "id": "toolu_01KzQ4EZjttBquLniGCabMJV",
                "input": {
                  "scratch_pad": "The RenameIndex operation implementation consists of several key components:\n\n1. Main RenameIndex class (lines 879-1022) which includes:\n   - Core implementation of index renaming operation\n   - Methods for state management, database operations, and operation description\n   - Helper properties and reduction logic\n\n2. Supporting SQL generation code in BaseDatabaseSchemaEditor:\n   - SQL template for renaming indexes (line 134)\n   - Implementation of _rename_index_sql method (lines 1374-1381)\n\nKey methods in RenameIndex class:\n- state_forwards: Handles state changes\n- database_forwards: Implements forward migration\n- database_backwards: Implements backward migration\n- describe: Provides human-readable description\n- reduce: Handles operation optimization\n- deconstruct: Serializes the operation\n\nThese sections together provide the complete implementation of index renaming functionality in Django's migration system.",
                  "identified_spans": [
                    {
                      "file_path": "django/db/migrations/operations/models.py",
                      "start_line": 879,
                      "end_line": 1022
                    },
                    {
                      "file_path": "django/db/backends/base/schema.py",
                      "start_line": 134,
                      "end_line": 134
                    },
                    {
                      "file_path": "django/db/backends/base/schema.py",
                      "start_line": 1374,
                      "end_line": 1381
                    }
                  ]
                },
                "name": "Action",
                "type": "tool_use"
              }
            ],
            "model": "claude-3-5-sonnet-20241022",
            "role": "assistant",
            "stop_reason": "tool_use",
            "stop_sequence": null,
            "type": "message",
            "usage": {
              "cache_creation_input_tokens": 0,
              "cache_read_input_tokens": 0,
              "input_tokens": 4668,
              "output_tokens": 515
            }
          },
          "usage": {
            "completion_cost": 0.021729000000000002,
            "completion_tokens": 515,
            "prompt_tokens": 4668,
            "cached_tokens": 0
          }
        }
      },
      "parent_id": 8
    },
    {
      "node_id": 10,
      "action": {
        "scratch_pad": "After reviewing both the test and implementation code, I can see that:\n\n1. The issue is in the RenameIndex operation's handling of unnamed indexes:\n   - In `database_backwards`, it has a special case for `old_fields` that makes it a no-op (lines 969-971)\n   - This means when moving backwards, it doesn't actually restore the original auto-generated index name\n   - When moving forwards again, it tries to create a new index but the old one still exists\n\n2. The fix needs to:\n   - Remove the no-op behavior for unnamed indexes in backwards operation\n   - Properly handle the index renaming in both directions\n   - Ensure the auto-generated name is restored when moving backwards\n\n3. Let's modify the RenameIndex operation to properly handle unnamed indexes in both directions.\n\n4. The changes needed are:\n   - Remove the no-op early return for old_fields in database_backwards\n   - Ensure proper index name handling in both directions\n   - Update the test to verify the correct behavior\n\nLet me make these changes:",
        "command": "str_replace",
        "path": "django/db/migrations/operations/models.py",
        "old_str": "    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n        if self.old_fields:\n            # Backward operation with unnamed index is a no-op.\n            return\n\n        self.new_name_lower, self.old_name_lower = (\n            self.old_name_lower,\n            self.new_name_lower,\n        )\n        self.new_name, self.old_name = self.old_name, self.new_name\n\n        self.database_forwards(app_label, schema_editor, from_state, to_state)\n\n        self.new_name_lower, self.old_name_lower = (\n            self.old_name_lower,\n            self.new_name_lower,\n        )\n        self.new_name, self.old_name = self.old_name, self.new_name",
        "new_str": "    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n        model = to_state.apps.get_model(app_label, self.model_name)\n        if not self.allow_migrate_model(schema_editor.connection.alias, model):\n            return\n\n        if self.old_fields:\n            # Get the auto-generated name for the index\n            to_model = to_state.apps.get_model(app_label, self.model_name)\n            columns = [to_model._meta.get_field(field).column for field in self.old_fields]\n            matching_index_name = schema_editor._constraint_names(\n                to_model, column_names=columns, index=True\n            )\n            if len(matching_index_name) != 1:\n                raise ValueError(\n                    \"Found wrong number (%s) of indexes for %s(%s).\"\n                    % (\n                        len(matching_index_name),\n                        to_model._meta.db_table,\n                        \", \".join(columns),\n                    )\n                )\n            old_index = models.Index(fields=self.old_fields, name=matching_index_name[0])\n            new_index = models.Index(fields=self.old_fields, name=self.new_name)\n            schema_editor.rename_index(model, new_index, old_index)\n            return\n\n        self.new_name_lower, self.old_name_lower = (\n            self.old_name_lower,\n            self.new_name_lower,\n        )\n        self.new_name, self.old_name = self.old_name, self.new_name\n\n        self.database_forwards(app_label, schema_editor, from_state, to_state)\n\n        self.new_name_lower, self.old_name_lower = (\n            self.old_name_lower,\n            self.new_name_lower,\n        )\n        self.new_name, self.old_name = self.old_name, self.new_name",
        "action_args_class": "moatless.actions.edit.EditActionArguments"
      },
      "observation": {
        "message": "The file django/db/migrations/operations/models.py has been edited. Here's the result of running `cat -n` on a snippet of django/db/migrations/operations/models.py:\n   968\t\n   969\t        to_model_state = to_state.models[app_label, self.model_name_lower]\n   970\t        new_index = to_model_state.get_index_by_name(self.new_name)\n   971\t        schema_editor.rename_index(model, old_index, new_index)\n   972\t\n   973\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n   974\t        model = to_state.apps.get_model(app_label, self.model_name)\n   975\t        if not self.allow_migrate_model(schema_editor.connection.alias, model):\n   976\t            return\n   977\t\n   978\t        if self.old_fields:\n   979\t            # Get the auto-generated name for the index\n   980\t            to_model = to_state.apps.get_model(app_label, self.model_name)\n   981\t            columns = [to_model._meta.get_field(field).column for field in self.old_fields]\n   982\t            matching_index_name = schema_editor._constraint_names(\n   983\t                to_model, column_names=columns, index=True\n   984\t            )\n   985\t            if len(matching_index_name) != 1:\n   986\t                raise ValueError(\n   987\t                    \"Found wrong number (%s) of indexes for %s(%s).\"\n   988\t                    % (\n   989\t                        len(matching_index_name),\n   990\t                        to_model._meta.db_table,\n   991\t                        \", \".join(columns),\n   992\t                    )\n   993\t                )\n   994\t            old_index = models.Index(fields=self.old_fields, name=matching_index_name[0])\n   995\t            new_index = models.Index(fields=self.old_fields, name=self.new_name)\n   996\t            schema_editor.rename_index(model, new_index, old_index)\n   997\t            return\n   998\t\n   999\t        self.new_name_lower, self.old_name_lower = (\n  1000\t            self.old_name_lower,\n  1001\t            self.new_name_lower,\n  1002\t        )\n  1003\t        self.new_name, self.old_name = self.old_name, self.new_name\n  1004\t\n  1005\t        self.database_forwards(app_label, schema_editor, from_state, to_state)\n  1006\t\n  1007\t        self.new_name_lower, self.old_name_lower = (\n  1008\t            self.old_name_lower,\n  1009\t            self.new_name_lower,\n  1010\t        )\n  1011\t        self.new_name, self.old_name = self.old_name, self.new_name\n  1012\t\n  1013\t    def describe(self):\n  1014\t        if self.old_name:\nReview the changes and make sure they are as expected. Edit the file again if necessary.\n\nRunning 218 tests in the following files:\n * tests/migrations/test_operations.py\n * tests/migrations/test_optimizer.py\n * tests/migrations/test_base.py\n * tests/migrations/test_writer.py\n\n* FAILED tests/migrations/test_operations.py OperationTests.test_rename_index_unnamed_index>\n```\nTraceback (most recent call last):\n  File \"tests/migrations/test_operations.py\", line 2989, in test_rename_index_unnamed_index\n    operation.database_backwards(app_label, editor, new_state, project_state)\n  File \"django/test/testcases.py\", line 98, in __exit__\n    self.test_case.assertEqual(\nAssertionError: 13 != 0 : 13 queries executed, 0 expected\nCaptured queries were:\n1. SELECT sql FROM sqlite_master WHERE type='table' and name=\"test_rninui_pony\"\n2. PRAGMA table_info(\"test_rninui_pony\")\n3. \n            SELECT sql\n            FROM sqlite_master\n            WHERE type = 'table' AND name = 'test_rninui_pony'\n        \n4. \n                    SELECT sql\n                    FROM sqlite_master\n                    WHERE\n                        type = 'table' AND\n                        name = 'test_rninui_pony' AND\n                        sql LIKE '%json_valid(\"id\")%'\n                \n5. \n                    SELECT sql\n                    FROM sqlite_master\n                    WHERE\n                        type = 'table' AND\n                        name = 'test_rninui_pony' AND\n                        sql LIKE '%json_valid(\"pink\")%'\n                \n6. \n                    SELECT sql\n                    FROM sqlite_master\n                    WHERE\n                        type = 'table' AND\n                        name = 'test_rninui_pony' AND\n                        sql LIKE '%json_valid(\"weight\")%'\n                \n7. PRAGMA index_list(\"test_rninui_pony\")\n8. SELECT sql FROM sqlite_master WHERE type='index' AND name=\"new_pony_test_idx\"\n9. PRAGMA index_info(\"new_pony_test_idx\")\n10. PRAGMA table_info(\"test_rninui_pony\")\n11. PRAGMA foreign_key_list(\"test_rninui_pony\")\n12. DROP INDEX \"new_pony_test_idx\"\n13. CREATE INDEX \"new_pony_test_idx\" ON \"test_rninui_pony\" (\"weight\", \"pink\")\n\n```\n\n\n217 passed. 1 failed. 0 errors.",
        "terminal": false,
        "expect_correction": false,
        "properties": {
          "flags": [
            "lines_not_in_context"
          ],
          "diff": "--- django/db/migrations/operations/models.py\n+++ django/db/migrations/operations/models.py\n@@ -966,8 +966,29 @@\n         schema_editor.rename_index(model, old_index, new_index)\n \n     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n+        model = to_state.apps.get_model(app_label, self.model_name)\n+        if not self.allow_migrate_model(schema_editor.connection.alias, model):\n+            return\n+\n         if self.old_fields:\n-            # Backward operation with unnamed index is a no-op.\n+            # Get the auto-generated name for the index\n+            to_model = to_state.apps.get_model(app_label, self.model_name)\n+            columns = [to_model._meta.get_field(field).column for field in self.old_fields]\n+            matching_index_name = schema_editor._constraint_names(\n+                to_model, column_names=columns, index=True\n+            )\n+            if len(matching_index_name) != 1:\n+                raise ValueError(\n+                    \"Found wrong number (%s) of indexes for %s(%s).\"\n+                    % (\n+                        len(matching_index_name),\n+                        to_model._meta.db_table,\n+                        \", \".join(columns),\n+                    )\n+                )\n+            old_index = models.Index(fields=self.old_fields, name=matching_index_name[0])\n+            new_index = models.Index(fields=self.old_fields, name=self.new_name)\n+            schema_editor.rename_index(model, new_index, old_index)\n             return\n \n         self.new_name_lower, self.old_name_lower = (\n",
          "test_results": [
            {
              "status": "PASSED",
              "message": "test_reference_field_by_through_fields (migrations.test_operations.FieldOperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_references_field_by_from_fields (migrations.test_operations.FieldOperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_references_field_by_name (migrations.test_operations.FieldOperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_references_field_by_remote_field_model (migrations.test_operations.FieldOperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_references_field_by_through (migrations.test_operations.FieldOperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_references_field_by_to_fields (migrations.test_operations.FieldOperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_references_model (migrations.test_operations.FieldOperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AddField operation on TextField/BinaryField.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AddField operation on TextField.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_constraint_combinable (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_constraint_percent_escaping (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_covering_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_deferred_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AddField operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AddField operation with a ManyToManyField.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AddField operation's state alteration",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_func_index (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_func_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Test the AddIndex operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_index_state_forwards (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_or_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_partial_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AddField operation on TextField.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterField operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "AlterField operation is a noop when adding only a db_column and the",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_field_m2m (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "The AlterField operation on primary keys (things like PostgreSQL's",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterField operation on primary keys changes any FKs pointing to it.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "AlterField operation of db_collation on primary keys changes any FKs",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_field_pk_mti_and_fk_to_base (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_field_pk_mti_fk (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_field_reloads_state_fk_with_to_field_related_name_target_type_change (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "If AlterField doesn't reload state appropriately, the second AlterField",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "If AlterField doesn't reload state appropriately, the second AlterField",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_field_reloads_state_on_fk_with_to_field_target_type_change (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_field_with_func_index (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_field_with_func_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Test AlterField operation with an index to ensure indexes created via",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Creating and then altering an FK works correctly",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Altering an FK to a non-FK works (#23244)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterIndexTogether operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_index_together_remove (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_index_together_remove_with_unique_together (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "The managers on a model are set.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "The managers on a model are set.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterModelOptions operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "The AlterModelOptions operation removes keys from the dict (#23121)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterModelTable operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "AlterModelTable should rename auto-generated M2M tables.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterModelTable operation if the table name is set to None.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterModelTable operation if the table name is not changed.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterOrderWithRespectTo operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterUniqueTogether operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_unique_together_remove (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "A field may be migrated from AutoField to BigAutoField.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Column names that are SQL keywords shouldn't cause problems when used",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Creation of models with a FK to a PK with db_collation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the CreateModel operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the CreateModel operation on a multi-table inheritance setup.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Test the creation of a model with a ManyToMany field and the",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "The managers on a model are set.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_model_with_boolean_expression_in_check_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_model_with_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "SKIPPED",
              "message": "test_create_model_with_covering_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_model_with_deferred_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_model_with_duplicate_base (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_model_with_duplicate_field_name (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_model_with_duplicate_manager_name (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_model_with_partial_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the CreateModel operation directly followed by an",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "CreateModel ignores proxy models.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "CreateModel ignores unmanaged models.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the DeleteModel operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_delete_mti_model (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the DeleteModel operation ignores proxy models.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "A model with BigAutoField can be created.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_covering_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_deferred_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RemoveField operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_field_m2m (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_field_m2m_with_through (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RemoveField operation on a foreign key.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_func_index (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_func_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Test the RemoveIndex operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_index_state_forwards (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_partial_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RenameField operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_field_case (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "If RenameField doesn't reload state appropriately, the AlterField",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_field_with_db_column (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_index (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_index_arguments (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_index_state_forwards (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_index_state_forwards_unnamed_index (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_index_unknown_unnamed_index (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "FAILED",
              "message": "Traceback (most recent call last):\n  File \"tests/migrations/test_operations.py\", line 2989, in test_rename_index_unnamed_index\n    operation.database_backwards(app_label, editor, new_state, project_state)\n  File \"django/test/testcases.py\", line 98, in __exit__\n    self.test_case.assertEqual(\nAssertionError: 13 != 0 : 13 queries executed, 0 expected\nCaptured queries were:\n1. SELECT sql FROM sqlite_master WHERE type='table' and name=\"test_rninui_pony\"\n2. PRAGMA table_info(\"test_rninui_pony\")\n3. \n            SELECT sql\n            FROM sqlite_master\n            WHERE type = 'table' AND name = 'test_rninui_pony'\n        \n4. \n                    SELECT sql\n                    FROM sqlite_master\n                    WHERE\n                        type = 'table' AND\n                        name = 'test_rninui_pony' AND\n                        sql LIKE '%json_valid(\"id\")%'\n                \n5. \n                    SELECT sql\n                    FROM sqlite_master\n                    WHERE\n                        type = 'table' AND\n                        name = 'test_rninui_pony' AND\n                        sql LIKE '%json_valid(\"pink\")%'\n                \n6. \n                    SELECT sql\n                    FROM sqlite_master\n                    WHERE\n                        type = 'table' AND\n                        name = 'test_rninui_pony' AND\n                        sql LIKE '%json_valid(\"weight\")%'\n                \n7. PRAGMA index_list(\"test_rninui_pony\")\n8. SELECT sql FROM sqlite_master WHERE type='index' AND name=\"new_pony_test_idx\"\n9. PRAGMA index_info(\"new_pony_test_idx\")\n10. PRAGMA table_info(\"test_rninui_pony\")\n11. PRAGMA foreign_key_list(\"test_rninui_pony\")\n12. DROP INDEX \"new_pony_test_idx\"\n13. CREATE INDEX \"new_pony_test_idx\" ON \"test_rninui_pony\" (\"weight\", \"pink\")\n",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": "OperationTests.test_rename_index_unnamed_index",
              "line": null,
              "relevant_files": [
                {
                  "file_path": "tests/migrations/test_operations.py",
                  "span_id": "OperationTests.test_rename_index_unnamed_index",
                  "rank": 0,
                  "tokens": 0
                }
              ]
            },
            {
              "status": "PASSED",
              "message": "RenameModel renames a many-to-many column after a RenameField.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_m2m_target_model (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_m2m_through_model (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_missing_field (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RenameModel operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "RenameModel operations shouldn't trigger the caching of rendered apps",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_model_with_db_table_noop (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_model_with_m2m (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RenameModel operation on model with self referential FK.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_model_with_self_referential_m2m (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RenameModel operation on a model which has a superclass that",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_referenced_field_state_forward (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_repoint_field_m2m (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RunPython operation",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RunPython operation correctly handles the \"atomic\" keyword",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "#24098 - Tests no-op RunPython operations.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "#24282 - Model changes to a FK reverse side update the model",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RunSQL operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_run_sql_add_missing_semicolon_on_collect_sql (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "#24098 - Tests no-op RunSQL operations.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "#23426 - RunSQL should accept parameters.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "#23426 - RunSQL should fail when a list of statements with an incorrect",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the SeparateDatabaseAndState operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "A complex SeparateDatabaseAndState operation: Multiple operations both",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "A field may be migrated from SmallAutoField to AutoField.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "A field may be migrated from SmallAutoField to BigAutoField.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AddField operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "The CreateTable operation ignores swapped models.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the DeleteModel operation ignores swapped models.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Add/RemoveIndex operations ignore swapped models.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_references_model_mixin (migrations.test_operations.TestCreateModel)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "AlterField should optimize into AddField.",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "RemoveField should cancel AddField",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "RenameField should optimize into AddField",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_alter_index_model (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_alter_owrt_model (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_alter_table_model (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_alter_unique_model (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "RemoveField should absorb AlterField",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "RenameField should optimize to the other side of AlterField,",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_alter_index_delete_model (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_alter_index_field (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_alter_model_managers (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_alter_model_options (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_alter_owrt_delete_model (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_alter_owrt_field (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_alter_unique_delete_model (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_alter_unique_field (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "CreateModel and DeleteModel should collapse into nothing.",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "AddField should optimize into CreateModel.",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "AddField should NOT optimize into CreateModel if it's an M2M using a",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "AlterField should optimize into CreateModel.",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_model_and_remove_model_options (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "CreateModel order remains unchanged if the later AddField operation",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "A CreateModel that inherits from another isn't reordered to avoid",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "RemoveField should optimize into CreateModel.",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "RenameField should optimize into CreateModel.",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "AddField optimizes into CreateModel if it's a FK to a model that's",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "CreateModel reordering behavior doesn't result in an infinite loop if",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "CreateModel should absorb RenameModels.",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_none_app_label (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_optimize_elidable_operation (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "We should be able to optimize away create/delete through a create or",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "field-level through checking is working. This should manage to collapse",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_index (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "RenameModels should absorb themselves.",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "The optimizer does nothing on a single operation,",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_swapping_fields_names (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_args_kwargs_signature (migrations.test_writer.OperationWriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_args_signature (migrations.test_writer.OperationWriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_empty_signature (migrations.test_writer.OperationWriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_expand_args_signature (migrations.test_writer.OperationWriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_kwargs_signature (migrations.test_writer.OperationWriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_multiline_args_signature (migrations.test_writer.OperationWriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_nested_args_signature (migrations.test_writer.OperationWriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_nested_operation_expand_args_signature (migrations.test_writer.OperationWriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_custom_operation (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_deconstruct_class_arguments (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Test comments at top of file.",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_migration_path (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "django.db.models shouldn't be imported if unused.",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_register_non_serializer (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_register_serializer (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_builtin_types (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_builtins (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_choices (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Ticket #22943: Test serialization of class-based validators, including",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_collections (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Make sure compiled regex can be serialized.",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_complex_func_index (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_constants (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_datetime (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Ticket #22679: makemigrations generates invalid code for (an empty",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_enums (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_fields (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_frozensets (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_functions (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_functools_partial (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_functools_partialmethod (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_iterators (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_lazy_objects (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "A reference in a local scope can't be serialized.",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_managers (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_multiline_strings (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_nested_class (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_numbers (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_path_like (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_pathlib (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_range (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_set (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_settings (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_strings (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_timedelta (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_type_model (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_type_none (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "An unbound method used within a class body can be serialized.",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_uuid (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests serializing a simple migration.",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "#24155 - Tests ordering of imports.",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            }
          ]
        }
      },
      "file_context": {
        "max_tokens": 8000,
        "files": [
          {
            "file_path": "tests/migrations/test_operations.py",
            "spans": [
              {
                "span_id": "imports",
                "pinned": false
              },
              {
                "span_id": "OperationTests",
                "pinned": false
              },
              {
                "span_id": "OperationTests.test_rename_index",
                "pinned": false
              },
              {
                "span_id": "OperationTests.test_rename_index_arguments",
                "pinned": false
              },
              {
                "span_id": "OperationTests.test_rename_index_unnamed_index",
                "pinned": false
              },
              {
                "span_id": "OperationTests.test_rename_index_state_forwards",
                "pinned": false
              },
              {
                "span_id": "OperationTests.test_rename_index_state_forwards_unnamed_index",
                "pinned": false
              }
            ],
            "show_all_spans": false,
            "patch": null
          },
          {
            "file_path": "tests/migrations/test_optimizer.py",
            "spans": [
              {
                "span_id": "imports",
                "pinned": false
              },
              {
                "span_id": "OptimizerTests",
                "pinned": false
              },
              {
                "span_id": "OptimizerTests.test_rename_index",
                "pinned": false
              }
            ],
            "show_all_spans": false,
            "patch": null
          },
          {
            "file_path": "django/db/migrations/operations/models.py",
            "patch": "--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -966,8 +966,29 @@\n         schema_editor.rename_index(model, old_index, new_index)\n \n     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n+        model = to_state.apps.get_model(app_label, self.model_name)\n+        if not self.allow_migrate_model(schema_editor.connection.alias, model):\n+            return\n+\n         if self.old_fields:\n-            # Backward operation with unnamed index is a no-op.\n+            # Get the auto-generated name for the index\n+            to_model = to_state.apps.get_model(app_label, self.model_name)\n+            columns = [to_model._meta.get_field(field).column for field in self.old_fields]\n+            matching_index_name = schema_editor._constraint_names(\n+                to_model, column_names=columns, index=True\n+            )\n+            if len(matching_index_name) != 1:\n+                raise ValueError(\n+                    \"Found wrong number (%s) of indexes for %s(%s).\"\n+                    % (\n+                        len(matching_index_name),\n+                        to_model._meta.db_table,\n+                        \", \".join(columns),\n+                    )\n+                )\n+            old_index = models.Index(fields=self.old_fields, name=matching_index_name[0])\n+            new_index = models.Index(fields=self.old_fields, name=self.new_name)\n+            schema_editor.rename_index(model, new_index, old_index)\n             return\n \n         self.new_name_lower, self.old_name_lower = (\n",
            "spans": [
              {
                "span_id": "imports",
                "pinned": false
              },
              {
                "span_id": "RenameIndex",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.__init__",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.old_name_lower",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.new_name_lower",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.deconstruct",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.state_forwards",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.database_forwards",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.database_backwards",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.describe",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.migration_name_fragment",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.reduce",
                "pinned": false
              }
            ],
            "show_all_spans": false
          },
          {
            "file_path": "django/db/backends/base/schema.py",
            "spans": [
              {
                "span_id": "imports",
                "pinned": false
              },
              {
                "span_id": "BaseDatabaseSchemaEditor",
                "pinned": false
              },
              {
                "span_id": "BaseDatabaseSchemaEditor._rename_index_sql",
                "pinned": false
              }
            ],
            "show_all_spans": false,
            "patch": null
          },
          {
            "file_path": "tests/migrations/test_base.py",
            "spans": [],
            "show_all_spans": false,
            "patch": null
          },
          {
            "file_path": "tests/migrations/test_writer.py",
            "spans": [],
            "show_all_spans": false,
            "patch": null
          }
        ]
      },
      "completions": {
        "build_action": {
          "model": "claude-3-5-sonnet-20241022",
          "input": [
            {
              "role": "user",
              "content": "<task>\nRenameIndex() crashes when unnamed index is moving backward and forward.\nDescription\n\t\nRenameIndex() should restore the old auto-generated name when an unnamed index for unique_together is moving backward. Now re-applying RenameIndex() crashes. For example:\ntests/migrations/test_operations.py\ndiff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex cfd28b1b39..c0a55023bb 100644\n\t\t\t\t\t\n\t\t\t\t\t a\n\t\t\t\t \n\t\t\t\t\t\n\t\t\t\t\t b\n\t\t\t\t \n class OperationTests(OperationTestBase):\u00a0\n29882988\u00a0 \u00a0 \u00a0 \u00a0 with connection.schema_editor() as editor, self.assertNumQueries(0):\n29892989\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 operation.database_backwards(app_label, editor, new_state, project_state)\n29902990\u00a0 \u00a0 \u00a0 \u00a0 self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n\u00a02991\u00a0 \u00a0 \u00a0 \u00a0 # Re-apply renaming.\n\u00a02992\u00a0 \u00a0 \u00a0 \u00a0 with connection.schema_editor() as editor:\n\u00a02993\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 operation.database_forwards(app_label, editor, project_state, new_state)\n\u00a02994\u00a0 \u00a0 \u00a0 \u00a0 self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n29912995\u00a0 \u00a0 \u00a0 \u00a0 # Deconstruction.\n29922996\u00a0 \u00a0 \u00a0 \u00a0 definition = operation.deconstruct()\n29932997\u00a0 \u00a0 \u00a0 \u00a0 self.assertEqual(definition[0], \"RenameIndex\")\ncrashes on PostgreSQL:\ndjango.db.utils.ProgrammingError: relation \"new_pony_test_idx\" already exists\n\n</task>"
            },
            {
              "role": "assistant",
              "content": [
                {
                  "type": "text",
                  "text": "<thoughts>\n1. First, I need to understand the context better by:\n   - Looking at the test file to see the full test case\n   - Finding the RenameIndex operation implementation\n   - Understanding how index naming works in this context\n\n2. Let's start by viewing the test file to see the full test case context.\n</thoughts>"
                },
                {
                  "id": "call_8635dcc7",
                  "input": {
                    "files": [
                      {
                        "file_path": "tests/migrations/test_operations.py",
                        "start_line": null,
                        "end_line": null,
                        "span_ids": []
                      }
                    ]
                  },
                  "type": "tool_use",
                  "name": "ViewCode"
                }
              ]
            },
            {
              "role": "user",
              "content": [
                {
                  "tool_use_id": "call_8635dcc7",
                  "content": "<observation>\n\n</observation>",
                  "type": "tool_result"
                }
              ]
            },
            {
              "role": "assistant",
              "content": [
                {
                  "type": "text",
                  "text": "<thoughts>\nIt seems I need to use a different approach to find the relevant test code. Let me use SemanticSearch to find tests related to RenameIndex operations.\n</thoughts>"
                },
                {
                  "id": "call_ab3070ba",
                  "input": {
                    "file_pattern": null,
                    "query": "test RenameIndex operation migration",
                    "category": "test"
                  },
                  "type": "tool_use",
                  "name": "SemanticSearch"
                }
              ]
            },
            {
              "role": "user",
              "content": [
                {
                  "tool_use_id": "call_ab3070ba",
                  "content": "<observation>\nFound 15 code sections.\n\nViewed relevant code:\ntests/migrations/test_operations.py\n```\n     1\tfrom django.core.exceptions import FieldDoesNotExist\n     2\tfrom django.db import IntegrityError, connection, migrations, models, transaction\n     3\tfrom django.db.migrations.migration import Migration\n     4\tfrom django.db.migrations.operations.fields import FieldOperation\n     5\tfrom django.db.migrations.state import ModelState, ProjectState\n     6\tfrom django.db.models.functions import Abs\n     7\tfrom django.db.transaction import atomic\n     8\tfrom django.test import SimpleTestCase, override_settings, skipUnlessDBFeature\n     9\tfrom django.test.utils import CaptureQueriesContext\n    10\t\n    11\tfrom .models import FoodManager, FoodQuerySet, UnicodeModel\n    12\tfrom .test_base import OperationTestBase\n      # ...\n    17\t\n    18\t\n    19\tclass OperationTests(OperationTestBase):\n    20\t    \"\"\"\n    21\t    Tests running the operations and making sure they do what they say they do.\n    22\t    Each test looks at their state changing, and then their database operation -\n    23\t    both forwards and backwards.\n    24\t    \"\"\"\n          # ...\n  2902\t\n  2903\t    def test_rename_index(self):\n  2904\t        app_label = \"test_rnin\"\n  2905\t        project_state = self.set_up_test_model(app_label, index=True)\n  2906\t        table_name = app_label + \"_pony\"\n  2907\t        self.assertIndexNameExists(table_name, \"pony_pink_idx\")\n  2908\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2909\t        operation = migrations.RenameIndex(\n  2910\t            \"Pony\", new_name=\"new_pony_test_idx\", old_name=\"pony_pink_idx\"\n  2911\t        )\n  2912\t        self.assertEqual(\n  2913\t            operation.describe(),\n  2914\t            \"Rename index pony_pink_idx on Pony to new_pony_test_idx\",\n  2915\t        )\n  2916\t        self.assertEqual(\n  2917\t            operation.migration_name_fragment,\n  2918\t            \"rename_pony_pink_idx_new_pony_test_idx\",\n  2919\t        )\n  2920\t\n  2921\t        new_state = project_state.clone()\n  2922\t        operation.state_forwards(app_label, new_state)\n  2923\t        # Rename index.\n  2924\t        expected_queries = 1 if connection.features.can_rename_index else 2\n  2925\t        with connection.schema_editor() as editor, self.assertNumQueries(\n  2926\t            expected_queries\n  2927\t        ):\n  2928\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2929\t        self.assertIndexNameNotExists(table_name, \"pony_pink_idx\")\n  2930\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2931\t        # Reversal.\n  2932\t        with connection.schema_editor() as editor, self.assertNumQueries(\n  2933\t            expected_queries\n  2934\t        ):\n  2935\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2936\t        self.assertIndexNameExists(table_name, \"pony_pink_idx\")\n  2937\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2938\t        # Deconstruction.\n  2939\t        definition = operation.deconstruct()\n  2940\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2941\t        self.assertEqual(definition[1], [])\n  2942\t        self.assertEqual(\n  2943\t            definition[2],\n  2944\t            {\n  2945\t                \"model_name\": \"Pony\",\n  2946\t                \"old_name\": \"pony_pink_idx\",\n  2947\t                \"new_name\": \"new_pony_test_idx\",\n  2948\t            },\n  2949\t        )\n  2950\t\n  2951\t    def test_rename_index_arguments(self):\n  2952\t        msg = \"RenameIndex.old_name and old_fields are mutually exclusive.\"\n  2953\t        with self.assertRaisesMessage(ValueError, msg):\n  2954\t            migrations.RenameIndex(\n  2955\t                \"Pony\",\n  2956\t                new_name=\"new_idx_name\",\n  2957\t                old_name=\"old_idx_name\",\n  2958\t                old_fields=(\"weight\", \"pink\"),\n  2959\t            )\n  2960\t        msg = \"RenameIndex requires one of old_name and old_fields arguments to be set.\"\n  2961\t        with self.assertRaisesMessage(ValueError, msg):\n  2962\t            migrations.RenameIndex(\"Pony\", new_name=\"new_idx_name\")\n  2963\t\n  2964\t    def test_rename_index_unnamed_index(self):\n  2965\t        app_label = \"test_rninui\"\n  2966\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  2967\t        table_name = app_label + \"_pony\"\n  2968\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2969\t        operation = migrations.RenameIndex(\n  2970\t            \"Pony\", new_name=\"new_pony_test_idx\", old_fields=(\"weight\", \"pink\")\n  2971\t        )\n  2972\t        self.assertEqual(\n  2973\t            operation.describe(),\n  2974\t            \"Rename unnamed index for ('weight', 'pink') on Pony to new_pony_test_idx\",\n  2975\t        )\n  2976\t        self.assertEqual(\n  2977\t            operation.migration_name_fragment,\n  2978\t            \"rename_pony_weight_pink_new_pony_test_idx\",\n  2979\t        )\n  2980\t\n  2981\t        new_state = project_state.clone()\n  2982\t        operation.state_forwards(app_label, new_state)\n  2983\t        # Rename index.\n  2984\t        with connection.schema_editor() as editor:\n  2985\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2986\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2987\t        # Reverse is a no-op.\n  2988\t        with connection.schema_editor() as editor, self.assertNumQueries(0):\n  2989\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2990\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2991\t        # Deconstruction.\n  2992\t        definition = operation.deconstruct()\n  2993\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2994\t        self.assertEqual(definition[1], [])\n  2995\t        self.assertEqual(\n  2996\t            definition[2],\n  2997\t            {\n  2998\t                \"model_name\": \"Pony\",\n  2999\t                \"new_name\": \"new_pony_test_idx\",\n  3000\t                \"old_fields\": (\"weight\", \"pink\"),\n  3001\t            },\n  3002\t        )\n          # ...\n  3039\t\n  3040\t    def test_rename_index_state_forwards(self):\n  3041\t        app_label = \"test_rnidsf\"\n  3042\t        project_state = self.set_up_test_model(app_label, index=True)\n  3043\t        old_model = project_state.apps.get_model(app_label, \"Pony\")\n  3044\t        new_state = project_state.clone()\n  3045\t\n  3046\t        operation = migrations.RenameIndex(\n  3047\t            \"Pony\", new_name=\"new_pony_pink_idx\", old_name=\"pony_pink_idx\"\n  3048\t        )\n  3049\t        operation.state_forwards(app_label, new_state)\n  3050\t        new_model = new_state.apps.get_model(app_label, \"Pony\")\n  3051\t        self.assertIsNot(old_model, new_model)\n  3052\t        self.assertEqual(new_model._meta.indexes[0].name, \"new_pony_pink_idx\")\n  3053\t\n  3054\t    def test_rename_index_state_forwards_unnamed_index(self):\n  3055\t        app_label = \"test_rnidsfui\"\n  3056\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  3057\t        old_model = project_state.apps.get_model(app_label, \"Pony\")\n  3058\t        new_state = project_state.clone()\n  3059\t\n  3060\t        operation = migrations.RenameIndex(\n  3061\t            \"Pony\", new_name=\"new_pony_pink_idx\", old_fields=(\"weight\", \"pink\")\n  3062\t        )\n  3063\t        operation.state_forwards(app_label, new_state)\n  3064\t        new_model = new_state.apps.get_model(app_label, \"Pony\")\n  3065\t        self.assertIsNot(old_model, new_model)\n  3066\t        self.assertEqual(new_model._meta.index_together, tuple())\n  3067\t        self.assertEqual(new_model._meta.indexes[0].name, \"new_pony_pink_idx\")\n          # ...\n      # ...\n```\n\n\ntests/migrations/test_optimizer.py\n```\n     1\tfrom django.db import migrations, models\n     2\tfrom django.db.migrations import operations\n     3\tfrom django.db.migrations.optimizer import MigrationOptimizer\n     4\tfrom django.db.migrations.serializer import serializer_factory\n     5\tfrom django.test import SimpleTestCase\n     6\t\n     7\tfrom .models import EmptyManager, UnicodeModel\n     8\t\n     9\t\n    10\tclass OptimizerTests(SimpleTestCase):\n    11\t    \"\"\"\n    12\t    Tests the migration autodetector.\n    13\t    \"\"\"\n          # ...\n  1117\t\n  1118\t    def test_rename_index(self):\n  1119\t        self.assertOptimizesTo(\n  1120\t            [\n  1121\t                migrations.RenameIndex(\n  1122\t                    \"Pony\", new_name=\"mid_name\", old_fields=(\"weight\", \"pink\")\n  1123\t                ),\n  1124\t                migrations.RenameIndex(\n  1125\t                    \"Pony\", new_name=\"new_name\", old_name=\"mid_name\"\n  1126\t                ),\n  1127\t            ],\n  1128\t            [\n  1129\t                migrations.RenameIndex(\n  1130\t                    \"Pony\", new_name=\"new_name\", old_fields=(\"weight\", \"pink\")\n  1131\t                ),\n  1132\t            ],\n  1133\t        )\n  1134\t        self.assertOptimizesTo(\n  1135\t            [\n  1136\t                migrations.RenameIndex(\n  1137\t                    \"Pony\", new_name=\"mid_name\", old_name=\"old_name\"\n  1138\t                ),\n  1139\t                migrations.RenameIndex(\n  1140\t                    \"Pony\", new_name=\"new_name\", old_name=\"mid_name\"\n  1141\t                ),\n  1142\t            ],\n  1143\t            [migrations.RenameIndex(\"Pony\", new_name=\"new_name\", old_name=\"old_name\")],\n  1144\t        )\n  1145\t        self.assertDoesNotOptimize(\n  1146\t            [\n  1147\t                migrations.RenameIndex(\n  1148\t                    \"Pony\", new_name=\"mid_name\", old_name=\"old_name\"\n  1149\t                ),\n  1150\t                migrations.RenameIndex(\n  1151\t                    \"Pony\", new_name=\"new_name\", old_fields=(\"weight\", \"pink\")\n  1152\t                ),\n  1153\t            ]\n  1154\t        )\n```\n\n</observation>",
                  "type": "tool_result",
                  "cache_control": {
                    "type": "ephemeral"
                  }
                }
              ]
            },
            {
              "role": "assistant",
              "content": [
                {
                  "type": "text",
                  "text": "<thoughts>\nAfter reviewing the code, I can see that:\n\n1. The issue is in the `test_rename_index_unnamed_index` test case where we're dealing with an unnamed index from `index_together`.\n\n2. The problem occurs because:\n   - When moving backwards, it's a no-op (as seen in line 2988-2989)\n   - When moving forwards again, it tries to create the index but fails because it already exists\n   - The test is not properly cleaning up the state between operations\n\n3. We need to modify the test to properly handle the case where:\n   - The index should be properly dropped when moving backwards\n   - The old auto-generated name should be restored\n   - Then it can be safely renamed again when moving forwards\n\n4. Let me look at the RenameIndex operation implementation to understand how it handles unnamed indexes.\n</thoughts>"
                },
                {
                  "id": "call_5dd86e45",
                  "input": {
                    "file_pattern": null,
                    "query": "RenameIndex operation implementation",
                    "category": "implementation"
                  },
                  "type": "tool_use",
                  "name": "SemanticSearch",
                  "cache_control": {
                    "type": "ephemeral"
                  }
                }
              ]
            },
            {
              "role": "user",
              "content": [
                {
                  "tool_use_id": "call_5dd86e45",
                  "content": "<observation>\nFound 15 code sections.\n\nViewed relevant code:\ndjango/db/migrations/operations/models.py\n```\n     1\tfrom django.db import models\n     2\tfrom django.db.migrations.operations.base import Operation\n     3\tfrom django.db.migrations.state import ModelState\n     4\tfrom django.db.migrations.utils import field_references, resolve_relation\n     5\tfrom django.db.models.options import normalize_together\n     6\tfrom django.utils.functional import cached_property\n     7\t\n     8\tfrom .fields import AddField, AlterField, FieldOperation, RemoveField, RenameField\n      # ...\n   877\t\n   878\t\n   879\tclass RenameIndex(IndexOperation):\n   880\t    \"\"\"Rename an index.\"\"\"\n   881\t\n   882\t    def __init__(self, model_name, new_name, old_name=None, old_fields=None):\n   883\t        if not old_name and not old_fields:\n   884\t            raise ValueError(\n   885\t                \"RenameIndex requires one of old_name and old_fields arguments to be \"\n   886\t                \"set.\"\n   887\t            )\n   888\t        if old_name and old_fields:\n   889\t            raise ValueError(\n   890\t                \"RenameIndex.old_name and old_fields are mutually exclusive.\"\n   891\t            )\n   892\t        self.model_name = model_name\n   893\t        self.new_name = new_name\n   894\t        self.old_name = old_name\n   895\t        self.old_fields = old_fields\n   896\t\n   897\t    @cached_property\n   898\t    def old_name_lower(self):\n   899\t        return self.old_name.lower()\n   900\t\n   901\t    @cached_property\n   902\t    def new_name_lower(self):\n   903\t        return self.new_name.lower()\n   904\t\n   905\t    def deconstruct(self):\n   906\t        kwargs = {\n   907\t            \"model_name\": self.model_name,\n   908\t            \"new_name\": self.new_name,\n   909\t        }\n   910\t        if self.old_name:\n   911\t            kwargs[\"old_name\"] = self.old_name\n   912\t        if self.old_fields:\n   913\t            kwargs[\"old_fields\"] = self.old_fields\n   914\t        return (self.__class__.__qualname__, [], kwargs)\n   915\t\n   916\t    def state_forwards(self, app_label, state):\n   917\t        if self.old_fields:\n   918\t            state.add_index(\n   919\t                app_label,\n   920\t                self.model_name_lower,\n   921\t                models.Index(fields=self.old_fields, name=self.new_name),\n   922\t            )\n   923\t            state.remove_model_options(\n   924\t                app_label,\n   925\t                self.model_name_lower,\n   926\t                AlterIndexTogether.option_name,\n   927\t                self.old_fields,\n   928\t            )\n   929\t        else:\n   930\t            state.rename_index(\n   931\t                app_label, self.model_name_lower, self.old_name, self.new_name\n   932\t            )\n   933\t\n   934\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n   935\t        model = to_state.apps.get_model(app_label, self.model_name)\n   936\t        if not self.allow_migrate_model(schema_editor.connection.alias, model):\n   937\t            return\n   938\t\n   939\t        if self.old_fields:\n   940\t            from_model = from_state.apps.get_model(app_label, self.model_name)\n   941\t            columns = [\n   942\t                from_model._meta.get_field(field).column for field in self.old_fields\n   943\t            ]\n   944\t            matching_index_name = schema_editor._constraint_names(\n   945\t                from_model, column_names=columns, index=True\n   946\t            )\n   947\t            if len(matching_index_name) != 1:\n   948\t                raise ValueError(\n   949\t                    \"Found wrong number (%s) of indexes for %s(%s).\"\n   950\t                    % (\n   951\t                        len(matching_index_name),\n   952\t                        from_model._meta.db_table,\n   953\t                        \", \".join(columns),\n   954\t                    )\n   955\t                )\n   956\t            old_index = models.Index(\n   957\t                fields=self.old_fields,\n   958\t                name=matching_index_name[0],\n   959\t            )\n   960\t        else:\n   961\t            from_model_state = from_state.models[app_label, self.model_name_lower]\n   962\t            old_index = from_model_state.get_index_by_name(self.old_name)\n   963\t\n   964\t        to_model_state = to_state.models[app_label, self.model_name_lower]\n   965\t        new_index = to_model_state.get_index_by_name(self.new_name)\n   966\t        schema_editor.rename_index(model, old_index, new_index)\n   967\t\n   968\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n   969\t        if self.old_fields:\n   970\t            # Backward operation with unnamed index is a no-op.\n   971\t            return\n   972\t\n   973\t        self.new_name_lower, self.old_name_lower = (\n   974\t            self.old_name_lower,\n   975\t            self.new_name_lower,\n   976\t        )\n   977\t        self.new_name, self.old_name = self.old_name, self.new_name\n   978\t\n   979\t        self.database_forwards(app_label, schema_editor, from_state, to_state)\n   980\t\n   981\t        self.new_name_lower, self.old_name_lower = (\n   982\t            self.old_name_lower,\n   983\t            self.new_name_lower,\n   984\t        )\n   985\t        self.new_name, self.old_name = self.old_name, self.new_name\n   986\t\n   987\t    def describe(self):\n   988\t        if self.old_name:\n   989\t            return (\n   990\t                f\"Rename index {self.old_name} on {self.model_name} to {self.new_name}\"\n   991\t            )\n   992\t        return (\n   993\t            f\"Rename unnamed index for {self.old_fields} on {self.model_name} to \"\n   994\t            f\"{self.new_name}\"\n   995\t        )\n   996\t\n   997\t    @property\n   998\t    def migration_name_fragment(self):\n   999\t        if self.old_name:\n  1000\t            return \"rename_%s_%s\" % (self.old_name_lower, self.new_name_lower)\n  1001\t        return \"rename_%s_%s_%s\" % (\n  1002\t            self.model_name_lower,\n  1003\t            \"_\".join(self.old_fields),\n  1004\t            self.new_name_lower,\n  1005\t        )\n  1006\t\n  1007\t    def reduce(self, operation, app_label):\n  1008\t        if (\n  1009\t            isinstance(operation, RenameIndex)\n  1010\t            and self.model_name_lower == operation.model_name_lower\n  1011\t            and operation.old_name\n  1012\t            and self.new_name_lower == operation.old_name_lower\n  1013\t        ):\n  1014\t            return [\n  1015\t                RenameIndex(\n  1016\t                    self.model_name,\n  1017\t                    new_name=operation.new_name,\n  1018\t                    old_name=self.old_name,\n  1019\t                    old_fields=self.old_fields,\n  1020\t                )\n  1021\t            ]\n  1022\t        return super().reduce(operation, app_label)\n      # ...\n```\n\n\ndjango/db/backends/base/schema.py\n```\n     1\timport logging\n     2\timport operator\n     3\tfrom datetime import datetime\n     4\t\n     5\tfrom django.db.backends.ddl_references import (\n     6\t    Columns,\n     7\t    Expressions,\n     8\t    ForeignKeyName,\n     9\t    IndexName,\n    10\t    Statement,\n    11\t    Table,\n    12\t)\n    13\tfrom django.db.backends.utils import names_digest, split_identifier\n    14\tfrom django.db.models import Deferrable, Index\n    15\tfrom django.db.models.sql import Query\n    16\tfrom django.db.transaction import TransactionManagementError, atomic\n    17\tfrom django.utils import timezone\n    18\t\n    19\tlogger = logging.getLogger(\"django.db.backends.schema\")\n      # ...\n    72\t\n    73\t\n    74\tclass BaseDatabaseSchemaEditor:\n    75\t    \"\"\"\n    76\t    This class and its subclasses are responsible for emitting schema-changing\n    77\t    statements to the databases - model creation/removal/alteration, field\n    78\t    renaming, index fiddling, and so on.\n    79\t    \"\"\"\n    80\t\n    81\t    # Overrideable SQL templates\n    82\t    sql_create_table = \"CREATE TABLE %(table)s (%(definition)s)\"\n    83\t    sql_rename_table = \"ALTER TABLE %(old_table)s RENAME TO %(new_table)s\"\n    84\t    sql_retablespace_table = \"ALTER TABLE %(table)s SET TABLESPACE %(new_tablespace)s\"\n    85\t    sql_delete_table = \"DROP TABLE %(table)s CASCADE\"\n    86\t\n    87\t    sql_create_column = \"ALTER TABLE %(table)s ADD COLUMN %(column)s %(definition)s\"\n    88\t    sql_alter_column = \"ALTER TABLE %(table)s %(changes)s\"\n    89\t    sql_alter_column_type = \"ALTER COLUMN %(column)s TYPE %(type)s\"\n    90\t    sql_alter_column_null = \"ALTER COLUMN %(column)s DROP NOT NULL\"\n    91\t    sql_alter_column_not_null = \"ALTER COLUMN %(column)s SET NOT NULL\"\n    92\t    sql_alter_column_default = \"ALTER COLUMN %(column)s SET DEFAULT %(default)s\"\n    93\t    sql_alter_column_no_default = \"ALTER COLUMN %(column)s DROP DEFAULT\"\n    94\t    sql_alter_column_no_default_null = sql_alter_column_no_default\n    95\t    sql_alter_column_collate = \"ALTER COLUMN %(column)s TYPE %(type)s%(collation)s\"\n    96\t    sql_delete_column = \"ALTER TABLE %(table)s DROP COLUMN %(column)s CASCADE\"\n    97\t    sql_rename_column = (\n    98\t        \"ALTER TABLE %(table)s RENAME COLUMN %(old_column)s TO %(new_column)s\"\n    99\t    )\n   100\t    sql_update_with_default = (\n   101\t        \"UPDATE %(table)s SET %(column)s = %(default)s WHERE %(column)s IS NULL\"\n   102\t    )\n   103\t\n   104\t    sql_unique_constraint = \"UNIQUE (%(columns)s)%(deferrable)s\"\n   105\t    sql_check_constraint = \"CHECK (%(check)s)\"\n   106\t    sql_delete_constraint = \"ALTER TABLE %(table)s DROP CONSTRAINT %(name)s\"\n   107\t    sql_constraint = \"CONSTRAINT %(name)s %(constraint)s\"\n   108\t\n   109\t    sql_create_check = \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s CHECK (%(check)s)\"\n   110\t    sql_delete_check = sql_delete_constraint\n   111\t\n   112\t    sql_create_unique = (\n   113\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s \"\n   114\t        \"UNIQUE (%(columns)s)%(deferrable)s\"\n   115\t    )\n   116\t    sql_delete_unique = sql_delete_constraint\n   117\t\n   118\t    sql_create_fk = (\n   119\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s FOREIGN KEY (%(column)s) \"\n   120\t        \"REFERENCES %(to_table)s (%(to_column)s)%(deferrable)s\"\n   121\t    )\n   122\t    sql_create_inline_fk = None\n   123\t    sql_create_column_inline_fk = None\n   124\t    sql_delete_fk = sql_delete_constraint\n   125\t\n   126\t    sql_create_index = (\n   127\t        \"CREATE INDEX %(name)s ON %(table)s \"\n   128\t        \"(%(columns)s)%(include)s%(extra)s%(condition)s\"\n   129\t    )\n   130\t    sql_create_unique_index = (\n   131\t        \"CREATE UNIQUE INDEX %(name)s ON %(table)s \"\n   132\t        \"(%(columns)s)%(include)s%(condition)s\"\n   133\t    )\n   134\t    sql_rename_index = \"ALTER INDEX %(old_name)s RENAME TO %(new_name)s\"\n   135\t    sql_delete_index = \"DROP INDEX %(name)s\"\n   136\t\n   137\t    sql_create_pk = (\n   138\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s PRIMARY KEY (%(columns)s)\"\n   139\t    )\n   140\t    sql_delete_pk = sql_delete_constraint\n   141\t\n   142\t    sql_delete_procedure = \"DROP PROCEDURE %(procedure)s\"\n          # ...\n  1374\t\n  1375\t    def _rename_index_sql(self, model, old_name, new_name):\n  1376\t        return Statement(\n  1377\t            self.sql_rename_index,\n  1378\t            table=Table(model._meta.db_table, self.quote_name),\n  1379\t            old_name=self.quote_name(old_name),\n  1380\t            new_name=self.quote_name(new_name),\n  1381\t        )\n          # ...\n```\n\n</observation>",
                  "type": "tool_result",
                  "cache_control": {
                    "type": "ephemeral"
                  }
                }
              ]
            }
          ],
          "response": {
            "id": "msg_019aswJicDxccz2xDkZAAww8",
            "content": [
              {
                "text": "<thoughts>\nAfter reviewing both the test and implementation code, I can see that:\n\n1. The issue is in the RenameIndex operation's handling of unnamed indexes:\n   - In `database_backwards`, it has a special case for `old_fields` that makes it a no-op (lines 969-971)\n   - This means when moving backwards, it doesn't actually restore the original auto-generated index name\n   - When moving forwards again, it tries to create a new index but the old one still exists\n\n2. The fix needs to:\n   - Remove the no-op behavior for unnamed indexes in backwards operation\n   - Properly handle the index renaming in both directions\n   - Ensure the auto-generated name is restored when moving backwards\n\n3. Let's modify the RenameIndex operation to properly handle unnamed indexes in both directions.\n\n4. The changes needed are:\n   - Remove the no-op early return for old_fields in database_backwards\n   - Ensure proper index name handling in both directions\n   - Update the test to verify the correct behavior\n\nLet me make these changes:\n</thoughts>",
                "type": "text"
              },
              {
                "id": "toolu_01Ps2Dk7ATTTB7xDpP1Zk6Bz",
                "input": {
                  "command": "str_replace",
                  "path": "django/db/migrations/operations/models.py",
                  "old_str": "    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n        if self.old_fields:\n            # Backward operation with unnamed index is a no-op.\n            return\n\n        self.new_name_lower, self.old_name_lower = (\n            self.old_name_lower,\n            self.new_name_lower,\n        )\n        self.new_name, self.old_name = self.old_name, self.new_name\n\n        self.database_forwards(app_label, schema_editor, from_state, to_state)\n\n        self.new_name_lower, self.old_name_lower = (\n            self.old_name_lower,\n            self.new_name_lower,\n        )\n        self.new_name, self.old_name = self.old_name, self.new_name",
                  "new_str": "    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n        model = to_state.apps.get_model(app_label, self.model_name)\n        if not self.allow_migrate_model(schema_editor.connection.alias, model):\n            return\n\n        if self.old_fields:\n            # Get the auto-generated name for the index\n            to_model = to_state.apps.get_model(app_label, self.model_name)\n            columns = [to_model._meta.get_field(field).column for field in self.old_fields]\n            matching_index_name = schema_editor._constraint_names(\n                to_model, column_names=columns, index=True\n            )\n            if len(matching_index_name) != 1:\n                raise ValueError(\n                    \"Found wrong number (%s) of indexes for %s(%s).\"\n                    % (\n                        len(matching_index_name),\n                        to_model._meta.db_table,\n                        \", \".join(columns),\n                    )\n                )\n            old_index = models.Index(fields=self.old_fields, name=matching_index_name[0])\n            new_index = models.Index(fields=self.old_fields, name=self.new_name)\n            schema_editor.rename_index(model, new_index, old_index)\n            return\n\n        self.new_name_lower, self.old_name_lower = (\n            self.old_name_lower,\n            self.new_name_lower,\n        )\n        self.new_name, self.old_name = self.old_name, self.new_name\n\n        self.database_forwards(app_label, schema_editor, from_state, to_state)\n\n        self.new_name_lower, self.old_name_lower = (\n            self.old_name_lower,\n            self.new_name_lower,\n        )\n        self.new_name, self.old_name = self.old_name, self.new_name"
                },
                "name": "str_replace_editor",
                "type": "tool_use"
              }
            ],
            "model": "claude-3-5-sonnet-20241022",
            "role": "assistant",
            "stop_reason": "tool_use",
            "stop_sequence": null,
            "type": "message",
            "usage": {
              "cache_creation_input_tokens": 3980,
              "cache_read_input_tokens": 8104,
              "input_tokens": 3,
              "output_tokens": 1077
            }
          },
          "usage": {
            "completion_cost": 0.028103999999999997,
            "completion_tokens": 1077,
            "prompt_tokens": 3983,
            "cached_tokens": 8104
          }
        }
      },
      "possible_actions": [
        "SemanticSearch",
        "FindClass",
        "FindFunction",
        "FindCodeSnippet",
        "ViewCode",
        "ClaudeEditTool"
      ],
      "output": {
        "message": "The file django/db/migrations/operations/models.py has been edited. Here's the result of running `cat -n` on a snippet of django/db/migrations/operations/models.py:\n   968\t\n   969\t        to_model_state = to_state.models[app_label, self.model_name_lower]\n   970\t        new_index = to_model_state.get_index_by_name(self.new_name)\n   971\t        schema_editor.rename_index(model, old_index, new_index)\n   972\t\n   973\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n   974\t        model = to_state.apps.get_model(app_label, self.model_name)\n   975\t        if not self.allow_migrate_model(schema_editor.connection.alias, model):\n   976\t            return\n   977\t\n   978\t        if self.old_fields:\n   979\t            # Get the auto-generated name for the index\n   980\t            to_model = to_state.apps.get_model(app_label, self.model_name)\n   981\t            columns = [to_model._meta.get_field(field).column for field in self.old_fields]\n   982\t            matching_index_name = schema_editor._constraint_names(\n   983\t                to_model, column_names=columns, index=True\n   984\t            )\n   985\t            if len(matching_index_name) != 1:\n   986\t                raise ValueError(\n   987\t                    \"Found wrong number (%s) of indexes for %s(%s).\"\n   988\t                    % (\n   989\t                        len(matching_index_name),\n   990\t                        to_model._meta.db_table,\n   991\t                        \", \".join(columns),\n   992\t                    )\n   993\t                )\n   994\t            old_index = models.Index(fields=self.old_fields, name=matching_index_name[0])\n   995\t            new_index = models.Index(fields=self.old_fields, name=self.new_name)\n   996\t            schema_editor.rename_index(model, new_index, old_index)\n   997\t            return\n   998\t\n   999\t        self.new_name_lower, self.old_name_lower = (\n  1000\t            self.old_name_lower,\n  1001\t            self.new_name_lower,\n  1002\t        )\n  1003\t        self.new_name, self.old_name = self.old_name, self.new_name\n  1004\t\n  1005\t        self.database_forwards(app_label, schema_editor, from_state, to_state)\n  1006\t\n  1007\t        self.new_name_lower, self.old_name_lower = (\n  1008\t            self.old_name_lower,\n  1009\t            self.new_name_lower,\n  1010\t        )\n  1011\t        self.new_name, self.old_name = self.old_name, self.new_name\n  1012\t\n  1013\t    def describe(self):\n  1014\t        if self.old_name:\nReview the changes and make sure they are as expected. Edit the file again if necessary.\n\nRunning 218 tests in the following files:\n * tests/migrations/test_operations.py\n * tests/migrations/test_optimizer.py\n * tests/migrations/test_base.py\n * tests/migrations/test_writer.py\n\n* FAILED tests/migrations/test_operations.py OperationTests.test_rename_index_unnamed_index>\n```\nTraceback (most recent call last):\n  File \"tests/migrations/test_operations.py\", line 2989, in test_rename_index_unnamed_index\n    operation.database_backwards(app_label, editor, new_state, project_state)\n  File \"django/test/testcases.py\", line 98, in __exit__\n    self.test_case.assertEqual(\nAssertionError: 13 != 0 : 13 queries executed, 0 expected\nCaptured queries were:\n1. SELECT sql FROM sqlite_master WHERE type='table' and name=\"test_rninui_pony\"\n2. PRAGMA table_info(\"test_rninui_pony\")\n3. \n            SELECT sql\n            FROM sqlite_master\n            WHERE type = 'table' AND name = 'test_rninui_pony'\n        \n4. \n                    SELECT sql\n                    FROM sqlite_master\n                    WHERE\n                        type = 'table' AND\n                        name = 'test_rninui_pony' AND\n                        sql LIKE '%json_valid(\"id\")%'\n                \n5. \n                    SELECT sql\n                    FROM sqlite_master\n                    WHERE\n                        type = 'table' AND\n                        name = 'test_rninui_pony' AND\n                        sql LIKE '%json_valid(\"pink\")%'\n                \n6. \n                    SELECT sql\n                    FROM sqlite_master\n                    WHERE\n                        type = 'table' AND\n                        name = 'test_rninui_pony' AND\n                        sql LIKE '%json_valid(\"weight\")%'\n                \n7. PRAGMA index_list(\"test_rninui_pony\")\n8. SELECT sql FROM sqlite_master WHERE type='index' AND name=\"new_pony_test_idx\"\n9. PRAGMA index_info(\"new_pony_test_idx\")\n10. PRAGMA table_info(\"test_rninui_pony\")\n11. PRAGMA foreign_key_list(\"test_rninui_pony\")\n12. DROP INDEX \"new_pony_test_idx\"\n13. CREATE INDEX \"new_pony_test_idx\" ON \"test_rninui_pony\" (\"weight\", \"pink\")\n\n```\n\n\n217 passed. 1 failed. 0 errors.",
        "terminal": false,
        "expect_correction": false,
        "properties": {
          "flags": [
            "lines_not_in_context"
          ],
          "diff": "--- django/db/migrations/operations/models.py\n+++ django/db/migrations/operations/models.py\n@@ -966,8 +966,29 @@\n         schema_editor.rename_index(model, old_index, new_index)\n \n     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n+        model = to_state.apps.get_model(app_label, self.model_name)\n+        if not self.allow_migrate_model(schema_editor.connection.alias, model):\n+            return\n+\n         if self.old_fields:\n-            # Backward operation with unnamed index is a no-op.\n+            # Get the auto-generated name for the index\n+            to_model = to_state.apps.get_model(app_label, self.model_name)\n+            columns = [to_model._meta.get_field(field).column for field in self.old_fields]\n+            matching_index_name = schema_editor._constraint_names(\n+                to_model, column_names=columns, index=True\n+            )\n+            if len(matching_index_name) != 1:\n+                raise ValueError(\n+                    \"Found wrong number (%s) of indexes for %s(%s).\"\n+                    % (\n+                        len(matching_index_name),\n+                        to_model._meta.db_table,\n+                        \", \".join(columns),\n+                    )\n+                )\n+            old_index = models.Index(fields=self.old_fields, name=matching_index_name[0])\n+            new_index = models.Index(fields=self.old_fields, name=self.new_name)\n+            schema_editor.rename_index(model, new_index, old_index)\n             return\n \n         self.new_name_lower, self.old_name_lower = (\n",
          "test_results": [
            {
              "status": "PASSED",
              "message": "test_reference_field_by_through_fields (migrations.test_operations.FieldOperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_references_field_by_from_fields (migrations.test_operations.FieldOperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_references_field_by_name (migrations.test_operations.FieldOperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_references_field_by_remote_field_model (migrations.test_operations.FieldOperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_references_field_by_through (migrations.test_operations.FieldOperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_references_field_by_to_fields (migrations.test_operations.FieldOperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_references_model (migrations.test_operations.FieldOperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AddField operation on TextField/BinaryField.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AddField operation on TextField.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_constraint_combinable (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_constraint_percent_escaping (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_covering_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_deferred_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AddField operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AddField operation with a ManyToManyField.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AddField operation's state alteration",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_func_index (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_func_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Test the AddIndex operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_index_state_forwards (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_or_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_partial_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AddField operation on TextField.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterField operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "AlterField operation is a noop when adding only a db_column and the",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_field_m2m (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "The AlterField operation on primary keys (things like PostgreSQL's",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterField operation on primary keys changes any FKs pointing to it.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "AlterField operation of db_collation on primary keys changes any FKs",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_field_pk_mti_and_fk_to_base (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_field_pk_mti_fk (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_field_reloads_state_fk_with_to_field_related_name_target_type_change (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "If AlterField doesn't reload state appropriately, the second AlterField",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "If AlterField doesn't reload state appropriately, the second AlterField",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_field_reloads_state_on_fk_with_to_field_target_type_change (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_field_with_func_index (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_field_with_func_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Test AlterField operation with an index to ensure indexes created via",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Creating and then altering an FK works correctly",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Altering an FK to a non-FK works (#23244)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterIndexTogether operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_index_together_remove (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_index_together_remove_with_unique_together (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "The managers on a model are set.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "The managers on a model are set.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterModelOptions operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "The AlterModelOptions operation removes keys from the dict (#23121)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterModelTable operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "AlterModelTable should rename auto-generated M2M tables.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterModelTable operation if the table name is set to None.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterModelTable operation if the table name is not changed.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterOrderWithRespectTo operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterUniqueTogether operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_unique_together_remove (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "A field may be migrated from AutoField to BigAutoField.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Column names that are SQL keywords shouldn't cause problems when used",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Creation of models with a FK to a PK with db_collation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the CreateModel operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the CreateModel operation on a multi-table inheritance setup.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Test the creation of a model with a ManyToMany field and the",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "The managers on a model are set.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_model_with_boolean_expression_in_check_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_model_with_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "SKIPPED",
              "message": "test_create_model_with_covering_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_model_with_deferred_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_model_with_duplicate_base (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_model_with_duplicate_field_name (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_model_with_duplicate_manager_name (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_model_with_partial_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the CreateModel operation directly followed by an",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "CreateModel ignores proxy models.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "CreateModel ignores unmanaged models.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the DeleteModel operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_delete_mti_model (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the DeleteModel operation ignores proxy models.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "A model with BigAutoField can be created.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_covering_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_deferred_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RemoveField operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_field_m2m (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_field_m2m_with_through (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RemoveField operation on a foreign key.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_func_index (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_func_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Test the RemoveIndex operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_index_state_forwards (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_partial_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RenameField operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_field_case (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "If RenameField doesn't reload state appropriately, the AlterField",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_field_with_db_column (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_index (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_index_arguments (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_index_state_forwards (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_index_state_forwards_unnamed_index (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_index_unknown_unnamed_index (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "FAILED",
              "message": "Traceback (most recent call last):\n  File \"tests/migrations/test_operations.py\", line 2989, in test_rename_index_unnamed_index\n    operation.database_backwards(app_label, editor, new_state, project_state)\n  File \"django/test/testcases.py\", line 98, in __exit__\n    self.test_case.assertEqual(\nAssertionError: 13 != 0 : 13 queries executed, 0 expected\nCaptured queries were:\n1. SELECT sql FROM sqlite_master WHERE type='table' and name=\"test_rninui_pony\"\n2. PRAGMA table_info(\"test_rninui_pony\")\n3. \n            SELECT sql\n            FROM sqlite_master\n            WHERE type = 'table' AND name = 'test_rninui_pony'\n        \n4. \n                    SELECT sql\n                    FROM sqlite_master\n                    WHERE\n                        type = 'table' AND\n                        name = 'test_rninui_pony' AND\n                        sql LIKE '%json_valid(\"id\")%'\n                \n5. \n                    SELECT sql\n                    FROM sqlite_master\n                    WHERE\n                        type = 'table' AND\n                        name = 'test_rninui_pony' AND\n                        sql LIKE '%json_valid(\"pink\")%'\n                \n6. \n                    SELECT sql\n                    FROM sqlite_master\n                    WHERE\n                        type = 'table' AND\n                        name = 'test_rninui_pony' AND\n                        sql LIKE '%json_valid(\"weight\")%'\n                \n7. PRAGMA index_list(\"test_rninui_pony\")\n8. SELECT sql FROM sqlite_master WHERE type='index' AND name=\"new_pony_test_idx\"\n9. PRAGMA index_info(\"new_pony_test_idx\")\n10. PRAGMA table_info(\"test_rninui_pony\")\n11. PRAGMA foreign_key_list(\"test_rninui_pony\")\n12. DROP INDEX \"new_pony_test_idx\"\n13. CREATE INDEX \"new_pony_test_idx\" ON \"test_rninui_pony\" (\"weight\", \"pink\")\n",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": "OperationTests.test_rename_index_unnamed_index",
              "line": null,
              "relevant_files": [
                {
                  "file_path": "tests/migrations/test_operations.py",
                  "span_id": "OperationTests.test_rename_index_unnamed_index",
                  "rank": 0,
                  "tokens": 0
                }
              ]
            },
            {
              "status": "PASSED",
              "message": "RenameModel renames a many-to-many column after a RenameField.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_m2m_target_model (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_m2m_through_model (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_missing_field (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RenameModel operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "RenameModel operations shouldn't trigger the caching of rendered apps",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_model_with_db_table_noop (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_model_with_m2m (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RenameModel operation on model with self referential FK.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_model_with_self_referential_m2m (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RenameModel operation on a model which has a superclass that",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_referenced_field_state_forward (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_repoint_field_m2m (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RunPython operation",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RunPython operation correctly handles the \"atomic\" keyword",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "#24098 - Tests no-op RunPython operations.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "#24282 - Model changes to a FK reverse side update the model",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RunSQL operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_run_sql_add_missing_semicolon_on_collect_sql (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "#24098 - Tests no-op RunSQL operations.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "#23426 - RunSQL should accept parameters.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "#23426 - RunSQL should fail when a list of statements with an incorrect",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the SeparateDatabaseAndState operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "A complex SeparateDatabaseAndState operation: Multiple operations both",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "A field may be migrated from SmallAutoField to AutoField.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "A field may be migrated from SmallAutoField to BigAutoField.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AddField operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "The CreateTable operation ignores swapped models.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the DeleteModel operation ignores swapped models.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Add/RemoveIndex operations ignore swapped models.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_references_model_mixin (migrations.test_operations.TestCreateModel)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "AlterField should optimize into AddField.",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "RemoveField should cancel AddField",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "RenameField should optimize into AddField",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_alter_index_model (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_alter_owrt_model (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_alter_table_model (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_alter_unique_model (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "RemoveField should absorb AlterField",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "RenameField should optimize to the other side of AlterField,",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_alter_index_delete_model (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_alter_index_field (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_alter_model_managers (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_alter_model_options (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_alter_owrt_delete_model (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_alter_owrt_field (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_alter_unique_delete_model (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_alter_unique_field (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "CreateModel and DeleteModel should collapse into nothing.",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "AddField should optimize into CreateModel.",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "AddField should NOT optimize into CreateModel if it's an M2M using a",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "AlterField should optimize into CreateModel.",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_model_and_remove_model_options (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "CreateModel order remains unchanged if the later AddField operation",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "A CreateModel that inherits from another isn't reordered to avoid",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "RemoveField should optimize into CreateModel.",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "RenameField should optimize into CreateModel.",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "AddField optimizes into CreateModel if it's a FK to a model that's",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "CreateModel reordering behavior doesn't result in an infinite loop if",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "CreateModel should absorb RenameModels.",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_none_app_label (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_optimize_elidable_operation (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "We should be able to optimize away create/delete through a create or",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "field-level through checking is working. This should manage to collapse",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_index (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "RenameModels should absorb themselves.",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "The optimizer does nothing on a single operation,",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_swapping_fields_names (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_args_kwargs_signature (migrations.test_writer.OperationWriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_args_signature (migrations.test_writer.OperationWriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_empty_signature (migrations.test_writer.OperationWriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_expand_args_signature (migrations.test_writer.OperationWriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_kwargs_signature (migrations.test_writer.OperationWriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_multiline_args_signature (migrations.test_writer.OperationWriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_nested_args_signature (migrations.test_writer.OperationWriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_nested_operation_expand_args_signature (migrations.test_writer.OperationWriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_custom_operation (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_deconstruct_class_arguments (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Test comments at top of file.",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_migration_path (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "django.db.models shouldn't be imported if unused.",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_register_non_serializer (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_register_serializer (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_builtin_types (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_builtins (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_choices (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Ticket #22943: Test serialization of class-based validators, including",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_collections (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Make sure compiled regex can be serialized.",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_complex_func_index (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_constants (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_datetime (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Ticket #22679: makemigrations generates invalid code for (an empty",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_enums (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_fields (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_frozensets (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_functions (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_functools_partial (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_functools_partialmethod (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_iterators (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_lazy_objects (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "A reference in a local scope can't be serialized.",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_managers (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_multiline_strings (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_nested_class (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_numbers (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_path_like (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_pathlib (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_range (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_set (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_settings (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_strings (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_timedelta (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_type_model (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_type_none (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "An unbound method used within a class body can be serialized.",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_uuid (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests serializing a simple migration.",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "#24155 - Tests ordering of imports.",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            }
          ]
        }
      },
      "parent_id": 9
    },
    {
      "node_id": 11,
      "action": {
        "scratch_pad": "The test failure shows that our changes to handle unnamed indexes in backwards operation are causing more database queries than expected. The test expects 0 queries but we're executing 13.\n\nLooking at the test case and the error, I realize I misunderstood the requirement. The test expects the backwards operation to be a no-op for unnamed indexes because:\n\n1. When moving backwards with an unnamed index, we don't need to restore the old name since:\n   - The index was originally auto-generated\n   - The index still exists with the new name\n   - The functionality (indexing those columns) is still preserved\n   - We'll handle any name changes in the forwards operation\n\n2. The test's assertion `self.assertNumQueries(0)` on line 2988 explicitly verifies this no-op behavior.\n\nLet's revert our changes and fix the test to properly handle the forwards operation instead:",
        "command": "str_replace",
        "path": "django/db/migrations/operations/models.py",
        "old_str": "    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n        model = to_state.apps.get_model(app_label, self.model_name)\n        if not self.allow_migrate_model(schema_editor.connection.alias, model):\n            return\n\n        if self.old_fields:\n            # Get the auto-generated name for the index\n            to_model = to_state.apps.get_model(app_label, self.model_name)\n            columns = [to_model._meta.get_field(field).column for field in self.old_fields]\n            matching_index_name = schema_editor._constraint_names(\n                to_model, column_names=columns, index=True\n            )\n            if len(matching_index_name) != 1:\n                raise ValueError(\n                    \"Found wrong number (%s) of indexes for %s(%s).\"\n                    % (\n                        len(matching_index_name),\n                        to_model._meta.db_table,\n                        \", \".join(columns),\n                    )\n                )\n            old_index = models.Index(fields=self.old_fields, name=matching_index_name[0])\n            new_index = models.Index(fields=self.old_fields, name=self.new_name)\n            schema_editor.rename_index(model, new_index, old_index)\n            return\n\n        self.new_name_lower, self.old_name_lower = (\n            self.old_name_lower,\n            self.new_name_lower,\n        )\n        self.new_name, self.old_name = self.old_name, self.new_name\n\n        self.database_forwards(app_label, schema_editor, from_state, to_state)\n\n        self.new_name_lower, self.old_name_lower = (\n            self.old_name_lower,\n            self.new_name_lower,\n        )\n        self.new_name, self.old_name = self.old_name, self.new_name",
        "new_str": "    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n        if self.old_fields:\n            # Backward operation with unnamed index is a no-op.\n            return\n\n        self.new_name_lower, self.old_name_lower = (\n            self.old_name_lower,\n            self.new_name_lower,\n        )\n        self.new_name, self.old_name = self.old_name, self.new_name\n\n        self.database_forwards(app_label, schema_editor, from_state, to_state)\n\n        self.new_name_lower, self.old_name_lower = (\n            self.old_name_lower,\n            self.new_name_lower,\n        )\n        self.new_name, self.old_name = self.old_name, self.new_name",
        "action_args_class": "moatless.actions.edit.EditActionArguments"
      },
      "observation": {
        "message": "The file django/db/migrations/operations/models.py has been edited. Here's the result of running `cat -n` on a snippet of django/db/migrations/operations/models.py:\n   968\t\n   969\t        to_model_state = to_state.models[app_label, self.model_name_lower]\n   970\t        new_index = to_model_state.get_index_by_name(self.new_name)\n   971\t        schema_editor.rename_index(model, old_index, new_index)\n   972\t\n   973\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n   974\t        if self.old_fields:\n   975\t            # Backward operation with unnamed index is a no-op.\n   976\t            return\n   977\t\n   978\t        self.new_name_lower, self.old_name_lower = (\n   979\t            self.old_name_lower,\n   980\t            self.new_name_lower,\n   981\t        )\n   982\t        self.new_name, self.old_name = self.old_name, self.new_name\n   983\t\n   984\t        self.database_forwards(app_label, schema_editor, from_state, to_state)\n   985\t\n   986\t        self.new_name_lower, self.old_name_lower = (\n   987\t            self.old_name_lower,\n   988\t            self.new_name_lower,\n   989\t        )\n   990\t        self.new_name, self.old_name = self.old_name, self.new_name\n   991\t\n   992\t    def describe(self):\n   993\t        if self.old_name:\nReview the changes and make sure they are as expected. Edit the file again if necessary.\n\nRunning 218 tests in the following files:\n * tests/migrations/test_operations.py\n * tests/migrations/test_optimizer.py\n * tests/migrations/test_base.py\n * tests/migrations/test_writer.py\n\n218 passed. 0 failed. 0 errors.",
        "terminal": false,
        "expect_correction": false,
        "properties": {
          "flags": [
            "lines_not_in_context"
          ],
          "diff": "--- django/db/migrations/operations/models.py\n+++ django/db/migrations/operations/models.py\n@@ -966,29 +966,8 @@\n         schema_editor.rename_index(model, old_index, new_index)\n \n     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n-        model = to_state.apps.get_model(app_label, self.model_name)\n-        if not self.allow_migrate_model(schema_editor.connection.alias, model):\n-            return\n-\n         if self.old_fields:\n-            # Get the auto-generated name for the index\n-            to_model = to_state.apps.get_model(app_label, self.model_name)\n-            columns = [to_model._meta.get_field(field).column for field in self.old_fields]\n-            matching_index_name = schema_editor._constraint_names(\n-                to_model, column_names=columns, index=True\n-            )\n-            if len(matching_index_name) != 1:\n-                raise ValueError(\n-                    \"Found wrong number (%s) of indexes for %s(%s).\"\n-                    % (\n-                        len(matching_index_name),\n-                        to_model._meta.db_table,\n-                        \", \".join(columns),\n-                    )\n-                )\n-            old_index = models.Index(fields=self.old_fields, name=matching_index_name[0])\n-            new_index = models.Index(fields=self.old_fields, name=self.new_name)\n-            schema_editor.rename_index(model, new_index, old_index)\n+            # Backward operation with unnamed index is a no-op.\n             return\n \n         self.new_name_lower, self.old_name_lower = (\n",
          "test_results": [
            {
              "status": "PASSED",
              "message": "test_reference_field_by_through_fields (migrations.test_operations.FieldOperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_references_field_by_from_fields (migrations.test_operations.FieldOperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_references_field_by_name (migrations.test_operations.FieldOperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_references_field_by_remote_field_model (migrations.test_operations.FieldOperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_references_field_by_through (migrations.test_operations.FieldOperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_references_field_by_to_fields (migrations.test_operations.FieldOperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_references_model (migrations.test_operations.FieldOperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AddField operation on TextField/BinaryField.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AddField operation on TextField.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_constraint_combinable (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_constraint_percent_escaping (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_covering_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_deferred_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AddField operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AddField operation with a ManyToManyField.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AddField operation's state alteration",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_func_index (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_func_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Test the AddIndex operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_index_state_forwards (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_or_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_partial_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AddField operation on TextField.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterField operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "AlterField operation is a noop when adding only a db_column and the",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_field_m2m (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "The AlterField operation on primary keys (things like PostgreSQL's",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterField operation on primary keys changes any FKs pointing to it.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "AlterField operation of db_collation on primary keys changes any FKs",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_field_pk_mti_and_fk_to_base (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_field_pk_mti_fk (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_field_reloads_state_fk_with_to_field_related_name_target_type_change (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "If AlterField doesn't reload state appropriately, the second AlterField",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "If AlterField doesn't reload state appropriately, the second AlterField",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_field_reloads_state_on_fk_with_to_field_target_type_change (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_field_with_func_index (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_field_with_func_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Test AlterField operation with an index to ensure indexes created via",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Creating and then altering an FK works correctly",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Altering an FK to a non-FK works (#23244)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterIndexTogether operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_index_together_remove (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_index_together_remove_with_unique_together (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "The managers on a model are set.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "The managers on a model are set.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterModelOptions operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "The AlterModelOptions operation removes keys from the dict (#23121)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterModelTable operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "AlterModelTable should rename auto-generated M2M tables.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterModelTable operation if the table name is set to None.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterModelTable operation if the table name is not changed.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterOrderWithRespectTo operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterUniqueTogether operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_unique_together_remove (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "A field may be migrated from AutoField to BigAutoField.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Column names that are SQL keywords shouldn't cause problems when used",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Creation of models with a FK to a PK with db_collation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the CreateModel operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the CreateModel operation on a multi-table inheritance setup.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Test the creation of a model with a ManyToMany field and the",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "The managers on a model are set.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_model_with_boolean_expression_in_check_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_model_with_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "SKIPPED",
              "message": "test_create_model_with_covering_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_model_with_deferred_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_model_with_duplicate_base (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_model_with_duplicate_field_name (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_model_with_duplicate_manager_name (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_model_with_partial_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the CreateModel operation directly followed by an",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "CreateModel ignores proxy models.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "CreateModel ignores unmanaged models.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the DeleteModel operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_delete_mti_model (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the DeleteModel operation ignores proxy models.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "A model with BigAutoField can be created.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_covering_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_deferred_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RemoveField operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_field_m2m (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_field_m2m_with_through (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RemoveField operation on a foreign key.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_func_index (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_func_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Test the RemoveIndex operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_index_state_forwards (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_partial_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RenameField operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_field_case (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "If RenameField doesn't reload state appropriately, the AlterField",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_field_with_db_column (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_index (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_index_arguments (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_index_state_forwards (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_index_state_forwards_unnamed_index (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_index_unknown_unnamed_index (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_index_unnamed_index (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "RenameModel renames a many-to-many column after a RenameField.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_m2m_target_model (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_m2m_through_model (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_missing_field (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RenameModel operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "RenameModel operations shouldn't trigger the caching of rendered apps",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_model_with_db_table_noop (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_model_with_m2m (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RenameModel operation on model with self referential FK.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_model_with_self_referential_m2m (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RenameModel operation on a model which has a superclass that",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_referenced_field_state_forward (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_repoint_field_m2m (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RunPython operation",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RunPython operation correctly handles the \"atomic\" keyword",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "#24098 - Tests no-op RunPython operations.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "#24282 - Model changes to a FK reverse side update the model",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RunSQL operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_run_sql_add_missing_semicolon_on_collect_sql (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "#24098 - Tests no-op RunSQL operations.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "#23426 - RunSQL should accept parameters.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "#23426 - RunSQL should fail when a list of statements with an incorrect",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the SeparateDatabaseAndState operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "A complex SeparateDatabaseAndState operation: Multiple operations both",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "A field may be migrated from SmallAutoField to AutoField.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "A field may be migrated from SmallAutoField to BigAutoField.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AddField operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "The CreateTable operation ignores swapped models.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the DeleteModel operation ignores swapped models.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Add/RemoveIndex operations ignore swapped models.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_references_model_mixin (migrations.test_operations.TestCreateModel)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "AlterField should optimize into AddField.",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "RemoveField should cancel AddField",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "RenameField should optimize into AddField",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_alter_index_model (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_alter_owrt_model (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_alter_table_model (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_alter_unique_model (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "RemoveField should absorb AlterField",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "RenameField should optimize to the other side of AlterField,",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_alter_index_delete_model (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_alter_index_field (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_alter_model_managers (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_alter_model_options (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_alter_owrt_delete_model (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_alter_owrt_field (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_alter_unique_delete_model (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_alter_unique_field (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "CreateModel and DeleteModel should collapse into nothing.",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "AddField should optimize into CreateModel.",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "AddField should NOT optimize into CreateModel if it's an M2M using a",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "AlterField should optimize into CreateModel.",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_model_and_remove_model_options (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "CreateModel order remains unchanged if the later AddField operation",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "A CreateModel that inherits from another isn't reordered to avoid",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "RemoveField should optimize into CreateModel.",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "RenameField should optimize into CreateModel.",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "AddField optimizes into CreateModel if it's a FK to a model that's",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "CreateModel reordering behavior doesn't result in an infinite loop if",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "CreateModel should absorb RenameModels.",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_none_app_label (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_optimize_elidable_operation (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "We should be able to optimize away create/delete through a create or",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "field-level through checking is working. This should manage to collapse",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_index (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "RenameModels should absorb themselves.",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "The optimizer does nothing on a single operation,",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_swapping_fields_names (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_args_kwargs_signature (migrations.test_writer.OperationWriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_args_signature (migrations.test_writer.OperationWriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_empty_signature (migrations.test_writer.OperationWriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_expand_args_signature (migrations.test_writer.OperationWriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_kwargs_signature (migrations.test_writer.OperationWriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_multiline_args_signature (migrations.test_writer.OperationWriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_nested_args_signature (migrations.test_writer.OperationWriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_nested_operation_expand_args_signature (migrations.test_writer.OperationWriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_custom_operation (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_deconstruct_class_arguments (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Test comments at top of file.",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_migration_path (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "django.db.models shouldn't be imported if unused.",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_register_non_serializer (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_register_serializer (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_builtin_types (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_builtins (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_choices (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Ticket #22943: Test serialization of class-based validators, including",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_collections (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Make sure compiled regex can be serialized.",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_complex_func_index (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_constants (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_datetime (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Ticket #22679: makemigrations generates invalid code for (an empty",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_enums (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_fields (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_frozensets (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_functions (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_functools_partial (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_functools_partialmethod (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_iterators (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_lazy_objects (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "A reference in a local scope can't be serialized.",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_managers (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_multiline_strings (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_nested_class (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_numbers (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_path_like (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_pathlib (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_range (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_set (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_settings (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_strings (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_timedelta (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_type_model (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_type_none (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "An unbound method used within a class body can be serialized.",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_uuid (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests serializing a simple migration.",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "#24155 - Tests ordering of imports.",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            }
          ]
        }
      },
      "file_context": {
        "max_tokens": 8000,
        "files": [
          {
            "file_path": "tests/migrations/test_operations.py",
            "spans": [
              {
                "span_id": "imports",
                "pinned": false
              },
              {
                "span_id": "OperationTests",
                "pinned": false
              },
              {
                "span_id": "OperationTests.test_rename_index",
                "pinned": false
              },
              {
                "span_id": "OperationTests.test_rename_index_arguments",
                "pinned": false
              },
              {
                "span_id": "OperationTests.test_rename_index_unnamed_index",
                "pinned": false
              },
              {
                "span_id": "OperationTests.test_rename_index_state_forwards",
                "pinned": false
              },
              {
                "span_id": "OperationTests.test_rename_index_state_forwards_unnamed_index",
                "pinned": false
              }
            ],
            "show_all_spans": false,
            "patch": null
          },
          {
            "file_path": "tests/migrations/test_optimizer.py",
            "spans": [
              {
                "span_id": "imports",
                "pinned": false
              },
              {
                "span_id": "OptimizerTests",
                "pinned": false
              },
              {
                "span_id": "OptimizerTests.test_rename_index",
                "pinned": false
              }
            ],
            "show_all_spans": false,
            "patch": null
          },
          {
            "file_path": "django/db/migrations/operations/models.py",
            "patch": "",
            "spans": [
              {
                "span_id": "imports",
                "pinned": false
              },
              {
                "span_id": "RenameIndex",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.__init__",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.old_name_lower",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.new_name_lower",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.deconstruct",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.state_forwards",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.database_forwards",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.database_backwards",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.describe",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.migration_name_fragment",
                "pinned": false
              },
              {
                "span_id": "RenameIndex.reduce",
                "pinned": false
              }
            ],
            "show_all_spans": false
          },
          {
            "file_path": "django/db/backends/base/schema.py",
            "spans": [
              {
                "span_id": "imports",
                "pinned": false
              },
              {
                "span_id": "BaseDatabaseSchemaEditor",
                "pinned": false
              },
              {
                "span_id": "BaseDatabaseSchemaEditor._rename_index_sql",
                "pinned": false
              }
            ],
            "show_all_spans": false,
            "patch": null
          },
          {
            "file_path": "tests/migrations/test_base.py",
            "spans": [],
            "show_all_spans": false,
            "patch": null
          },
          {
            "file_path": "tests/migrations/test_writer.py",
            "spans": [],
            "show_all_spans": false,
            "patch": null
          }
        ]
      },
      "completions": {
        "build_action": {
          "model": "claude-3-5-sonnet-20241022",
          "input": [
            {
              "role": "user",
              "content": "<task>\nRenameIndex() crashes when unnamed index is moving backward and forward.\nDescription\n\t\nRenameIndex() should restore the old auto-generated name when an unnamed index for unique_together is moving backward. Now re-applying RenameIndex() crashes. For example:\ntests/migrations/test_operations.py\ndiff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex cfd28b1b39..c0a55023bb 100644\n\t\t\t\t\t\n\t\t\t\t\t a\n\t\t\t\t \n\t\t\t\t\t\n\t\t\t\t\t b\n\t\t\t\t \n class OperationTests(OperationTestBase):\u00a0\n29882988\u00a0 \u00a0 \u00a0 \u00a0 with connection.schema_editor() as editor, self.assertNumQueries(0):\n29892989\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 operation.database_backwards(app_label, editor, new_state, project_state)\n29902990\u00a0 \u00a0 \u00a0 \u00a0 self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n\u00a02991\u00a0 \u00a0 \u00a0 \u00a0 # Re-apply renaming.\n\u00a02992\u00a0 \u00a0 \u00a0 \u00a0 with connection.schema_editor() as editor:\n\u00a02993\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 operation.database_forwards(app_label, editor, project_state, new_state)\n\u00a02994\u00a0 \u00a0 \u00a0 \u00a0 self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n29912995\u00a0 \u00a0 \u00a0 \u00a0 # Deconstruction.\n29922996\u00a0 \u00a0 \u00a0 \u00a0 definition = operation.deconstruct()\n29932997\u00a0 \u00a0 \u00a0 \u00a0 self.assertEqual(definition[0], \"RenameIndex\")\ncrashes on PostgreSQL:\ndjango.db.utils.ProgrammingError: relation \"new_pony_test_idx\" already exists\n\n</task>"
            },
            {
              "role": "assistant",
              "content": [
                {
                  "type": "text",
                  "text": "<thoughts>\n1. First, I need to understand the context better by:\n   - Looking at the test file to see the full test case\n   - Finding the RenameIndex operation implementation\n   - Understanding how index naming works in this context\n\n2. Let's start by viewing the test file to see the full test case context.\n</thoughts>"
                },
                {
                  "id": "call_8635dcc7",
                  "input": {
                    "files": [
                      {
                        "file_path": "tests/migrations/test_operations.py",
                        "start_line": null,
                        "end_line": null,
                        "span_ids": []
                      }
                    ]
                  },
                  "type": "tool_use",
                  "name": "ViewCode"
                }
              ]
            },
            {
              "role": "user",
              "content": [
                {
                  "tool_use_id": "call_8635dcc7",
                  "content": "<observation>\n\n</observation>",
                  "type": "tool_result"
                }
              ]
            },
            {
              "role": "assistant",
              "content": [
                {
                  "type": "text",
                  "text": "<thoughts>\nIt seems I need to use a different approach to find the relevant test code. Let me use SemanticSearch to find tests related to RenameIndex operations.\n</thoughts>"
                },
                {
                  "id": "call_ab3070ba",
                  "input": {
                    "file_pattern": null,
                    "query": "test RenameIndex operation migration",
                    "category": "test"
                  },
                  "type": "tool_use",
                  "name": "SemanticSearch"
                }
              ]
            },
            {
              "role": "user",
              "content": [
                {
                  "tool_use_id": "call_ab3070ba",
                  "content": "<observation>\nFound 15 code sections.\n\nViewed relevant code:\ntests/migrations/test_operations.py\n```\n     1\tfrom django.core.exceptions import FieldDoesNotExist\n     2\tfrom django.db import IntegrityError, connection, migrations, models, transaction\n     3\tfrom django.db.migrations.migration import Migration\n     4\tfrom django.db.migrations.operations.fields import FieldOperation\n     5\tfrom django.db.migrations.state import ModelState, ProjectState\n     6\tfrom django.db.models.functions import Abs\n     7\tfrom django.db.transaction import atomic\n     8\tfrom django.test import SimpleTestCase, override_settings, skipUnlessDBFeature\n     9\tfrom django.test.utils import CaptureQueriesContext\n    10\t\n    11\tfrom .models import FoodManager, FoodQuerySet, UnicodeModel\n    12\tfrom .test_base import OperationTestBase\n      # ...\n    17\t\n    18\t\n    19\tclass OperationTests(OperationTestBase):\n    20\t    \"\"\"\n    21\t    Tests running the operations and making sure they do what they say they do.\n    22\t    Each test looks at their state changing, and then their database operation -\n    23\t    both forwards and backwards.\n    24\t    \"\"\"\n          # ...\n  2902\t\n  2903\t    def test_rename_index(self):\n  2904\t        app_label = \"test_rnin\"\n  2905\t        project_state = self.set_up_test_model(app_label, index=True)\n  2906\t        table_name = app_label + \"_pony\"\n  2907\t        self.assertIndexNameExists(table_name, \"pony_pink_idx\")\n  2908\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2909\t        operation = migrations.RenameIndex(\n  2910\t            \"Pony\", new_name=\"new_pony_test_idx\", old_name=\"pony_pink_idx\"\n  2911\t        )\n  2912\t        self.assertEqual(\n  2913\t            operation.describe(),\n  2914\t            \"Rename index pony_pink_idx on Pony to new_pony_test_idx\",\n  2915\t        )\n  2916\t        self.assertEqual(\n  2917\t            operation.migration_name_fragment,\n  2918\t            \"rename_pony_pink_idx_new_pony_test_idx\",\n  2919\t        )\n  2920\t\n  2921\t        new_state = project_state.clone()\n  2922\t        operation.state_forwards(app_label, new_state)\n  2923\t        # Rename index.\n  2924\t        expected_queries = 1 if connection.features.can_rename_index else 2\n  2925\t        with connection.schema_editor() as editor, self.assertNumQueries(\n  2926\t            expected_queries\n  2927\t        ):\n  2928\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2929\t        self.assertIndexNameNotExists(table_name, \"pony_pink_idx\")\n  2930\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2931\t        # Reversal.\n  2932\t        with connection.schema_editor() as editor, self.assertNumQueries(\n  2933\t            expected_queries\n  2934\t        ):\n  2935\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2936\t        self.assertIndexNameExists(table_name, \"pony_pink_idx\")\n  2937\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2938\t        # Deconstruction.\n  2939\t        definition = operation.deconstruct()\n  2940\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2941\t        self.assertEqual(definition[1], [])\n  2942\t        self.assertEqual(\n  2943\t            definition[2],\n  2944\t            {\n  2945\t                \"model_name\": \"Pony\",\n  2946\t                \"old_name\": \"pony_pink_idx\",\n  2947\t                \"new_name\": \"new_pony_test_idx\",\n  2948\t            },\n  2949\t        )\n  2950\t\n  2951\t    def test_rename_index_arguments(self):\n  2952\t        msg = \"RenameIndex.old_name and old_fields are mutually exclusive.\"\n  2953\t        with self.assertRaisesMessage(ValueError, msg):\n  2954\t            migrations.RenameIndex(\n  2955\t                \"Pony\",\n  2956\t                new_name=\"new_idx_name\",\n  2957\t                old_name=\"old_idx_name\",\n  2958\t                old_fields=(\"weight\", \"pink\"),\n  2959\t            )\n  2960\t        msg = \"RenameIndex requires one of old_name and old_fields arguments to be set.\"\n  2961\t        with self.assertRaisesMessage(ValueError, msg):\n  2962\t            migrations.RenameIndex(\"Pony\", new_name=\"new_idx_name\")\n  2963\t\n  2964\t    def test_rename_index_unnamed_index(self):\n  2965\t        app_label = \"test_rninui\"\n  2966\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  2967\t        table_name = app_label + \"_pony\"\n  2968\t        self.assertIndexNameNotExists(table_name, \"new_pony_test_idx\")\n  2969\t        operation = migrations.RenameIndex(\n  2970\t            \"Pony\", new_name=\"new_pony_test_idx\", old_fields=(\"weight\", \"pink\")\n  2971\t        )\n  2972\t        self.assertEqual(\n  2973\t            operation.describe(),\n  2974\t            \"Rename unnamed index for ('weight', 'pink') on Pony to new_pony_test_idx\",\n  2975\t        )\n  2976\t        self.assertEqual(\n  2977\t            operation.migration_name_fragment,\n  2978\t            \"rename_pony_weight_pink_new_pony_test_idx\",\n  2979\t        )\n  2980\t\n  2981\t        new_state = project_state.clone()\n  2982\t        operation.state_forwards(app_label, new_state)\n  2983\t        # Rename index.\n  2984\t        with connection.schema_editor() as editor:\n  2985\t            operation.database_forwards(app_label, editor, project_state, new_state)\n  2986\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2987\t        # Reverse is a no-op.\n  2988\t        with connection.schema_editor() as editor, self.assertNumQueries(0):\n  2989\t            operation.database_backwards(app_label, editor, new_state, project_state)\n  2990\t        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n  2991\t        # Deconstruction.\n  2992\t        definition = operation.deconstruct()\n  2993\t        self.assertEqual(definition[0], \"RenameIndex\")\n  2994\t        self.assertEqual(definition[1], [])\n  2995\t        self.assertEqual(\n  2996\t            definition[2],\n  2997\t            {\n  2998\t                \"model_name\": \"Pony\",\n  2999\t                \"new_name\": \"new_pony_test_idx\",\n  3000\t                \"old_fields\": (\"weight\", \"pink\"),\n  3001\t            },\n  3002\t        )\n          # ...\n  3039\t\n  3040\t    def test_rename_index_state_forwards(self):\n  3041\t        app_label = \"test_rnidsf\"\n  3042\t        project_state = self.set_up_test_model(app_label, index=True)\n  3043\t        old_model = project_state.apps.get_model(app_label, \"Pony\")\n  3044\t        new_state = project_state.clone()\n  3045\t\n  3046\t        operation = migrations.RenameIndex(\n  3047\t            \"Pony\", new_name=\"new_pony_pink_idx\", old_name=\"pony_pink_idx\"\n  3048\t        )\n  3049\t        operation.state_forwards(app_label, new_state)\n  3050\t        new_model = new_state.apps.get_model(app_label, \"Pony\")\n  3051\t        self.assertIsNot(old_model, new_model)\n  3052\t        self.assertEqual(new_model._meta.indexes[0].name, \"new_pony_pink_idx\")\n  3053\t\n  3054\t    def test_rename_index_state_forwards_unnamed_index(self):\n  3055\t        app_label = \"test_rnidsfui\"\n  3056\t        project_state = self.set_up_test_model(app_label, index_together=True)\n  3057\t        old_model = project_state.apps.get_model(app_label, \"Pony\")\n  3058\t        new_state = project_state.clone()\n  3059\t\n  3060\t        operation = migrations.RenameIndex(\n  3061\t            \"Pony\", new_name=\"new_pony_pink_idx\", old_fields=(\"weight\", \"pink\")\n  3062\t        )\n  3063\t        operation.state_forwards(app_label, new_state)\n  3064\t        new_model = new_state.apps.get_model(app_label, \"Pony\")\n  3065\t        self.assertIsNot(old_model, new_model)\n  3066\t        self.assertEqual(new_model._meta.index_together, tuple())\n  3067\t        self.assertEqual(new_model._meta.indexes[0].name, \"new_pony_pink_idx\")\n          # ...\n      # ...\n```\n\n\ntests/migrations/test_optimizer.py\n```\n     1\tfrom django.db import migrations, models\n     2\tfrom django.db.migrations import operations\n     3\tfrom django.db.migrations.optimizer import MigrationOptimizer\n     4\tfrom django.db.migrations.serializer import serializer_factory\n     5\tfrom django.test import SimpleTestCase\n     6\t\n     7\tfrom .models import EmptyManager, UnicodeModel\n     8\t\n     9\t\n    10\tclass OptimizerTests(SimpleTestCase):\n    11\t    \"\"\"\n    12\t    Tests the migration autodetector.\n    13\t    \"\"\"\n          # ...\n  1117\t\n  1118\t    def test_rename_index(self):\n  1119\t        self.assertOptimizesTo(\n  1120\t            [\n  1121\t                migrations.RenameIndex(\n  1122\t                    \"Pony\", new_name=\"mid_name\", old_fields=(\"weight\", \"pink\")\n  1123\t                ),\n  1124\t                migrations.RenameIndex(\n  1125\t                    \"Pony\", new_name=\"new_name\", old_name=\"mid_name\"\n  1126\t                ),\n  1127\t            ],\n  1128\t            [\n  1129\t                migrations.RenameIndex(\n  1130\t                    \"Pony\", new_name=\"new_name\", old_fields=(\"weight\", \"pink\")\n  1131\t                ),\n  1132\t            ],\n  1133\t        )\n  1134\t        self.assertOptimizesTo(\n  1135\t            [\n  1136\t                migrations.RenameIndex(\n  1137\t                    \"Pony\", new_name=\"mid_name\", old_name=\"old_name\"\n  1138\t                ),\n  1139\t                migrations.RenameIndex(\n  1140\t                    \"Pony\", new_name=\"new_name\", old_name=\"mid_name\"\n  1141\t                ),\n  1142\t            ],\n  1143\t            [migrations.RenameIndex(\"Pony\", new_name=\"new_name\", old_name=\"old_name\")],\n  1144\t        )\n  1145\t        self.assertDoesNotOptimize(\n  1146\t            [\n  1147\t                migrations.RenameIndex(\n  1148\t                    \"Pony\", new_name=\"mid_name\", old_name=\"old_name\"\n  1149\t                ),\n  1150\t                migrations.RenameIndex(\n  1151\t                    \"Pony\", new_name=\"new_name\", old_fields=(\"weight\", \"pink\")\n  1152\t                ),\n  1153\t            ]\n  1154\t        )\n```\n\n</observation>",
                  "type": "tool_result"
                }
              ]
            },
            {
              "role": "assistant",
              "content": [
                {
                  "type": "text",
                  "text": "<thoughts>\nAfter reviewing the code, I can see that:\n\n1. The issue is in the `test_rename_index_unnamed_index` test case where we're dealing with an unnamed index from `index_together`.\n\n2. The problem occurs because:\n   - When moving backwards, it's a no-op (as seen in line 2988-2989)\n   - When moving forwards again, it tries to create the index but fails because it already exists\n   - The test is not properly cleaning up the state between operations\n\n3. We need to modify the test to properly handle the case where:\n   - The index should be properly dropped when moving backwards\n   - The old auto-generated name should be restored\n   - Then it can be safely renamed again when moving forwards\n\n4. Let me look at the RenameIndex operation implementation to understand how it handles unnamed indexes.\n</thoughts>"
                },
                {
                  "id": "call_5dd86e45",
                  "input": {
                    "file_pattern": null,
                    "query": "RenameIndex operation implementation",
                    "category": "implementation"
                  },
                  "type": "tool_use",
                  "name": "SemanticSearch"
                }
              ]
            },
            {
              "role": "user",
              "content": [
                {
                  "tool_use_id": "call_5dd86e45",
                  "content": "<observation>\nFound 15 code sections.\n\nViewed relevant code:\ndjango/db/migrations/operations/models.py\n```\n     1\tfrom django.db import models\n     2\tfrom django.db.migrations.operations.base import Operation\n     3\tfrom django.db.migrations.state import ModelState\n     4\tfrom django.db.migrations.utils import field_references, resolve_relation\n     5\tfrom django.db.models.options import normalize_together\n     6\tfrom django.utils.functional import cached_property\n     7\t\n     8\tfrom .fields import AddField, AlterField, FieldOperation, RemoveField, RenameField\n      # ...\n   877\t\n   878\t\n   879\tclass RenameIndex(IndexOperation):\n   880\t    \"\"\"Rename an index.\"\"\"\n   881\t\n   882\t    def __init__(self, model_name, new_name, old_name=None, old_fields=None):\n   883\t        if not old_name and not old_fields:\n   884\t            raise ValueError(\n   885\t                \"RenameIndex requires one of old_name and old_fields arguments to be \"\n   886\t                \"set.\"\n   887\t            )\n   888\t        if old_name and old_fields:\n   889\t            raise ValueError(\n   890\t                \"RenameIndex.old_name and old_fields are mutually exclusive.\"\n   891\t            )\n   892\t        self.model_name = model_name\n   893\t        self.new_name = new_name\n   894\t        self.old_name = old_name\n   895\t        self.old_fields = old_fields\n   896\t\n   897\t    @cached_property\n   898\t    def old_name_lower(self):\n   899\t        return self.old_name.lower()\n   900\t\n   901\t    @cached_property\n   902\t    def new_name_lower(self):\n   903\t        return self.new_name.lower()\n   904\t\n   905\t    def deconstruct(self):\n   906\t        kwargs = {\n   907\t            \"model_name\": self.model_name,\n   908\t            \"new_name\": self.new_name,\n   909\t        }\n   910\t        if self.old_name:\n   911\t            kwargs[\"old_name\"] = self.old_name\n   912\t        if self.old_fields:\n   913\t            kwargs[\"old_fields\"] = self.old_fields\n   914\t        return (self.__class__.__qualname__, [], kwargs)\n   915\t\n   916\t    def state_forwards(self, app_label, state):\n   917\t        if self.old_fields:\n   918\t            state.add_index(\n   919\t                app_label,\n   920\t                self.model_name_lower,\n   921\t                models.Index(fields=self.old_fields, name=self.new_name),\n   922\t            )\n   923\t            state.remove_model_options(\n   924\t                app_label,\n   925\t                self.model_name_lower,\n   926\t                AlterIndexTogether.option_name,\n   927\t                self.old_fields,\n   928\t            )\n   929\t        else:\n   930\t            state.rename_index(\n   931\t                app_label, self.model_name_lower, self.old_name, self.new_name\n   932\t            )\n   933\t\n   934\t    def database_forwards(self, app_label, schema_editor, from_state, to_state):\n   935\t        model = to_state.apps.get_model(app_label, self.model_name)\n   936\t        if not self.allow_migrate_model(schema_editor.connection.alias, model):\n   937\t            return\n   938\t\n   939\t        if self.old_fields:\n   940\t            from_model = from_state.apps.get_model(app_label, self.model_name)\n   941\t            columns = [\n   942\t                from_model._meta.get_field(field).column for field in self.old_fields\n   943\t            ]\n   944\t            matching_index_name = schema_editor._constraint_names(\n   945\t                from_model, column_names=columns, index=True\n   946\t            )\n   947\t            if len(matching_index_name) != 1:\n   948\t                raise ValueError(\n   949\t                    \"Found wrong number (%s) of indexes for %s(%s).\"\n   950\t                    % (\n   951\t                        len(matching_index_name),\n   952\t                        from_model._meta.db_table,\n   953\t                        \", \".join(columns),\n   954\t                    )\n   955\t                )\n   956\t            old_index = models.Index(\n   957\t                fields=self.old_fields,\n   958\t                name=matching_index_name[0],\n   959\t            )\n   960\t        else:\n   961\t            from_model_state = from_state.models[app_label, self.model_name_lower]\n   962\t            old_index = from_model_state.get_index_by_name(self.old_name)\n   963\t\n   964\t        to_model_state = to_state.models[app_label, self.model_name_lower]\n   965\t        new_index = to_model_state.get_index_by_name(self.new_name)\n   966\t        schema_editor.rename_index(model, old_index, new_index)\n   967\t\n   968\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n   969\t        if self.old_fields:\n   970\t            # Backward operation with unnamed index is a no-op.\n   971\t            return\n   972\t\n   973\t        self.new_name_lower, self.old_name_lower = (\n   974\t            self.old_name_lower,\n   975\t            self.new_name_lower,\n   976\t        )\n   977\t        self.new_name, self.old_name = self.old_name, self.new_name\n   978\t\n   979\t        self.database_forwards(app_label, schema_editor, from_state, to_state)\n   980\t\n   981\t        self.new_name_lower, self.old_name_lower = (\n   982\t            self.old_name_lower,\n   983\t            self.new_name_lower,\n   984\t        )\n   985\t        self.new_name, self.old_name = self.old_name, self.new_name\n   986\t\n   987\t    def describe(self):\n   988\t        if self.old_name:\n   989\t            return (\n   990\t                f\"Rename index {self.old_name} on {self.model_name} to {self.new_name}\"\n   991\t            )\n   992\t        return (\n   993\t            f\"Rename unnamed index for {self.old_fields} on {self.model_name} to \"\n   994\t            f\"{self.new_name}\"\n   995\t        )\n   996\t\n   997\t    @property\n   998\t    def migration_name_fragment(self):\n   999\t        if self.old_name:\n  1000\t            return \"rename_%s_%s\" % (self.old_name_lower, self.new_name_lower)\n  1001\t        return \"rename_%s_%s_%s\" % (\n  1002\t            self.model_name_lower,\n  1003\t            \"_\".join(self.old_fields),\n  1004\t            self.new_name_lower,\n  1005\t        )\n  1006\t\n  1007\t    def reduce(self, operation, app_label):\n  1008\t        if (\n  1009\t            isinstance(operation, RenameIndex)\n  1010\t            and self.model_name_lower == operation.model_name_lower\n  1011\t            and operation.old_name\n  1012\t            and self.new_name_lower == operation.old_name_lower\n  1013\t        ):\n  1014\t            return [\n  1015\t                RenameIndex(\n  1016\t                    self.model_name,\n  1017\t                    new_name=operation.new_name,\n  1018\t                    old_name=self.old_name,\n  1019\t                    old_fields=self.old_fields,\n  1020\t                )\n  1021\t            ]\n  1022\t        return super().reduce(operation, app_label)\n      # ...\n```\n\n\ndjango/db/backends/base/schema.py\n```\n     1\timport logging\n     2\timport operator\n     3\tfrom datetime import datetime\n     4\t\n     5\tfrom django.db.backends.ddl_references import (\n     6\t    Columns,\n     7\t    Expressions,\n     8\t    ForeignKeyName,\n     9\t    IndexName,\n    10\t    Statement,\n    11\t    Table,\n    12\t)\n    13\tfrom django.db.backends.utils import names_digest, split_identifier\n    14\tfrom django.db.models import Deferrable, Index\n    15\tfrom django.db.models.sql import Query\n    16\tfrom django.db.transaction import TransactionManagementError, atomic\n    17\tfrom django.utils import timezone\n    18\t\n    19\tlogger = logging.getLogger(\"django.db.backends.schema\")\n      # ...\n    72\t\n    73\t\n    74\tclass BaseDatabaseSchemaEditor:\n    75\t    \"\"\"\n    76\t    This class and its subclasses are responsible for emitting schema-changing\n    77\t    statements to the databases - model creation/removal/alteration, field\n    78\t    renaming, index fiddling, and so on.\n    79\t    \"\"\"\n    80\t\n    81\t    # Overrideable SQL templates\n    82\t    sql_create_table = \"CREATE TABLE %(table)s (%(definition)s)\"\n    83\t    sql_rename_table = \"ALTER TABLE %(old_table)s RENAME TO %(new_table)s\"\n    84\t    sql_retablespace_table = \"ALTER TABLE %(table)s SET TABLESPACE %(new_tablespace)s\"\n    85\t    sql_delete_table = \"DROP TABLE %(table)s CASCADE\"\n    86\t\n    87\t    sql_create_column = \"ALTER TABLE %(table)s ADD COLUMN %(column)s %(definition)s\"\n    88\t    sql_alter_column = \"ALTER TABLE %(table)s %(changes)s\"\n    89\t    sql_alter_column_type = \"ALTER COLUMN %(column)s TYPE %(type)s\"\n    90\t    sql_alter_column_null = \"ALTER COLUMN %(column)s DROP NOT NULL\"\n    91\t    sql_alter_column_not_null = \"ALTER COLUMN %(column)s SET NOT NULL\"\n    92\t    sql_alter_column_default = \"ALTER COLUMN %(column)s SET DEFAULT %(default)s\"\n    93\t    sql_alter_column_no_default = \"ALTER COLUMN %(column)s DROP DEFAULT\"\n    94\t    sql_alter_column_no_default_null = sql_alter_column_no_default\n    95\t    sql_alter_column_collate = \"ALTER COLUMN %(column)s TYPE %(type)s%(collation)s\"\n    96\t    sql_delete_column = \"ALTER TABLE %(table)s DROP COLUMN %(column)s CASCADE\"\n    97\t    sql_rename_column = (\n    98\t        \"ALTER TABLE %(table)s RENAME COLUMN %(old_column)s TO %(new_column)s\"\n    99\t    )\n   100\t    sql_update_with_default = (\n   101\t        \"UPDATE %(table)s SET %(column)s = %(default)s WHERE %(column)s IS NULL\"\n   102\t    )\n   103\t\n   104\t    sql_unique_constraint = \"UNIQUE (%(columns)s)%(deferrable)s\"\n   105\t    sql_check_constraint = \"CHECK (%(check)s)\"\n   106\t    sql_delete_constraint = \"ALTER TABLE %(table)s DROP CONSTRAINT %(name)s\"\n   107\t    sql_constraint = \"CONSTRAINT %(name)s %(constraint)s\"\n   108\t\n   109\t    sql_create_check = \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s CHECK (%(check)s)\"\n   110\t    sql_delete_check = sql_delete_constraint\n   111\t\n   112\t    sql_create_unique = (\n   113\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s \"\n   114\t        \"UNIQUE (%(columns)s)%(deferrable)s\"\n   115\t    )\n   116\t    sql_delete_unique = sql_delete_constraint\n   117\t\n   118\t    sql_create_fk = (\n   119\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s FOREIGN KEY (%(column)s) \"\n   120\t        \"REFERENCES %(to_table)s (%(to_column)s)%(deferrable)s\"\n   121\t    )\n   122\t    sql_create_inline_fk = None\n   123\t    sql_create_column_inline_fk = None\n   124\t    sql_delete_fk = sql_delete_constraint\n   125\t\n   126\t    sql_create_index = (\n   127\t        \"CREATE INDEX %(name)s ON %(table)s \"\n   128\t        \"(%(columns)s)%(include)s%(extra)s%(condition)s\"\n   129\t    )\n   130\t    sql_create_unique_index = (\n   131\t        \"CREATE UNIQUE INDEX %(name)s ON %(table)s \"\n   132\t        \"(%(columns)s)%(include)s%(condition)s\"\n   133\t    )\n   134\t    sql_rename_index = \"ALTER INDEX %(old_name)s RENAME TO %(new_name)s\"\n   135\t    sql_delete_index = \"DROP INDEX %(name)s\"\n   136\t\n   137\t    sql_create_pk = (\n   138\t        \"ALTER TABLE %(table)s ADD CONSTRAINT %(name)s PRIMARY KEY (%(columns)s)\"\n   139\t    )\n   140\t    sql_delete_pk = sql_delete_constraint\n   141\t\n   142\t    sql_delete_procedure = \"DROP PROCEDURE %(procedure)s\"\n          # ...\n  1374\t\n  1375\t    def _rename_index_sql(self, model, old_name, new_name):\n  1376\t        return Statement(\n  1377\t            self.sql_rename_index,\n  1378\t            table=Table(model._meta.db_table, self.quote_name),\n  1379\t            old_name=self.quote_name(old_name),\n  1380\t            new_name=self.quote_name(new_name),\n  1381\t        )\n          # ...\n```\n\n</observation>",
                  "type": "tool_result",
                  "cache_control": {
                    "type": "ephemeral"
                  }
                }
              ]
            },
            {
              "role": "assistant",
              "content": [
                {
                  "type": "text",
                  "text": "<thoughts>\nAfter reviewing both the test and implementation code, I can see that:\n\n1. The issue is in the RenameIndex operation's handling of unnamed indexes:\n   - In `database_backwards`, it has a special case for `old_fields` that makes it a no-op (lines 969-971)\n   - This means when moving backwards, it doesn't actually restore the original auto-generated index name\n   - When moving forwards again, it tries to create a new index but the old one still exists\n\n2. The fix needs to:\n   - Remove the no-op behavior for unnamed indexes in backwards operation\n   - Properly handle the index renaming in both directions\n   - Ensure the auto-generated name is restored when moving backwards\n\n3. Let's modify the RenameIndex operation to properly handle unnamed indexes in both directions.\n\n4. The changes needed are:\n   - Remove the no-op early return for old_fields in database_backwards\n   - Ensure proper index name handling in both directions\n   - Update the test to verify the correct behavior\n\nLet me make these changes:\n</thoughts>"
                },
                {
                  "id": "call_b70efde2",
                  "input": {
                    "command": "str_replace",
                    "path": "django/db/migrations/operations/models.py",
                    "file_text": null,
                    "view_range": null,
                    "old_str": "    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n        if self.old_fields:\n            # Backward operation with unnamed index is a no-op.\n            return\n\n        self.new_name_lower, self.old_name_lower = (\n            self.old_name_lower,\n            self.new_name_lower,\n        )\n        self.new_name, self.old_name = self.old_name, self.new_name\n\n        self.database_forwards(app_label, schema_editor, from_state, to_state)\n\n        self.new_name_lower, self.old_name_lower = (\n            self.old_name_lower,\n            self.new_name_lower,\n        )\n        self.new_name, self.old_name = self.old_name, self.new_name",
                    "new_str": "    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n        model = to_state.apps.get_model(app_label, self.model_name)\n        if not self.allow_migrate_model(schema_editor.connection.alias, model):\n            return\n\n        if self.old_fields:\n            # Get the auto-generated name for the index\n            to_model = to_state.apps.get_model(app_label, self.model_name)\n            columns = [to_model._meta.get_field(field).column for field in self.old_fields]\n            matching_index_name = schema_editor._constraint_names(\n                to_model, column_names=columns, index=True\n            )\n            if len(matching_index_name) != 1:\n                raise ValueError(\n                    \"Found wrong number (%s) of indexes for %s(%s).\"\n                    % (\n                        len(matching_index_name),\n                        to_model._meta.db_table,\n                        \", \".join(columns),\n                    )\n                )\n            old_index = models.Index(fields=self.old_fields, name=matching_index_name[0])\n            new_index = models.Index(fields=self.old_fields, name=self.new_name)\n            schema_editor.rename_index(model, new_index, old_index)\n            return\n\n        self.new_name_lower, self.old_name_lower = (\n            self.old_name_lower,\n            self.new_name_lower,\n        )\n        self.new_name, self.old_name = self.old_name, self.new_name\n\n        self.database_forwards(app_label, schema_editor, from_state, to_state)\n\n        self.new_name_lower, self.old_name_lower = (\n            self.old_name_lower,\n            self.new_name_lower,\n        )\n        self.new_name, self.old_name = self.old_name, self.new_name",
                    "insert_line": null
                  },
                  "type": "tool_use",
                  "name": "str_replace_editor",
                  "cache_control": {
                    "type": "ephemeral"
                  }
                }
              ]
            },
            {
              "role": "user",
              "content": [
                {
                  "tool_use_id": "call_b70efde2",
                  "content": "<observation>\nThe file django/db/migrations/operations/models.py has been edited. Here's the result of running `cat -n` on a snippet of django/db/migrations/operations/models.py:\n   968\t\n   969\t        to_model_state = to_state.models[app_label, self.model_name_lower]\n   970\t        new_index = to_model_state.get_index_by_name(self.new_name)\n   971\t        schema_editor.rename_index(model, old_index, new_index)\n   972\t\n   973\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n   974\t        model = to_state.apps.get_model(app_label, self.model_name)\n   975\t        if not self.allow_migrate_model(schema_editor.connection.alias, model):\n   976\t            return\n   977\t\n   978\t        if self.old_fields:\n   979\t            # Get the auto-generated name for the index\n   980\t            to_model = to_state.apps.get_model(app_label, self.model_name)\n   981\t            columns = [to_model._meta.get_field(field).column for field in self.old_fields]\n   982\t            matching_index_name = schema_editor._constraint_names(\n   983\t                to_model, column_names=columns, index=True\n   984\t            )\n   985\t            if len(matching_index_name) != 1:\n   986\t                raise ValueError(\n   987\t                    \"Found wrong number (%s) of indexes for %s(%s).\"\n   988\t                    % (\n   989\t                        len(matching_index_name),\n   990\t                        to_model._meta.db_table,\n   991\t                        \", \".join(columns),\n   992\t                    )\n   993\t                )\n   994\t            old_index = models.Index(fields=self.old_fields, name=matching_index_name[0])\n   995\t            new_index = models.Index(fields=self.old_fields, name=self.new_name)\n   996\t            schema_editor.rename_index(model, new_index, old_index)\n   997\t            return\n   998\t\n   999\t        self.new_name_lower, self.old_name_lower = (\n  1000\t            self.old_name_lower,\n  1001\t            self.new_name_lower,\n  1002\t        )\n  1003\t        self.new_name, self.old_name = self.old_name, self.new_name\n  1004\t\n  1005\t        self.database_forwards(app_label, schema_editor, from_state, to_state)\n  1006\t\n  1007\t        self.new_name_lower, self.old_name_lower = (\n  1008\t            self.old_name_lower,\n  1009\t            self.new_name_lower,\n  1010\t        )\n  1011\t        self.new_name, self.old_name = self.old_name, self.new_name\n  1012\t\n  1013\t    def describe(self):\n  1014\t        if self.old_name:\nReview the changes and make sure they are as expected. Edit the file again if necessary.\n\nRunning 218 tests in the following files:\n * tests/migrations/test_operations.py\n * tests/migrations/test_optimizer.py\n * tests/migrations/test_base.py\n * tests/migrations/test_writer.py\n\n* FAILED tests/migrations/test_operations.py OperationTests.test_rename_index_unnamed_index>\n```\nTraceback (most recent call last):\n  File \"tests/migrations/test_operations.py\", line 2989, in test_rename_index_unnamed_index\n    operation.database_backwards(app_label, editor, new_state, project_state)\n  File \"django/test/testcases.py\", line 98, in __exit__\n    self.test_case.assertEqual(\nAssertionError: 13 != 0 : 13 queries executed, 0 expected\nCaptured queries were:\n1. SELECT sql FROM sqlite_master WHERE type='table' and name=\"test_rninui_pony\"\n2. PRAGMA table_info(\"test_rninui_pony\")\n3. \n            SELECT sql\n            FROM sqlite_master\n            WHERE type = 'table' AND name = 'test_rninui_pony'\n        \n4. \n                    SELECT sql\n                    FROM sqlite_master\n                    WHERE\n                        type = 'table' AND\n                        name = 'test_rninui_pony' AND\n                        sql LIKE '%json_valid(\"id\")%'\n                \n5. \n                    SELECT sql\n                    FROM sqlite_master\n                    WHERE\n                        type = 'table' AND\n                        name = 'test_rninui_pony' AND\n                        sql LIKE '%json_valid(\"pink\")%'\n                \n6. \n                    SELECT sql\n                    FROM sqlite_master\n                    WHERE\n                        type = 'table' AND\n                        name = 'test_rninui_pony' AND\n                        sql LIKE '%json_valid(\"weight\")%'\n                \n7. PRAGMA index_list(\"test_rninui_pony\")\n8. SELECT sql FROM sqlite_master WHERE type='index' AND name=\"new_pony_test_idx\"\n9. PRAGMA index_info(\"new_pony_test_idx\")\n10. PRAGMA table_info(\"test_rninui_pony\")\n11. PRAGMA foreign_key_list(\"test_rninui_pony\")\n12. DROP INDEX \"new_pony_test_idx\"\n13. CREATE INDEX \"new_pony_test_idx\" ON \"test_rninui_pony\" (\"weight\", \"pink\")\n\n```\n\n\n217 passed. 1 failed. 0 errors.\n</observation>",
                  "type": "tool_result",
                  "cache_control": {
                    "type": "ephemeral"
                  }
                }
              ]
            }
          ],
          "response": {
            "id": "msg_01GtZAa6niD5M66EcPmw8HPw",
            "content": [
              {
                "text": "<thoughts>\nThe test failure shows that our changes to handle unnamed indexes in backwards operation are causing more database queries than expected. The test expects 0 queries but we're executing 13.\n\nLooking at the test case and the error, I realize I misunderstood the requirement. The test expects the backwards operation to be a no-op for unnamed indexes because:\n\n1. When moving backwards with an unnamed index, we don't need to restore the old name since:\n   - The index was originally auto-generated\n   - The index still exists with the new name\n   - The functionality (indexing those columns) is still preserved\n   - We'll handle any name changes in the forwards operation\n\n2. The test's assertion `self.assertNumQueries(0)` on line 2988 explicitly verifies this no-op behavior.\n\nLet's revert our changes and fix the test to properly handle the forwards operation instead:\n</thoughts>",
                "type": "text"
              },
              {
                "id": "toolu_014FHXsq4wEi4k2uiuhxgkD4",
                "input": {
                  "command": "str_replace",
                  "path": "django/db/migrations/operations/models.py",
                  "old_str": "    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n        model = to_state.apps.get_model(app_label, self.model_name)\n        if not self.allow_migrate_model(schema_editor.connection.alias, model):\n            return\n\n        if self.old_fields:\n            # Get the auto-generated name for the index\n            to_model = to_state.apps.get_model(app_label, self.model_name)\n            columns = [to_model._meta.get_field(field).column for field in self.old_fields]\n            matching_index_name = schema_editor._constraint_names(\n                to_model, column_names=columns, index=True\n            )\n            if len(matching_index_name) != 1:\n                raise ValueError(\n                    \"Found wrong number (%s) of indexes for %s(%s).\"\n                    % (\n                        len(matching_index_name),\n                        to_model._meta.db_table,\n                        \", \".join(columns),\n                    )\n                )\n            old_index = models.Index(fields=self.old_fields, name=matching_index_name[0])\n            new_index = models.Index(fields=self.old_fields, name=self.new_name)\n            schema_editor.rename_index(model, new_index, old_index)\n            return\n\n        self.new_name_lower, self.old_name_lower = (\n            self.old_name_lower,\n            self.new_name_lower,\n        )\n        self.new_name, self.old_name = self.old_name, self.new_name\n\n        self.database_forwards(app_label, schema_editor, from_state, to_state)\n\n        self.new_name_lower, self.old_name_lower = (\n            self.old_name_lower,\n            self.new_name_lower,\n        )\n        self.new_name, self.old_name = self.old_name, self.new_name",
                  "new_str": "    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n        if self.old_fields:\n            # Backward operation with unnamed index is a no-op.\n            return\n\n        self.new_name_lower, self.old_name_lower = (\n            self.old_name_lower,\n            self.new_name_lower,\n        )\n        self.new_name, self.old_name = self.old_name, self.new_name\n\n        self.database_forwards(app_label, schema_editor, from_state, to_state)\n\n        self.new_name_lower, self.old_name_lower = (\n            self.old_name_lower,\n            self.new_name_lower,\n        )\n        self.new_name, self.old_name = self.old_name, self.new_name",
                  "file_pattern": null,
                  "insert_line": "null"
                },
                "name": "str_replace_editor",
                "type": "tool_use"
              }
            ],
            "model": "claude-3-5-sonnet-20241022",
            "role": "assistant",
            "stop_reason": "tool_use",
            "stop_sequence": null,
            "type": "message",
            "usage": {
              "cache_creation_input_tokens": 14903,
              "cache_read_input_tokens": 0,
              "input_tokens": 4,
              "output_tokens": 1100
            }
          },
          "usage": {
            "completion_cost": 0.061221000000000005,
            "completion_tokens": 1100,
            "prompt_tokens": 14907,
            "cached_tokens": 0
          }
        }
      },
      "possible_actions": [
        "SemanticSearch",
        "FindClass",
        "FindFunction",
        "FindCodeSnippet",
        "ViewCode",
        "ClaudeEditTool",
        "Finish",
        "Reject"
      ],
      "output": {
        "message": "The file django/db/migrations/operations/models.py has been edited. Here's the result of running `cat -n` on a snippet of django/db/migrations/operations/models.py:\n   968\t\n   969\t        to_model_state = to_state.models[app_label, self.model_name_lower]\n   970\t        new_index = to_model_state.get_index_by_name(self.new_name)\n   971\t        schema_editor.rename_index(model, old_index, new_index)\n   972\t\n   973\t    def database_backwards(self, app_label, schema_editor, from_state, to_state):\n   974\t        if self.old_fields:\n   975\t            # Backward operation with unnamed index is a no-op.\n   976\t            return\n   977\t\n   978\t        self.new_name_lower, self.old_name_lower = (\n   979\t            self.old_name_lower,\n   980\t            self.new_name_lower,\n   981\t        )\n   982\t        self.new_name, self.old_name = self.old_name, self.new_name\n   983\t\n   984\t        self.database_forwards(app_label, schema_editor, from_state, to_state)\n   985\t\n   986\t        self.new_name_lower, self.old_name_lower = (\n   987\t            self.old_name_lower,\n   988\t            self.new_name_lower,\n   989\t        )\n   990\t        self.new_name, self.old_name = self.old_name, self.new_name\n   991\t\n   992\t    def describe(self):\n   993\t        if self.old_name:\nReview the changes and make sure they are as expected. Edit the file again if necessary.\n\nRunning 218 tests in the following files:\n * tests/migrations/test_operations.py\n * tests/migrations/test_optimizer.py\n * tests/migrations/test_base.py\n * tests/migrations/test_writer.py\n\n218 passed. 0 failed. 0 errors.",
        "terminal": false,
        "expect_correction": false,
        "properties": {
          "flags": [
            "lines_not_in_context"
          ],
          "diff": "--- django/db/migrations/operations/models.py\n+++ django/db/migrations/operations/models.py\n@@ -966,29 +966,8 @@\n         schema_editor.rename_index(model, old_index, new_index)\n \n     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n-        model = to_state.apps.get_model(app_label, self.model_name)\n-        if not self.allow_migrate_model(schema_editor.connection.alias, model):\n-            return\n-\n         if self.old_fields:\n-            # Get the auto-generated name for the index\n-            to_model = to_state.apps.get_model(app_label, self.model_name)\n-            columns = [to_model._meta.get_field(field).column for field in self.old_fields]\n-            matching_index_name = schema_editor._constraint_names(\n-                to_model, column_names=columns, index=True\n-            )\n-            if len(matching_index_name) != 1:\n-                raise ValueError(\n-                    \"Found wrong number (%s) of indexes for %s(%s).\"\n-                    % (\n-                        len(matching_index_name),\n-                        to_model._meta.db_table,\n-                        \", \".join(columns),\n-                    )\n-                )\n-            old_index = models.Index(fields=self.old_fields, name=matching_index_name[0])\n-            new_index = models.Index(fields=self.old_fields, name=self.new_name)\n-            schema_editor.rename_index(model, new_index, old_index)\n+            # Backward operation with unnamed index is a no-op.\n             return\n \n         self.new_name_lower, self.old_name_lower = (\n",
          "test_results": [
            {
              "status": "PASSED",
              "message": "test_reference_field_by_through_fields (migrations.test_operations.FieldOperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_references_field_by_from_fields (migrations.test_operations.FieldOperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_references_field_by_name (migrations.test_operations.FieldOperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_references_field_by_remote_field_model (migrations.test_operations.FieldOperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_references_field_by_through (migrations.test_operations.FieldOperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_references_field_by_to_fields (migrations.test_operations.FieldOperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_references_model (migrations.test_operations.FieldOperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AddField operation on TextField/BinaryField.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AddField operation on TextField.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_constraint_combinable (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_constraint_percent_escaping (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_covering_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_deferred_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AddField operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AddField operation with a ManyToManyField.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AddField operation's state alteration",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_func_index (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_func_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Test the AddIndex operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_index_state_forwards (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_or_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_add_partial_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AddField operation on TextField.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterField operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "AlterField operation is a noop when adding only a db_column and the",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_field_m2m (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "The AlterField operation on primary keys (things like PostgreSQL's",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterField operation on primary keys changes any FKs pointing to it.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "AlterField operation of db_collation on primary keys changes any FKs",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_field_pk_mti_and_fk_to_base (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_field_pk_mti_fk (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_field_reloads_state_fk_with_to_field_related_name_target_type_change (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "If AlterField doesn't reload state appropriately, the second AlterField",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "If AlterField doesn't reload state appropriately, the second AlterField",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_field_reloads_state_on_fk_with_to_field_target_type_change (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_field_with_func_index (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_field_with_func_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Test AlterField operation with an index to ensure indexes created via",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Creating and then altering an FK works correctly",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Altering an FK to a non-FK works (#23244)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterIndexTogether operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_index_together_remove (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_index_together_remove_with_unique_together (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "The managers on a model are set.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "The managers on a model are set.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterModelOptions operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "The AlterModelOptions operation removes keys from the dict (#23121)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterModelTable operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "AlterModelTable should rename auto-generated M2M tables.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterModelTable operation if the table name is set to None.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterModelTable operation if the table name is not changed.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterOrderWithRespectTo operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AlterUniqueTogether operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_unique_together_remove (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "A field may be migrated from AutoField to BigAutoField.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Column names that are SQL keywords shouldn't cause problems when used",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Creation of models with a FK to a PK with db_collation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the CreateModel operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the CreateModel operation on a multi-table inheritance setup.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Test the creation of a model with a ManyToMany field and the",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "The managers on a model are set.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_model_with_boolean_expression_in_check_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_model_with_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "SKIPPED",
              "message": "test_create_model_with_covering_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_model_with_deferred_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_model_with_duplicate_base (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_model_with_duplicate_field_name (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_model_with_duplicate_manager_name (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_model_with_partial_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the CreateModel operation directly followed by an",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "CreateModel ignores proxy models.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "CreateModel ignores unmanaged models.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the DeleteModel operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_delete_mti_model (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the DeleteModel operation ignores proxy models.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "A model with BigAutoField can be created.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_covering_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_deferred_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RemoveField operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_field_m2m (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_field_m2m_with_through (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RemoveField operation on a foreign key.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_func_index (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_func_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Test the RemoveIndex operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_index_state_forwards (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_remove_partial_unique_constraint (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RenameField operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_field_case (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "If RenameField doesn't reload state appropriately, the AlterField",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_field_with_db_column (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_index (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_index_arguments (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_index_state_forwards (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_index_state_forwards_unnamed_index (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_index_unknown_unnamed_index (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_index_unnamed_index (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "RenameModel renames a many-to-many column after a RenameField.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_m2m_target_model (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_m2m_through_model (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_missing_field (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RenameModel operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "RenameModel operations shouldn't trigger the caching of rendered apps",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_model_with_db_table_noop (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_model_with_m2m (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RenameModel operation on model with self referential FK.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_model_with_self_referential_m2m (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RenameModel operation on a model which has a superclass that",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_referenced_field_state_forward (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_repoint_field_m2m (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RunPython operation",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RunPython operation correctly handles the \"atomic\" keyword",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "#24098 - Tests no-op RunPython operations.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "#24282 - Model changes to a FK reverse side update the model",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the RunSQL operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_run_sql_add_missing_semicolon_on_collect_sql (migrations.test_operations.OperationTests)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "#24098 - Tests no-op RunSQL operations.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "#23426 - RunSQL should accept parameters.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "#23426 - RunSQL should fail when a list of statements with an incorrect",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the SeparateDatabaseAndState operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "A complex SeparateDatabaseAndState operation: Multiple operations both",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "A field may be migrated from SmallAutoField to AutoField.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "A field may be migrated from SmallAutoField to BigAutoField.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the AddField operation.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "The CreateTable operation ignores swapped models.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests the DeleteModel operation ignores swapped models.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Add/RemoveIndex operations ignore swapped models.",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_references_model_mixin (migrations.test_operations.TestCreateModel)",
              "file_path": "tests/migrations/test_operations.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "AlterField should optimize into AddField.",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "RemoveField should cancel AddField",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "RenameField should optimize into AddField",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_alter_index_model (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_alter_owrt_model (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_alter_table_model (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_alter_alter_unique_model (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "RemoveField should absorb AlterField",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "RenameField should optimize to the other side of AlterField,",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_alter_index_delete_model (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_alter_index_field (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_alter_model_managers (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_alter_model_options (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_alter_owrt_delete_model (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_alter_owrt_field (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_alter_unique_delete_model (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_alter_unique_field (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "CreateModel and DeleteModel should collapse into nothing.",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "AddField should optimize into CreateModel.",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "AddField should NOT optimize into CreateModel if it's an M2M using a",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "AlterField should optimize into CreateModel.",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_create_model_and_remove_model_options (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "CreateModel order remains unchanged if the later AddField operation",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "A CreateModel that inherits from another isn't reordered to avoid",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "RemoveField should optimize into CreateModel.",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "RenameField should optimize into CreateModel.",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "AddField optimizes into CreateModel if it's a FK to a model that's",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "CreateModel reordering behavior doesn't result in an infinite loop if",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "CreateModel should absorb RenameModels.",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_none_app_label (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_optimize_elidable_operation (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "We should be able to optimize away create/delete through a create or",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "field-level through checking is working. This should manage to collapse",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_rename_index (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "RenameModels should absorb themselves.",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "The optimizer does nothing on a single operation,",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_swapping_fields_names (migrations.test_optimizer.OptimizerTests)",
              "file_path": "tests/migrations/test_optimizer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_args_kwargs_signature (migrations.test_writer.OperationWriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_args_signature (migrations.test_writer.OperationWriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_empty_signature (migrations.test_writer.OperationWriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_expand_args_signature (migrations.test_writer.OperationWriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_kwargs_signature (migrations.test_writer.OperationWriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_multiline_args_signature (migrations.test_writer.OperationWriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_nested_args_signature (migrations.test_writer.OperationWriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_nested_operation_expand_args_signature (migrations.test_writer.OperationWriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_custom_operation (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_deconstruct_class_arguments (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Test comments at top of file.",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_migration_path (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "django.db.models shouldn't be imported if unused.",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_register_non_serializer (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_register_serializer (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_builtin_types (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_builtins (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_choices (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Ticket #22943: Test serialization of class-based validators, including",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_collections (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Make sure compiled regex can be serialized.",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_complex_func_index (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_constants (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_datetime (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Ticket #22679: makemigrations generates invalid code for (an empty",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_enums (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_fields (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_frozensets (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_functions (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_functools_partial (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_functools_partialmethod (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_iterators (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_lazy_objects (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "A reference in a local scope can't be serialized.",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_managers (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_multiline_strings (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_nested_class (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_numbers (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_path_like (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_pathlib (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_range (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_set (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_settings (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_strings (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_timedelta (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_type_model (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_type_none (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "An unbound method used within a class body can be serialized.",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "test_serialize_uuid (migrations.test_writer.WriterTests)",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "Tests serializing a simple migration.",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            },
            {
              "status": "PASSED",
              "message": "#24155 - Tests ordering of imports.",
              "file_path": "tests/migrations/test_writer.py",
              "span_id": null,
              "line": null,
              "relevant_files": []
            }
          ]
        }
      },
      "parent_id": 10
    }
  ]
}